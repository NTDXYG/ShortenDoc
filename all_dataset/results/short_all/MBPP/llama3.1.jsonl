{"task_id": "MBPP/11", "completion": "\n    return s.replace(ch, '')\n"}
{"task_id": "MBPP/12", "completion": "\n    # Get the dimensions of the matrix\n    rows, cols = M.shape\n    \n    # Create a new matrix to store the sorted elements\n    sorted_M = np.zeros((rows, cols))\n    \n    # Iterate over each column\n    for c in range(cols):\n        # Get the column from the original matrix\n        col = M[:, c]\n        \n        # Sort the column in ascending order\n        sorted_col = np.sort(col)\n        \n        # Place the sorted column in the corresponding column of the new matrix\n        sorted_M[:, c] = sorted_col\n    \n    return sorted_M\n"}
{"task_id": "MBPP/13", "completion": "\n    word_counts = Counter(words)\n    common_words = [word for word, count in word_counts.items() if count > 1]\n    return common_words\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'(?<=[a-z])(?=[A-Z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'[^a-zA-Z0-9]+', '_', text).lower()\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return 4 * a\n\n"}
{"task_id": "MBPP/18", "completion": "\n    return [ord(char) for char in string]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    # Check if the array has any duplicate elements\n    if len(arraynums) != len(set(arraynums)):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/20", "completion": "\n    return x == 2 * (x - 1) * (x - 2) + 1\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i for i in range(m, n+1) if i % m == 0]\n"}
{"task_id": "MBPP/22", "completion": "\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            return num\n        num_set.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    max_sum = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            for k in range(j+1, len(list1)):\n                for l in range(k+1, len(list1)):\n                    for m in range(l+1, len(list1)):\n                        for n in range(m+1, len(list1)):\n                            for o in range(n+1, len(list1)):\n                                for p in range(o+1, len(list1)):\n                                    for q in range(p+1, len(list1)):\n                                        for r in range(q+1, len(list1)):\n                                            for s in range(r+1, len(list1)):\n                                                for t in range(s+1, len(list1)):\n                                                    for u in range(t+1, len(list1)):\n                                                        for v in range(u+1, len(list1)):\n                                                            for w in range(v+1, len(list1)):\n                                                                for x in range(w+1, len(list1)):\n                                                                    for y in range(x+1, len(list1)):\n                                                                        for z in range(y+1, len(list1)):\n                                                                            for a in range(z+1, len(list1)):\n                                                                                for b in range(a+1, len(list1)):\n                                                                                    for c in range(b+1, len(list1)):\n                                                                                        for d in range(c+1, len(list1)):\n                                                                                            for e in range(d+1, len(list1)):\n                                                                                                for f in range(e+1, len(list1)):\n                                                                                                    for g in range(f+1, len(list1)):\n                                                                                                        for h in range(g+1, len(list1)):\n                                                                                                            for i in range(h+1, len(list1)):\n                                                                                                                for j in range(i+1, len(list1)):\n                                                                                                                    for k in range(j+1, len(list1)):\n                                                                                                                        for l in range(k+1, len(list1)):\n                                                                                                                            for m in range(l+1, len(list1)):\n                                                                                                                                for n in range(m+1, len(list1)):\n                                                                                                                                    for o in range(n+1, len(list1)):\n                                                                                                                                        for p in range(o+1, len(list1)):\n                                                                                                                                            for q in range(p+1, len(list1)):\n                                                                                                                                                for r in range(q+1, len(list1)):\n                                                                                                                                                    for s in range(r+1, len(list1)):\n                                                                                                                                                        for t"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i, bit in enumerate(binary[::-1]):\n        decimal += int(bit) * (2 ** i)\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each product\n    freq = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            product = arr[i] * arr[j]\n            if product in freq:\n                freq[product] += 1\n            else:\n                freq[product] = 1\n\n    # Find the product with the maximum frequency\n    max_freq = 0\n    max_product = 0\n    for product, count in freq.items():\n        if count > max_freq:\n            max_freq = count\n            max_product = product\n\n    return max_product\n"}
{"task_id": "MBPP/26", "completion": "\n    # Check if the list has at least K elements\n    if len(test_list) < K:\n        return False\n    # Check if the list has at most K elements\n    if len(test_list) > K:\n        return False\n    # Check if the list has exactly K elements\n    if len(test_list) == K:\n        return True\n    return False\n"}
{"task_id": "MBPP/27", "completion": "\n    return [i for i in list if i != '']\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    else:\n        return binomial_Coeff(n-1, k-1) + binomial_Coeff(n-1, k)\n"}
{"task_id": "MBPP/29", "completion": "\n    # Initialize count of odd occurrence elements\n    count = 0\n    # Initialize a dictionary to store frequency of elements\n    freq = {}\n    \n    # Traverse through the array\n    for i in range(arr_size):\n        # If element is already in dictionary, increment its count\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        # Else, add element to dictionary with count 1\n        else:\n            freq[arr[i]] = 1\n    \n    # Traverse through the dictionary\n    for key in freq:\n        # If count of element is odd, increment count\n        if freq[key] % 2 != 0:\n            count += 1\n    \n    # Return count of odd occurrence elements\n    return count\n"}
{"task_id": "MBPP/30", "completion": "\n    # Check if the string is empty\n    if not s:\n        return True\n\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq = collections.Counter(nums)\n    \n    # Create a max heap to store the numbers and their frequencies\n    max_heap = []\n    \n    # Push each number and its frequency into the max heap\n    for num, count in freq.items():\n        # Push a tuple (count, num) into the max heap\n        # The max heap will automatically sort the tuples in descending order\n        heapq.heappush(max_heap, (-count, num))\n    \n    # Pop the top k elements from the max heap\n    for _ in range(k):\n        # Pop the top element from the max heap\n        count, num = heapq.heappop(max_heap)\n        \n        # Print the number\n        print(num, end=\" \")\n        \n        # If the count is not zero, push the number back into the max heap\n        if count != 0:\n            # Push a tuple (count, num) into the max heap\n            heapq.heappush(max_heap, (count + 1, num))\n\n"}
{"task_id": "MBPP/32", "completion": "\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    # Create a set of all numbers from 1 to N\n    all_nums = set(range(1, N + 1))\n    \n    # Find the difference between the set of all numbers and the array\n    missing_nums = all_nums - set(ar)\n    \n    return missing_nums\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the numbers to strings\n    p_str = str(p)\n    q_str = str(q)\n    \n    # Find the Nth digit in the first number\n    Nth_digit_p = p_str[N-1]\n    \n    # Find the Nth digit in the second number\n    Nth_digit_q = q_str[N-1]\n    \n    # Return the Nth digit of the first number\n    return Nth_digit_p\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate the list into two lists, one for integers and one for strings\n    int_list = [x for x in mixed_list if isinstance(x, int)]\n    str_list = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the integer list in ascending order\n    int_list.sort()\n\n    # Sort the string list in alphabetical order\n    str_list.sort()\n\n    # Combine the sorted lists into a single list\n    sorted_list = int_list + str_list\n\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even = [i for i in list1 if i % 2 == 0]\n    odd = [i for i in list1 if i % 2 != 0]\n    return even, odd\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    res = []\n    while max_heap:\n        freq, char = heapq.heappop(max_heap)\n        res.append(char)\n        if -freq > 1:\n            heapq.heappush(max_heap, (-freq - 1, char))\n    return ''.join(res)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    return Counter(chain(*nums))\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return [num for num in nums if num % 2 == 0]\n"}
{"task_id": "MBPP/42", "completion": "\n    # Initialize sum\n    total = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the sum\n        total += arr[i]\n    \n    # Return the sum\n    return total\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"^[a-zA-Z0-9_]+$\"\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r\"(\\w+)(\\w+)\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1), match.group(2)\n    else:\n        return None, None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/46", "completion": "\n    return list(set(data))\n"}
{"task_id": "MBPP/47", "completion": "\n    # Convert the input integers to strings\n    str_A = str(A)\n    str_B = str(B)\n    \n    # Find the last digit of each number\n    last_digit_A = int(str_A[-1])\n    last_digit_B = int(str_B[-1])\n    \n    # Compute the last digit of the sum\n    last_digit_sum = (last_digit_A + last_digit_B) % 10\n    \n    return last_digit_sum\n"}
{"task_id": "MBPP/48", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a counter for the number of 1's\n    ones = 0\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', increment the counter\n        if bit == '1':\n            ones += 1\n    \n    # If the number of 1's is odd, return True; otherwise, return False\n    return ones % 2 != 0\n"}
{"task_id": "MBPP/49", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Find the element with the highest frequency\n    max_freq = 0\n    for num in freq:\n        if freq[num] > max_freq:\n            max_freq = freq[num]\n            max_num = num\n\n    # Check if the frequency of the element is greater than N/2\n    if freq[max_num] > N/2:\n        return max_num\n    else:\n        return None\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(len(sublist) for sublist in input_list)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    # Check if the string is empty\n    if str == \"\":\n        return True\n    # Check if the string is equal to itself\n    elif str == str:\n        return True\n    # Check if the string is equal to a string that is the same but with a different case\n    elif str.lower() == str.lower():\n        return True\n    # If none of the above conditions are met, return False\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    # Create a dictionary to store the count of each element in the list\n    count_dict = {}\n    for num in my_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Create a list to store the sorted elements\n    sorted_list = []\n    for key in sorted(count_dict.keys()):\n        sorted_list.extend([key] * count_dict[key])\n\n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r)) * (a ** r) * ((1 - a) ** (n - r))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    \n    # Convert the number to a string to easily reverse it\n    str_num = str(num)\n    \n    # Reverse the string\n    rev_str_num = str_num[::-1]\n    \n    # Convert the reversed string back to an integer\n    rev_num = int(rev_str_num)\n    \n    # Check if the number is one less than twice its reverse\n    if num == 2 * rev_num - 1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/57", "completion": "\n    max_num = arr[0]\n    for i in range(1, n):\n        if arr[i] > max_num:\n            max_num = arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return x * y < 0\n"}
{"task_id": "MBPP/59", "completion": "\n    return n % 8 == 0\n"}
{"task_id": "MBPP/60", "completion": "\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub_arr = arr[i:j+1]\n            if len(sub_arr) > max_len:\n                max_len = len(sub_arr)\n    return max_len\n"}
{"task_id": "MBPP/61", "completion": "\n    # Create a dictionary to store the frequency of each substring\n    freq = defaultdict(int)\n    \n    # Iterate over the string\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            # Extract the substring\n            substring = s[i:j]\n            \n            # Increment the frequency of the substring\n            freq[substring] += 1\n    \n    # Return the frequency of each substring\n    return dict(freq)\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    return max(test_list) - min(test_list)\n"}
{"task_id": "MBPP/64", "completion": "\n    subject = subjectmarks['subject']\n    marks = subjectmarks['marks']\n    if subject == 'Maths':\n        if marks >= 80:\n            return 'A'\n        elif marks >= 60:\n            return 'B'\n        elif marks >= 40:\n            return 'C'\n        else:\n            return 'F'\n    elif subject == 'Science':\n        if marks >= 80:\n            return 'A'\n        elif marks >= 60:\n            return 'B'\n        elif marks >= 40:\n            return 'C'\n        else:\n            return 'F'\n    elif subject == 'English':\n        if marks >= 80:\n            return 'A'\n        elif marks >= 60:\n            return 'B'\n        elif marks >= 40:\n            return 'C'\n        else:\n            return 'F'\n    else:\n        return 'Invalid Subject'\n"}
{"task_id": "MBPP/65", "completion": "\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n"}
{"task_id": "MBPP/66", "completion": "\n    return list.count('pos')\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return sum(bell_number(n - i - 1) for i in range(n))\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    for i in range(n-1):\n        if A[i] > A[i+1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the input list\n    for i in range(len(Input)):\n        # Check if the current element is equal to k\n        if Input[i] == k:\n            # If it is, append the current index to the result list\n            result.append(i)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/71", "completion": "\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[len(nums) // 2]\n    left = [x for x in nums if x < pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x > pivot]\n\n    return comb_sort(left) + middle + comb_sort(right)\n"}
{"task_id": "MBPP/72", "completion": "\n    return n**2\n"}
{"task_id": "MBPP/73", "completion": "\n    pattern = r\"(\\d+)\"\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/74", "completion": "\n    return colors == patterns\n"}
{"task_id": "MBPP/75", "completion": "\n    # Initialize an empty list to store the tuples\n    tuples_list = []\n    \n    # Iterate over the list with two nested loops\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            # Check if the sum of the two elements is equal to K\n            if test_list[i] + test_list[j] == K:\n                # If true, create a tuple and add it to the list\n                tuples_list.append((test_list[i], test_list[j]))\n    \n    # Return the list of tuples\n    return tuples_list\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    return n % 2 != 0\n"}
{"task_id": "MBPP/78", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a counter for the number of set bits\n    count = 0\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', increment the counter\n        if bit == '1':\n            count += 1\n    \n    # Return the count of set bits\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s)\n"}
{"task_id": "MBPP/80", "completion": "\n    return (n * (n + 1) * (n + 2)) // 6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return strr[0]\n"}
{"task_id": "MBPP/84", "completion": "\n    return [i for i in range(1, n+1)]\n\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    merged_dict = ct.ChainMap(dict1, dict2, dict3)\n    return dict(merged_dict)\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return min(N)\n"}
{"task_id": "MBPP/90", "completion": "\n    return len(list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    # Initialize the index to 0\n    index = 0\n    \n    # Loop through the string\n    while index < len(str1):\n        # Check if the substring is found at the current index\n        if str1[index:index+len(sub_str)] == sub_str:\n            # If found, return the index\n            return index\n        # If not found, increment the index by 1\n        index += 1\n    \n    # If the loop completes without finding the substring, return -1\n    return -1\n"}
{"task_id": "MBPP/92", "completion": "\n    return n % 2 == 0 and n != 0\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    return min(test_list)\n\n"}
{"task_id": "MBPP/95", "completion": "\n    return min(lst)\n"}
{"task_id": "MBPP/96", "completion": "\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n)[2:]\n"}
{"task_id": "MBPP/100", "completion": "\n    num_str = str(num)\n    num_len = len(num_str)\n    if num_str == num_str[::-1]:\n        return num + 1\n\n    for i in range(num_len // 2):\n        if num_str[i] < num_str[num_len - i - 1]:\n            return int(num_str[:i] + num_str[i] + num_str[i + 1:num_len - i - 1] + str(num_str[i]) + num_str[num_len - i - 1:])\n\n        elif num_str[i] > num_str[num_len - i - 1]:\n            return int(num_str[:i] + str(num_str[num_len - i - 1] + 1) + num_str[i + 1:num_len - i - 1] + num_str[i] + num_str[num_len - i - 1:])\n\n    return int(num_str[:num_len // 2] + str(num_str[num_len // 2]) + num_str[:num_len // 2][::-1])\n\n"}
{"task_id": "MBPP/101", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Return the kth element\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split(r'(\\d+)', word)\n    return ''.join(word.capitalize() for word in words if word.isalpha())\n\n"}
{"task_id": "MBPP/103", "completion": "\n    return (n - 1) * m + 1\n"}
{"task_id": "MBPP/104", "completion": "\n    # Sort each sublist in the input list\n    return [sorted(sublist) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return len(lst)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup = list(test_tup)\n    \n    # Add the two lists together\n    result = test_list + test_tup\n    \n    return result\n"}
{"task_id": "MBPP/107", "completion": "\n    # Convert the hexadecimal numbers to integers\n    L = int(L, 16)\n    R = int(R, 16)\n    \n    # Count the number of hexadecimal numbers in the range\n    count = 0\n    for i in range(L, R+1):\n        # Convert the integer back to hexadecimal and count the number of digits\n        hex_i = hex(i)[2:]\n        count += len(hex_i)\n    \n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap to store the smallest number from the three lists\n    min_heap = []\n    heapq.heappush(min_heap, (num1[0], 0, num1))\n    heapq.heappush(min_heap, (num2[0], 0, num2))\n    heapq.heappush(min_heap, (num3[0], 0, num3))\n\n    # Initialize the result list\n    result = []\n\n    # While the min heap is not empty\n    while min_heap:\n        # Get the smallest number from the min heap\n        num, index, nums = heapq.heappop(min_heap)\n\n        # Add the smallest number to the result list\n        result.append(num)\n\n        # If there are more numbers in the list from which the smallest number was taken\n        if index + 1 < len(nums):\n            # Push the next number from the list into the min heap\n            heapq.heappush(min_heap, (nums[index + 1], index + 1, nums))\n\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    # Convert the string to a list of characters\n    s = list(s)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Loop through the string\n    for i in range(n):\n        # Append the character at the current index to the result list\n        result.append(s[i])\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_list = []\n    for i in range(strt_val, stop_val):\n        if i not in test_list:\n            missing_list.append(i)\n    return missing_list\n"}
{"task_id": "MBPP/111", "completion": "\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common = common.intersection(sublist)\n    return list(common)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * (radius + height)\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        return int(text)\n    except ValueError:\n        return None\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    return [i for i in list1 if i == '']\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list]\n"}
{"task_id": "MBPP/118", "completion": "\n    return list(string)\n"}
{"task_id": "MBPP/119", "completion": "\n    for i in range(n):\n        if arr[i] == 0:\n            return i\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    # Find the maximum product of two numbers in the list\n    max_product = max(list1) * max(list1)\n    # Find the minimum product of two numbers in the list\n    min_product = min(list1) * min(list1)\n    # Return the maximum product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    if count == 3:\n        return True\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if A[i] + A[j] + A[k] == sum:\n                    return True\n    return False\n"}
{"task_id": "MBPP/122", "completion": "\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    elif n == 1:\n        return True\n    elif n == 2:\n        return True\n    elif n == 3:\n        return True\n    elif n == 4:\n        return True\n    elif n == 5:\n        return True\n    elif n == 6:\n        return True\n    elif n == 7:\n        return True\n    elif n == 8:\n        return True\n    elif n == 9:\n        return True\n    elif n == 10:\n        return True\n    elif n == 11:\n        return True\n    elif n == 12:\n        return True\n    elif n == 13:\n        return True\n    elif n == 14:\n        return True\n    elif n == 15:\n        return True\n    elif n == 16:\n        return True\n    elif n == 17:\n        return True\n    elif n == 18:\n        return True\n    elif n == 19:\n        return True\n    elif n == 20:\n        return True\n    elif n == 21:\n        return True\n    elif n == 22:\n        return True\n    elif n == 23:\n        return True\n    elif n == 24:\n        return True\n    elif n == 25:\n        return True\n    elif n == 26:\n        return True\n    elif n == 27:\n        return True\n    elif n == 28:\n        return True\n    elif n == 29:\n        return True\n    elif n == 30:\n        return True\n    elif n == 31:\n        return True\n    elif n == 32:\n        return True\n    elif n == 33:\n        return True\n    elif n == 34:\n        return True\n    elif n == 35:\n        return True\n    elif n == 36:\n        return True\n    elif n == 37:\n        return True\n    elif n == 38:\n        return True\n    elif n == 39:\n        return True\n    elif n == 40:\n        return True\n    elif n == 41:\n        return True\n    elif n == 42:\n        return True\n    elif n == 43:\n        return True\n    elif"}
{"task_id": "MBPP/123", "completion": "\n    amicable_numbers = []\n    for i in range(1, limit):\n        sum_of_divisors = sum_of_divisors(i)\n        if sum_of_divisors != i and sum_of_divisors < limit:\n            sum_of_divisors_of_sum = sum_of_divisors(sum_of_divisors)\n            if sum_of_divisors_of_sum == i:\n                amicable_numbers.append(i)\n    return sum(amicable_numbers)\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    # Initialize a list to store the lengths of the substrings\n    lengths = [0] * n\n    \n    # Initialize the length of the first substring\n    lengths[0] = 1\n    \n    # Initialize the length of the second substring\n    lengths[1] = 2 if string[0] == string[1] else 1\n    \n    # Iterate over the string from the third character to the end\n    for i in range(2, n):\n        # If the current character is equal to the character two positions before\n        if string[i] == string[i - 2]:\n            # Update the length of the current substring\n            lengths[i] = lengths[i - 2] + 1\n        # If the current character is equal to the character one position before\n        elif string[i] == string[i - 1]:\n            # Update the length of the current substring\n            lengths[i] = lengths[i - 1] + 1\n        # If neither of the above conditions is met\n        else:\n            # The length of the current substring is 1\n            lengths[i] = 1\n    \n    # Return the maximum length of the substrings\n    return max(lengths)\n"}
{"task_id": "MBPP/126", "completion": "\n    return a + b\n"}
{"task_id": "MBPP/127", "completion": "\n    return x * y\n"}
{"task_id": "MBPP/128", "completion": "\n    words = str.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n    \n    # Check if the matrix is a magic square\n    for i in range(len(my_matrix)):\n        # Check the rows\n        if sum(my_matrix[i]) != sum(my_matrix[0]):\n            return False\n        \n        # Check the columns\n        if sum([my_matrix[j][i] for j in range(len(my_matrix))]) != sum(my_matrix[0]):\n            return False\n    \n    # Check the diagonals\n    if sum([my_matrix[i][i] for i in range(len(my_matrix))]) != sum(my_matrix[0]):\n        return False\n    if sum([my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))]) != sum(my_matrix[0]):\n        return False\n    \n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq_dict = defaultdict(int)\n    \n    # Iterate over the list of numbers\n    for num in nums:\n        # Increment the frequency of the current number\n        freq_dict[num] += 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_dict.values())\n    \n    # Return the maximum frequency\n    return max_freq\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    i = 0\n    j = len(str1) - 1\n    while i < j:\n        if str1[i] not in vowels:\n            i += 1\n        elif str1[j] not in vowels:\n            j -= 1\n        else:\n            str1[i], str1[j] = str1[j], str1[i]\n            i += 1\n            j -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(num for num in nums if num < 0)\n"}
{"task_id": "MBPP/134", "completion": "\n    if n == 0:\n        return arr[-1] == p\n    else:\n        return check_last(arr[:-n], n-1, p)\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    # Define the electricity bill rates\n    rates = {\n        'kWh': 0.12,\n        'kVAh': 0.12,\n        'kVARh': 0.12,\n        'kW': 0.12,\n        'kVA': 0.12,\n        'kVAR': 0.12\n    }\n    \n    # Check if the unit is in the rates dictionary\n    if units in rates:\n        # Calculate the electricity bill\n        bill = units * rates[units]\n        return bill\n    else:\n        return \"Invalid unit. Please use one of the following: kWh, kVAh, kVARh, kW, kVA, kVAR\"\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of zeros with the same length as the input list\n    zeros = array('i', [0] * len(nums))\n    \n    # Iterate over the input list\n    for i, num in enumerate(nums):\n        # If the current number is zero, increment the corresponding index in the zeros array\n        if num == 0:\n            zeros[i] += 1\n    \n    # Return the count of zeros\n    return zeros[-1]\n\n"}
{"task_id": "MBPP/138", "completion": "\n    while n > 0:\n        if n % 2 == 1:\n            return False\n        n = n // 2\n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14159 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Initialize an empty list to store the extracted elements\n    extracted_list = []\n    \n    # Iterate over the test list\n    for i in range(len(test_list)):\n        # Check if the current element is a list\n        if isinstance(test_list[i], list):\n            # If it's a list, recursively call the function on it\n            extracted_list.extend(extract_singly(test_list[i]))\n        else:\n            # If it's not a list, add it to the extracted list\n            extracted_list.append(test_list[i])\n    \n    # Return the extracted list\n    return extracted_list\n"}
{"task_id": "MBPP/141", "completion": "\n    def reverse(nums, start, end):\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n\n    def sort(nums):\n        stack = []\n        for num in nums:\n            while stack and stack[-1] < num:\n                stack.pop()\n            stack.append(num)\n        return stack\n\n    for i in range(len(nums)):\n        nums = sort(nums)\n        reverse(nums, 0, i)\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for the number of same pairs\n    count = 0\n    \n    # Iterate over the elements in the first list\n    for i in range(len(list1)):\n        # Check if the element is present in the second list\n        if list1[i] in list2:\n            # Check if the element is present in the third list\n            if list1[i] in list3:\n                # Increment the counter\n                count += 1\n                \n    # Return the count of same pairs\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    lists = []\n    for i in range(len(Input)):\n        if isinstance(Input[i], list):\n            lists.append(Input[i])\n    return lists\n"}
{"task_id": "MBPP/144", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize the sum of pairs\n    sum_of_pairs = 0\n\n    # Iterate over the dictionary\n    for num in freq:\n        # Calculate the number of pairs for the current number\n        num_pairs = freq[num] * (freq[num] - 1) // 2\n        # Add the sum of pairs for the current number to the total sum\n        sum_of_pairs += num_pairs * num\n\n    return sum_of_pairs\n"}
{"task_id": "MBPP/145", "completion": "\n    # Initialize the maximum difference\n    max_diff = 0\n    \n    # Iterate over the array\n    for i in range(1, n):\n        # Calculate the absolute difference between the current element and the previous element\n        diff = abs(arr[i] - arr[i - 1])\n        \n        # Update the maximum difference if the current difference is larger\n        max_diff = max(max_diff, diff)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return ''.join(str(ord(c)) for c in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = tri[i][j]\n            elif i == 0:\n                dp[i][j] = tri[i][j] + dp[i][j-1]\n            elif j == 0:\n                dp[i][j] = tri[i][j] + dp[i-1][j]\n            else:\n                dp[i][j] = tri[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/148", "completion": "\n    return sum(int(digit) for digit in str(x))\n"}
{"task_id": "MBPP/149", "completion": "\n    # Initialize a 2D table to store the lengths of the longest subsequences\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize the maximum length of the longest subsequence\n    max_len = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        for j in range(i, n):\n            # If the current element is equal to the previous element, \n            # the length of the longest subsequence is the same as the previous one\n            if i == 0 or arr[i] == arr[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            # If the current element is not equal to the previous element, \n            # the length of the longest subsequence is the maximum of the previous one and the current one\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            \n            # Update the maximum length of the longest subsequence\n            max_len = max(max_len, dp[i][j])\n    \n    # Return the maximum length of the longest subsequence\n    return max_len\n"}
{"task_id": "MBPP/150", "completion": "\n    return a in b and b in c\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    \n    # Base case: if a is empty, return b\n    if not a:\n        return b\n    \n    # Base case: if b is empty, return a\n    if not b:\n        return a\n    \n    # If the first element of a is smaller than the first element of b, \n    # then the first element of a should be the first element of the merged list\n    if a[0] < b[0]:\n        # Recursively sort the rest of a and merge the result with the first element of a\n        return [a[0]] + merge(a[1:], b)\n    \n    # If the first element of b is smaller than the first element of a, \n    # then the first element of b should be the first element of the merged list\n    else:\n        # Recursively sort the rest of b and merge the result with the first element of b\n        return [b[0]] + merge(a, b[1:])\n"}
{"task_id": "MBPP/153", "completion": "\n    if a == 0:\n        return None\n    x = -b / (2 * a)\n    y = a * x**2 + b * x + c\n    return (x, y)\n"}
{"task_id": "MBPP/154", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Find the element with the highest frequency\n    max_freq = 0\n    for num in freq:\n        if freq[num] > max_freq:\n            max_freq = freq[num]\n            max_num = num\n\n    # Check if the frequency of the element is greater than N/2\n    if freq[max_num] > N/2:\n        return max_num\n    else:\n        return None\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)\n"}
{"task_id": "MBPP/156", "completion": "\n    # Convert the string to a tuple\n    tuple_str = tuple_str.replace(\"(\", \"\").replace(\")\", \"\").split(\",\")\n    # Convert the string to integers\n    tuple_int = [int(i) for i in tuple_str]\n    return tuple_int\n"}
{"task_id": "MBPP/157", "completion": "\n    encoded_list = []\n    for key, group in groupby(list1):\n        encoded_list.append((key, len(list(group))))\n    return encoded_list\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Initialize the count of operations\n    ops = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # If the current element is greater than k, increment the operations count\n        if arr[i] > k:\n            ops += 1\n    \n    # Return the minimum number of operations\n    return ops\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 1 or month == 2 or month == 12:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    # Calculate the number of times the first number can be divided by the second number\n    count = n // b\n    \n    # Calculate the remaining number after division\n    remaining = n % b\n    \n    # Calculate the sum of the first number multiplied by the count and the remaining number\n    result = a * count + remaining * a\n    \n    return result\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    return sum(range(1, n + 1))\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * l) / 2\n\n"}
{"task_id": "MBPP/164", "completion": "\n    return sum(math.floor(n / i) for i in range(1, int(math.sqrt(n)) + 1))\n\n"}
{"task_id": "MBPP/165", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq = {}\n    for num in A:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Iterate through the dictionary to find the pair with the highest frequency\n    max_freq = 0\n    pair = None\n    for num in freq:\n        if freq[num] > max_freq and num % 2 == 0:\n            max_freq = freq[num]\n            pair = (num, num)\n\n    # If no pair is found, return None\n    if pair is None:\n        return None\n\n    # Return the pair with the highest frequency\n    return pair\n\n"}
{"task_id": "MBPP/167", "completion": "\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Return the dictionary\n    return char_count\n"}
{"task_id": "MBPP/173", "completion": "\n    text = re.sub(r'[^\\w\\s]', '', text)\n    return text\n\n"}
{"task_id": "MBPP/174", "completion": "\n    return dict(l)\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    return L + R\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    return x == 0 or x == 1 or x == 2 or x == 3 or x == 4 or x == 5 or x == 6 or x == 7 or x == 8 or x == 9\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n    # Radius of the Earth in kilometers\n    R = 6371\n    return R * c\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    pattern = r\"[a-zA-Z]\"\n    matches = re.findall(pattern, string)\n    return matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    # Initialize a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize a variable to store the count of pairs\n    count = 0\n\n    # Iterate over the frequency dictionary\n    for num in freq:\n        # If the frequency of the current number is greater than or equal to k\n        if freq[num] >= k:\n            # Calculate the number of pairs that can be formed with the current number\n            pairs = freq[num] * (freq[num] - 1) // 2\n            # Add the number of pairs to the count\n            count += pairs\n\n    # Return the count of pairs\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focus of the parabola\n    focus_x = -b / (2 * a)\n    focus_y = c / (4 * a)\n    \n    return focus_x, focus_y\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequences of substrings.\n    L = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Fill the table in a bottom-up manner.\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # The length of the longest common subsequence is stored in L[m][n].\n    return L[m][n]\n"}
{"task_id": "MBPP/188", "completion": "\n    return n * n\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a boolean array, prime, of size n+1\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False\n\n    # Iterate over the array\n    for num in arr:\n        # If the number is within the range of the boolean array\n        if 1 <= num <= n:\n            # Mark the corresponding index in the boolean array as False\n            prime[num] = False\n\n    # Find the first missing positive number\n    for i in range(1, n + 1):\n        # If the number is marked as True, it's the first missing positive number\n        if prime[i]:\n            return i\n\n    # If no missing positive number is found, return n + 1\n    return n + 1\n\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points in the rectangle defined by (x1, y1) and (x2, y2)\n    # The formula is (x2 - x1 + 1) * (y2 - y1 + 1)\n    return (x2 - x1 + 1) * (y2 - y1 + 1)\n"}
{"task_id": "MBPP/191", "completion": "\n    monthnumber = {\n        \"January\": 1,\n        \"February\": 2,\n        \"March\": 3,\n        \"April\": 4,\n        \"May\": 5,\n        \"June\": 6,\n        \"July\": 7,\n        \"August\": 8,\n        \"September\": 9,\n        \"October\": 10,\n        \"November\": 11,\n        \"December\": 12\n    }\n    return monthnumber.get(monthname3)\n"}
{"task_id": "MBPP/192", "completion": "\n    if str == \"hello\":\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return test_tup[0]\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    # Initialize the count of elements less than x\n    count = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # If the current element is less than x, increment the count\n        if arr[i] < x:\n            count += 1\n    \n    # Return the count\n    return count\n"}
{"task_id": "MBPP/196", "completion": "\n    # Create a new list to store the result\n    result = []\n    # Iterate over the test list\n    for i in range(len(test_list)):\n        # Check if the tuple is not in the result list\n        if test_list[i] not in result:\n            # Add the tuple to the result list\n            result.append(test_list[i])\n        # Check if the length of the result list is greater than K\n        if len(result) > K:\n            # Remove the first tuple from the result list\n            result.pop(0)\n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/197", "completion": "\n    # Convert the tuples to lists\n    test_list1 = list(test_tup1)\n    test_list2 = list(test_tup2)\n    \n    # Find the exponentiation of the two lists\n    result = [a ** b for a, b in zip(test_list1, test_list2)]\n    \n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    return max(a, b)\n\n"}
{"task_id": "MBPP/199", "completion": "\n    # Initialize the highest power of 2 to 0\n    highest_power = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if the number is a power of 2\n        if (i & (i - 1) == 0):\n            # If it is, update the highest power of 2\n            highest_power = i\n    \n    # Return the highest power of 2\n    return highest_power\n"}
{"task_id": "MBPP/200", "completion": "\n    return max(list1)\n"}
{"task_id": "MBPP/201", "completion": "\n    if len(lst) == 0:\n        return True\n    if len(lst) == 1:\n        return lst[0] == lst[0]\n    if lst[0] == lst[0]:\n        return chkList(lst[1:])\n    return False\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for char in str1 if int(char) % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return sum(el1 != el2 for el1, el2 in zip(n1, n2))\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    return tuple(test_tup[::-1])\n"}
{"task_id": "MBPP/206", "completion": "\n    # Initialize an empty string to store the concatenated elements\n    concatenated_str = \"\"\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # Concatenate the element to the string\n        concatenated_str += str(element)\n    \n    # Return the concatenated string\n    return concatenated_str\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            if str[i] == str[j]:\n                if i == j:\n                    dp[i][j] = 1\n                elif j - i == 1:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                max_length = max(max_length, dp[i][j])\n    return max_length\n"}
{"task_id": "MBPP/208", "completion": "\n    try:\n        float(num)\n        return True\n    except ValueError:\n        return False\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappushpop(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = r'[^a-zA-Z0-9\\s\\.,!?;:\\-\\'\\\"]'\n    if re.search(pattern, string):\n        return False\n    return True\n\n"}
{"task_id": "MBPP/211", "completion": "\n    return str(n).count('0')\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([i**4 for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    # Concatenate the strings in the tuples\n    result = test_tup1 + test_tup2\n    return result\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    return [decode(x) for x in alist]\n"}
{"task_id": "MBPP/216", "completion": "\n    return set(list1).issubset(set(list2))\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char, count in char_count.items():\n        if count > 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the number of operations\n    operations = 0\n    for i in range(len(A)):\n        operations += abs(A[i] - B[i])\n    return operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    min_val = float('inf')\n    max_val = float('-inf')\n    for i in range(K):\n        if test_tup[i] < min_val:\n            min_val = test_tup[i]\n        if test_tup[i] > max_val:\n            max_val = test_tup[i]\n    return min_val, max_val\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all special characters in the text\n    special_chars = re.findall(r'[^\\w\\s]', text)\n    \n    # Sort the special characters by their frequency in descending order\n    special_chars.sort(key=lambda x: text.count(x), reverse=True)\n    \n    # Replace the most frequent special characters with the nth most frequent special character\n    for i in range(n):\n        char = special_chars[i]\n        text = text.replace(char, special_chars[n])\n    \n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if isinstance(test_tuple, tuple):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/223", "completion": "\n    count = 0\n    for i in range(n):\n        if arr[i] == x:\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            count = 1\n        else:\n            count += 1\n    return count > 0\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return low\n    mid = (low + high) // 2\n    if arr[mid] < arr[mid + 1]:\n        return mid\n    if arr[mid] > arr[mid - 1]:\n        return mid - 1\n    if arr[mid] < arr[low]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)\n"}
{"task_id": "MBPP/226", "completion": "\n    odd_values = [char for char in str if ord(char) % 2 != 0]\n    return ''.join(odd_values)\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Calculate the number of bits set in the given range\n    bits_set = 0\n    for i in range(l, r + 1):\n        bits_set += bin(n & (1 << i)).count('1')\n    return bits_set\n"}
{"task_id": "MBPP/229", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Create a list to store the result\n    result = []\n    for i in range(1, n + 1):\n        if i in freq_dict:\n            result.append((i, freq_dict[i]))\n\n    return result\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Initialize the maximum sum\n    max_sum = 0\n    \n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Iterate over each element in the current row\n        for j in range(i + 1):\n            # If the current element is the maximum in the row, update the maximum sum\n            if j == 0 or tri[i][j] > tri[i][j - 1]:\n                max_sum = max(max_sum, tri[i][j])\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/232", "completion": "\n    heapq.heapify(list1)\n    for i in range(n):\n        heapq.heappop(list1)\n    return list1\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l**3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n & 0xAAAAAAAA\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of triangles\n    num_triangles = (N * (N - 1) * (N - 2)) // 6\n    # Calculate the number of triangles with K sides\n    num_triangles_with_K_sides = (N * (N - 1) * (N - 2)) // 6\n    return num_triangles_with_K_sides\n"}
{"task_id": "MBPP/237", "completion": "\n    # Count the occurrences of each element in the list\n    counter = Counter(test_list)\n    \n    # Check if any element occurs more than once\n    if any(count > 1 for count in counter.values()):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/238", "completion": "\n    n = len(str)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/239", "completion": "\n    return m * n\n\n"}
{"task_id": "MBPP/240", "completion": "\n    return [x for x in list1 if x not in list2]\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[0 for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lst.count, reverse=True)\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.sqrt(N)\n    if root == int(root):\n        return int(root) ** 2\n    else:\n        return (int(root) + 1) ** 2\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += arr[i]\n        \n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n            \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/246", "completion": "\n    x = number / 2.0\n    while True:\n        better_guess = (x + number / x) / 2.0\n        if abs(better_guess - x) < 0.000001:\n            return better_guess\n        x = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    stack = []\n    for char in str:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1 / (i + 1) for i in range(n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return [num for num in array_nums1 if num in array_nums2]\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    list.append(element)\n    return list\n"}
{"task_id": "MBPP/252", "completion": "\n    return [cmath.polar(n) for n in numbers]\n\n"}
{"task_id": "MBPP/253", "completion": "\n    return len(list1)\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\b\\w+\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    return list(combinations_with_replacement(l, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    count = 0\n    for i in range(2, n+1):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    count = 0\n    for num in array_nums:\n        if num % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum elements\n    return max1, max2\n"}
{"task_id": "MBPP/260", "completion": "\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/261", "completion": "\n    # Check if the tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Tuples must have the same length\"\n    \n    # Check if the tuples are empty\n    if len(test_tup1) == 0:\n        return \"Error: Tuples cannot be empty\"\n    \n    # Check if the tuples contain only numbers\n    if not all(isinstance(x, (int, float)) for x in test_tup1) or not all(isinstance(x, (int, float)) for x in test_tup2):\n        return \"Error: Tuples must contain only numbers\"\n    \n    # Perform element-wise division\n    result = [x / y for x, y in zip(test_tup1, test_tup2)]\n    \n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    for key in d2:\n        if key in d1:\n            if isinstance(d1[key], dict) and isinstance(d2[key], dict):\n                merge_dict(d1[key], d2[key])\n            else:\n                d1[key] = d2[key]\n        else:\n            d1[key] = d2[key]\n    return d1\n"}
{"task_id": "MBPP/264", "completion": "\n    return h_age * 7\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i+step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum([i**2 for i in range(1, n+1)])\n"}
{"task_id": "MBPP/268", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    even_index_sum = 0\n    for i in range(n):\n        if arr[i] % 2 == 0:\n            even_sum += arr[i]\n        if i % 2 == 0:\n            even_index_sum += arr[i]\n    return even_sum + even_index_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    return sum([i**2 for i in range(1, n+1) if i % 2 == 0])\n"}
{"task_id": "MBPP/272", "completion": "\n    return test_list[-1]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(set(test_tup1) - set(test_tup2))\n"}
{"task_id": "MBPP/274", "completion": "\n    sum = 0\n    for k in range(0, n + 1):\n        sum += math.comb(n, k)\n    return sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    return a % n + 1\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return len(test_tup)\n"}
{"task_id": "MBPP/279", "completion": "\n    return n % 10 == 0 and n % 100 != 0\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return [num for num in nums1 if num not in nums2]\n"}
{"task_id": "MBPP/283", "completion": "\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        return validate(n // 10) and (n % 10) == (n // 10) % 10\n"}
{"task_id": "MBPP/284", "completion": "\n    if element in list:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"(\\w{2})(\\w{3})\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1), match.group(2)\n    else:\n        return None, None\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Initialize the window start index\n    window_start = 0\n\n    # Iterate over the array\n    for window_end in range(n):\n        # Add the current element to the current sum\n        current_sum += a[window_end]\n\n        # If the window size is greater than k, subtract the element at the window start index\n        if window_end >= k - 1:\n            max_sum = max(max_sum, current_sum)\n            current_sum -= a[window_start]\n            window_start += 1\n\n    return max_sum\n\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum([i**2 for i in range(1, n+1)])\n"}
{"task_id": "MBPP/288", "completion": "\n    # Create a 2D array to store the modular inverses\n    mod_inv = [[0 for _ in range(N)] for _ in range(N)]\n    \n    # Calculate the modular inverses\n    for i in range(N):\n        for j in range(N):\n            mod_inv[i][j] = pow(arr[i][j], P-2, P)\n    \n    return mod_inv\n"}
{"task_id": "MBPP/289", "completion": "\n    odd_days = 0\n    for i in range(1, N+1):\n        if i % 2 != 0:\n            odd_days += 1\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(len(i) for i in list1)\n"}
{"task_id": "MBPP/291", "completion": "\n    # Create a 2D array to store the number of ways to reach each cell\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    \n    # Initialize the base case\n    for i in range(n + 1):\n        dp[i][0] = 1\n    \n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            # For each cell, the number of ways to reach it is the sum of the number of ways to reach the cell above it and the cell to its left\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n    \n    # The number of ways to reach the bottom-right cell is stored in the bottom-right cell of the dp array\n    return dp[n][k]\n"}
{"task_id": "MBPP/292", "completion": "\n    # Initialize the list to store the results\n    results = []\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if the number is divisible by m\n        if i % m == 0:\n            # If it is, append it to the results list\n            results.append(i)\n    \n    # Return the list of results\n    return results\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    sum = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum += i\n    return sum\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    return [item for sublist in list1 for item in sublist]\n"}
{"task_id": "MBPP/298", "completion": "\n    return [value for value in l1 if value in l2]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum values for each column\n    max_values = defaultdict(int)\n    \n    # Iterate over each row in the data\n    for row in stdata:\n        # Iterate over each column in the row\n        for col, value in enumerate(row):\n            # Update the maximum value for the column if the current value is greater\n            max_values[col] = max(max_values[col], value)\n    \n    # Return the maximum values as a list\n    return list(max_values.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return count_binary_seq(n-1) + count_binary_seq(n-2)\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    else:\n        return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    return bin(n).count('1')\n"}
{"task_id": "MBPP/303", "completion": "\n    # Create a list to store the results of subproblems\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i - 1]] + a[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    # Return the maximum value that can be put in a knapsack of capacity n\n    return dp[n][n]\n\n"}
{"task_id": "MBPP/304", "completion": "\n    if index >= len(arr):\n        return None\n    if index < 0:\n        return None\n    if index == 0:\n        return arr[index]\n    if index == len(arr) - 1:\n        return arr[index]\n    if index == rotations:\n        return arr[index]\n    if index == rotations + 1:\n        return arr[index]\n    if index == rotations + 2:\n        return arr[index]\n    if index == rotations + 3:\n        return arr[index]\n    if index == rotations + 4:\n        return arr[index]\n    if index == rotations + 5:\n        return arr[index]\n    if index == rotations + 6:\n        return arr[index]\n    if index == rotations + 7:\n        return arr[index]\n    if index == rotations + 8:\n        return arr[index]\n    if index == rotations + 9:\n        return arr[index]\n    if index == rotations + 10:\n        return arr[index]\n    if index == rotations + 11:\n        return arr[index]\n    if index == rotations + 12:\n        return arr[index]\n    if index == rotations + 13:\n        return arr[index]\n    if index == rotations + 14:\n        return arr[index]\n    if index == rotations + 15:\n        return arr[index]\n    if index == rotations + 16:\n        return arr[index]\n    if index == rotations + 17:\n        return arr[index]\n    if index == rotations + 18:\n        return arr[index]\n    if index == rotations + 19:\n        return arr[index]\n    if index == rotations + 20:\n        return arr[index]\n    if index == rotations + 21:\n        return arr[index]\n    if index == rotations + 22:\n        return arr[index]\n    if index == rotations + 23:\n        return arr[index]\n    if index == rotations + 24:\n        return arr[index]\n    if index == rotations + 25:\n        return arr[index]\n    if index == rotations + 26:\n        return arr[index]\n    if index == rotations + 27:\n        return arr[index]\n    if index == rotations + 28:\n        return arr[index]\n    if index == rotations + 29:\n        return arr[index]\n    if index == rotations + 30:\n        return arr[index]\n    if index == rotations + 31:\n        return arr[index]\n    if"}
{"task_id": "MBPP/305", "completion": "\n    return [word for word in words if word.startswith('p')]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == n:\n        return 0\n    if index in memo:\n        return memo[index]\n    if a[index] > k:\n        return max_sum_increasing_subseq(a, n, index + 1, k)\n    else:\n        return max(max_sum_increasing_subseq(a, n, index + 1, k),\n                   a[index] + max_sum_increasing_subseq(a, n, index + 1, a[index]))\n\nmemo = {}"}
{"task_id": "MBPP/307", "completion": "\n    if tuplex == ():\n        return (0, 0)\n    elif tuplex == (m, n):\n        return (m, n)\n    else:\n        return (tuplex[0] + m, tuplex[1] + n)\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Initialize the maximum product\n    max_product = 0\n    \n    # Iterate over all possible pairs of numbers\n    for i in range(N):\n        for j in range(N):\n            # Calculate the product of the current pair\n            product = nums1[i] * nums2[j]\n            \n            # Update the maximum product if the current product is larger\n            max_product = max(max_product, product)\n    \n    return max_product\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1.split(','))\n"}
{"task_id": "MBPP/311", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Find the leftmost unset bit\n    left_most_unset_bit = binary.find('0')\n    \n    # If no unset bit is found, return -1\n    if left_most_unset_bit == -1:\n        return -1\n    \n    # Set the leftmost unset bit to 1\n    binary = binary[:left_most_unset_bit] + '1' + binary[left_most_unset_bit + 1:]\n    \n    # Convert the binary string back to an integer\n    n = int(binary, 2)\n    \n    return n\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    return [i for i in list1 if i >= 0]\n"}
{"task_id": "MBPP/314", "completion": "\n    # Initialize the maximum sum\n    max_sum = float('-inf')\n    \n    # Iterate over each cell in the grid\n    for i in range(n):\n        for j in range(n):\n            # Initialize the sum of the current cell and its neighbors\n            curr_sum = grid[i][j]\n            \n            # Check the cell to the right\n            if j < n - 1:\n                curr_sum += grid[i][j + 1]\n            \n            # Check the cell below\n            if i < n - 1:\n                curr_sum += grid[i + 1][j]\n            \n            # Check the cell to the right and below\n            if j < n - 1 and i < n - 1:\n                curr_sum += grid[i + 1][j + 1]\n            \n            # Update the maximum sum\n            max_sum = max(max_sum, curr_sum)\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    # Initialize variables\n    max_len = 0\n    max_len_str = \"\"\n    \n    # Loop through the string\n    for i in range(len(str)):\n        # Check if the character is even\n        if str[i] % 2 == 0:\n            # Initialize variables\n            len_str = 0\n            temp_str = \"\"\n            \n            # Loop through the string from the current index\n            for j in range(i, len(str)):\n                # Add the character to the temporary string\n                temp_str += str[j]\n                # Increment the length of the temporary string\n                len_str += 1\n                \n                # Check if the length of the temporary string is greater than the max length\n                if len_str > max_len:\n                    # Update the max length and the max length string\n                    max_len = len_str\n                    max_len_str = temp_str\n                    \n    # Return the max length string\n    return max_len_str\n"}
{"task_id": "MBPP/316", "completion": "\n    # Initialize the index to -1, assuming x is not in the list\n    last_occurrence = -1\n    \n    # Iterate over the list in reverse order\n    for i in range(len(A) - 1, -1, -1):\n        # If the current element is equal to x, update the last occurrence index\n        if A[i] == x:\n            last_occurrence = i\n            # Break the loop as we have found the last occurrence\n            break\n    \n    # Return the last occurrence index\n    return last_occurrence\n"}
{"task_id": "MBPP/317", "completion": "\n    return [x for x, _ in groupby(alist)]\n\n"}
{"task_id": "MBPP/318", "completion": "\n    stack = []\n    max_volume = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            if stack:\n                start = stack.pop()\n                max_volume = max(max_volume, i - start)\n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    words = re.findall(r'\\b\\w+\\b', text)\n    max_len = 0\n    max_word = ''\n    for word in words:\n        if len(word) > max_len:\n            max_len = len(word)\n            max_word = word\n    return max_word\n\n"}
{"task_id": "MBPP/320", "completion": "\n    return sum(range(n + 1)) - sum(range(n))\n"}
{"task_id": "MBPP/321", "completion": "\n    # Initialize the list of possible words\n    words = [\"demlo\", \"dello\", \"demol\", \"dello\", \"demol\", \"demlo\", \"demol\", \"demlo\"]\n    # Initialize the list of possible words with the given string\n    words.append(s)\n    # Sort the list of words\n    words.sort()\n    # Return the first word in the sorted list\n    return words[0]\n"}
{"task_id": "MBPP/322", "completion": "\n    return min(list1)\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n    if out_of_place:\n        temp = arr[cur]\n        for i in range(cur, n):\n            arr[i] = arr[i + 1]\n        arr[n] = temp\n    else:\n        for i in range(n - 1, cur, -1):\n            arr[i] = arr[i - 1]\n        arr[cur] = arr[n]\n    return right_rotate(arr, n - 1, out_of_place, cur + 1)\n\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[::2]) + sum(test_tuple[1::2])\n"}
{"task_id": "MBPP/325", "completion": "\n    if n == 0:\n        return 0\n    min_squares = float('inf')\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            min_squares = min(min_squares, 1 + get_Min_Squares(n - i ** 2))\n    return min_squares\n"}
{"task_id": "MBPP/326", "completion": "\n    # Create a dictionary to store the frequency of each element\n    frequency_dict = defaultdict(int)\n    \n    # Iterate over the list and count the frequency of each element\n    for element in test_list:\n        frequency_dict[element] += 1\n    \n    # Find the element with the highest frequency\n    most_frequent_element = max(frequency_dict, key=frequency_dict.get)\n    \n    return most_frequent_element\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y and y != z:\n        return True\n    elif x == z and z != y:\n        return True\n    elif y == z and z != x:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    # Create a copy of the list\n    list2 = list1.copy()\n    \n    # Rotate the list to the left by n places\n    list2 = list2[-n:] + list2[:-n]\n    \n    # Return the rotated list\n    return list2\n"}
{"task_id": "MBPP/329", "completion": "\n    return list.count(-1)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r\"[a-zA-Z]\"\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/331", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Count the number of unset bits (0s)\n    unset_bits = binary.count('0')\n    \n    return unset_bits\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort(key=lambda x: x[0])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    if a == b == c:\n        return True\n    elif a == b or b == c or a == c:\n        return False\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return a * n * (2 + (n - 1) * d) / 2\n"}
{"task_id": "MBPP/336", "completion": "\n    monthnum = {\n        \"January\": 1,\n        \"February\": 2,\n        \"March\": 3,\n        \"April\": 4,\n        \"May\": 5,\n        \"June\": 6,\n        \"July\": 7,\n        \"August\": 8,\n        \"September\": 9,\n        \"October\": 10,\n        \"November\": 11,\n        \"December\": 12\n    }\n    return monthnum.get(monthname1, \"Invalid month name\")\n"}
{"task_id": "MBPP/337", "completion": "\n    # Regular expression to match a word\n    pattern = r'\\b\\w+\\b'\n    # Find all matches in the text\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/338", "completion": "\n    # Check if the string is empty\n    if not s:\n        return True\n\n    # Check if the string is equal to itself\n    if s == s[::-1]:\n        return True\n\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n"}
{"task_id": "MBPP/339", "completion": "\n    if y == 0:\n        return None\n    else:\n        return x // y\n"}
{"task_id": "MBPP/340", "completion": "\n    return sum(sorted(lst)[:3])  # sorted() returns a new sorted list, and [:3] gets the first three elements of the sorted list\n\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(s)\n"}
{"task_id": "MBPP/342", "completion": "\n    if not list:\n        return 0\n\n    min_heap = []\n    max_heap = []\n\n    for i, num in enumerate(list):\n        heappush(min_heap, Node(num, i, 0))\n        heappush(max_heap, Node(-num, i, 0))\n\n    min_sum = 0\n    max_sum = 0\n    min_range = float('inf')\n    max_range = float('-inf')\n\n    while min_heap:\n        node = heappop(min_heap)\n        if node.index == len(list) - 1:\n            break\n\n        next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n        heappush(min_heap, next_node)\n\n        min_sum += list[node.list_num][node.index]\n        max_sum -= list[node.list_num][node.index]\n\n        min_range = min(min_range, node.value - min_sum)\n        max_range = max(max_range, -node.value - max_sum)\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    return s[0]\n"}
{"task_id": "MBPP/344", "completion": "\n    # Initialize a counter for odd squares\n    odd_squares = 0\n    \n    # Iterate over the range of numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if the square of the current number is odd\n        if i ** 2 % 2 != 0:\n            # If it's odd, increment the counter\n            odd_squares += 1\n    \n    # Return the count of odd squares\n    return odd_squares\n"}
{"task_id": "MBPP/345", "completion": "\n    if len(nums) < 2:\n        return False\n    for i in range(len(nums) - 1):\n        if nums[i + 1] - nums[i] != 1:\n            return False\n    return True\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2] * (k - 1)\n    return dp[n] % (10 ** 9 + 7)  # return the result modulo 10^9 + 7\n"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    elif n < 0:\n        return 0\n    else:\n        return bin_coff(n - 1, r - 1) + bin_coff(n - 1, r)\n"}
{"task_id": "MBPP/349", "completion": "\n    if len(string) == 0:\n        return False\n    if len(string) == 1:\n        return True\n    if string[0] == string[-1]:\n        return check_s(string[1:-1])\n    return False\n"}
{"task_id": "MBPP/350", "completion": "\n    n = len(s)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a list of all elements in the array\n    elements = [arr[i] for i in range(n)]\n    \n    # Sort the list of elements\n    elements.sort()\n    \n    # Find the kth smallest element\n    kth_smallest = elements[k-1]\n    \n    # Find the index of the kth smallest element in the original array\n    index = arr.index(kth_smallest)\n    \n    # Return the first element of the subarray starting at the index of the kth smallest element\n    return arr[index:index+1][0]\n"}
{"task_id": "MBPP/352", "completion": "\n    return ''.join(sorted(set(str), key=str.index))\n"}
{"task_id": "MBPP/353", "completion": "\n    return [item for i, item in enumerate(list1) if i != n]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a * n / d\n\n"}
{"task_id": "MBPP/355", "completion": "\n    # Calculate the area of the rectangle\n    area = 2 * radius ** 2\n    \n    # Return the count of rectangles\n    return area\n"}
{"task_id": "MBPP/356", "completion": "\n    return math.acos((a * b) / (math.sqrt(a ** 2 + b ** 2) * math.sqrt(b ** 2 + a ** 2)))\n"}
{"task_id": "MBPP/357", "completion": "\n    max_num = test_list[0]\n    for num in test_list:\n        if num > max_num:\n            max_num = num\n    return max_num\n"}
{"task_id": "MBPP/358", "completion": "\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] % nums2[i])\n    return result\n"}
{"task_id": "MBPP/359", "completion": "\n    # Check if the solution is valid\n    if a + b + c == 180:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    return n * 2\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != '']\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq.values())\n    \n    # Find all numbers with the maximum frequency\n    max_nums = [num for num, count in freq.items() if count == max_freq]\n    \n    return max_nums\n"}
{"task_id": "MBPP/363", "completion": "\n    # Check if the list is empty\n    if not test_list:\n        return \"List is empty\"\n    \n    # Check if K is a positive integer\n    if not isinstance(K, int) or K <= 0:\n        return \"K must be a positive integer\"\n    \n    # Check if the list has at least K elements\n    if len(test_list) < K:\n        return \"List must have at least K elements\"\n    \n    # Add K elements to the list\n    test_list.extend([0] * K)\n    \n    return test_list\n"}
{"task_id": "MBPP/364", "completion": "\n    if ch == 'A':\n        return 'T'\n    elif ch == 'C':\n        return 'G'\n    elif ch == 'G':\n        return 'C'\n    elif ch == 'T':\n        return 'A'\n    else:\n        return ch\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(n))\n"}
{"task_id": "MBPP/366", "completion": "\n    product = 1\n    for num in list_nums:\n        product *= num\n    return product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return [test_tup] * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: x['price'])\n"}
{"task_id": "MBPP/371", "completion": "\n    A.sort()\n    for i in range(left_element, right_element + 1):\n        if A[i] != i:\n            return i\n    return right_element + 1\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n, m)\n"}
{"task_id": "MBPP/376", "completion": "\n    # Remove the replica from the test tuple\n    test_tup = test_tup[:len(test_tup)//2] + test_tup[len(test_tup)//2+1:]\n    return test_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 0:\n        first_element = test_list.pop(0)\n        return first_element\n    else:\n        return None\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    # Create a list of lists\n    list_of_lists = []\n    for i in range(rownum):\n        list_of_lists.append([0] * colnum)\n    return list_of_lists\n"}
{"task_id": "MBPP/381", "completion": "\n    return [item[index_no] for item in list_data]\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    count = 0\n    for i in range(n):\n        if A[i] == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the smallest number with the highest frequency\n    smallest_freq = float('inf')\n    smallest_num = None\n    for num, freq in freq_dict.items():\n        if freq > smallest_freq:\n            smallest_freq = freq\n            smallest_num = num\n\n    return smallest_num, smallest_freq\n\n"}
{"task_id": "MBPP/385", "completion": "\n    return 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - 1 / (1 - "}
{"task_id": "MBPP/386", "completion": "\n    count = 0\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/387", "completion": "\n    if N % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    # Initialize the highest power of 2\n    highest_power = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if the number is a power of 2\n        if (i & (i - 1) == 0):\n            # If it is, update the highest power of 2\n            highest_power = i\n    \n    # Return the highest power of 2\n    return highest_power\n"}
{"task_id": "MBPP/389", "completion": "\n    a, b = 2, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return b\n"}
{"task_id": "MBPP/390", "completion": "\n    list.append(string)\n    return list\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create a dictionary with the keys from l1 and the values from l2\n    dict1 = dict(zip(l1, l2))\n    \n    # Create a dictionary with the keys from l1 and the values from l3\n    dict2 = dict(zip(l1, l3))\n    \n    # Return a dictionary with the keys from l1 and the values from dict1 and dict2\n    return {key: (value1, value2) for key, value1, value2 in zip(l1, dict1.values(), dict2.values())}\n"}
{"task_id": "MBPP/392", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return n + get_max_sum(n - 1)\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(len(i) for i in input_list)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return sum(int(digit) for digit in str(nums))\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq = {}\n    for item in test_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n"}
{"task_id": "MBPP/401", "completion": "\n    # Convert the tuples to lists\n    test_list1 = list(test_tup1)\n    test_list2 = list(test_tup2)\n    \n    # Add the lists together\n    result_list = test_list1 + test_list2\n    \n    # Convert the result back to a tuple\n    result_tup = tuple(result_list)\n    \n    return result_tup\n"}
{"task_id": "MBPP/402", "completion": "\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n - r < r:\n        return ncr_modp(n, n - r, p)\n    res = 1\n    for i in range(r):\n        res = (res * (n - i)) % p\n    return res\n"}
{"task_id": "MBPP/403", "completion": "\n    pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(pattern.match(str))\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return min(a, b)\n"}
{"task_id": "MBPP/405", "completion": "\n    if tuplex == tuple1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/406", "completion": "\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/407", "completion": "\n    return [i for i in range(n, 0, -1)] + [0] + [i for i in range(1, n)]\n\n"}
{"task_id": "MBPP/408", "completion": "\n    min_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(min_heap, (num1 + num2, num1, num2))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n    return [pair[1:] for pair in min_heap]\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Find the minimum product of two numbers in the list\n    min_product = float('inf')\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i] * list1[j]\n            if product < min_product:\n                min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'_(\\w)', lambda m: m.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n            \n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        result = max(result, max_product)\n        \n    return result\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n < 0:\n        return -1\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 7\n    if n == 5:\n        return 13\n    if n == 6:\n        return 24\n    if n == 7:\n        return 44\n    if n == 8:\n        return 81\n    if n == 9:\n        return 149\n    if n == 10:\n        return 274\n    if n == 11:\n        return 504\n    if n == 12:\n        return 927\n    if n == 13:\n        return 1705\n    if n == 14:\n        return 3136\n    if n == 15:\n        return 5768\n    if n == 16:\n        return 10609\n    if n == 17:\n        return 19513\n    if n == 18:\n        return 35850\n    if n == 19:\n        return 65664\n    if n == 20:\n        return 120511\n    if n == 21:\n        return 220923\n    if n == 22:\n        return 403291\n    if n == 23:\n        return 736192\n    if n == 24:\n        return 1346269\n    if n == 25:\n        return 2464784\n    if n == 26:\n        return 4503063\n    if n == 27:\n        return 8206349\n    if n == 28:\n        return 14930352\n    if n == 29:\n        return 27294403\n    if n == 30:\n        return 49876369\n    if n == 31:\n        return 91162521\n    if n == 32:\n        return 166097184\n    if n == 33:\n        return 302444509\n    if n == 34:\n        return 553111729\n    if n == 35:\n        return 1008161159\n    if n == 36:\n        return 1841111117\n   "}
{"task_id": "MBPP/417", "completion": "\n    # Initialize an empty dictionary to store the grouped tuples\n    grouped_tuples = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Extract the first element of the tuple (the key)\n        key = tup[0]\n        \n        # If the key is not already in the dictionary, add it with an empty list as its value\n        if key not in grouped_tuples:\n            grouped_tuples[key] = []\n        \n        # Append the tuple to the list of tuples for the corresponding key\n        grouped_tuples[key].append(tup)\n    \n    # Return the dictionary of grouped tuples\n    return grouped_tuples\n"}
{"task_id": "MBPP/418", "completion": "\n    return max(lst)\n"}
{"task_id": "MBPP/419", "completion": "\n    # Round each number in the list to the nearest integer\n    rounded_list = [round(num) for num in list1]\n    \n    # Sum the rounded numbers\n    total = sum(rounded_list)\n    \n    return total\n"}
{"task_id": "MBPP/420", "completion": "\n    return n**3 + 1\n"}
{"task_id": "MBPP/421", "completion": "\n    # Initialize an empty string to store the concatenated result\n    result = \"\"\n    \n    # Iterate over each element in the tuple\n    for element in test_tup:\n        # Concatenate the element to the result string\n        result += str(element)\n    \n    # Return the concatenated result\n    return result\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    # Return average of cubes\n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each position\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Initialize the first row and column of the 2D array\n    for i in range(m+1):\n        dp[i][0] = 0\n    for j in range(n+1):\n        dp[0][j] = 0\n    \n    # Fill in the rest of the 2D array\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            # If the current position is not blocked, calculate the maximum gold that can be collected\n            if gold[i-1][j-1] != 0:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + gold[i-1][j-1])\n            # If the current position is blocked, the maximum gold that can be collected is the same as the maximum gold that can be collected without visiting this position\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Return the maximum gold that can be collected\n    return dp[m][n]\n"}
{"task_id": "MBPP/424", "completion": "\n    return test_tuple[-1]\n"}
{"task_id": "MBPP/425", "completion": "\n    return list1.count(x)\n"}
{"task_id": "MBPP/426", "completion": "\n    return [num for num in nums if num % 2 != 0]\n"}
{"task_id": "MBPP/427", "completion": "\n    return dt.strftime('%Y-%m-%d')\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Check if the tuples are equal\n    if test_tup1 == test_tup2:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the directrix\n    directrix = -b / (4 * a)\n    \n    return focal_length, directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    return [element for element in list1 if element in list2]\n"}
{"task_id": "MBPP/432", "completion": "\n    area = 0.5 * (base1 + base2) * height\n    return area\n"}
{"task_id": "MBPP/433", "completion": "\n    return [x for x in arr if x > number]\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"^[a-zA-Z0-9]+$\"\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    return [i for i in list1 if i < 0]\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([i for i in str1 if i not in '13579'])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return [i for i in L if i % 2 == 0]\n"}
{"task_id": "MBPP/440", "completion": "\n    # Regular expression to find adverbs\n    adverb_pattern = r'\\b(very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|highly|really|quite|somewhat|fairly|pretty|rather|pretty|"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l**2\n"}
{"task_id": "MBPP/442", "completion": "\n    return sum(1 for num in nums if num > 0)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    if len(list1) == 0:\n        return None\n    else:\n        return max(list1)\n"}
{"task_id": "MBPP/444", "completion": "\n    # Check if the input is a list\n    if not isinstance(test_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if the list is empty\n    if len(test_list) == 0:\n        return []\n    \n    # Check if K is an integer\n    if not isinstance(K, int):\n        raise TypeError(\"K must be an integer.\")\n    \n    # Check if K is within the bounds of the list\n    if K < 0 or K >= len(test_list):\n        raise ValueError(\"K is out of bounds.\")\n    \n    # Trim the list\n    return test_list[:K] + test_list[K+1:]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Multiply the two tuples together\n    result = test_tup1 * test_tup2\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    \n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    \n    # Count the occurrence of each element in the tuple\n    tup_count = Counter(tup)\n    \n    # Return the difference between the two counts\n    return count - tup_count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return [num ** 3 for num in nums]\n"}
{"task_id": "MBPP/448", "completion": "\n    return sum(range(1, n + 1))\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the triangle is valid (sum of any two sides is greater than the third side)\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return str[l:]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', ' ', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    return actual_cost - sale_amount\n"}
{"task_id": "MBPP/453", "completion": "\n    factors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    return sum(factors)\n\n"}
{"task_id": "MBPP/454", "completion": "\n    # Define the pattern to match\n    pattern = r'\\b\\w+\\b'\n    \n    # Find all matches\n    matches = re.findall(pattern, text)\n    \n    # Return the matches\n    return matches\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 == 1:\n        return \"January\"\n    elif monthnum2 == 2:\n        return \"February\"\n    elif monthnum2 == 3:\n        return \"March\"\n    elif monthnum2 == 4:\n        return \"April\"\n    elif monthnum2 == 5:\n        return \"May\"\n    elif monthnum2 == 6:\n        return \"June\"\n    elif monthnum2 == 7:\n        return \"July\"\n    elif monthnum2 == 8:\n        return \"August\"\n    elif monthnum2 == 9:\n        return \"September\"\n    elif monthnum2 == 10:\n        return \"October\"\n    elif monthnum2 == 11:\n        return \"November\"\n    elif monthnum2 == 12:\n        return \"December\"\n    else:\n        return \"Invalid month number\"\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub(r'[A-Z]', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [i for i in lst if i % 2 == 0]\n"}
{"task_id": "MBPP/461", "completion": "\n    return str.upper()\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    if n in dict:\n        return dict[n]\n    else:\n        return None\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n    return arr[mid]\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize the maximum and minimum product\n    max_product = min_product = result = arr[0]\n    \n    # Iterate through the array from the second element to the end\n    for i in range(1, n):\n        # If the current element is negative, swap max_product and min_product\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        # Update max_product and min_product\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        # Update the result\n        result = max(result, max_product)\n    \n    return result\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2 or k == 0:\n        return 0\n\n    # Create a 2D table to store the maximum profit for each subproblem\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n\n    # Iterate over each day\n    for i in range(1, n):\n        # Iterate over each transaction\n        for j in range(1, k + 1):\n            # Initialize the maximum profit for the current subproblem\n            max_profit = 0\n            # Iterate over each previous day\n            for m in range(i):\n                # Calculate the profit for the current subproblem\n                profit = price[i] - price[m] + dp[m][j - 1]\n                # Update the maximum profit for the current subproblem\n                max_profit = max(max_profit, profit)\n            # Update the maximum profit for the current subproblem in the table\n            dp[i][j] = max(dp[i - 1][j], max_profit)\n\n    # Return the maximum profit for the entire problem\n    return dp[n - 1][k]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty dictionary to store the results\n    result_dict = {}\n    \n    # Iterate over the test tuple\n    for i in range(len(test_tup)):\n        # Iterate over the test tuple again to compare each pair\n        for j in range(i+1, len(test_tup)):\n            # Check if the pair is already in the dictionary\n            if (test_tup[i], test_tup[j]) in result_dict:\n                # If it is, increment the count\n                result_dict[(test_tup[i], test_tup[j])] += 1\n            else:\n                # If it's not, add it to the dictionary with a count of 1\n                result_dict[(test_tup[i], test_tup[j])] = 1\n                \n    return result_dict\n"}
{"task_id": "MBPP/471", "completion": "\n    # Calculate the remainder of the array length divided by n\n    remainder = lens % n\n    \n    # If the remainder is 0, return the array length\n    if remainder == 0:\n        return lens\n    \n    # Otherwise, return the remainder\n    else:\n        return remainder\n"}
{"task_id": "MBPP/472", "completion": "\n    if len(l) < 2:\n        return False\n    for i in range(len(l) - 1):\n        if l[i] + 1 != l[i + 1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return sum(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.islower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return n // 10 ** (len(str(n)) - 1)\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_freq:\n            char_freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n    \n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if sum < 0 or len(set) == 0:\n        return False\n    return is_subset_sum(set[1:], n, sum - set[0]) or is_subset_sum(set[1:], n, sum)\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r\"(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s*->\\s*(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1), match.group(2)\n    else:\n        return None, None\n\n"}
{"task_id": "MBPP/483", "completion": "\n    i = 1\n    while True:\n        if factorial(i) % x == 0:\n            return i\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    # Create a list to store the result\n    result = []\n    \n    # Iterate over the two lists\n    for i in range(len(test_list1)):\n        for j in range(len(test_list2)):\n            # Check if the two tuples are equal\n            if test_list1[i] == test_list2[j]:\n                # If they are equal, add the first tuple to the result\n                result.append(test_list1[i])\n                # Remove the first tuple from the first list\n                test_list1.pop(i)\n                # Remove the second tuple from the second list\n                test_list2.pop(j)\n                # Break the loop to avoid duplicate removal\n                break\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/485", "completion": "\n    return str(n) == str(n)[::-1]\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take advantage of symmetry of binomial coefficients\n        r = n - r\n    C = [0] * (r + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            C[j] += C[j - 1]\n    return C[r]\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup)\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) * a**2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Create a dictionary to store the frequency of each number\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the maximum frequency\n    max_freq = max(freq_dict.values())\n\n    # Find the numbers with the maximum frequency\n    max_freq_nums = [num for num, freq in freq_dict.items() if freq == max_freq]\n\n    # Return the frequency of the largest number\n    return max_freq\n"}
{"task_id": "MBPP/490", "completion": "\n    # Initialize an empty list to store the symmetric elements\n    symmetric_elements = []\n    \n    # Iterate over the test list\n    for i in range(len(test_list)):\n        # Check if the element at index i is equal to the element at index len(test_list) - i - 1\n        if test_list[i] == test_list[len(test_list) - i - 1]:\n            # If they are equal, add the element to the symmetric_elements list\n            symmetric_elements.append(test_list[i])\n    \n    # Return the list of symmetric elements\n    return symmetric_elements\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the center of the circle\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the distance between the start and end points\n    distance = math.sqrt((endx - startx) ** 2 + (endy - starty) ** 2)\n\n    # Calculate the number of points to use for the polygon\n    num_points = int(distance / radius)\n\n    # Create a list to store the points of the polygon\n    points = []\n\n    # Calculate the points of the polygon\n    for i in range(num_points):\n        # Calculate the angle of the current point\n        angle = (i / num_points) * 2 * math.pi\n\n        # Calculate the x and y coordinates of the current point\n        x = center_x + math.cos(angle) * radius\n        y = center_y + math.sin(angle) * radius\n\n        # Add the point to the list\n        points.append((x, y))\n\n    # Add the start and end points to the list\n    points.append((startx, starty))\n    points.append((endx, endy))\n\n    # Return the list of points\n    return points\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert binary string to integer\n    integer = int(test_tup[0], 2)\n    \n    # Return the integer\n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    return math.pi * r * (r + math.sqrt(h**2 + r**2))\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while y:\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    return gcd(x, y)\n"}
{"task_id": "MBPP/502", "completion": "\n    # Initialize the list to store the results\n    results = []\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if the number is divisible by m\n        if i % m == 0:\n            # If it is, append it to the results list\n            results.append(i)\n    \n    # Return the list of results\n    return results\n"}
{"task_id": "MBPP/503", "completion": "\n    if len(nums) == 0:\n        return []\n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i - 1] == 1:\n            result[-1] = nums[i]\n        else:\n            result.append(nums[i])\n    return result\n"}
{"task_id": "MBPP/504", "completion": "\n    return n * (n + 1) * (2 * n + 1) // 6\n"}
{"task_id": "MBPP/505", "completion": "\n    n = len(A)\n    for i in range(n):\n        for j in range(n - 1):\n            if A[j][0] > A[j + 1][0]:\n                A[j], A[j + 1] = A[j + 1], A[j]\n    return A\n"}
{"task_id": "MBPP/506", "completion": "\n    # Calculate the permutation coefficient using the formula\n    permutation_coefficient = math.factorial(n) / math.factorial(n - k)\n    return permutation_coefficient\n"}
{"task_id": "MBPP/507", "completion": "\n    # Create a copy of the list to avoid modifying the original list\n    new_list = list1.copy()\n    \n    # Iterate over the words to be removed\n    for word in removewords:\n        # Check if the word is in the list\n        if word in new_list:\n            # Remove the word from the list\n            new_list.remove(word)\n    \n    # Return the updated list\n    return new_list\n"}
{"task_id": "MBPP/508", "completion": "\n    return sorted(l1) == sorted(l2)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_sum = 0\n    for i in range(1, n+1):\n        if i % 2 != 0:\n            odd_sum += i\n    return odd_sum / (n // 2)\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if arr[i-1] <= j:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-arr[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][k]\n"}
