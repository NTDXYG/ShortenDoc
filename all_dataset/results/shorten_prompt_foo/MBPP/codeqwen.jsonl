{"task_id": "MBPP/11", "completion": "\n    if ch in s:\n        s = s.replace(ch, '', 1)\n        s = s.rstrip(ch)\n    return s\n\n"}
{"task_id": "MBPP/12", "completion": "\n    return M[np.argsort(np.sum(M, axis=1))]\n"}
{"task_id": "MBPP/13", "completion": "\n    word_count = Counter(words)\n    most_common_words = word_count.most_common(3)\n    return dict(most_common_words)\n\n"}
{"task_id": "MBPP/14", "completion": "\n    return 0.5 * l * b * h\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split('([a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.findall(r'[a-z]+_[a-z]+', text)\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return 4 * a\n"}
{"task_id": "MBPP/18", "completion": "\n    count = [0] * NO_OF_CHARS\n    for char in string:\n        count[ord(char)] += 1\n\n    result = \"\"\n    for char in string:\n        if count[ord(char)] == 1:\n            result += char\n\n    return result\n\n"}
{"task_id": "MBPP/19", "completion": "\n    # Create an empty set to store unique elements\n    unique_elements = set()\n\n    # Iterate over the array\n    for num in arraynums:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Otherwise, add the element to the set\n        unique_elements.add(num)\n\n    # If we get here, there are no duplicates\n    return False\n"}
{"task_id": "MBPP/20", "completion": "\n    if x % 2 == 0:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/21", "completion": "\n    return [n * i for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    max_sum = float('-inf')\n    for sublist in list1:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n"}
{"task_id": "MBPP/24", "completion": "\n    return int(binary, 2)\n\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize the product to 1\n    product = 1\n\n    # Multiply the product by the elements that have a frequency of 1\n    for key, value in freq.items():\n        if value == 1:\n            product *= key\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    for sub in test_list:\n        if len(sub) != K:\n            return False\n    return True\n"}
{"task_id": "MBPP/27", "completion": "\n    for i in list:\n        list.remove(i)\n    return list\n\n"}
{"task_id": "MBPP/28", "completion": "\n    # Create a 2D array to store intermediate results\n    C = [[0 for x in range(x+1)] for x in range(n+1)]\n \n    # Calculate value of binomial coefficient using bottom-up approach\n    for i in range(n+1):\n        for j in range(min(i, k)+1):\n            # Base cases\n            if j == 0 or j == i:\n                C[i][j] = 1\n            else:\n                # Recurrence relation\n                C[i][j] = C[i-1][j-1] + C[i-1][j]\n \n    return C[n][k]\n"}
{"task_id": "MBPP/29", "completion": "\n    for i in range(arr_size):\n        count = 0\n        for j in range(arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if count % 2 != 0:\n            return arr[i]\n    return -1\n\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/31", "completion": "\n    counter = collections.Counter(nums)\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (freq, num))\n    return [num for freq, num in heap]\n\n"}
{"task_id": "MBPP/32", "completion": "\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n = n / 2\n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)\n\n"}
{"task_id": "MBPP/33", "completion": "\n    if N == 0:\n        return \"0\"\n    binary = \"\"\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary\n"}
{"task_id": "MBPP/34", "completion": "\n    # Sort the array\n    ar.sort()\n\n    # Iterate through the array\n    for i in range(N):\n        # If the current element is not equal to its index + 1, return the index + 1\n        if ar[i] != i + 1:\n            return i + 1\n\n    # If no missing number is found, return N + 1\n    return N + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/36", "completion": "\n    # Find the least common multiple of p and q\n    lcm = (p * q) // math.gcd(p, q)\n    \n    # Find the number of digits in the numerator of the proper fraction\n    num_digits = len(str(p))\n    \n    # Find the position of the desired digit\n    position = N - num_digits\n    \n    # Find the numerator of the proper fraction\n    numerator = lcm // q\n    \n    # Find the digit at the desired position\n    digit = numerator // (10 ** position) % 10\n    \n    return digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate integers and strings into two lists\n    int_list = [x for x in mixed_list if isinstance(x, int)]\n    str_list = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the integer list in ascending order\n    int_list.sort()\n\n    # Sort the string list in alphabetical order\n    str_list.sort()\n\n    # Combine the sorted integer and string lists\n    sorted_list = int_list + str_list\n\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if num % 2 == 0:\n            if even_num is None:\n                even_num = num\n            elif num < even_num:\n                even_num = num\n        else:\n            if odd_num is None:\n                odd_num = num\n            elif num < odd_num:\n                odd_num = num\n    return even_num, odd_num\n\n"}
{"task_id": "MBPP/39", "completion": "\n    count = Counter(S)\n    max_heap = []\n    for char, freq in count.items():\n        heapq.heappush(max_heap, (-freq, char))\n    prev_freq, prev_char = 0, None\n    while max_heap:\n        freq, char = heapq.heappop(max_heap)\n        if prev_freq < 0:\n            heapq.heappush(max_heap, (prev_freq, prev_char))\n        if freq + 1 < 0:\n            prev_freq, prev_char = freq + 1, char\n        else:\n            prev_freq, prev_char = 0, None\n    return prev_freq is None\n\n"}
{"task_id": "MBPP/40", "completion": "\n    # Flatten the list of lists\n    flat_list = list(chain.from_iterable(nums))\n    # Count the frequency of each element\n    freq = Counter(flat_list)\n    return freq\n\n"}
{"task_id": "MBPP/41", "completion": "\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums\n"}
{"task_id": "MBPP/42", "completion": "\n    sum = 0\n    for i in range(n):\n        if arr[i] == arr[i+1]:\n            sum += arr[i]\n    return sum\n"}
{"task_id": "MBPP/43", "completion": "\n    return re.findall(r'[a-z]+', text)\n\n"}
{"task_id": "MBPP/44", "completion": "\n    return re.match(r'\\w+', text)\n\n"}
{"task_id": "MBPP/45", "completion": "\n    if y == 0:\n        return x\n    else:\n        return foo(y, x % y)\n\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    if A == B:\n        return 1\n    elif A == 0:\n        return 1\n    else:\n        return B - A + 1\n\n"}
{"task_id": "MBPP/48", "completion": "\n    mask = 0\n    for i in range(n.bit_length()):\n        if i % 2 == 0:\n            mask |= 1 << i\n    return n | mask\n"}
{"task_id": "MBPP/49", "completion": "\n    result = []\n    for i in range(N):\n        result.append(nums[i][0])\n    return result\n"}
{"task_id": "MBPP/50", "completion": "\n    min_list = min(input_list, key=lambda x: len(x))\n    return min_list\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        print(\"Equilateral triangle\")\n    else:\n        print(\"Not an equilateral triangle\")\n\nfoo(5, 5, 5)\nfoo(5, 5, 4)\nfoo(5, 4, 3)\nfoo(5, 5, 5, 5)\nfoo(5, 5)\nfoo(5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)\nfoo(5, 5, 5, 5, 5, 5, 5, 5"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n\n"}
{"task_id": "MBPP/53", "completion": "\n    return str[-1] == str[-2]\n"}
{"task_id": "MBPP/54", "completion": "\n    if not my_list:\n        return []\n\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Initialize the count array with zeros\n    count_array = [0] * (max_value + 1)\n\n    # Populate the count array\n    for num in my_list:\n        count_array[num] += 1\n\n    # Generate the sorted list\n    sorted_list = []\n    for i, count in enumerate(count_array):\n        sorted_list.extend([i] * count)\n\n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * math.pow(r, n - 1)\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return 2 * rev(n) == n + 1\n    # return 2 * n - rev(n) == 1 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == 0 # another way to write it\n    # return 2 * n - rev(n) - 1 == "}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    res = \"\"\n    for i in range(n):\n        res += str(arr[i])\n    return int(res)\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x ^ y) < 0\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2)\n"}
{"task_id": "MBPP/60", "completion": "\n    # Create a dictionary to store the length of longest subsequence ending at each index\n    dp = {}\n\n    # Iterate over the array\n    for i in range(n):\n        # Initialize the maximum length of subsequence ending at index i as 1\n        dp[i] = 1\n\n        # Iterate over the previous indices\n        for j in range(i):\n            # If the difference between the current element and the previous element is 1\n            if abs(arr[i] - arr[j]) == 1:\n                # Update the maximum length of subsequence ending at index i\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Return the maximum length of subsequence ending at any index\n    return max(dp.values())\n"}
{"task_id": "MBPP/61", "completion": "\n    count = defaultdict(int)\n    count[0] = 1\n    curr_sum = 0\n    res = 0\n    for i in range(len(s)):\n        curr_sum += int(s[i])\n        res += count[curr_sum - (i + 1)]\n        count[curr_sum - (i + 1)] += 1\n    return res\n\n"}
{"task_id": "MBPP/62", "completion": "\n    if len(xs) == 0:\n        return None\n    else:\n        return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Calculate the difference between each pair\n    diff_list = [abs(x - y) for x, y in test_list]\n    \n    # Return the maximum difference\n    return max(diff_list)\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1])\n"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + foo(data_list[1:])\n\n"}
{"task_id": "MBPP/66", "completion": "\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        bell[i] = bell[i - 1] * (i + 1)\n        for j in range(i - 1, 0, -1):\n            bell[j] = bell[j] + bell[j - 1]\n    return bell[n]\n\n"}
{"task_id": "MBPP/68", "completion": "\n    increasing = decreasing = True\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n    return increasing or decreasing\n\n"}
{"task_id": "MBPP/69", "completion": "\n    if not s:\n        return True\n    if not l:\n        return False\n    if l[0] == s[0]:\n        return foo(l[1:], s[1:])\n    return foo(l[1:], s)\n\n"}
{"task_id": "MBPP/70", "completion": "\n    # Check if all tuples have the same length\n    if all(len(t) == len(Input[0]) for t in Input):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/71", "completion": "\n    nums.sort()\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    for i in range(1, n):\n        if (n + i) % (2 * i) == 0:\n            return True\n    return False\n\n"}
{"task_id": "MBPP/73", "completion": "\n    return re.split('[,; ]+', text)\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n\n    pattern_to_color = {}\n    color_to_pattern = {}\n\n    for i in range(len(patterns)):\n        pattern = patterns[i]\n        color = colors[i]\n\n        if pattern in pattern_to_color and pattern_to_color[pattern] != color:\n            return False\n        if color in color_to_pattern and color_to_pattern[color] != pattern:\n            return False\n\n        pattern_to_color[pattern] = color\n        color_to_pattern[color] = pattern\n\n    return True\n\n"}
{"task_id": "MBPP/75", "completion": "\n    res = [ele for ele in test_list if all(ele % K == 0)]\n    return res\n"}
{"task_id": "MBPP/76", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m and j * j <= n:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return abs(even_sum - odd_sum)\n\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 == 1\n"}
{"task_id": "MBPP/80", "completion": "\n    if n == 0:\n        return 0\n    else:\n        return n + foo(n - 1)\n\n"}
{"task_id": "MBPP/81", "completion": "\n    res = tuple(zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/82", "completion": "\n    return 4/3 * math.pi * r**3\n\n"}
{"task_id": "MBPP/83", "completion": "\n    sum_ascii = sum(ord(char) for char in strr)\n    return chr(sum_ascii)\n\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return foo(foo(n - 1)) + foo(n - foo(n - 1))\n\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    if n < 1:\n        raise ValueError(\"n must be greater than 0\")\n    return 3 * n * (n - 1) + 1\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    return collections.Counter(list1)\n\n"}
{"task_id": "MBPP/89", "completion": "\n    if N <= 1:\n        return None\n    else:\n        return N - 1\n"}
{"task_id": "MBPP/90", "completion": "\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n"}
{"task_id": "MBPP/91", "completion": "\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False\n\n"}
{"task_id": "MBPP/92", "completion": "\n    if n < 10:\n        return False\n    digits = [int(d) for d in str(n)]\n    if len(set(digits)) == 1:\n        return False\n    for i in range(2, len(digits)):\n        if i % 2 == 0 and digits[i] != digits[i - 2]:\n            return False\n        if i % 2 != 0 and digits[i] != digits[i - 2]:\n            return False\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    return a * b\n"}
{"task_id": "MBPP/94", "completion": "\n    res = [idx for idx, ele in enumerate(test_list) if ele[0] == 'a']\n    return res\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_len = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n    return min_len\n"}
{"task_id": "MBPP/96", "completion": "\n    if n < 1:\n        return []\n    foos = []\n    for i in range(1, n+1):\n        if i % 3 == 0 and i % 5 == 0:\n            foos.append('FooBar')\n        elif i % 3 == 0:\n            foos.append('Foo')\n        elif i % 5 == 0:\n            foos.append('Bar')\n        else:\n            foos.append(i)\n    return foos\n\n"}
{"task_id": "MBPP/97", "completion": "\n    count = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in count:\n                count[item] += 1\n            else:\n                count[item] = 1\n    return count\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for number in numbers:\n        result *= number\n    return result / len(numbers)\n\n"}
{"task_id": "MBPP/99", "completion": "\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if n == m == 0:\n        return 1\n    if m == 0 or m > n:\n        return 0\n    return ((n - m) * foo(n - 1, m - 1) + (m + 1) * foo(n - 1, m))\n\n"}
{"task_id": "MBPP/104", "completion": "\n    # Sort each sublist using lambda function\n    sorted_list = [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n    return sorted_list\n"}
{"task_id": "MBPP/105", "completion": "\n    return sum(1 for x in lst if x)\n"}
{"task_id": "MBPP/106", "completion": "\n    res = tuple(list(ele) + test_list for ele in test_tup)\n    return res\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if 'A' <= hex(i)[2].upper() <= 'F':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Convert inputs to iterators\n    iters = [iter(num1), iter(num2), iter(num3)]\n    # Initialize heap with first element of each iterator\n    heap = [(val, idx) for idx, val in enumerate(iters)]\n    heapq.heapify(heap)\n    # Merge sorted inputs\n    while heap:\n        val, idx = heapq.heappop(heap)\n        yield val\n        try:\n            # Get next element from iterator and push it to heap\n            next_val = next(iters[idx])\n            heapq.heappush(heap, (next_val, idx))\n        except StopIteration:\n            # If iterator is exhausted, remove it from heap\n            iters[idx] = iter([])\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            count += 1\n    return count % n\n"}
{"task_id": "MBPP/110", "completion": "\n    res = [test_list[i:j] for i in range(len(test_list)) for j in range(i + 1, len(test_list) + 1) if strt_val <= i < j <= stop_val]\n    return res\n"}
{"task_id": "MBPP/111", "completion": "\n    flat_list = []\n    for sublist in nestedlist:\n        for item in sublist:\n            flat_list.append(item)\n    common_elements = []\n    for item in flat_list:\n        if flat_list.count(item) > 1 and item not in common_elements:\n            common_elements.append(item)\n    return common_elements\n"}
{"task_id": "MBPP/112", "completion": "\n    return 3.14159 * diameter * height\n\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n\n"}
{"task_id": "MBPP/114", "completion": "\n    res = Counter(test_list)\n    return res\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for d in list1:\n        if d:\n            return False\n    return True\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    res = []\n    for ele in test_list:\n        try:\n            res.append(float(ele))\n        except ValueError:\n            res.append(ele)\n    return res\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low, high = 0, n - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        # Check if mid is even or odd\n        if mid % 2 == 0:\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid\n        else:\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return arr[low]\n\n"}
{"task_id": "MBPP/120", "completion": "\n    # Initialize maximum product to negative infinity\n    max_product = float('-inf')\n\n    # Iterate over all pairs of tuples\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            # Calculate product of current pair\n            product = list1[i][0]*list1[i][1]*list1[j][0]*list1[j][1]\n\n            # Update maximum product if current product is greater\n            if product > max_product:\n                max_product = product\n\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    if count == 3 and sum == 0:\n        return True\n    if count == 3 or n == 0 or sum < 0:\n        return False\n    # Include the current element in the sum and increment the count\n    include = foo(A, n-1, sum-A[n-1], count+1)\n    # Exclude the current element from the sum\n    exclude = foo(A, n-1, sum, count)\n    return include or exclude\n"}
{"task_id": "MBPP/122", "completion": "\n    if n <= 0:\n        return None\n    nums = [0] * MAX\n    count = 0\n    for i in range(1, MAX):\n        if nums[i] == 0:\n            for j in range(i, MAX, i):\n                nums[j] += 1\n        if nums[i] == 3:\n            count += 1\n            if count == n:\n                return i\n    return None\n\n"}
{"task_id": "MBPP/123", "completion": "\n\n        Return the sum of all proper divisors of a number.\n        \"\"\"\n        return sum([i for i in range(1, n) if n % i == 0])\n\n    amicable_numbers = set()\n    for i in range(2, limit):\n        if i in amicable_numbers:\n            continue\n        divisors_sum = sum_proper_divisors(i)\n        if divisors_sum != i and sum_proper_divisors(divisors_sum) == i:\n            amicable_numbers.update([i, divisors_sum])\n    return sum(amicable_numbers)\n\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(a + b)\n\n"}
{"task_id": "MBPP/125", "completion": "\n    # Initialize variables\n    max_diff = 0\n    current_diff = 0\n    count_one = 0\n    count_zero = 0\n    \n    # Iterate over the string\n    for i in range(len(string)):\n        # If the character is 1, increment count_one and current_diff\n        if string[i] == '1':\n            count_one += 1\n            current_diff += 1\n        # If the character is 0, increment count_zero and decrement current_diff\n        else:\n            count_zero += 1\n            current_diff -= 1\n        \n        # If current_diff becomes negative, reset it to 0\n        if current_diff < 0:\n            current_diff = 0\n        \n        # Update max_diff if current_diff is greater\n        max_diff = max(max_diff, current_diff)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Your code here\n"}
{"task_id": "MBPP/127", "completion": "\n    if y < 0:\n        return -foo(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + foo(x, y - 1)\n\n"}
{"task_id": "MBPP/128", "completion": "\n    shortlisted_words = []\n    for word in str:\n        if len(word) > n:\n            shortlisted_words.append(word)\n    return shortlisted_words\n"}
{"task_id": "MBPP/129", "completion": "\n    n = len(my_matrix)\n    magic_sum = n * (n * n + 1) // 2\n    \n    # Check rows and columns\n    for i in range(n):\n        if sum(my_matrix[i]) != magic_sum or sum(my_matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum or sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    return max(count, key=count.get)\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] in vowels and str1[right] in vowels:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n        elif str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return ''.join(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    if p % 2 == 0:\n        return arr[-1] % 2 == 0\n    else:\n        return (arr[-1] + n) % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units <= 50:\n        bill = units * 2.4\n    elif units <= 100:\n        bill = 50 * 2.4 + (units - 50) * 3.0\n    elif units <= 200:\n        bill = 50 * 2.4 + 50 * 3.0 + (units - 100) * 4.2\n    else:\n        bill = 50 * 2.4 + 50 * 3.0 + 100 * 4.2 + (units - 200) * 5.6\n    return bill\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create a dictionary to store the count of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Create a list to store the ratio of each number to the total count\n    ratios = []\n    for num, cnt in count.items():\n        ratios.append(cnt / len(nums))\n\n    # Return the list of ratios\n    return ratios\n\n"}
{"task_id": "MBPP/138", "completion": "\n    if n == 0:\n        return False\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n            if n % 2 != 0:\n                return False\n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create an empty dictionary to store the count of each element\n    count_dict = {}\n    for item in test_list:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Extract elements that occur singly\n    singles = [item for item, count in count_dict.items() if count == 1]\n    \n    return singles\n"}
{"task_id": "MBPP/141", "completion": "\n    for size in range(len(nums), 1, -1):\n        # Find index of the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:size]))\n        \n        # Flip the list from 0 to max_index (bring max to the front)\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        \n        # Flip the list from 0 to size (move max to its correct position)\n        nums[:size] = reversed(nums[:size])\n    \n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    count = 0\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            for k in range(len(list3)):\n                if list1[i] == list2[j] == list3[k]:\n                    count += 1\n    return count\n\n"}
{"task_id": "MBPP/143", "completion": "\n    result = []\n    for i in Input:\n        if isinstance(i, list):\n            result.append(i)\n    return result\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    total = 0\n    for i in range(n):\n        total += (arr[i] * i) - (arr[i] * (n - i - 1))\n    return total\n\n"}
{"task_id": "MBPP/145", "completion": "\n    if len(arr) < 2:\n        return -1\n\n    max_diff = arr[1] - arr[0]\n    min_element = arr[0]\n\n    for i in range(1, n):\n        max_diff = max(max_diff, arr[i] - min_element)\n        min_element = min(min_element, arr[i])\n\n    return max_diff\n\n"}
{"task_id": "MBPP/146", "completion": "\n    ascii_str = \"\"\n    for char in str1:\n        ascii_str += str(ord(char)) + \" \"\n    return ascii_str.strip()\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m-1, -1, -1):\n        for j in range(i+1):\n            if j == 0:\n                tri[i][j] += tri[i+1][j]\n            elif j == i:\n                tri[i][j] += tri[i+1][j-1]\n            else:\n                tri[i][j] += max(tri[i+1][j], tri[i+1][j-1])\n    return tri[0][0]\n\n"}
{"task_id": "MBPP/148", "completion": "\n    if x == 0:\n        return 0\n    else:\n        return x % 10 + foo(x // 10)\n\n"}
{"task_id": "MBPP/149", "completion": "\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b or b == c or c == a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/151", "completion": "\n\n        Return the greatest common divisor of two numbers.\n        \"\"\"\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    return gcd(p, q) == 1\n\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        left = x[:mid]\n        right = x[mid:]\n        return merge(foo(left), foo(right))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == "}
{"task_id": "MBPP/153", "completion": "\n    x = -b / (2 * a)\n    y = (a * x ** 2) + (b * x) + c\n    return (x, y)\n\n"}
{"task_id": "MBPP/154", "completion": "\n    result = []\n    for i in range(N):\n        result.append(nums[i][i])\n    return result\n"}
{"task_id": "MBPP/155", "completion": "\n    result = 0\n    count = 0\n    temp = n\n    while temp > 0:\n        # Check if the current bit position is even\n        if count % 2 == 0:\n            # Toggle the bit at the current position\n            result = result | (1 << count)\n        count += 1\n        temp >>= 1\n    return n ^ result\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(sum(1 for _ in group), key) for key, group in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    count = 0\n    for i in range(1, n):\n        if arr[i] != arr[0]:\n            count += abs(arr[i] - arr[0]) // k\n    return count\n"}
{"task_id": "MBPP/159", "completion": "\n    if month in ('January', 'February', 'March'):\n        if days <= 19:\n            print('winter')\n        else:\n            print('spring')\n    elif month in ('April', 'May', 'June'):\n        if days <= 20:\n            print('spring')\n        else:\n            print('summer')\n    elif month in ('July', 'August', 'September'):\n        if days <= 21:\n            print('summer')\n        else:\n            print('autumn')\n    elif month in ('October', 'November', 'December'):\n        if days <= 20:\n            print('autumn')\n        else:\n            print('winter')\n    else:\n        print('Invalid month')\n\nfoo('January', 15)  # winter\nfoo('April', 21)   # spring\nfoo('July', 22)   # summer\nfoo('October', 21)  # autumn\nfoo('February', 20)  # winter\nfoo('June', 19)   # spring\nfoo('September', 20)  # summer\nfoo('December', 21)  # autumn\nfoo('Invalid', 15)   # Invalid month\n"}
{"task_id": "MBPP/160", "completion": "\n    if a == 0:\n        return (b, 0)\n    if b == 0:\n        return (0, a)\n    if a == b:\n        return (n//a, 0)\n    if a > b:\n        x, y = solution(b, a%b, n)\n        return (y, x-y)\n    else:\n        x, y = solution(a, b%a, n)\n        return (x-y, y)\n"}
{"task_id": "MBPP/161", "completion": "\n    for i in list1:\n        if i in list2:\n            list1.remove(i)\n    return list1\n"}
{"task_id": "MBPP/162", "completion": "\n    if n < 0:\n        return \"Invalid input\"\n    elif n == 0:\n        return 0\n    else:\n        return n + foo(n-2)\n"}
{"task_id": "MBPP/163", "completion": "\n    return s * l * tan(pi / l)\n\n"}
{"task_id": "MBPP/164", "completion": "\n    if n == 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/165", "completion": "\n    count = 0\n    for i in range(len(str1)):\n        if str1[i].lower() == chr(ord('a') + i):\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/168", "completion": "\n    if a is None or len(a) == 0:\n        return None\n    \n    # sort the array\n    a.sort()\n    \n    # find the index of the first element greater than or equal to x\n    i = 0\n    while i < len(a) and a[i] < x:\n        i += 1\n    \n    # if the index is out of range, return None\n    if i == len(a):\n        return None\n    \n    # return the element at the index\n    return a[i]\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    return s.count('std')\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'\\W+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for k, v in l:\n        if k not in d:\n            d[k] = []\n        d[k].append(v)\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    for i in range(L, R):\n        for j in range(i+1, R):\n            lcm = (i*j)//math.gcd(i, j)\n            if L <= lcm <= R:\n                return (i, j)\n    return (-1, -1)\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Initialize the list with the first n digits of x\n    sequence = [int(digit) for digit in str(x)]\n    \n    # Calculate the next term in the sequence\n    next_term = sum(sequence[-len(sequence):])\n    \n    # Keep generating terms until the next term is equal to x\n    while next_term != x:\n        sequence.append(next_term)\n        next_term = sum(sequence[-len(sequence):])\n    \n    # If the next term is equal to x, it is a Keith number\n    return next_term == x\n"}
{"task_id": "MBPP/180", "completion": "\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n    return 6371 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon))\n\n"}
{"task_id": "MBPP/181", "completion": "\n    if not str1 or not str2:\n        return \"\"\n    \n    i = 0\n    while i < len(str1) and i < len(str2) and str1[i] == str2[i]:\n        i += 1\n    \n    return str1[:i]\n"}
{"task_id": "MBPP/182", "completion": "\n    uppercase = re.findall(r\"[A-Z]\", string)\n    lowercase = re.findall(r\"[a-z]\", string)\n    characters = re.findall(r\"[^A-Za-z0-9]\", string)\n    values = re.findall(r\"\\d\", string)\n\n    return uppercase, lowercase, characters, values\n\n"}
{"task_id": "MBPP/183", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(arr[i] - arr[j]) == k:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focus\n    focus_x = -b / (2 * a)\n    focus_y = (1 - (b ** 2) + (4 * a * c)) / (4 * a)\n    return focus_x, focus_y\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a 2D array to store the lengths of the longest common subsequences\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n    # Fill the dp array\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    # Reconstruct the longest common subsequence\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if X[i-1] == Y[j-1]:\n            lcs.append(X[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Return the longest common subsequence\n    return lcs[::-1]\n\n"}
{"task_id": "MBPP/188", "completion": "\n    for i in range(1, n):\n        for j in range(1, n):\n            if i*i * j*j == n:\n                return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    return n + 1\n\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the side length of the square\n    side_length = max(abs(x2 - x1), abs(y2 - y1))\n    \n    # Count the number of integral co-ordinates inside the square\n    count = 0\n    for i in range(1, side_length):\n        for j in range(1, side_length):\n            if i + j < side_length:\n                count += 1\n    \n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    return monthname3 in months_with_30_days\n"}
{"task_id": "MBPP/192", "completion": "\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        if has_letter and has_number:\n            return True\n    return False\n\n"}
{"task_id": "MBPP/193", "completion": "\n    res = tuple(set(test_tup))\n    return res\n"}
{"task_id": "MBPP/194", "completion": "\n    if n == 0:\n        return 0\n    else:\n        return n % 10 + 8 * foo(n // 10)\n\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    res = [ele for ele in test_list if len(ele) != K]\n    return res\n"}
{"task_id": "MBPP/197", "completion": "\n    res = tuple(pow(ele1, ele2) for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/198", "completion": "\n    if a > b:\n        a, b = b, a\n    if a <= 0 or b <= 0:\n        return -1\n    return math.sqrt(a**2 - (a**2 - b**2) / 4)\n\n"}
{"task_id": "MBPP/199", "completion": "\n    if n < 1:\n        return 0\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    return [i for i, x in enumerate(list1) if x == max_val]\n\n"}
{"task_id": "MBPP/201", "completion": "\n    return all(x == lst[0] for x in lst)\n\n"}
{"task_id": "MBPP/202", "completion": "\n    return str1[::2]\n"}
{"task_id": "MBPP/203", "completion": "\n    xor = n1 ^ n2\n    count = 0\n    while xor:\n        count += xor & 1\n        xor >>= 1\n    return count\n\n"}
{"task_id": "MBPP/204", "completion": "\n    count = 0\n    for char in s:\n        if char == c:\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/205", "completion": "\n    res = 0\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i] > test_tup[j]:\n                res += 1\n    return res\n"}
{"task_id": "MBPP/206", "completion": "\n    res = tuple(str(ele1) + str(ele2) for ele1, ele2 in zip(test_tup, test_tup[1:]))\n    return res\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n    return dp[n][n]\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = re.compile(r\"^\\d+(\\.\\d{1,2})?$\")\n    return bool(pattern.match(str(num)))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappushpop(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, 2**n):\n        if i & (1 << (n-1)):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([i**4 for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    res = tuple(map(''.join, zip(test_tup1, test_tup2)))\n    return res\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * (180 / math.pi)\n\n"}
{"task_id": "MBPP/215", "completion": "\n    result = []\n    for item in alist:\n        if isinstance(item, list):\n            result.extend([item[1]] * item[0])\n        else:\n            result.append(item)\n    return result\n\n"}
{"task_id": "MBPP/216", "completion": "\n    for sublist in list1:\n        if sublist not in list2:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/217", "completion": "\n    str = str.lower()\n    for i in range(len(str)):\n        if str.count(str[i]) > 1:\n            return str[i]\n    return None\n\n"}
{"task_id": "MBPP/218", "completion": "\n    if A == B:\n        return 0\n    if A > B:\n        A, B = B, A\n    while A < B:\n        B = B - A\n    return math.ceil((B - A) / A)\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # sort the tuple in ascending order\n    test_tup = sorted(test_tup)\n    \n    # extract the first k elements\n    res = test_tup[:K]\n    \n    # extract the last k elements\n    res += test_tup[-K:]\n    \n    return res\n"}
{"task_id": "MBPP/220", "completion": "\n    return re.sub(r'[ ,]+', ':', text)[:n]\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n\n"}
{"task_id": "MBPP/222", "completion": "\n    res = all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple)\n    return (res)\n"}
{"task_id": "MBPP/223", "completion": "\n    # find first occurrence of x\n    i = arr.index(x)\n    # check if x is present at index i and is the majority element\n    if i + n // 2 < len(arr) and arr[i + n // 2] == x:\n        return True\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return arr[low]\n\n"}
{"task_id": "MBPP/226", "completion": "\n    return str[::2]\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    for i in range(l, r+1):\n        if (n & (1 << i)) != 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/229", "completion": "\n    neg = []\n    pos = []\n    for i in range(n):\n        if arr[i] < 0:\n            neg.append(arr[i])\n        else:\n            pos.append(arr[i])\n    return neg + pos\n\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(' ', char)\n\n"}
{"task_id": "MBPP/231", "completion": "\n    for i in range(n):\n        for j in range(i+1):\n            if j == 0 or j == i:\n                tri[i][j] = tri[i][j]\n            else:\n                tri[i][j] = max(tri[i-1][j-1], tri[i-1][j]) + tri[i][j]\n    return max(tri[n-1])\n\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * 3.1415 * r * h\n\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    i = 0\n    while n >> i:\n        if i % 2 == 0:\n            n |= (1 << i)\n        i += 1\n    return n\n"}
{"task_id": "MBPP/236", "completion": "\n    if N < K:\n        return -1\n    else:\n        return (N - K + 1) * (N - K + 2) // 2\n"}
{"task_id": "MBPP/237", "completion": "\n    res = Counter(test_list)\n    return all(res[ele] == res[ele + 1] for ele in test_list if ele + 1 in res)\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/239", "completion": "\n    MOD = 10**9 + 7\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if j == 1:\n                dp[i][j] = i\n            else:\n                dp[i][j] = (dp[i-1][j] + dp[i//2][j-1]) % MOD\n    return dp[m][n]\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1:] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[ '*' for _ in range(m)] for _ in range(n)] for _ in range(o)]\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: x[0])\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.ceil(math.sqrt(N))\n    return root ** 2\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Create two arrays to store maximum sum increasing and decreasing subsequence ending at each index\n    inc = [0]*n\n    dec = [0]*n\n\n    # Initialize all elements of inc and dec arrays to be the same as the input array\n    for i in range(n):\n        inc[i] = dec[i] = arr[i]\n\n    # Compute maximum sum increasing subsequence ending at each index\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n\n    # Compute maximum sum decreasing subsequence ending at each index\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n\n    # Compute maximum sum bi-tonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum\n"}
{"task_id": "MBPP/246", "completion": "\n    if number == 0:\n        return 0\n    guess = number / 2.0\n    better_guess = (guess + number / guess) / 2\n    while better_guess != guess:\n        guess = better_guess\n        better_guess = (guess + number / guess) / 2\n    return better_guess\n\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0]*n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    return dp[0][n-1]\n"}
{"task_id": "MBPP/248", "completion": "\n    if n == 1:\n        return 1\n    else:\n        return 1 / n + foo(n - 1)\n\n"}
{"task_id": "MBPP/249", "completion": "\n    intersection = list(filter(lambda x: x in array_nums1, array_nums2))\n    return intersection\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] + list\n"}
{"task_id": "MBPP/252", "completion": "\n    return [cmath.polar(num) for num in numbers]\n\n"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    return re.findall(r'\\b[ae]\\w+', text, re.IGNORECASE)\n\n"}
{"task_id": "MBPP/255", "completion": "\n    return list(combinations_with_replacement(l, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    if n < 0:\n        return 0\n    elif n < 10:\n        return 1\n    else:\n        return 1 + foo(n // 10)\n\n"}
{"task_id": "MBPP/257", "completion": "\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b\n\n"}
{"task_id": "MBPP/258", "completion": "\n    odd_count = len(list(filter(lambda x: (x%2 != 0), array_nums)))\n    return odd_count\n"}
{"task_id": "MBPP/259", "completion": "\n    res = tuple(max(ele1, ele2) for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/260", "completion": "\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        a, b = 1, 2\n        for _ in range(2, n):\n            a, b = b, 2 * b + a\n        return b\n\n"}
{"task_id": "MBPP/261", "completion": "\n    res = tuple(map(lambda x, y: x / y if y != 0 else 'Error', test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    merged_dict = d1.copy()\n    merged_dict.update(d2)\n    return merged_dict\n"}
{"task_id": "MBPP/264", "completion": "\n    if h_age < 0:\n        return \"Invalid age\"\n    elif h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i::step] for i in range(step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/267", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**2\n    return sum\n"}
{"task_id": "MBPP/268", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return n + foo(n - 1)\n\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    sum = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum += arr[i]\n    return sum\n"}
{"task_id": "MBPP/271", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    res = [sub[-1] for sub in test_list]\n    return res\n"}
{"task_id": "MBPP/273", "completion": "\n    res = tuple(a - b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize result\n    res = 0\n\n    # Loop for even index\n    for i in range(0, n, 2):\n        # Add binomial coefficient at even index\n        res += math.comb(n, i)\n\n    return res\n\n"}
{"task_id": "MBPP/275", "completion": "\n    if n == 1:\n        return 0\n    return (foo(a, n - 1, m) + m) % n\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.1415 * r * r * h\n\n"}
{"task_id": "MBPP/277", "completion": "\n    return {k: v for k, v in dict.items() if v > n}\n\n"}
{"task_id": "MBPP/278", "completion": "\n    res = {}\n    for idx, ele in enumerate(test_tup):\n        if ele not in res:\n            res[ele] = idx\n    return res\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * 10\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    # Using set() to remove duplicates\n    res = len(test_list) == len(set(test_list))\n    return res\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n\n"}
{"task_id": "MBPP/283", "completion": "\n    for i in range(1, n+1):\n        digits = set(str(i))\n        for digit in digits:\n            if i.count(digit) > int(digit):\n                return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    return re.findall('ab{2,3}', text)\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Create a modified array by repeating the given array k times\n    modified_array = a * k\n    \n    # Initialize variables to keep track of the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Iterate through the modified array to find the maximum sum of a contiguous subarray\n    for i in range(len(modified_array)):\n        current_sum = max(modified_array[i], current_sum + modified_array[i])\n        max_sum = max(max_sum, current_sum)\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**2\n    return sum\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for i in range(N):\n        if arr[i] == (arr[i] * arr[i]) % P:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate leap years\n    leap_years = N // 4 - N // 100 + N // 400\n    # Calculate total days\n    total_days = 365 * N + leap_years\n    # Calculate odd days\n    odd_days = total_days % 7\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = max(len(x) for x in list1)\n    return [x for x in list1 if len(x) == max_len]\n\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same, diff = k, k * (k - 1)\n    total = same + diff\n    for i in range(3, n + 1):\n        same = diff\n        diff = total * (k - 1)\n        total = (same + diff) % 1000000007\n    return total\n"}
{"task_id": "MBPP/292", "completion": "\n    if m == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return n // m\n\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    maxval = listval[0]\n    for i in listval:\n        if i > maxval:\n            maxval = i\n    return maxval\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [1]\n    for i in range(2, number):\n        if number % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\n"}
{"task_id": "MBPP/297", "completion": "\n    result = []\n    for i in list1:\n        if isinstance(i, list):\n            result.extend(foo(i))\n        else:\n            result.append(i)\n    return result\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for i in l1:\n        if i in l2:\n            result.append(i)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a default dictionary to hold the sums\n    sums = defaultdict(int)\n\n    # Iterate over the list of tuples\n    for tup in stdata:\n        # Add the second element of the tuple to the sum for the first element of the tuple\n        sums[tup[0]] += tup[1]\n\n    # Return the maximum sum\n    return max(sums.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    # Initialize a 2D array to store intermediate results\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    \n    # Base case: There is only one way to form a sequence of length 0 with equal sums\n    dp[0][0] = 1\n    \n    # Fill the dp array\n    for i in range(1, n+1):\n        for j in range(i+1):\n            # If the sum of the first i bits is equal to the sum of the last i bits\n            if j == i:\n                dp[i][j] = dp[i-1][j-1] * 2\n            else:\n                # Otherwise, the sequence can be formed by adding a 0 to the sequence of length i-1 with equal sums,\n                # or by adding a 1 to the sequence of length j-1 with equal sums\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n    \n    # The answer is the number of sequences of length 2n with equal sums\n    return dp[n][n]\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict) or not d:\n        return 0\n    else:\n        return 1 + max(foo(value) for value in d.values())\n\n"}
{"task_id": "MBPP/302", "completion": "\n    if n == 0:\n        return 0\n    # Find the position of the most significant bit (MSB)\n    msb_position = int(math.log2(n))\n    # Create a number with all bits set to 1 up to the MSB position\n    return (1 << (msb_position + 1)) - 1\n"}
{"task_id": "MBPP/303", "completion": "\n    if n == 1:\n        return True\n    if n == 2:\n        return a[0] < a[1]\n    if n == 3:\n        return (a[0] < a[1] < a[2]) or (a[0] < a[2] < a[1]) or (a[1] < a[0] < a[2]) or (a[1] < a[2] < a[0]) or (a[2] < a[0] < a[1]) or (a[2] < a[1] < a[0])\n\n    # Check for all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                return False\n    return True\n\n"}
{"task_id": "MBPP/304", "completion": "\n    for i in range(rotations):\n        start, end = ranges[i]\n        if start <= index <= end:\n            if index == start:\n                index = end\n            else:\n                index -= 1\n    return arr[index]\n\n"}
{"task_id": "MBPP/305", "completion": "\n    return [word for word in words if word.startswith('p')]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == n:\n        return 0\n    if k == index:\n        return 0\n    if a[index] > a[k]:\n        return max(foo(a, n, index + 1, k) + a[index], foo(a, n, index + 1, index))\n    else:\n        return foo(a, n, index + 1, k)\n\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort the lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize an empty list to store the products\n    products = []\n\n    # Iterate over the first N elements of the sorted lists\n    for i in range(N):\n        # Calculate the product of the current elements from both lists\n        product = nums1[i] * nums2[i]\n\n        # Append the product to the products list\n        products.append(product)\n\n    # Return the products list\n    return products\n"}
{"task_id": "MBPP/309", "completion": "\n    return a + b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n"}
{"task_id": "MBPP/311", "completion": "\n    if n == 0:\n        return 1\n    if n & (n + 1) == 0:\n        return n\n    mask = 0\n    while n & (n + 1) != 0:\n        n >>= 1\n        mask <<= 1\n        mask += 1\n    return n | mask + 1\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1/3) * math.pi * r * r * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return grid[0][0]\n    else:\n        # Initialize the first two values\n        max_sum = max(grid[0][0], grid[1][0])\n        \n        # Iterate over the remaining columns\n        for i in range(1, n):\n            # Calculate the maximum sum for the current column\n            max_sum_current = max(max_sum, max_sum_prev + max(grid[0][i], grid[1][i]))\n            \n            # Update the previous maximum sum\n            max_sum_prev = max_sum\n            \n            # Update the maximum sum\n            max_sum = max_sum_current\n        \n        return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    str = str.split()\n    max_len = 0\n    for word in str:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            result = mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\n"}
{"task_id": "MBPP/317", "completion": "\n    def encode(lst):\n        return [(sum(1 for _ in group), key) for key, group in groupby(lst)]\n\n    def decode(lst):\n        return [key for _, key in lst]\n\n    return decode(encode(alist))\n\n"}
{"task_id": "MBPP/318", "completion": "\n    sides = sorted(list(set(s)))\n    max_vol = 0\n    for i in range(len(sides)):\n        for j in range(i+1, len(sides)):\n            for k in range(j+1, len(sides)):\n                if sides[i] + sides[j] + sides[k] == s:\n                    max_vol = max(max_vol, sides[i]*sides[j]*sides[k])\n    return max_vol\n"}
{"task_id": "MBPP/319", "completion": "\n    return re.findall(r\"\\b\\w{5}\\b\", text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_of_squares = sum([i**2 for i in range(1, n+1)])\n    square_of_sum = sum(range(1, n+1)) ** 2\n    return square_of_sum - sum_of_squares\n"}
{"task_id": "MBPP/321", "completion": "\n    # Check if the input is a number\n    if not isinstance(s, (int, float)):\n        raise ValueError(\"Input must be a number\")\n\n    # Convert the number to a string\n    s = str(s)\n\n    # Check if the number is a decimal number\n    if '.' in s:\n        # Split the number into integer and decimal parts\n        integer_part, decimal_part = s.split('.')\n\n        # Find the demlo number for the integer part\n        demlo_integer = foo(int(integer_part))\n\n        # Find the demlo number for the decimal part\n        demlo_decimal = foo(float('0.' + decimal_part))\n\n        # Concatenate the demlo numbers\n        demlo_number = demlo_integer + demlo_decimal\n\n    else:\n        # Find the demlo number for the integer part\n        demlo_number = ''\n        for i in range(len(s)):\n            demlo_number += s[i] * (len(s) - i)\n\n    return demlo_number\n\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if cur >= n:\n        return\n    if out_of_place >= 0 and ((arr[cur] >= 0 and arr[out_of_place] < 0) or (arr[cur] < 0 and arr[out_of_place] >= 0)):\n        arr[out_of_place + 1:cur + 1] = arr[out_of_place:cur]\n        if cur - out_of_place >= 2:\n            arr[out_of_place] = arr[cur - 1]\n        else:\n            arr[out_of_place] = None\n        out_of_place += 1\n    arr[cur] = arr[cur]\n    foo(arr, n, out_of_place, cur + 1)\n\n"}
{"task_id": "MBPP/324", "completion": "\n    result = 0\n    for i in range(0, len(test_tuple), 2):\n        result += sum(test_tuple[i])\n    return result\n"}
{"task_id": "MBPP/325", "completion": "\n    # Base cases\n    if n <= 3:\n        return n\n\n    # This array will store minimum squares required for all numbers up to n\n    dp = [float('inf')] * (n + 1)\n\n    # Zero has zero squares\n    dp[0] = 0\n\n    # Precompute the minimum squares for all numbers up to n\n    for i in range(1, n + 1):\n        # Check squares of numbers up to i\n        for j in range(1, i + 1):\n            square = j * j\n            if square > i:\n                break\n            else:\n                dp[i] = min(dp[i], 1 + dp[i - square])\n\n    return dp[n]\n\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n\ntest_list = [\"hello world\", \"world is great\", \"hello everyone\"]"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or z == x:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nfoo(3, 3, 3)\nfoo(3, 4, 4)\nfoo(3, 4, 5)\n"}
{"task_id": "MBPP/328", "completion": "\n    # Check if list is empty\n    if not list1:\n        return []\n\n    # Check if m and n are valid\n    if m < 0 or n < 0 or m > len(list1) or n > len(list1):\n        return list1\n\n    # Rotate list\n    list1 = list1[m:] + list1[:m]\n    list1 = list1[n:] + list1[:n]\n\n    return list1\n\n"}
{"task_id": "MBPP/329", "completion": "\n    count = 0\n    for num in list:\n        if num < 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/330", "completion": "\n    return re.findall(r\"\\b\\w{3,5}\\b\", text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    str1 = str1.lower()\n    char_freq = {}\n    for char in str1:\n        if char.isalpha():\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n    return char_freq\n\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort()\n    return sub_li\n\n"}
{"task_id": "MBPP/334", "completion": "\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n * (2 * a + (n - 1) * d)) / 2\n"}
{"task_id": "MBPP/336", "completion": "\n    months_with_28_days = [\"February\", \"Feb\", \"February 2020\", \"February 2021\"]\n    return monthname1 in months_with_28_days\n"}
{"task_id": "MBPP/337", "completion": "\n    return re.compile(r'\\b\\w+\\b\\S*$', re.IGNORECASE).search(text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Find the greatest common divisor of x and y\n    gcd = x\n    while gcd != 0:\n        gcd = y % gcd\n        y = gcd\n    return x // gcd\n"}
{"task_id": "MBPP/340", "completion": "\n    # Filter out non-positive numbers\n    positive_numbers = [num for num in lst if num > 0]\n    \n    # Sort the positive numbers\n    positive_numbers.sort()\n    \n    # Sum the three lowest positive numbers\n    return sum(positive_numbers[:3])\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_value = float('-inf')\n    for i, l in enumerate(list):\n        heappush(min_heap, Node(l[0], i, 0))\n        max_value = max(max_value, l[0])\n\n    min_range = max_value - min_heap[0].value\n    start = min_heap[0].value\n    end = max_value\n    result = [start, end]\n\n    while True:\n        node = heappop(min_heap)\n        if node.index == len(list[node.list_num]) - 1:\n            break\n\n        next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n        heappush(min_heap, next_node)\n        max_value = max(max_value, next_node.value)\n        min_value = min_heap[0].value\n        if max_value - min_value < min_range:\n            min_range = max_value - min_value\n            start = min_value\n            end = max_value\n            result = [start, end]\n\n    return result\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n    return digits, s.upper()\n"}
{"task_id": "MBPP/344", "completion": "\n    # Count of numbers with odd factors in range [1, n]\n    odd_count = n // 2\n\n    # Count of numbers with odd factors in range [1, m]\n    odd_count_m = m // 2\n\n    # Subtract count of numbers with even factors in range [1, m]\n    # These numbers are counted twice in the above step\n    even_count_m = m // 4\n    odd_count_m -= even_count_m\n\n    # Add count of numbers with even factors in range [1, n]\n    # These numbers are subtracted twice in the above step\n    even_count_n = n // 4\n    odd_count_n = even_count_n\n\n    # Return the final count\n    return odd_count_m - odd_count_n\n"}
{"task_id": "MBPP/345", "completion": "\n    diff = [nums[i+1] - nums[i] for i in range(len(nums)-1)]\n    return diff\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    return foo(n, k - 1) + foo(n - 1, n - k)\n\n"}
{"task_id": "MBPP/347", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m and j * j <= n:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/348", "completion": "\n    MOD = 10**9 + 7\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(i+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n    res = 0\n    for i in range(n+1):\n        res = (res + dp[n][i]*pow(r, i, MOD)) % MOD\n    return res\n"}
{"task_id": "MBPP/349", "completion": "\n    return string.isalpha()\n\n"}
{"task_id": "MBPP/350", "completion": "\n    # Count the occurrence of each character\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    \n    # Find the character with the maximum occurrence\n    max_occurrence = max(count.values())\n    \n    # Calculate the length of the string after removing the character with the maximum occurrence\n    min_length = len(s) - max_occurrence\n    \n    return min_length\n"}
{"task_id": "MBPP/351", "completion": "\n    count = {}\n    for i in range(n):\n        if arr[i] in count:\n            count[arr[i]] += 1\n        else:\n            count[arr[i]] = 1\n\n    for i in range(n):\n        if count[arr[i]] == k:\n            return arr[i]\n\n    return -1\n\n"}
{"task_id": "MBPP/352", "completion": "\n    # Create a set from the string\n    str_set = set(str)\n\n    # If the length of the set is the same as the length of the string,\n    # all characters are unique\n    return len(str_set) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [row[:n] + row[n+1:] for row in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n\n"}
{"task_id": "MBPP/355", "completion": "\n    count = 0\n    for x in range(1, radius):\n        for y in range(1, radius):\n            if x + y <= radius:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/356", "completion": "\n    if a + b > 180:\n        return \"Invalid input\"\n    else:\n        return 180 - (a + b)\n\n"}
{"task_id": "MBPP/357", "completion": "\n    # Using list comprehension to find the maximum element\n    res = max([sub[1] for sub in test_list])\n    return res\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # calculate the discriminant\n    d = (b**2) - (4*a*c)\n\n    # check if the discriminant is positive\n    if d > 0:\n        # calculate the two roots\n        root1 = (-b + (d**0.5)) / (2*a)\n        root2 = (-b - (d**0.5)) / (2*a)\n\n        # check if one root is twice the other\n        if root1 == 2*root2 or root2 == 2*root1:\n            return True\n        else:\n            return False\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return (2 ** n - 1) ** 2 - foo(n - 1)\n\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i]\n"}
{"task_id": "MBPP/362", "completion": "\n    counts = {}\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    max_count = max(counts.values())\n    max_items = [num for num, count in counts.items() if count == max_count]\n    return max_items[0] if len(max_items) == 1 else None\n\n"}
{"task_id": "MBPP/363", "completion": "\n    res = [ele + K for ele in test_list]\n    return res\n"}
{"task_id": "MBPP/364", "completion": "\n    # Initialize counters for flips with '0' and '1' as starting characters\n    flip_0 = flip_1 = 0\n    \n    # Iterate over the string, comparing each character with the expected character\n    for i in range(len(ch)):\n        if i % 2 == 0:  # If index is even, expect '0'\n            if ch[i] != '0':  # If current character is not '0', increment flip_0\n                flip_0 += 1\n        else:  # If index is odd, expect '1'\n            if ch[i] != '1':  # If current character is not '1', increment flip_1\n                flip_1 += 1\n    \n    # Return the minimum of the two flip counts\n    return min(flip_0, flip_1)\n"}
{"task_id": "MBPP/365", "completion": "\n    if n == 0:\n        return 1\n    count = 0\n    while n != 0:\n        n //= 10\n        count += 1\n    return count\n\n"}
{"task_id": "MBPP/366", "completion": "\n    # Check if list is empty or contains less than two elements\n    if not list_nums or len(list_nums) < 2:\n        return None\n\n    # Initialize maximum product\n    max_product = list_nums[0] * list_nums[1]\n\n    # Iterate over list to find maximum product of adjacent elements\n    for i in range(1, len(list_nums) - 1):\n        max_product = max(max_product, list_nums[i] * list_nums[i + 1])\n\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) <= 1 and foo(root.left) and foo(root.right):\n        return True\n    return False\n\n"}
{"task_id": "MBPP/368", "completion": "\n    res = tuple(test_tup for _ in range(N))\n    return res\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return float(price[1])\n\n"}
{"task_id": "MBPP/371", "completion": "\n    if left_element > right_element:\n        return left_element\n    mid_element = (left_element + right_element) // 2\n    if A[mid_element] == mid_element:\n        return foo(A, mid_element + 1, right_element)\n    else:\n        return foo(A, left_element, mid_element - 1)\n\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(len(nums))]\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 0:\n        return []\n    if len(str) == 1:\n        return [str]\n    \n    perms = []\n    for i in range(len(str)):\n        char = str[i]\n        remaining_str = str[:i] + str[i+1:]\n        for perm in foo(remaining_str):\n            perms.append(char + perm)\n    \n    return perms\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n\n"}
{"task_id": "MBPP/376", "completion": "\n    res = []\n    for ele in test_tup:\n        if ele not in res:\n            res.append(ele)\n        else:\n            res.append('custom_value')\n    return tuple(res)\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n\n"}
{"task_id": "MBPP/378", "completion": "\n    test_list = test_list[-1:] + test_list[:-1]\n    return test_list\n\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[rownum * colnum for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    low, high = 0, n - 1\n    while low <= high:\n        if A[low] <= A[high]:\n            return low\n        mid = (low + high) // 2\n        next_idx = (mid + 1) % n\n        prev_idx = (mid - 1 + n) % n\n        if A[mid] <= A[next_idx] and A[mid] <= A[prev_idx]:\n            return mid\n        elif A[mid] <= A[high]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\n"}
{"task_id": "MBPP/383", "completion": "\n    mask = 0\n    for i in range(n.bit_length()):\n        if i % 2 == 0:\n            mask |= 1 << i\n    return n ^ mask\n"}
{"task_id": "MBPP/384", "completion": "\n    if not arr:\n        return 0\n    min_val = min(arr)\n    count = arr.count(min_val)\n    return count\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return foo(n - 2) + foo(n - 3)\n\n"}
{"task_id": "MBPP/386", "completion": "\n    open_brackets = []\n    close_brackets = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            open_brackets.append(i)\n        else:\n            close_brackets.append(i)\n    open_brackets.reverse()\n    close_brackets.reverse()\n    swaps = 0\n    i = 0\n    j = 0\n    while i < len(open_brackets) and j < len(close_brackets):\n        if open_brackets[i] < close_brackets[j]:\n            i += 1\n            j += 1\n        else:\n            swaps += 1\n            j += 1\n    return swaps\n"}
{"task_id": "MBPP/387", "completion": "\n    if N % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/389", "completion": "\n    a, b = 2, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    for i in range(len(l1)):\n        l1[i] = {k: v for k, v in l1[i].items() if k in l2[i]}\n        l1[i] = {k: v for k, v in l1[i].items() if k in l3[i]}\n    return l1\n"}
{"task_id": "MBPP/392", "completion": "\n    # Initialize a list to store the maximum sums for each number up to n\n    max_sums = [0] * (n + 1)\n    \n    # Base cases\n    max_sums[0] = 0\n    max_sums[1] = 1\n    \n    # Fill in the list with the maximum sums\n    for i in range(2, n + 1):\n        max_sums[i] = max(i, max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5])\n    \n    # Return the maximum sum for n\n    return max_sums[n]\n"}
{"task_id": "MBPP/393", "completion": "\n    max_list = max(input_list, key=lambda x: len(x))\n    return max_list\n"}
{"task_id": "MBPP/394", "completion": "\n    res = len(test_tup) == len(set(test_tup))\n    return (res)\n"}
{"task_id": "MBPP/395", "completion": "\n    count = {}\n    for char in str1:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in str1:\n        if count[char] == 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    return bool(re.match(regex, string, re.IGNORECASE))\n\n"}
{"task_id": "MBPP/397", "completion": "\n    if a > b:\n        if a < c:\n            if b > c:\n                return a\n            else:\n                return c\n        else:\n            if a > c:\n                return a\n            else:\n                return b\n    else:\n        if a > c:\n            if b < c:\n                return a\n            else:\n                return c\n        else:\n            if a < c:\n                return a\n            else:\n                return b\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(abs(num))) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    res = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/400", "completion": "\n    res = {}\n    for sub in test_list:\n        sub.sort()\n        sub_tuple = tuple(sub)\n        if sub_tuple not in res:\n            res[sub_tuple] = 1\n        else:\n            res[sub_tuple] += 1\n    return list(res.items())\n"}
{"task_id": "MBPP/401", "completion": "\n    res = tuple(map(lambda x, y: x + y, test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/402", "completion": "\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if r == 1:\n        return n % p\n    if r == n:\n        return 1\n    if r == n // 2:\n        return comb(n, r) % p\n    return (comb(n, r) * pow(comb(n, n - r), p - 2, p)) % p\n\n"}
{"task_id": "MBPP/403", "completion": "\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return re.match(regex, str) is not None\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return a + b\n"}
{"task_id": "MBPP/405", "completion": "\n    if tuplex in tuple1:\n        return True\n    else:\n        return False\n\ntuplex = (1, 2, 3, 4, 5)\ntuple1 = (6, 7, 8, 9, 10)"}
{"task_id": "MBPP/406", "completion": "\n    if x == 0:\n        return \"Even\"\n    elif x == 1:\n        return \"Odd\"\n    else:\n        return foo(x-2)\n"}
{"task_id": "MBPP/407", "completion": "\n    digits = list(str(n))\n    for i in range(len(digits)-2, -1, -1):\n        if digits[i] < digits[i+1]:\n            sub = digits[i:]\n            min_bigger = min(filter(lambda x: x > sub[0], sub))\n            sub.remove(min_bigger)\n            sub.sort()\n            digits[i:] = [min_bigger] + sub\n            return int(\"\".join(digits))\n    return -1\n\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    # Add the first element of nums1 and the first element of nums2 to the heap\n    heapq.heappush(min_heap, (nums1[0] + nums2[0], 0, 0))\n    # Create a set to store the visited pairs\n    visited = set()\n    # Initialize the result list\n    res = []\n    # Loop until we have found k pairs\n    while len(res) < k:\n        # Pop the smallest pair from the heap\n        sum, i, j = heapq.heappop(min_heap)\n        # Add the pair to the result list\n        res.append((nums1[i], nums2[j]))\n        # If we have not visited the next pair in nums1, add it to the heap\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        # If we have not visited the next pair in nums2, add it to the heap\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    # Return the result list\n    return res\n\n"}
{"task_id": "MBPP/409", "completion": "\n    min_product = float('inf')\n    for pair in list1:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    minval = listval[0]\n    for i in listval:\n        if i < minval:\n            minval = i\n    return minval\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [x for x in l if x % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return [t[n] for t in list1]\n\n"}
{"task_id": "MBPP/414", "completion": "\n    for i in range(len(list1)):\n        if list1[i] == list2[0]:\n            for j in range(len(list2)):\n                if list1[i+j] != list2[j]:\n                    break\n            else:\n                return True\n    return False\n\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n\n    max_product = arr[0] * arr[1]\n    min_product = arr[0] * arr[1]\n    max_index = 0\n    min_index = 1\n\n    for i in range(2, len(arr)):\n        if arr[i] > max_product:\n            max_product = arr[i] * max(arr[max_index], arr[min_index])\n            max_index = i\n        elif arr[i] < min_product:\n            min_product = arr[i] * min(arr[max_index], arr[min_index])\n            min_index = i\n\n    return max_product\n\n"}
{"task_id": "MBPP/416", "completion": "\n    # Initialize a list to store the maximum sum for each number up to n\n    max_sum = [0] * (n + 1)\n\n    # Base cases\n    max_sum[0] = 0\n    max_sum[1] = 1\n\n    # Fill in the max_sum list using dynamic programming\n    for i in range(2, n + 1):\n        # Calculate the maximum sum by dividing the number into three parts\n        max_sum[i] = max(max_sum[i // 2] + max_sum[i // 3] + max_sum[i // 4], i)\n\n    # Return the maximum sum for the given number\n    return max_sum[n]\n\n"}
{"task_id": "MBPP/417", "completion": "\n    # Create an empty list to store the common elements\n    common_elements = []\n\n    # Iterate over the list of tuples\n    for tup in Input:\n        # Check if the first element of the tuple is already in the list\n        if tup[0] not in common_elements:\n            # If not, add it to the list\n            common_elements.append(tup[0])\n\n    # Return the list of common elements\n    return common_elements\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n\n"}
{"task_id": "MBPP/419", "completion": "\n    total = 0\n    for num in list1:\n        total += round(num)\n    return total * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**3\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    res = ''.join(ele for ele in test_tup)\n    return (res)\n"}
{"task_id": "MBPP/422", "completion": "\n    for i in range(n):\n        print(i**3)\n\nfoo(5)\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a table to store intermediate results\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            # If we are at the last column, we can only move right or right-up\n            if j == n-1:\n                dp[i][j] = max(dp[i+1][j], dp[i+1][j-1]) + gold[i][j]\n            # If we are at the last row, we can only move down or down-left\n            elif i == m-1:\n                dp[i][j] = max(dp[i][j+1], dp[i-1][j+1]) + gold[i][j]\n            # Otherwise, we can move in all four directions\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i+1][j-1], dp[i][j+1], dp[i-1][j+1]) + gold[i][j]\n\n    # The maximum gold collected will be the maximum value in the first column\n    return max(dp[i][0] for i in range(m))\n"}
{"task_id": "MBPP/424", "completion": "\n    result = [test_tuple[i][-1] for i in range(len(test_tuple))]\n    return result\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    return re.sub(r'(\\d{4})-(\\d{2})-(\\d{2})', r'\\3-\\2-\\1', dt)\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    res = tuple(map(lambda x, y: (x, y), test_tup1, test_tup2))\n    return (res)\n"}
{"task_id": "MBPP/430", "completion": "\n    return a * (b ** 2) - (c ** 2)\n\n"}
{"task_id": "MBPP/431", "completion": "\n    for i in list1:\n        if i in list2:\n            return True\n    return False\n"}
{"task_id": "MBPP/432", "completion": "\n    return (base1 + base2) / 2 * height / 2\n\n"}
{"task_id": "MBPP/433", "completion": "\n    for i in arr:\n        if i > number:\n            return True\n    return False\n\n"}
{"task_id": "MBPP/434", "completion": "\n    return re.match(r'ab+', text) is not None\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n\n"}
{"task_id": "MBPP/438", "completion": "\n    res = 0\n    for idx in range(len(test_list)):\n        for idx1 in range(idx + 1, len(test_list)):\n            if test_list[idx] == test_list[idx1][::-1]:\n                res += 1\n    return res\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(str(i) for i in L))\n"}
{"task_id": "MBPP/440", "completion": "\n    adverb_positions = []\n    words = text.split()\n    for i, word in enumerate(words):\n        if re.match(r'\\w+ly', word):\n            adverb_positions.append((i, word))\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    if not nums:\n        return 0\n\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n\n    return count / len(nums)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    # Initialize max_neg to None\n    max_neg = None\n\n    # Iterate over the list\n    for num in list1:\n        # Check if the number is negative\n        if num < 0:\n            # If max_neg is None or num is greater than max_neg\n            if max_neg is None or num > max_neg:\n                # Update max_neg\n                max_neg = num\n\n    # Return max_neg\n    return max_neg\n"}
{"task_id": "MBPP/444", "completion": "\n    res = [tuple(ele[:K] for ele in sub) for sub in test_list]\n    return res\n"}
{"task_id": "MBPP/445", "completion": "\n    res = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/446", "completion": "\n    # Create a counter object for the tuple\n    tuple_counter = Counter(tup)\n    \n    # Create a counter object for the list\n    list_counter = Counter(lst)\n    \n    # Combine the two counters\n    combined_counter = tuple_counter + list_counter\n    \n    return combined_counter\n\n"}
{"task_id": "MBPP/447", "completion": "\n    cubes = list(map(lambda x: x**3, nums))\n    return cubes\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c = 3, 0, 2\n        sum = 5\n        for i in range(3, n + 1):\n            d = a + b\n            sum += d\n            a, b, c = b, c, d\n        return sum\n\n"}
{"task_id": "MBPP/449", "completion": "\n    # calculate area of triangle\n    area = 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    # if area is zero, then triangle is invalid\n    if area == 0:\n        return False\n    else:\n        return True\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    if actual_cost > sale_amount:\n        loss = actual_cost - sale_amount\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    return sum(range(n))\n\n"}
{"task_id": "MBPP/454", "completion": "\n    return re.findall(r'\\b\\w*z\\w*\\b', text, re.IGNORECASE)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 == 1 or monthnum2 == 3 or monthnum2 == 5 or monthnum2 == 7 or monthnum2 == 8 or monthnum2 == 10 or monthnum2 == 12:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n\n"}
{"task_id": "MBPP/457", "completion": "\n    min_len = min(len(sublist) for sublist in lst)\n    return [sublist for sublist in lst if len(sublist) == min_len]\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub('[A-Z]+', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n\n"}
{"task_id": "MBPP/461", "completion": "\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 0:\n        return [[]]\n    else:\n        first = list1[0]\n        rest = list1[1:]\n        without_first = foo(rest)\n        with_first = [ [first] + item for item in without_first ]\n        return without_first + with_first\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n\n"}
{"task_id": "MBPP/464", "completion": "\n    for key in dict:\n        if dict[key] != n:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/465", "completion": "\n    return {k: v for k, v in dict1.items() if v}\n\n"}
{"task_id": "MBPP/466", "completion": "\n    if low == high:\n        return arr[low]\n\n    mid = (low + high) // 2\n\n    if arr[mid] > arr[mid + 1]:\n        return foo(arr, low, mid, n)\n    return foo(arr, mid + 1, high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    octalNum = \"\"\n    while deciNum > 0:\n        remainder = deciNum % 8\n        octalNum = str(remainder) + octalNum\n        deciNum = deciNum // 8\n    return octalNum\n\n"}
{"task_id": "MBPP/468", "completion": "\n    # Create a list to store maximum product subsequence ending at each index\n    max_prod_subseq = [0] * n\n    max_prod_subseq[0] = arr[0]\n\n    # Iterate over the array\n    for i in range(1, n):\n        # Iterate over the previous elements\n        for j in range(i):\n            # If the current element is greater than the previous element\n            # and the product of the current element and the maximum product subsequence ending at the previous element is greater than the maximum product subsequence ending at the current element\n            if arr[i] > arr[j] and max_prod_subseq[i] < max_prod_subseq[j] * arr[i]:\n                max_prod_subseq[i] = max_prod_subseq[j] * arr[i]\n\n        # If the maximum product subsequence ending at the current element is less than the current element, update it\n        if max_prod_subseq[i] < arr[i]:\n            max_prod_subseq[i] = arr[i]\n\n    # Return the maximum product subsequence\n    return max(max_prod_subseq)\n"}
{"task_id": "MBPP/469", "completion": "\n    if not price or k <= 0:\n        return 0\n\n    n = len(price)\n    if k >= n // 2:\n        return sum(max(price[i] - price[i-1], 0) for i in range(1, n))\n\n    dp = [[0 for _ in range(k+1)] for _ in range(n)]\n    for i in range(n):\n        for j in range(1, k+1):\n            max_profit = 0\n            for m in range(i):\n                max_profit = max(max_profit, dp[m][j-1] + price[i] - price[m])\n            dp[i][j] = max(dp[i-1][j], max_profit)\n\n    return dp[n-1][k]\n\n"}
{"task_id": "MBPP/470", "completion": "\n    res = tuple(map(lambda x, y: x + y, test_tup[::2], test_tup[1::2]))\n    return res\n"}
{"task_id": "MBPP/471", "completion": "\n    res = 1\n    for i in range(lens):\n        res = (res * (arr[i] % n)) % n\n    return res\n"}
{"task_id": "MBPP/472", "completion": "\n    for i in l:\n        if isinstance(i, (int, float)):\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    # Convert each tuple in the list to a set and find the intersection\n    intersection = set(test_list1).intersection(set(test_list2))\n    # Convert the intersection set back to a tuple and return\n    return tuple(intersection)\n"}
{"task_id": "MBPP/474", "completion": "\n    str1 = str1.replace(ch, newch)\n    return str1\n\n"}
{"task_id": "MBPP/475", "completion": "\n    return sorted(dict1.items(), key=lambda x: x[1])\n\n"}
{"task_id": "MBPP/476", "completion": "\n    if not nums:\n        return 0\n    \n    min_num = min(nums)\n    max_num = max(nums)\n    \n    return min_num + max_num\n\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    if n < 0:\n        return -1\n    if n < 10:\n        return n\n    else:\n        return foo(n // 10)\n\n"}
{"task_id": "MBPP/480", "completion": "\n    str1 = str1.lower()\n    count = {}\n    for char in str1:\n        if char.isalpha():\n            if char in count:\n                count[char] += 1\n            else:\n                count[char] = 1\n    max_char = max(count, key=count.get)\n    return max_char\n\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n    if set[n - 1] > sum:\n        return foo(set, n - 1, sum)\n    return foo(set, n - 1, sum) or foo(set, n - 1, sum - set[n - 1])\n\n"}
{"task_id": "MBPP/482", "completion": "\n    return re.findall(r'[A-Z][a-z]+', text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    fact = 1\n    i = 1\n    while True:\n        fact *= i\n        if fact % x == 0:\n            return i\n        i += 1\n\n"}
{"task_id": "MBPP/484", "completion": "\n    res = tuple(filter(lambda ele: ele not in test_list2, test_list1))\n    return res\n"}
{"task_id": "MBPP/485", "completion": "\n    # Check if the array is empty\n    if not n:\n        return None\n\n    # Check if the array contains only one element\n    if len(n) == 1:\n        return n[0]\n\n    # Sort the array in descending order\n    n.sort(reverse=True)\n\n    # Check if the first element is a palindrome\n    if str(n[0]) == str(n[0])[::-1]:\n        return n[0]\n\n    # Check if the second element is a palindrome\n    if str(n[1]) == str(n[1])[::-1]:\n        return n[1]\n\n    # Check if the first two elements are a palindrome\n    if str(n[0]) + str(n[1]) == str(n[0]) + str(n[1])[::-1]:\n        return str(n[0]) + str(n[1])\n\n    # Check if the first three elements are a palindrome\n    if str(n[0]) + str(n[1]) + str(n[2]) == str(n[0]) + str(n[1]) + str(n[2])[::-1]:\n        return str(n[0]) + str(n[1]) + str(n[2])\n\n    # Check if the first four elements are a palindrome\n    if str(n[0]) + str(n[1]) + str(n[2]) + str(n[3]) == str(n[0]) + str(n[1]) + str(n[2]) + str(n[3])[::-1]:\n        return str(n[0]) + str(n[1]) + str(n[2]) + str(n[3])\n\n    # Check if the first five elements are a palindrome\n    if str(n[0]) + str(n[1]) + str(n[2]) + str(n[3]) + str(n[4]) == str(n[0]) + str(n[1]) + str(n[2]) + str(n[3]) + str(n[4])[::-1]:\n        return str(n[0]) + str(n"}
{"task_id": "MBPP/486", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 1\n    if r == n:\n        return 1\n    if r > n:\n        return 0\n    return foo(n - 1, r - 1) + foo(n - 1, r)\n\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    max_val = max(arr)\n    count = arr.count(max_val)\n    return count\n"}
{"task_id": "MBPP/490", "completion": "\n    res = []\n    for idx in range(len(test_list)):\n        for idx2 in range(idx + 1, len(test_list)):\n            if test_list[idx] == test_list[idx2]:\n                res.append((test_list[idx], test_list[idx2]))\n    return res\n\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - math.pow(r, n)) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return True\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the side length of the hexagon\n    side_length = radius * math.sqrt(3)\n\n    # Calculate the horizontal distance between the centers of two adjacent hexagons\n    horizontal_distance = 1.5 * radius\n\n    # Calculate the vertical distance between the centers of two adjacent hexagons\n    vertical_distance = 0.75 * radius\n\n    # Calculate the starting and ending x and y coordinates\n    startx = startx - horizontal_distance\n    starty = starty - vertical_distance\n    endx = endx + horizontal_distance\n    endy = endy + vertical_distance\n\n    # Initialize the list of hexagons\n    hexagons = []\n\n    # Calculate the hexagons\n    x = startx\n    y = starty\n    while y < endy:\n        row = []\n        for i in range(6):\n            row.append((x, y))\n            x += horizontal_distance / 2\n        hexagons.append(row)\n        y += vertical_distance\n\n    return hexagons\n\n"}
{"task_id": "MBPP/494", "completion": "\n    res = int(\"\".join(map(str, test_tup)), 2)\n    return res\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub('[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    return hq.nsmallest(n, nums)\n\n"}
{"task_id": "MBPP/497", "completion": "\n    return math.pi * r * (r + math.sqrt(r**2 + h**2))\n\n"}
{"task_id": "MBPP/498", "completion": "\n    # Your code here\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    while y != 0:\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(nums)\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum([i**3 for i in range(1, n+1)])\n"}
{"task_id": "MBPP/505", "completion": "\n    count = 0\n    for i in range(len(A)):\n        if A[i] == 0:\n            count += 1\n    for i in range(count):\n        A.append(0)\n    return A[:-count]\n\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    return n * foo(n - 1, k - 1)\n"}
{"task_id": "MBPP/507", "completion": "\n    for word in removewords:\n        while word in list1:\n            list1.remove(word)\n    return list1\n"}
{"task_id": "MBPP/508", "completion": "\n    common_elements = [i for i in l1 if i in l2]\n    return common_elements == common_elements[::-1]\n"}
{"task_id": "MBPP/509", "completion": "\n    if n % 2 == 0:\n        return \"Invalid Input\"\n    else:\n        sum = 0\n        count = 0\n        for i in range(1, n+1, 2):\n            sum += i\n            count += 1\n        return sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        p = 1\n        for j in range(i, n):\n            p *= arr[j]\n            if p < k:\n                res += 1\n            else:\n                break\n    return res\n"}
