{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == ch:\n            s.pop(i)\n            break\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum)\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the input string into words\n    words = words.split()\n    \n    # Count the frequency of each word\n    word_count = Counter(words)\n    \n    # Get the most common word and its count\n    most_common_word = word_count.most_common(1)\n    \n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'([a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'(\\w)([A-Z])', r'\\1_\\2', text).lower()\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string_to_list(string[1:])]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    n = 1\n    while True:\n        woodall_number = (n * (2 ** n)) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i * n for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            return num\n        num_set.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(i) for i in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize product as 1\n    product = 1\n\n    # Iterate over the dictionary\n    for key, value in freq.items():\n        # If frequency is 1, multiply the product by the key\n        if value == 1:\n            product *= key\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element has odd frequency, return -1\n    return -1\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a heap to store the integers and their frequencies\n    heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(heap, (-count, num))\n\n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        if heap:\n            # Get the integer with the highest frequency\n            count, num = heapq.heappop(heap)\n            top_k.append(num)\n\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    for i in range(N - 1):\n        if ar[i + 1] - ar[i] > 1:\n            return ar[i] + 1\n    return ar[-1] + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    count = 0\n    i = 1\n    while True:\n        if is_rectangular(i):\n            count += 1\n            if count == n:\n                return i\n        i += 1\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a string\n    fraction = str(p) + '/' + str(q)\n    # Split the fraction into numerator and denominator\n    numerator, denominator = fraction.split('/')\n    # Remove the '0.' from the numerator\n    numerator = numerator[2:]\n    # Find the Nth digit\n    Nth_digit = int(numerator[N-1])\n    return Nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Use the sorted function with a custom sorting key\n    # The key function returns a tuple for each element in the list\n    # The first element of the tuple is the element itself (for strings)\n    # The second element of the tuple is the integer value of the element (for integers)\n    # This way, the sorted function will first sort by the integer value and then by the string value\n    sorted_list = sorted(mixed_list, key=lambda x: (str(x) if isinstance(x, int) else x, x if isinstance(x, int) else int(x)))\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even_div = 0\n    odd_div = 0\n    for i in list1:\n        if i % 2 == 0:\n            even_div += 1\n        else:\n            odd_div += 1\n    return even_div, odd_div\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    res = []\n    while max_heap:\n        freq1, char1 = heapq.heappop(max_heap)\n        if max_heap and -max_heap[0][0] == freq1 + 1:\n            freq2, char2 = heapq.heappop(max_heap)\n            res.append(char1 + char2)\n            if freq2 < -2:\n                heapq.heappush(max_heap, (freq2 + 1, char2))\n        else:\n            res.append(char1)\n            if freq1 < -1:\n                heapq.heappush(max_heap, (freq1 + 1, char1))\n    return ''.join(res)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = list(chain(*nums))\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"(\\w+) \\1\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(0)\n    else:\n        return None\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'\\b\\w+\\b'\n    match = re.search(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in x[1:]:\n        result = gcd(result, i)\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    fact_A = factorial(A)\n    fact_B = factorial(B)\n    last_digit_A = fact_A % 10\n    last_digit_B = fact_B % 10\n    if last_digit_A == 0:\n        return 0\n    else:\n        return last_digit_B // last_digit_A\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n >> 1\n"}
{"task_id": "MBPP/49", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each sublist in the given list\n    for sublist in nums:\n        # Check if the sublist has at least one element\n        if len(sublist) > 0:\n            # Append the first element of the sublist to the result list\n            result.append(sublist[0])\n        else:\n            # If the sublist is empty, append None to the result list\n            result.append(None)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if str[0] == str[-1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum element in the array\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrences of each element in the array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, max_element + 1):\n        count_array[i] += count_array[i - 1]\n    \n    # Create a sorted array\n    sorted_array = [0] * len(my_list)\n    for num in my_list:\n        sorted_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return sorted_array\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return: True if the number is one less than twice its reverse, False otherwise\n    \"\"\"\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return: True if the number is one less than twice its reverse, False otherwise\n    \"\"\"\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return: True if the number is one less than twice its reverse, False otherwise\n    \"\"\"\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return: True if the number is one less than twice its reverse, False otherwise\n    \"\"\"\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return: True if the number is one less than twice its reverse, False otherwise\n    \"\"\"\n    rev_num = 0\n    while n > 0:\n        rev_num = rev_num * 10 + n % 10\n        n = n // 10\n    return rev_num == 2 * n - 1\n    \"\"\"\n    :param n: The number to check\n    :return:"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    max_num = 0\n    for i in range(n-1, -1, -1):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n*(2*n-1) == 1\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return max(arr[0], arr[1])\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n\n    return dp[-1]\n"}
{"task_id": "MBPP/61", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize the minimum and maximum values\n    min_val = test_list[0]\n    max_val = test_list[-1]\n    \n    # Initialize the maximum difference\n    max_diff = max_val - min_val\n    \n    # Iterate over the list to find the maximum difference\n    for i in range(1, len(test_list)):\n        # Calculate the difference between the current and previous elements\n        diff = test_list[i] - test_list[i-1]\n        \n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x['marks'], reverse=True)\n\nsubjectmarks = [\n    {'name': 'John', 'marks': 90},\n    {'name': 'Alice', 'marks': 80},\n    {'name': 'Bob', 'marks': 70},\n    {'name': 'Charlie', 'marks': 60},\n    {'name': 'David', 'marks': 50}\n]\n"}
{"task_id": "MBPP/65", "completion": "\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return sum(bell_number(n - i) for i in range(n + 1))  # This is the recursive formula for Bell numbers\n\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    for i in range(n-1):\n        if A[i] > A[i+1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    return all(len(i) == k for i in Input)\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    else:\n        return (int((n ** 0.5) ** 2) == n ** 0.5) or (int((n ** 0.5) ** 2) == n ** 0.5 + 1)\n\n"}
{"task_id": "MBPP/73", "completion": "\n    # Using regex to split the string with multiple delimiters\n    return re.split(r'[,\\s]+', text)\n\n"}
{"task_id": "MBPP/74", "completion": "\n    for i in range(len(colors) - 1):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum - odd_sum\n"}
{"task_id": "MBPP/78", "completion": "\n    # Initialize count of integers with odd number of set bits\n    count = 0\n    # Iterate over all possible integers\n    for i in range(1, 2**32):\n        # Convert integer to binary and remove the '0b' prefix\n        binary = bin(i)[2:]\n        # Count the number of set bits\n        set_bits = binary.count('1')\n        # Check if the number of set bits is odd\n        if set_bits % 2 != 0:\n            # If the number of set bits is odd, increment the count\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return list(zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    sequence = [0, 1]\n    while len(sequence) < n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max([i for i in range(1, N) if i < N])\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to string to check each digit\n    str_n = str(n)\n    \n    # Check if the number has more than one digit\n    if len(str_n) <= 1:\n        return False\n    \n    # Check if the number is undulating\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is greater than the next digit\n        if int(str_n[i]) > int(str_n[i + 1]):\n            return False\n        # Check if the current digit is less than the next digit\n        elif int(str_n[i]) < int(str_n[i + 1]):\n            return False\n    \n    # If the number is not undulating, return False\n    return False\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    if not test_list:\n        return None\n    min_val = min(test_list, key=itemgetter(1))\n    return test_list.index(min_val)\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    min_sublist = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_sublist = sublist\n    return min_sublist\n"}
{"task_id": "MBPP/96", "completion": "\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('[_-]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return (m + 1) * eulerian_num(n - 1, m)\n"}
{"task_id": "MBPP/104", "completion": "\n    return [[sublist.sort(), sublist] for sublist in input_list]\n\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup = list(test_tup)\n    \n    # Add the two lists together\n    result = test_list + test_tup\n    \n    return result\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap\n    min_heap = []\n    # Push the first element of each list into the heap\n    heapq.heappush(min_heap, (num1[0], 0, num1))\n    heapq.heappush(min_heap, (num2[0], 0, num2))\n    heapq.heappush(min_heap, (num3[0], 0, num3))\n\n    # Initialize the result list\n    result = []\n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, idx, nums = heapq.heappop(min_heap)\n        # Add the popped element to the result list\n        result.append(val)\n        # If there are more elements in the list, push the next element into the heap\n        if idx + 1 < len(nums):\n            heapq.heappush(min_heap, (nums[idx + 1], idx + 1, nums))\n\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if s[i] == '1':\n            count += 1\n    return count % 2 == 1\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    for i in range(len(test_list) - 1):\n        if test_list[i] + 1 < test_list[i + 1]:\n            missing_ranges.append((test_list[i] + 1, test_list[i + 1] - 1))\n    if strt_val < test_list[0]:\n        missing_ranges.append((strt_val, test_list[0] - 1))\n    if test_list[-1] < stop_val:\n        missing_ranges.append((test_list[-1] + 1, stop_val))\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    return all(not dict1 for dict1 in list1)\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list if isinstance(i, (int, float))]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if arr[mid] == arr[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return arr[low]\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i] * list1[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    left = 0\n    right = n - 1\n    while left < right:\n        current_sum = A[left] + A[right]\n        if current_sum == sum:\n            count += 1\n            left += 1\n            right -= 1\n        elif current_sum < sum:\n            left += 1\n        else:\n            right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize the list to store smart numbers\n    smartNumbers = []\n    # Initialize the counter\n    i = 1\n    # Loop until we find the nth smart number\n    while len(smartNumbers) < n:\n        # Check if the number is smart\n        if isSmart(i):\n            # If it is, add it to the list\n            smartNumbers.append(i)\n        # Increment the counter\n        i += 1\n    # Return the nth smart number\n    return smartNumbers[-1]\n\n"}
{"task_id": "MBPP/123", "completion": "\nReturn the sum of proper divisors of n\"\"\"\n        return sum(i for i in range(1, n) if n % i == 0)\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        n = sum_proper_divisors(i)\n        if n < limit and sum_proper_divisors(n) == i and i != n:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    count = 0\n    max_count = 0\n    for i in range(n):\n        if string[i] == '1':\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 0\n    return max(max_count, count)\n"}
{"task_id": "MBPP/126", "completion": "\n    # Calculate the greatest common divisor (GCD) of a and b\n    gcd = math.gcd(a, b)\n    \n    # Calculate the sum of divisors of the GCD\n    sum_div = sum(i for i in range(1, gcd + 1) if gcd % i == 0)\n    \n    return sum_div\n"}
{"task_id": "MBPP/127", "completion": "\n    if x == 0 or y == 0:\n        return 0\n    elif x < 0:\n        return -multiply_int(-x, y)\n    elif y < 0:\n        return -multiply_int(x, -y)\n    elif x < y:\n        return multiply_int(y, x)\n    else:\n        return 1 + multiply_int(x - y, y)\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is a magic square\n    if not is_magic_square(my_matrix):\n        return False\n\n    # Check if the matrix is a 3x3 matrix\n    if len(my_matrix) != 3 or len(my_matrix[0]) != 3:\n        return False\n\n    # Check if the matrix is a square matrix\n    if my_matrix != [list(row) for row in zip(*my_matrix)]:\n        return False\n\n    # Check if the matrix has the same number of rows and columns\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row\n    if len(my_matrix[0]) != len(my_matrix):\n        return False\n\n    # Check if the matrix has the same number of elements in each column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each diagonal\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each anti-diagonal\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store frequency of each item\n    freq_dict = defaultdict(int)\n    \n    # Iterate over the list to count frequency of each item\n    for num in nums:\n        freq_dict[num] += 1\n    \n    # Find the item with maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n    \n    return max_freq_item\n\n"}
{"task_id": "MBPP/131", "completion": "\n    # Define vowels\n    vowels = 'aeiouAEIOU'\n    # Convert string to list\n    str_list = list(str1)\n    # Initialize two pointers\n    left, right = 0, len(str_list) - 1\n    # Traverse the string from both ends\n    while left < right:\n        # If left character is not a vowel, move left pointer\n        if str_list[left] not in vowels:\n            left += 1\n        # If right character is not a vowel, move right pointer\n        elif str_list[right] not in vowels:\n            right -= 1\n        # If both characters are vowels, swap them\n        else:\n            str_list[left], str_list[right] = str_list[right], str_list[left]\n            left += 1\n            right -= 1\n    # Convert list back to string\n    return ''.join(str_list)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    for _ in range(p):\n        arr[-1] = arr[-1] % 2\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n*(2*n-1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units < 0:\n        return \"Invalid input\"\n    elif units <= 50:\n        return units * 0.5\n    elif units <= 150:\n        return 25 + (units - 50) * 0.75\n    elif units <= 250:\n        return 125 + (units - 150) * 1.0\n    else:\n        return 250 + (units - 250) * 1.2\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of boolean values indicating whether each element is zero\n    bool_array = array('b', [num == 0 for num in nums])\n    \n    # Count the number of True values in the array\n    zero_count = bool_array.count(1)\n    \n    # Return the ratio of zeros to the total number of elements\n    return zero_count / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0's\n    return '0' not in binary\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Initialize an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for element in test_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    # Initialize an empty list to store the elements that occur only once\n    singly_list = []\n    \n    # Iterate over each key-value pair in the dictionary\n    for key, value in freq_dict.items():\n        # If the value is 1, add the key to the singly list\n        if value == 1:\n            singly_list.append(key)\n    \n    # Return the list of elements that occur only once\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n\n        Helper function to reverse the list\n        \"\"\"\n        return nums[::-1]\n\n    def is_sorted(nums):\n        \"\"\"\n        Helper function to check if the list is sorted\n        \"\"\"\n        return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\n\n    for i in range(len(nums)):\n        # Find the maximum element in the unsorted part of the list\n        max_idx = nums.index(max(nums[:i+1]))\n        # Move the maximum element to the beginning of the unsorted part\n        nums[:i+1], nums[max_idx] = nums[max_idx], nums[:i+1][0]\n        # Reverse the unsorted part of the list\n        nums[:i+1] = reverse(nums[:i+1])\n        # Check if the list is sorted\n        if not is_sorted(nums):\n            # If not, continue the process\n            continue\n        # If the list is sorted, break the loop\n        break\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter\n    count = 0\n    # Iterate over the first list\n    for i in list1:\n        # Iterate over the second list\n        for j in list2:\n            # Check if the pair (i, j) exists in the third list\n            if (i, j) in list3 or (j, i) in list3:\n                # If the pair exists, increment the counter\n                count += 1\n    # Return the count\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    lists = []\n    for item in Input:\n        if isinstance(item, list):\n            lists.append(item)\n    return lists\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_diff += abs(arr[i] - arr[j])\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    arr.sort()\n    max_diff = arr[n - 1] - arr[0]\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(c) for c in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m-2, -1, -1):\n        for j in range(n-1):\n            tri[i][j] += max(tri[i+1][j], tri[i+1][j+1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    if x < 10:\n        return x\n    else:\n        return max(x % 10 + sum_digits_single(x // 10), sum_digits_single(x // 10))\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    elif a > b:\n        return False\n    else:\n        return does_Contain_B(a + c, b, c)\n\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1: return x else: mid = len(x) // 2 left = merge_sort(x[:mid]) right = merge_sort(x[mid:]) return merge(left, right) "}
{"task_id": "MBPP/153", "completion": "\n    # calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    # calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    specified = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                specified.append(nums[i][j])\n    return specified\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '0', append '1' to the result\n        if bit == '0':\n            result += '1'\n        # If the bit is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    min_ops = 0\n    for i in range(n):\n        min_ops += abs(arr[i] - arr[0])\n    return min_ops\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return -1\n    else:\n        return x * (n // gcd) % (b // gcd)\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    total = 0\n    x = 1\n    while n - x >= 0:\n        total += n - x\n        x += 1\n    return total\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s ** 2) * tan(pi / l) / (4 * tan(pi / l) - l * tan(2 * pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_div = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_div += i\n    return sum_div\n\n"}
{"task_id": "MBPP/165", "completion": "\n    char_count = {}\n    for i in range(len(str1)):\n        char = str1[i]\n        if char.isalpha():\n            if char.islower():\n                char = char.lower()\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    return s.count('std')\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^a-zA-Z0-9\\s]', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if lcm(L[i], L[j]) <= R and lcm(L[i], L[j]) not in L:\n                return [L[i], L[j]]\n    return []\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    num = x\n    sum = 0\n    while num > 0:\n        sum += num % 10\n        num //= 10\n    return is_prime(sum) and is_prime(x)\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude to radians\n    slat, slon = radians(slat), radians(slon)\n    elat, elon = radians(elat), radians(elon)\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n\n    # Radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate distance\n    distance = R * c\n\n    return distance\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Regular expression to find upper case letters\n    upper_case = re.findall(r'[A-Z]', string)\n    # Regular expression to find special characters\n    special_chars = re.findall(r'[^A-Za-z0-9\\s]', string)\n    # Regular expression to find numeric values\n    numeric_values = re.findall(r'\\d', string)\n    return upper_case, special_chars, numeric_values\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    count = 0\n    i = 0\n    j = 1\n    while j < n:\n        if arr[j] - arr[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif arr[j] - arr[i] < k:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    # Calculate the focus point\n    focus_point = (c / (4 * a), 0)\n    return focus_point\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequences of\n    # substrings. Note that the length of LCS for X[0..m-1], Y[0..n-1] is\n    # stored in table[m+1][n+1]\n    L = [[0 for k in range(n+1)] for l in range(m+1)]\n\n    # Following steps build L[m+1][n+1] in bottom up fashion\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0 :\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1]+1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index+1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store\n    # characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X and Y are same, then current character\n        # is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction\n        # of larger value\n        elif L[i-1][j] > L[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    elif n == 0 or n == 1:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if n % (i * i) == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers\n    num_set = set()\n    \n    # Iterate over the array and add the positive numbers to the set\n    for num in arr:\n        if 1 <= num <= n:\n            num_set.add(num)\n    \n    # Iterate from 1 to n and return the first missing positive number\n    for i in range(1, n + 1):\n        if i not in num_set:\n            return i\n    \n    # If all numbers from 1 to n are present in the set, return n + 1\n    return n + 1\n"}
{"task_id": "MBPP/190", "completion": "\n    # Define the square boundaries\n    x_min, x_max = min(x1, x2), max(x1, x2)\n    y_min, y_max = min(y1, y2), max(y1, y2)\n\n    # Define the integral points\n    integral_points = [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n    # Count the integral points inside the square\n    count = 0\n    for point in integral_points:\n        if x_min <= point[0] <= x_max and y_min <= point[1] <= y_max:\n            count += 1\n\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if len(str) < 2:\n        return False\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n    return has_letter and has_number\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [i for i in test_list if len(i) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    return test_tup1[0]**test_tup2[0]\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major axis\n    a = a / 2\n    # Calculate the semi-minor axis\n    b = b / 2\n    # Calculate the area of the ellipse\n    area = math.pi * a * b\n    # Calculate the radius of the inscribed circle\n    r = (a * b) / (a + b)\n    # Calculate the area of the inscribed circle\n    circle_area = math.pi * r ** 2\n    # Calculate the area of the largest triangle\n    triangle_area = area - circle_area\n    return triangle_area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (n > 1):\n        n = n // 2\n        i += 1\n    return 2 ** i\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    # Initialize an empty list to store the inversion elements\n    inversion_list = []\n    \n    # Iterate over the tuple list\n    for tup in test_tup:\n        # Iterate over the tuple elements\n        for i in range(len(tup)):\n            # Check if the current element is greater than the next element\n            if i < len(tup) - 1 and tup[i] > tup[i + 1]:\n                # If true, append the inversion elements to the list\n                inversion_list.append((tup[i], tup[i + 1]))\n    \n    # Return the inversion list\n    return inversion_list\n"}
{"task_id": "MBPP/206", "completion": "\n    return [test_tup[i] + test_tup[i+1] for i in range(len(test_tup)-1)]\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                if i == j:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                max_len = max(max_len, dp[i][j])\n    return max_len\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(n):\n        if (i & (i - 1)) == 0 and (i & n) != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum(i**4 for i in range(1, n+1))\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return ''.join(test_tup1) + ''.join(test_tup2)\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    def is_subset(subset, superset):\n        if not subset:\n            return True\n        if not superset:\n            return False\n        if subset[0] in superset:\n            return is_subset(subset[1:], superset)\n        else:\n            return is_subset(subset, superset[1:])\n\n    return is_subset(list1, list2)\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str:\n        if char_count[char] > 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    \n    # Calculate the minimum number of operations required\n    # This is done by dividing the difference by 2 and rounding up to the nearest integer\n    # This is because we can divide the difference by 2 in each operation\n    min_operations = math.ceil(diff / 2)\n    \n    return min_operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple to a list\n    test_list = list(test_tup)\n    \n    # Sort the list in descending order\n    test_list.sort(reverse=True)\n    \n    # Extract the maximum element\n    max_element = test_list[0]\n    \n    # Extract the kth element\n    kth_element = test_list[K-1]\n    \n    return max_element, kth_element\n"}
{"task_id": "MBPP/220", "completion": "\n    text = re.sub(r'\\s+', ':', text)\n    text = re.sub(r'[.,]', ':', text)\n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if len(test_tuple) == 0:\n        return True\n    else:\n        return all(isinstance(x, type(test_tuple[0])) for x in test_tuple)\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count of the given element\n    count = 0\n    # Traverse the array\n    for i in range(n):\n        # If the current element is equal to x, increment the count\n        if arr[i] == x:\n            count += 1\n        # If the current element is not equal to x, decrement the count\n        else:\n            count -= 1\n        # If the count becomes zero, reset it\n        if count == 0:\n            count = 1\n        # If the count becomes greater than n/2, return True\n        if count > n / 2:\n            return True\n    # If the loop completes and count is not greater than n/2, return False\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if high < low:\n        return arr[low]\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < high and arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    if mid > low and arr[mid] < arr[low]:\n        return find_Min(arr, low, mid - 1)\n    return arr[mid]\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Check if the range is valid\n    if l < 0 or r >= n:\n        return False\n\n    # Calculate the number of bits in the range\n    num_bits = r - l + 1\n\n    # Calculate the number of bits that are set in the range\n    num_set_bits = bin(n).count('1') - bin(l).count('1') - bin(n - r - 1).count('1')\n\n    # Check if all bits are unset in the range\n    return num_set_bits == 0\n"}
{"task_id": "MBPP/229", "completion": "\n    return sorted(arr, key=lambda x: (x < 0, x))\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Create a 2D list to store the maximum sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of dp\n    for i in range(n):\n        dp[0][i] = tri[0][i]\n        dp[i][0] = tri[i][0]\n    \n    # Fill the dp table in a bottom-up manner\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum at position (i, j) is the maximum of the sum of the number at position (i, j)\n            # and the maximum sum of the numbers above it\n            dp[i][j] = tri[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # The maximum sum in the triangle is stored in the bottom-right corner of the dp table\n    return dp[n-1][n-1]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    # Import necessary module\n    import math\n\n    # Define the function\n    def lateral_surface_area_cylinder(r, h):\n        # Calculate the lateral surface area\n        lateral_surface_area = 2 * math.pi * r * h\n        return lateral_surface_area\n\n    # Return the result\n    return lateral_surface_area_cylinder(r, h)\n\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n | n << 1\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of equilateral triangles that can be formed\n    # The formula for this is (N * (N - 1) * (N - 2)) / 6\n    # This is because each triangle has 3 vertices, and we need to choose 3 vertices from N vertices\n    # The number of ways to choose 3 vertices from N vertices is (N * (N - 1) * (N - 2)) / 6\n    # However, this formula counts each triangle 6 times (since each triangle has 3 vertices, and each vertex is counted 3 times)\n    # So, we divide by 6 to get the correct count\n    return (N * (N - 1) * (N - 2)) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Count the occurrences of each record\n    count = Counter(test_list)\n    # Get the maximum count\n    max_count = max(count.values())\n    # Get the records with the maximum count\n    max_count_records = [record for record, freq in count.items() if freq == max_count]\n    return max_count_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if j > m:\n                break\n            if j <= m // 2:\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += dp[i - 1]\n    return dp[n] - 1  # subtract 1 because we don't want to count the empty sequence\n\n"}
{"task_id": "MBPP/240", "completion": "\n    if len(list1) > 0 and len(list2) > 0:\n        list1[-1] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: (x[0], lst.count(x[0])))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    # Calculate the next integer greater than sqrt_N\n    next_int = math.ceil(sqrt_N)\n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of bi-tonic sub-sequence\n    # ending at the current position and the maximum sum of bi-tonic sub-sequence\n    # ending at the previous position\n    max_ending_here = [0] * n\n    max_ending_here[0] = arr[0]\n    max_so_far = arr[0]\n\n    # Initialize variables to store the maximum sum of bi-tonic sub-sequence\n    # ending at the current position and the maximum sum of bi-tonic sub-sequence\n    # ending at the previous position\n    max_ending_here_prev = [0] * n\n    max_ending_here_prev[0] = arr[0]\n    max_so_far_prev = arr[0]\n\n    # Iterate over the array from the second element to the last element\n    for i in range(1, n):\n        # If the current element is greater than the previous element, then\n        # the maximum sum of bi-tonic sub-sequence ending at the current position\n        # is the maximum of the maximum sum of bi-tonic sub-sequence ending at the\n        # previous position and the sum of the current element and the maximum sum\n        # of bi-tonic sub-sequence ending at the position two elements before\n        if arr[i] > arr[i - 1]:\n            max_ending_here[i] = max_ending_here[i - 1] + arr[i]\n            max_ending_here_prev[i] = max_ending_here_prev[i - 1]\n        # If the current element is less than the previous element, then\n        # the maximum sum of bi-tonic sub-sequence ending at the current position\n        # is the maximum of the maximum sum of bi-tonic sub-sequence ending at the\n        # previous position and the current element\n        else:\n            max_ending_here[i] = arr[i]\n            max_ending_here_prev[i] = max_ending_here_prev[i - 1] + arr[i]\n\n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        max_ending_here[i] = max(max_ending_here[i], max_ending_here_prev[i])\n\n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        # and the maximum sum of bi-tonic sub-sequence ending at the previous position\n        max_so_far = max(max_so_far, max_"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number\")\n    if number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.00001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    if n == 0:\n        return \"\"\n    elif n == 1:\n        return str\n    elif n == 2:\n        if str[0] == str[1]:\n            return str[0:2]\n        else:\n            return str[0:1]\n    else:\n        # Initialize a 2D table to store the longest palindromic subsequences\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        max_length = 1\n        start = 0\n        for i in range(n):\n            dp[i][i] = True\n            max_length = 1\n            start = i\n            for j in range(i + 1, n):\n                if str[i] == str[j]:\n                    if j - i == 1 or dp[i + 1][j - 1]:\n                        dp[i][j] = True\n                        if max_length < j - i + 1:\n                            max_length = j - i + 1\n                            start = i\n                else:\n                    dp[i][j] = False\n        return str[start:start + max_length]\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(filter(lambda x: x in array_nums2, array_nums1))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    new_list = []\n    for i in list:\n        new_list.append(i)\n        new_list.append(element)\n    return new_list\n"}
{"task_id": "MBPP/252", "completion": "\n    return [cmath.polar(num) for num in numbers]\n\n\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\ba\\w+\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum of the two maximum elements\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_newman_shanks_williams_prime(num):\n        # Newman\u2013Shanks\u2013Williams prime is a prime number that is one more or one less than a power of two\n        return is_prime(num) and (num - 1) & (num + 1) == 1\n\n    count = 0\n    num = 1\n    while True:\n        if is_newman_shanks_williams_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(\"Error: Division by zero is not allowed\")\n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # Define the conversion factor\n    conversion_factor = 7\n\n    # Calculate the dog age\n    dog_age = h_age / conversion_factor\n\n    # Return the dog age\n    return dog_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    # Define the formula for lateral surface area of a cube\n    lateral_surface_area = 4 * l ** 2\n    return lateral_surface_area\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum(i**2 for i in range(1, n*2, 2))\n"}
{"task_id": "MBPP/268", "completion": "\n    star_num = 0\n    i = 1\n    while star_num < n:\n        star_num += i\n        i += 1\n    return star_num\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if arr[i] % 2 == 0 and i % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    even_sum = 0\n    for i in range(2, n+1, 2):\n        even_sum += i ** 5\n    return even_sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return test_list[-1]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a[n] + m) % (n + 1)\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return len([i for i in test_tup if i < test_tup[0]])\n\n"}
{"task_id": "MBPP/279", "completion": "\n    return n*(10*n-1)//2\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is greater than or equal to the digit itself, return False\n        if count >= int(digit):\n            return False\n    \n    # If the function has not returned False, return True\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum([i**2 for i in range(2, n+1, 2)])\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    return N//2\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = 0\n    max_lists = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_lists = [lst]\n        elif len(lst) == max_len:\n            max_lists.append(lst)\n    return max_lists\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from the 3rd post to the nth post\n    for i in range(3, n + 1):\n        # The number of ways to paint the ith post is the sum of the number of ways to paint the (i-1)th post and the (i-2)th post\n        # because we can paint the ith post with any of the k colors, and the (i-1)th post can be painted with any of the k colors\n        # and the (i-2)th post can be painted with any of the k colors\n        ways[i] = (ways[i - 1] + ways[i - 2]) * k\n\n    return ways[n] // 2  # Return the number of ways to paint the fence with at most 2 adjacent posts of the same color\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [i for i in range(1, number) if number % i == 0]\n    return sum(divisors)\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for i in l1:\n        if isinstance(i, list):\n            result.extend(intersection_nested_lists(i, l2))\n        elif i in l2:\n            result.append(i)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_aggregates = defaultdict(int)\n    \n    # Iterate over the list of tuples\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_aggregates[num] = max(max_aggregates[num], aggregate)\n    \n    # Return the maximum aggregate\n    return max(max_aggregates.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    def count(n):\n        if n == 0:\n            return 1\n        else:\n            return 2 * count(n - 1)\n    return count(n) ** 2\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    n = n & -n\n    return bin(n).count('1')\n"}
{"task_id": "MBPP/303", "completion": "\n    inversion_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversion_count += 1\n    return inversion_count\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Check if the index is within the range of the array\n    if index < 0 or index >= len(arr):\n        return None\n\n    # Check if the index is within the range of the rotated array\n    if index < ranges[0] or index >= ranges[1]:\n        return None\n\n    # Find the element at the given index\n    element = arr[index]\n\n    return element\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = re.compile(r'^p')\n    return [word for word in words if pattern.match(word)]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == 0:\n        return a[0]\n    elif index == n:\n        return 0\n    else:\n        # Recursive call for including the current element\n        include = a[index] + max_sum_increasing_subseq(a, n, index - 1, k)\n        # Recursive call for excluding the current element\n        exclude = max_sum_increasing_subseq(a, n, index - 1, k)\n        return max(include, exclude)\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort the lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize a list to store the products\n    products = []\n\n    # Iterate over the lists to find the products\n    for i in range(N):\n        product = nums1[i] * nums2[i]\n        products.append(product)\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the N largest products\n    return products[:N]\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n\n    return max(dp[0][n-1], dp[1][n-1])  # return the maximum sum of the last row or column\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) > max_len and len(word) % 2 == 0:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    encoded = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        encoded.append((key, count))\n    return encoded\n\n"}
{"task_id": "MBPP/318", "completion": "\n    s = int(s)\n    for a in range(1, s):\n        for b in range(a, s):\n            c = s - a - b\n            if a * b * c > max_volume:\n                max_volume = a * b * c\n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    pattern = r'\\b\\w{5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n\ntext = \"I am a software developer and I love to code in python and java\""}
{"task_id": "MBPP/320", "completion": "\n    sum_n = n * (n + 1) // 2\n    sum_square_n = n * (n + 1) * (2 * n + 1) // 6\n    sum_square_sum_n = (sum_n ** 2)\n    return sum_square_sum_n - sum_square_n\n"}
{"task_id": "MBPP/321", "completion": "\n    # Convert the number to string\n    s = str(s)\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through each character in the string\n    for i in range(len(s)):\n        # Add the value of the character to the demlo number\n        demlo += int(s[i])\n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n    if n == 1:\n        return arr\n    if n == 2:\n        return arr\n    if n % 2 == 0:\n        return right_rotate(arr, n - 1, out_of_place, cur)\n    else:\n        return right_rotate(arr, n - 1, out_of_place, cur + 1)\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[i] for i in range(0, len(test_tuple), 2))\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # Update the minimum number of squares for the current number\n            min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return most_common_words\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles\")\n    else:\n        print(\"The triangle is not isosceles\")\n"}
{"task_id": "MBPP/328", "completion": "\n    n = n % len(list1)\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return list.count(-1)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,4}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # reverse = None (Sorts in Ascending order)\n    # or reverse = True (Sorts in Descending order)\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n/2) * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b'\n    return re.search(pattern, text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    divisors = []\n    for i in range(1, y+1):\n        if x % i == 0:\n            divisors.append(i)\n    return max(set(divisors), key=divisors.count)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # We then filter out the non-positive numbers\n    positive_lst = [num for num in sorted_lst if num > 0]\n    \n    # If there are less than three positive numbers, we return the sum of all positive numbers\n    if len(positive_lst) < 3:\n        return sum(positive_lst)\n    \n    # Otherwise, we return the sum of the three smallest positive numbers\n    else:\n        return sum(positive_lst[:3])  # We use list slicing to get the first three elements of the list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_range = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_range = max(max_range, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if max_range - node.value < min_range:\n            min_range = max_range - node.value\n        if node.index + 1 < len(list[node.list_num]):\n            next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n            heappush(min_heap, next_node)\n            heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n            max_range = max(max_range, -list[node.list_num][node.index + 1])\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    num = 0\n    let = 0\n    for char in s:\n        if char.isdigit():\n            num += 1\n        elif char.isalpha():\n            let += 1\n    return num, let\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    if n == 9:\n        return 256\n    if n == 10:\n        return 512\n    if n == 11:\n        return 1024\n    if n == 12:\n        return 2048\n    if n == 13:\n        return 4096\n    if n == 14:\n        return 8192\n    if n == 15:\n        return 16384\n    if n == 16:\n        return 32768\n    if n == 17:\n        return 65536\n    if n == 18:\n        return 131072\n    if n == 19:\n        return 262144\n    if n == 20:\n        return 524288\n    if n == 21:\n        return 1048576\n    if n == 22:\n        return 2097152\n    if n == 23:\n        return 4194304\n    if n == 24:\n        return 8388608\n    if n == 25:\n        return 16777216\n    if n == 26:\n        return 33554432\n    if n == 27:\n        return 67108864\n    if n == 28:\n        return 134217728\n    if n == 29:\n        return 268435456\n    if n == 30:\n        return 536870912\n    if n == 31:\n        return 1073741824\n    if n == 32:\n        return 2147483648\n    if n == 33:\n        return 4294967296\n    if n == 34:\n        return 8589934592\n    if n == 35:\n        return 17179869184\n    if n == 36:\n        return 34359738368\n    if n == 37:\n        return 68719476736\n    if n == 38:\n        return 137438953472\n    if"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < 0:\n        return 0\n    if n == r:\n        return 1\n    if n > r:\n        return 0\n    return bin_coff(n - 1, r - 1) + bin_coff(n - 1, r)\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) == {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element that occurs k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [x[:n] + x[n+1:] for x in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    return 4 * (radius ** 2) / (4 * (1/4) * (radius ** 2))\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - a - b\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = test_list[0]\n    for i in range(1, len(test_list)):\n        if test_list[i] > max_val:\n            max_val = test_list[i]\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n\n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n\n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n\n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n):\n        carol = carol + i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum count\n    max_count = max(count_dict.values())\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_items\n"}
{"task_id": "MBPP/363", "completion": "\n    return [x + K for x in test_list]\n"}
{"task_id": "MBPP/364", "completion": "\n    flips = 0\n    for i in range(1, len(ch)):\n        if ch[i] != ch[i - 1]:\n            flips += 1\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    return (abs(left_height - right_height) <= 1 and\n            is_tree_balanced(root.left) and\n            is_tree_balanced(root.right))\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))\n"}
{"task_id": "MBPP/371", "completion": "\n    # Check if the array is empty\n    if not A:\n        return 1\n\n    # Check if the array has only one element\n    if len(A) == 1:\n        if A[0] == left_element:\n            return left_element + 1\n        elif A[0] == right_element:\n            return left_element\n        else:\n            return left_element\n\n    # Check if the array has only two elements\n    if len(A) == 2:\n        if A[0] == left_element:\n            if A[1] == right_element:\n                return left_element + 1\n            else:\n                return left_element\n        elif A[0] == right_element:\n            if A[1] == left_element:\n                return right_element + 1\n            else:\n                return right_element\n        else:\n            return left_element\n\n    # Check if the array has more than two elements\n    for i in range(len(A) - 1):\n        if A[i + 1] - A[i] > 1:\n            return A[i] + 1\n\n    # If the array is sorted and has no gaps\n    return right_element + 1\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with the custom value for elements that occur more than once\n    new_tup = []\n    for element in test_tup:\n        if count_dict[element] > 1:\n            new_tup.append('REPLICA')\n        else:\n            new_tup.append(element)\n\n    return tuple(new_tup)\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 0:\n        first_element = test_list.pop()\n        test_list.insert(0, first_element)\n    return test_list\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    # Initialize two empty lists\n    list1 = []\n    list2 = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append the current row and column to the lists\n            list1.append(i)\n            list2.append(j)\n    \n    # Return the two lists\n    return list1, list2\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    def find_pivot(A, low, high):\n        if high < low:\n            return -1\n        if high == low:\n            return low\n        mid = (low + high) // 2\n        if mid < high and A[mid] > A[mid + 1]:\n            return mid\n        if mid > low and A[mid] < A[mid - 1]:\n            return mid - 1\n        if A[low] >= A[mid]:\n            return find_pivot(A, low, mid - 1)\n        return find_pivot(A, mid + 1, high)\n\n    pivot = find_pivot(A, 0, len(A) - 1)\n    if pivot == -1:\n        return 0\n    return len(A) - pivot\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', toggle it to '0' and vice versa\n        if bit == '1':\n            result += '0'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # Find the smallest value in the array\n    smallest = min(arr)\n    \n    # Count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(s[i])\n        elif s[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    if N % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    i = 0\n    while (1 << i) <= n:\n        i += 1\n    return 1 << (i - 1)  # return the highest power of 2 less than or equal to n\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    list.insert(0, string)\n    return list\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create an empty dictionary\n    d = {}\n    # Iterate over the lists\n    for i in range(len(l1)):\n        # Create a new dictionary for each list\n        d[l1[i]] = {}\n        # Iterate over the lists again\n        for j in range(len(l2)):\n            # Create a new dictionary for each list\n            d[l1[i]][l2[j]] = {}\n            # Iterate over the lists again\n            for k in range(len(l3)):\n                # Add the value to the dictionary\n                d[l1[i]][l2[j]][l3[k]] = l3[k]\n    return d\n"}
{"task_id": "MBPP/392", "completion": "\n    if n == 0:\n        return 0\n    else:\n        return max((n // 2) + get_max_sum(n // 3) + get_max_sum(n - 1), n)\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return sum(int(digit) for num in nums for digit in str(num))  # <--- changed here\n\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tu in test_list:\n        if tu in freq_dict:\n            freq_dict[tu] += 1\n        else:\n            freq_dict[tu] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the elements are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function to add the nested tuples\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If the elements are not tuples, add them directly\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if r == 1:\n        return n\n    p = p % (n + 1)\n    res = 1\n    for i in range(1, r + 1):\n        res = (res * (n - i + 1)) % p\n    return res\n"}
{"task_id": "MBPP/403", "completion": "\n    url_pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(url_pattern.match(str))\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    i = len(n) - 1\n    while i > 0 and n[i - 1] >= n[i]:\n        i -= 1\n    if i <= 0:\n        return -1\n    j = len(n) - 1\n    while n[j] <= n[i - 1]:\n        j -= 1\n    n = list(n)\n    n[i - 1], n[j] = n[j], n[i - 1]\n    n[i : ] = n[len(n) - 1 : i - 1 : -1]\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            # Push the pair into the heap\n            heapq.heappush(min_heap, (num1 + num2, num1, num2))\n            # If the heap size is larger than k, pop the largest pair\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n    # Get the k smallest pairs from the heap\n    return [(-pair[0], pair[1], pair[2]) for pair in min_heap]\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize minimum product as infinity\n    min_product = float('inf')\n    \n    # Iterate over the list to find the minimum product\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            # Calculate the product of the current pair\n            product = list1[i] * list1[j]\n            \n            # Update the minimum product if the current product is smaller\n            if product < min_product:\n                min_product = product\n                \n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the string\n    words = re.findall(r'\\w+', word)\n    # Use list comprehension to capitalize the first letter of each word\n    # except the first word\n    camel_case = [words[0]] + [word.capitalize() for word in words[1:]]\n    # Join the words together\n    return ''.join(camel_case)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    return result\n"}
{"task_id": "MBPP/416", "completion": "\n    if n < 3:\n        return 0\n    if n == 3:\n        return 1\n    if n == 4:\n        return 3\n    if n == 5:\n        return 8\n    if n == 6:\n        return 13\n    if n == 7:\n        return 24\n    if n == 8:\n        return 40\n    if n == 9:\n        return 64\n    if n == 10:\n        return 104\n    if n == 11:\n        return 169\n    if n == 12:\n        return 274\n    if n == 13:\n        return 441\n    if n == 14:\n        return 713\n    if n == 15:\n        return 1144\n    if n == 16:\n        return 1849\n    if n == 17:\n        return 2984\n    if n == 18:\n        return 4837\n    if n == 19:\n        return 7841\n    if n == 20:\n        return 12724\n    if n == 21:\n        return 20565\n    if n == 22:\n        return 33189\n    if n == 23:\n        return 53674\n    if n == 24:\n        return 86963\n    if n == 25:\n        return 141237\n    if n == 26:\n        return 228800\n    if n == 27:\n        return 371639\n    if n == 28:\n        return 602439\n    if n == 29:\n        return 977880\n    if n == 30:\n        return 1582419\n    if n == 31:\n        return 2562400\n    if n == 32:\n        return 4144819\n    if n == 33:\n        return 6697220\n    if n == 34:\n        return 10842040\n    if n == 35:\n        return 17619260\n    if n == 36:\n        return 28541320\n    if n == 37:\n        return 46280680\n    if n == 38:\n        return 75132000\n    if n == 39:\n        return 121763180\n    if n == 40:\n        return 197395460\n    if n == 41:\n"}
{"task_id": "MBPP/417", "completion": "\n    return [list(x) for x in set(tuple(x) for x in Input)]\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(rounded_list))\n    return total_sum * len(rounded_list)\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum(i**3 for i in range(2, n+2, 2))\n"}
{"task_id": "MBPP/421", "completion": "\n    return delim.join(map(str, test_tup))\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    # Loop through first n natural numbers\n    for i in range(1, n + 1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill in the rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum gold that can be collected at this cell is the maximum of the gold that can be collected from the cell above, the cell to the left, and the cell diagonally above and to the left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple(string[-1] for string in test_tuple)\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to find all occurrences of yyymm in the string\n    dates = re.findall(r'\\d{6}', dt)\n    \n    # Looping over each date found\n    for date in dates:\n        # Converting the date from yyymm to dd-mmyy format\n        new_date = date[:2] + '-' + date[2:4] + '-' + date[4:]\n        \n        # Replacing the old date with the new date in the string\n        dt = dt.replace(date, new_date)\n    \n    # Returning the modified string\n    return dt\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Extract the elements from the tuples\n    tup1_elements = test_tup1\n    tup2_elements = test_tup2\n\n    # Use zip to pair up the elements from the two tuples\n    paired_elements = list(zip(tup1_elements, tup2_elements))\n\n    # Use a list comprehension to extract the first element from each pair\n    first_elements = [pair[0] for pair in paired_elements]\n\n    # Use a list comprehension to extract the second element from each pair\n    second_elements = [pair[1] for pair in paired_elements]\n\n    # Return the extracted elements\n    return first_elements, second_elements\n"}
{"task_id": "MBPP/430", "completion": "\n    # Directrix is a horizontal line y = -1/(4a)\n    return -1/(4*a)\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > i for i in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b*)\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(0)\n    else:\n        return None\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return sum(L)\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a list of adverbs\n    adverbs = [\"quickly\", \"slowly\", \"loudly\", \"wisely\", \"happily\", \"sadly\", \"carefully\", \"patiently\", \"gently\", \"strongly\"]\n    # Initialize an empty list to store the positions of adverbs\n    adverb_positions = []\n    # Iterate over the adverbs\n    for adverb in adverbs:\n        # Use regular expression to find the adverb in the text\n        match = re.search(r'\\b' + re.escape(adverb) + r'\\b', text)\n        # If the adverb is found, add its position to the list\n        if match:\n            adverb_positions.append((match.start(), match.end()))\n    # Return the list of adverb positions\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values indicating whether each number is positive\n    positive = array('b', [num > 0 for num in nums])\n    \n    # Count the number of True values (i.e., the number of positive numbers)\n    count = positive.count(True)\n    \n    # Return the ratio of positive numbers to the total number of numbers\n    return count / len(nums)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    return max([num for num in list1 if num < 0])\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][j] for j in range(len(test_list[i])-K, len(test_list[i]))) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n    # Convert the list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Return the count of each element\n    return count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    else:\n        a, b = 2, 5\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    # Use regular expression to find words containing 'z'\n    pattern = r'\\b\\w*z\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    # Using regex to find all upper case substrings\n    upper_case = re.findall(r'[A-Z]+', str1)\n    \n    # Removing upper case substrings from the string\n    str1 = re.sub(r'[A-Z]+', '', str1)\n    \n    return str1, upper_case\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    if high == low:\n        return low\n\n    mid = (low + high) // 2\n\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    return mid\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    if n == 0:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, n):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, price[i] - price[i - 1]) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    return [test_tup[i] + test_tup[i+1] for i in range(len(test_tup)-1)]\n\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result as 1\n    result = 1\n    # Multiply all elements in the array\n    for i in range(lens):\n        result = (result * arr[i]) % n\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] == 1:\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    max_char = max(char_count, key=char_count.get)\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if len(set) == 0 or sum < 0:\n        return False\n    return is_subset_sum(set[1:], n, sum - set[0]) or is_subset_sum(set[1:], n, sum)\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    i = 1\n    while True:\n        fact = 1\n        for j in range(1, i + 1):\n            fact *= j\n            if fact % x == 0:\n                return i\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Remove the intersection from the first set\n    set1 -= intersection\n    \n    # Convert the set back to a list and return it\n    return list(set1)\n"}
{"task_id": "MBPP/485", "completion": "\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = 0\n    for i in range(n):\n        for j in range(i, n):\n            num = int(str(n[i]) + str(n[j]))\n            if is_palindrome(num) and num > max_palindrome:\n                max_palindrome = num\n    return max_palindrome\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n:\n        return 0\n    elif r == 0 or r == n:\n        return 1\n    else:\n        return nCr(n - 1, r - 1) + nCr(n - 1, r)\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Count the frequency of the maximum value\n    frequency = arr.count(max_val)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid of hexagons\n    grid = [[None for _ in range(num_hexagons_x)] for _ in range(num_hexagons_y)]\n\n    # Calculate the coordinates of each hexagon\n    for y in range(num_hexagons_y):\n        for x in range(num_hexagons_x):\n            # Calculate the center of the hexagon\n            center_x = startx + x * 2 * radius\n            center_y = starty + y * 2 * radius\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = center_x + math.cos(angle) * radius\n                point_y = center_y + math.sin(angle) * radius\n                points.append((point_x, point_y))\n\n            # Store the coordinates of the hexagon in the grid\n            grid[y][x] = points\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    return int(''.join(map(str, test_tup)), 2)\n\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate slant height\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate surface area\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    return x * y // math.gcd(x, y)\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return [sum(nums[i:i+2]) for i in range(len(nums)-1)]\n\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    elif k == 0 or k == n:\n        return 1\n    else:\n        return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    removewords_set = set(removewords)\n    \n    # Use a list comprehension to filter out the words to remove\n    result = [word for word in list1 if word not in removewords_set]\n    \n    return result\n"}
{"task_id": "MBPP/508", "completion": "\n    return l1 == sorted(l2) or l2 == sorted(l1)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_sum = 0\n    count = 0\n    odd = 1\n    while odd <= n:\n        odd_sum += odd\n        count += 1\n        odd += 2\n    return odd_sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product <= k:\n            count += 1\n    return count\n"}
