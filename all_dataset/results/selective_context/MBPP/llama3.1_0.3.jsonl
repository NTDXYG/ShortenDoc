{"task_id": "MBPP/11", "completion": "\n    s = s.replace(ch, '', 1)\n    return s\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum)\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the text into words\n    words = words.split()\n    # Count the frequency of each word\n    word_count = Counter(words)\n    # Get the most common word and its count\n    most_common_word = word_count.most_common(1)\n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (l * b * h) / 2\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'([a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'(\\w)([A-Z])', r'\\1_\\2', text).lower()\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string[1:]]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # Check if number is woodall number\n    if x == 1:\n        return True\n    elif x == 2:\n        return True\n    elif x == 3:\n        return True\n    else:\n        # Check if number is woodall number\n        n = 1\n        while True:\n            woodall_number = (n * 2^n) + 1\n            if woodall_number == x:\n                return True\n            elif woodall_number > x:\n                return False\n            n += 1\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i * n for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(i) for i in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n\nbinary = \"1010\""}
{"task_id": "MBPP/25", "completion": "\n    # Create a set to store unique elements\n    unique_elements = set(arr)\n    \n    # Initialize product as 1\n    product = 1\n    \n    # Iterate over each unique element\n    for element in unique_elements:\n        # If element is not repeated, multiply it with product\n        if arr.count(element) == 1:\n            product *= element\n    \n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    odd_count = 0\n    for i in range(arr_size):\n        if arr[i] % 2 != 0:\n            odd_count += 1\n    return odd_count\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.Counter(nums)\n    \n    # Create a heap to store the integers and their frequencies\n    heap = []\n    \n    # Push each integer and its frequency into the heap\n    for num, count in freq.items():\n        # Use a tuple to store the frequency and the integer, so that the heap is sorted by frequency\n        heapq.heappush(heap, (-count, num))\n    \n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        if heap:\n            top_k.append(heapq.heappop(heap)[1])\n    \n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    for i in range(N - 1):\n        if ar[i + 1] - ar[i] > 1:\n            return ar[i] + 1\n    return ar[-1] + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    count = 0\n    for i in range(1, n):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a string\n    fraction = str(p) + '/' + str(q)\n    # Split the fraction into numerator and denominator\n    numerator, denominator = fraction.split('/')\n    # Remove the leading zero from the numerator\n    numerator = numerator.lstrip('0')\n    # Find the Nth digit\n    Nth_digit = int(numerator[N-1])\n    return Nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    return sorted(mixed_list, key=lambda x: (isinstance(x, int), x))\n"}
{"task_id": "MBPP/38", "completion": "\n    even = []\n    odd = []\n    for i in list1:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return even, odd\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    res = []\n    while max_heap:\n        freq1, char1 = heapq.heappop(max_heap)\n        if res and res[-1][1] == char1:\n            if not max_heap:\n                return False\n            freq2, char2 = heapq.heappop(max_heap)\n            res.append((freq2, char2))\n            if freq2 < -1:\n                heapq.heappush(max_heap, (freq2 + 1, char2))\n        else:\n            res.append((freq1, char1))\n            if freq1 < -1:\n                heapq.heappush(max_heap, (freq1 + 1, char1))\n    return True\n\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = list(chain(*nums))\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"(\\w+)(\\s+and\\s+)(\\w+)\"\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1) + match.group(3)\n    else:\n        return text\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'\\b\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in range(1, len(x)):\n        result = gcd(result, x[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    fact_A = factorial(A)\n    fact_B = factorial(B)\n    last_digit_A = fact_A % 10\n    last_digit_B = fact_B % 10\n    if last_digit_A == 0:\n        return 0\n    else:\n        return last_digit_B // last_digit_A\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n >> 1\n"}
{"task_id": "MBPP/49", "completion": "\n    return [nums[i] for i in range(N) if i % 2 == 0]\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    return str[0] == str[-1]\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum element in the array\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrences of each element in the array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, max_element + 1):\n        count_array[i] += count_array[i - 1]\n    \n    # Create a sorted array\n    sorted_array = [0] * len(my_list)\n    \n    # Build the sorted array\n    for num in my_list:\n        sorted_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return sorted_array\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return n == 2 * rev(n) - 1\n    \"\"\"\n    \"\"\"\n    return n == 2 * rev(n) - 1\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    max_num = 0\n    for i in range(n):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n*(2*n-1) == 1\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [0] * n\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n):\n        if abs(arr[i] - arr[i - 1]) <= 1:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n    return dp[n - 1]\n"}
{"task_id": "MBPP/61", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize max_diff with negative infinity\n    max_diff = float('-inf')\n    \n    # Iterate over the list to find the maximum difference\n    for i in range(1, len(test_list)):\n        # Calculate the difference between current and previous element\n        diff = test_list[i] - test_list[i-1]\n        \n        # Update max_diff if current difference is greater\n        max_diff = max(max_diff, diff)\n    \n    # Return the maximum difference found\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x['marks'], reverse=True)\n\nsubjectmarks = [\n    {'name': 'John', 'marks': 90},\n    {'name': 'Emma', 'marks': 85},\n    {'name': 'Oliver', 'marks': 95},\n    {'name': 'Ava', 'marks': 80},\n    {'name': 'William', 'marks': 92}\n]\n"}
{"task_id": "MBPP/65", "completion": "\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return sum(bell_number(n - i) for i in range(n + 1))  # This is the recursive formula for Bell numbers\n\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    for i in range(n-1):\n        if A[i] > A[i+1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in (l[i: j] for i in range(len(l)) for j in range(i + 1, len(l) + 1))\n"}
{"task_id": "MBPP/70", "completion": "\n    return all(len(i) == k for i in Input)\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    else:\n        for i in range(int(n**0.5) + 1):\n            if (n - i**2) >= 0 and (n - i**2) % i == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/73", "completion": "\n    pattern = r'[.,;!?]'\n    return re.split(pattern, text)\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    return sum(int(digit) for digit in str(n) if int(digit) % 2 == 0)\n"}
{"task_id": "MBPP/78", "completion": "\n    # Initialize count of integers with odd set bits\n    count = 0\n    # Iterate over all possible integers\n    for i in range(1, n + 1):\n        # Convert integer to binary and remove '0b' prefix\n        binary = bin(i)[2:]\n        # Count the number of '1's in the binary representation\n        set_bits = binary.count('1')\n        # If the count of '1's is odd, increment the count\n        if set_bits % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return list(zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    sequence = [0, 1]\n    while len(sequence) < n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n\n"}
{"task_id": "MBPP/87", "completion": "\n    # Create a new dictionary to store the merged result\n    merged_dict = {}\n    \n    # Get all keys from the three dictionaries\n    keys = set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())\n    \n    # Iterate over the keys\n    for key in keys:\n        # If the key exists in all three dictionaries, add it to the merged dictionary\n        if key in dict1 and key in dict2 and key in dict3:\n            merged_dict[key] = (dict1[key], dict2[key], dict3[key])\n        # If the key exists in two dictionaries, add it to the merged dictionary\n        elif key in dict1 and key in dict2:\n            merged_dict[key] = (dict1[key], dict2[key])\n        elif key in dict1 and key in dict3:\n            merged_dict[key] = (dict1[key], dict3[key])\n        elif key in dict2 and key in dict3:\n            merged_dict[key] = (dict2[key], dict3[key])\n        # If the key only exists in one dictionary, add it to the merged dictionary\n        elif key in dict1:\n            merged_dict[key] = dict1[key]\n        elif key in dict2:\n            merged_dict[key] = dict2[key]\n        elif key in dict3:\n            merged_dict[key] = dict3[key]\n    \n    return merged_dict\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max([i for i in range(1, N) if i < N])\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to string to check each digit\n    str_n = str(n)\n    # Check if the number has at least 3 digits\n    if len(str_n) < 3:\n        return False\n    # Check if the number is undulating\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is greater than the next digit\n        if int(str_n[i]) > int(str_n[i + 1]):\n            # If the current digit is greater than the next digit, check if the next digit is greater than the digit after the next digit\n            if i < len(str_n) - 2 and int(str_n[i + 1]) > int(str_n[i + 2]):\n                continue\n            else:\n                return False\n        # Check if the current digit is less than the next digit\n        elif int(str_n[i]) < int(str_n[i + 1]):\n            # If the current digit is less than the next digit, check if the next digit is less than the digit after the next digit\n            if i < len(str_n) - 2 and int(str_n[i + 1]) < int(str_n[i + 2]):\n                continue\n            else:\n                return False\n        # If the current digit is equal to the next digit, return False\n        else:\n            return False\n    # If the function has not returned False, the number is undulating\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    return test_list.index(min(test_list))\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    min_length_sublist = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_length_sublist = sublist\n    return min_length_sublist\n"}
{"task_id": "MBPP/96", "completion": "\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('[_-]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if m == 1:\n        return 1\n    else:\n        return m * eulerian_num(n - 1, m) + eulerian_num(n - 1, m - 1)\n"}
{"task_id": "MBPP/104", "completion": "\n    return [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup = list(test_tup)\n    \n    # Add the two lists together\n    result = test_list + test_tup\n    \n    return result\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap\n    min_heap = []\n    # Push the first element of each list into the heap\n    heapq.heappush(min_heap, (num1[0], 0, num1))\n    heapq.heappush(min_heap, (num2[0], 0, num2))\n    heapq.heappush(min_heap, (num3[0], 0, num3))\n\n    # Initialize the result list\n    result = []\n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, idx, nums = heapq.heappop(min_heap)\n        # Add the popped element to the result list\n        result.append(val)\n        # If there are more elements in the list, push the next element into the heap\n        if idx + 1 < len(nums):\n            heapq.heappush(min_heap, (nums[idx + 1], idx + 1, nums))\n\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if s[i] == '1':\n            count += 1\n    return count % 2 == 1\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_list = []\n    for i in range(strt_val, stop_val):\n        if i not in test_list:\n            missing_list.append(i)\n    return missing_list\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if i:\n            return False\n    return True\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list if isinstance(i, (int, float))]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == arr[mid]:\n            return mid\n        elif mid > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i] * list1[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    left = 0\n    right = n - 1\n    while left < right:\n        current_sum = A[left] + A[right]\n        if current_sum == sum:\n            count += 1\n            left += 1\n            right -= 1\n        elif current_sum < sum:\n            left += 1\n        else:\n            right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    if n < 1:\n        return \"Input should be a positive integer\"\n    elif n == 1:\n        return 1\n    else:\n        return 2 * n - 1\n\n"}
{"task_id": "MBPP/123", "completion": "\n    amicable_numbers = []\n    for i in range(1, limit):\n        sum_divisors = sum_divisors(i)\n        if sum_divisors != i and sum_divisors < limit and sum_divisors != 0:\n            amicable_numbers.append(sum_divisors)\n    return sum(set(amicable_numbers + [i for i in amicable_numbers if i != 0]))\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    count = 0\n    max_count = 0\n    for i in range(n):\n        if string[i] == '1':\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 0\n    max_count = max(max_count, count)\n    return max_count\n"}
{"task_id": "MBPP/126", "completion": "\n    # Calculate the greatest common divisor (GCD) of a and b\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Calculate the sum of common divisors of a and b\n    def sum_common_divisors(a, b):\n        gcd_val = gcd(a, b)\n        sum_divisors = 0\n        for i in range(1, gcd_val + 1):\n            if gcd_val % i == 0:\n                sum_divisors += i\n        return sum_divisors\n\n    return sum_common_divisors(a, b)\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    for i in range(abs(y)):\n        result += abs(x)\n    if (x < 0 and y < 0) or (x > 0 and y > 0):\n        return result\n    else:\n        return -result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    n = len(my_matrix)\n    if n != len(my_matrix[0]):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum(my_matrix[i][::-1]):\n            return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum([my_matrix[j][i] for j in range(n)]):\n            return False\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each item\n    freq_dict = defaultdict(int)\n    for num in nums:\n        freq_dict[num] += 1\n\n    # Find the item with the maximum frequency\n    max_freq = max(freq_dict.values())\n    max_items = [item for item, freq in freq_dict.items() if freq == max_freq]\n\n    return max_items\n\n"}
{"task_id": "MBPP/131", "completion": "\n    # Define vowels\n    vowels = 'aeiouAEIOU'\n    # Convert string to list\n    str_list = list(str1)\n    # Find the first and last vowel in the string\n    first_vowel = next((i for i, letter in enumerate(str_list) if letter in vowels), None)\n    last_vowel = next((i for i, letter in enumerate(str_list[::-1]) if letter in vowels), None)\n    # If there are no vowels, return the original string\n    if first_vowel is None:\n        return str1\n    # Swap the first and last vowel\n    str_list[first_vowel], str_list[-last_vowel - 1] = str_list[-last_vowel - 1], str_list[first_vowel]\n    # Join the list back into a string\n    return ''.join(str_list)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    if n % 2 == 0:\n        return arr[-1] % 2 == 0\n    else:\n        for _ in range(p):\n            arr[-1] = arr[-1] * arr[-1]\n        return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units < 0:\n        return \"Invalid input\"\n    elif units <= 50:\n        return units * 0.5\n    elif units <= 150:\n        return 25 + (units - 50) * 0.75\n    elif units <= 300:\n        return 125 + (units - 150) * 1.2\n    else:\n        return 425 + (units - 300) * 1.5\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of integers with the given values\n    arr = array('i', nums)\n    \n    # Count the number of zeros in the array\n    zero_count = arr.count(0)\n    \n    # Calculate the ratio of zeros to the total number of elements\n    ratio = zero_count / len(arr)\n    \n    return ratio\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0's\n    return '0' not in binary\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Check if the tuple has only one element\n        if len(tup) == 1:\n            # If it does, append the element to the result list\n            result.append(tup[0])\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/141", "completion": "\n    def reverse(nums, start, end):\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n\n    def max_element_index(nums, start):\n        max_idx = start\n        for i in range(start + 1, len(nums)):\n            if nums[i] > nums[max_idx]:\n                max_idx = i\n        return max_idx\n\n    for size in range(len(nums), 0, -1):\n        max_idx = max_element_index(nums, 0)\n        reverse(nums, 0, max_idx)\n        reverse(nums, 0, size - 1)\n\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for same pairs\n    count = 0\n    # Iterate over the first list\n    for i in range(len(list1)):\n        # Iterate over the second list\n        for j in range(len(list2)):\n            # Check if the pair is the same in the third list\n            if (list1[i], list2[j]) in list3:\n                # If the pair is the same, increment the counter\n                count += 1\n    # Return the count of same pairs\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    lists = []\n    for item in Input:\n        if isinstance(item, list):\n            lists.append(item)\n    return lists\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_diff += abs(arr[i] - arr[j])\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    arr.sort()\n    max_diff = arr[n - 1] - arr[0]\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(c) for c in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m-2, -1, -1):\n        for j in range(n-1):\n            tri[i][j] += max(tri[i+1][j], tri[i+1][j+1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    if x < 10:\n        return x\n    else:\n        return max(x % 10 + sum_digits_single(x // 10), sum_digits_single(x // 10))\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    elif a > b:\n        return False\n    else:\n        return does_Contain_B(a + c, b, c)\n\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1: return x else: mid = len(x) // 2 left = merge_sort(x[:mid]) right = merge_sort(x[mid:]) return merge(left, right) "}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    specified = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                specified.append(nums[i][j])\n    return specified\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '0', append '1' to the result\n        if bit == '0':\n            result += '1'\n        # If the bit is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    min_ops = 0\n    for i in range(n):\n        if arr[i] != arr[0]:\n            min_ops += (arr[i] - arr[0]) // k + 1\n    return min_ops\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return -1\n    else:\n        return x * (n // gcd) % (b // gcd)\n"}
{"task_id": "MBPP/161", "completion": "\n    return [value for value in list1 if value not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    total = 0\n    x = 1\n    while n - x >= 0:\n        total += n - x\n        x += 2\n    return total\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s**2) * tan(pi / l) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_div = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_div += i\n    return sum_div\n\n"}
{"task_id": "MBPP/165", "completion": "\n    # Initialize a dictionary to store the count of characters at each position\n    char_count = {}\n    \n    # Iterate over the string\n    for i in range(len(str1)):\n        # Get the character at the current position\n        char = str1[i]\n        \n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Return the dictionary\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Return the dictionary with the count of each character\n    return char_count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'[^a-zA-Z0-9\\s]', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if lcm(L[i], L[j]) in R:\n                return [L[i], L[j]]\n    return None\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    num = x\n    sum = 0\n    while num > 0:\n        sum += num % 10\n        num //= 10\n    return is_prime(sum) and is_prime(x) and x != sum\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n    return 6371 * c\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Regular expression to find 'u', special character and numeric values\n    pattern = r\"[u\\W\\d]\"\n    \n    # Find all matches of the pattern in the string\n    matches = re.findall(pattern, string)\n    \n    return matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    # Create a dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize a variable to store the count of pairs\n    count = 0\n\n    # Iterate over the frequency dictionary\n    for num in freq:\n        # Check if the difference between the current number and k is present in the dictionary\n        if num - k in freq and num + k in freq:\n            # If the difference is present, increment the count by the product of their frequencies\n            count += freq[num] * freq[num - k] * freq[num + k]\n\n    # Return the count of pairs\n    return count // 2  # Divide by 2 to avoid counting each pair twice\n\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus point\n    focus_point = (c / (4 * a), 0)\n    \n    return focus_point\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequence of substrings.\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index + 1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character is part of LCS\n        if X[i - 1] == Y[j - 1]:\n            lcs[index - 1] = X[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    elif n == 0 or n == 1:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if n % (i * i) == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers\n    num_set = set()\n    \n    # Iterate over the array and add the positive numbers to the set\n    for num in arr:\n        if 1 <= num <= n:\n            num_set.add(num)\n    \n    # Iterate from 1 to n and return the first missing positive number\n    for i in range(1, n + 1):\n        if i not in num_set:\n            return i\n    \n    # If all numbers from 1 to n are present in the set, return n + 1\n    return n + 1\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points inside the square\n    count = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if len(str) < 2:\n        return False\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n    return has_letter and has_number\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [i for i in test_list if len(i) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    return test_tup1[0]**test_tup2[0]\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major axis\n    a = a / 2\n    # Calculate the semi-minor axis\n    b = b / 2\n    # Calculate the area of the ellipse\n    area = math.pi * a * b\n    # Calculate the radius of the inscribed circle\n    r = (a * b) / (a + b)\n    # Calculate the area of the inscribed circle\n    circle_area = math.pi * r ** 2\n    # Calculate the area of the largest triangle\n    triangle_area = area - circle_area\n    return triangle_area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (n > 1):\n        n = n // 2\n        i += 1\n    return 2 ** i\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    inversions = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i] > test_tup[j]:\n                inversions.append((test_tup[i], test_tup[j]))\n    return inversions\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for i in range(len(test_tup)):\n        if i == 0:\n            result.append(test_tup[i])\n        elif i == len(test_tup) - 1:\n            result.append(test_tup[i])\n        else:\n            result.append(test_tup[i] + test_tup[i - 1])\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    max_length = 0\n    for gap in range(1, n):\n        for i in range(n - gap):\n            j = i + gap\n            if str[i] == str[j] and gap == 1:\n                dp[i][j] = 1\n                max_length = 1\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n    return max_length\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(n):\n        if (i & (i - 1)) == 0 and (i & n) != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([i**4 for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return ''.join(test_tup1) + ''.join(test_tup2)\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    return set(list1).issubset(set(list2))\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    # Calculate the minimum number of operations required\n    min_operations = math.ceil(diff / 2)\n    return min_operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Extract the maximum element from the tuple\n    max_val = max(test_tup)\n    \n    # Extract the kth maximum element from the tuple\n    kth_max_val = sorted(test_tup, reverse=True)[K-1]\n    \n    return max_val, kth_max_val\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, and dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n\n    # Replace the first n occurrences with a colon\n    for i in range(n):\n        text = text.replace(matches[i], ':', 1)\n\n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if len(test_tuple) == 0:\n        return True\n    else:\n        return all(isinstance(x, type(test_tuple[0])) for x in test_tuple)\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count of given element\n    count = 0\n    # Traverse through the array\n    for i in range(n):\n        # If element is equal to x, increment count\n        if arr[i] == x:\n            count += 1\n        # If element is not equal to x, decrement count\n        else:\n            count -= 1\n        # If count becomes zero, reset count to 1\n        if count == 0:\n            count = 1\n    # Return True if count is not zero, else return False\n    return count != 0\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return arr[mid + 1]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    if arr[low] >= arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Check if the range is valid\n    if l < 0 or r >= n:\n        return False\n\n    # Calculate the number of bits in the range\n    num_bits = r - l + 1\n\n    # Calculate the number of bits that can be set in the range\n    max_set_bits = n - (n - r - 1)\n\n    # Check if all bits in the range are set\n    return num_bits == max_set_bits\n"}
{"task_id": "MBPP/229", "completion": "\n    return sorted(arr, key=lambda x: (x < 0, x))\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Create a 2D list to store the maximum sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of dp\n    for i in range(n):\n        dp[0][i] = tri[0][i]\n        dp[i][0] = tri[i][0]\n    \n    # Fill the dp table in a bottom-up manner\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum at position (i, j) is the maximum of the sum of the current number and the maximum sum of the two numbers above it\n            dp[i][j] = tri[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # The maximum sum in the triangle is stored in the bottom-right corner of the dp table\n    return dp[n-1][n-1]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n | n & -n\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of equilateral triangles that can be formed\n    return N * (N - 1) * (N - 2) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(test_list)\n    # Find the maximum count\n    max_count = max(record_count.values())\n    # Find the records with the maximum count\n    max_count_records = [record for record, count in record_count.items() if count == max_count]\n    return max_count_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1\n"}
{"task_id": "MBPP/239", "completion": "\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if j <= m and j >= dp[i - 1]:\n                dp[i] += 1\n            if j <= m and j >= 2 * dp[i - 1]:\n                dp[i] += 1\n    return dp[n] - 1  # subtract 1 because we don't want to count the empty sequence\n\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: (x[0], lst.count(x[0])))\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.sqrt(N)\n    next_root = math.ceil(root)\n    return next_root ** 2\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Create a table to store results of subproblems\n    table = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table in a bottom-up manner\n    for gap in range(n):\n        for i in range(n - gap):\n            j = i + gap\n            if gap == 0:\n                table[i][j] = arr[i]\n            elif gap == 1:\n                table[i][j] = max(arr[i], arr[j])\n            else:\n                # Find maximum sum of sub-sequence with gap 1\n                max_sum_with_gap_1 = max(table[i + 1][j - 1], table[i][j - 1], table[i + 1][j])\n                # Find maximum sum of sub-sequence with gap 2\n                max_sum_with_gap_2 = max(table[i + 2][j - 1], table[i + 1][j - 2], table[i + 2][j - 2])\n                # Update table[i][j] with maximum of max_sum_with_gap_1 and max_sum_with_gap_2\n                table[i][j] = max(max_sum_with_gap_1, max_sum_with_gap_2)\n    \n    # Return the maximum sum of bitonic sub-sequence\n    return table[0][n - 1]\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    elif number == 0 or number == 1:\n        return number\n    else:\n        guess = number\n        while True:\n            better_guess = (guess + number / guess) / 2\n            if abs(guess - better_guess) < 0.000001:\n                return better_guess\n            guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    if n == 0:\n        return \"\"\n    elif n == 1:\n        return str\n    elif n == 2:\n        if str[0] == str[1]:\n            return str[0:2]\n        else:\n            return str[0:1]\n    else:\n        table = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            table[i][i] = 1\n        for i in range(n - 1):\n            if str[i] == str[i + 1]:\n                table[i][i + 1] = 2\n            else:\n                table[i][i + 1] = 0\n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if str[i] == str[j] and table[i + 1][j - 1] == length - 2:\n                    table[i][j] = length\n                else:\n                    table[i][j] = max(table[i][j - 1], table[i + 1][j])\n        return str[table[0][n - 1] // 2:table[0][n - 1] // 2 + table[0][n - 1] // 2] if table[0][n - 1] % 2 == 0 else str[table[0][n - 1] // 2:table[0][n - 1] // 2 + table[0][n - 1] // 2 + 1]  # return the longest palindromic substring\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(set(array_nums1) & set(array_nums2))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    new_list = []\n    for i in list:\n        new_list.append(i)\n        new_list.append(element)\n    return new_list\n"}
{"task_id": "MBPP/252", "completion": "\n    return [cmath.polar(num) for num in numbers]\n\n\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    # Use regular expression to find all words starting with 'a' or 'ore'\n    pattern = r'\\b(a|ore)\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum of the two maximum elements\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes[-n:]  # return the last n primes\n\n"}
{"task_id": "MBPP/261", "completion": "\n    return tuple(i / j for i, j in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # Calculate dog age\n    d_age = h_age * 7\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum(i**2 for i in range(1, n*2, 2))\n"}
{"task_id": "MBPP/268", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if arr[i] % 2 == 0 and i % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    return sum([i**5 for i in range(2, n+1, 2)])\n"}
{"task_id": "MBPP/272", "completion": "\n    return test_list[-1]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a[n] + m) % (n + 1)\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return len([i for i in test_tup if i == test_tup[0]])\n\n"}
{"task_id": "MBPP/279", "completion": "\n    return n*(2*n-1) == 1\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    n = str(n)\n    for i in range(10):\n        count = n.count(str(i))\n        if count != i:\n            return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(isinstance(item, str) for item in list) and all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize variables\n    max_sum = float('-inf')\n    current_sum = 0\n    window_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add current element to window sum\n        window_sum += a[i]\n\n        # If window size is greater than k, remove first element from window sum\n        if i >= k:\n            window_sum -= a[i - k]\n\n        # Update current sum\n        current_sum = max(current_sum, window_sum)\n\n        # Update max sum\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum([i**2 for i in range(2, n+1, 2)])\n"}
{"task_id": "MBPP/288", "completion": "\n    mod = P\n    res = []\n    for i in arr:\n        if pow(i, mod - 2, mod) == i:\n            res.append(i)\n    return res\n"}
{"task_id": "MBPP/289", "completion": "\n    return N//2\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = 0\n    max_lists = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_lists = [lst]\n        elif len(lst) == max_len:\n            max_lists.append(lst)\n    return max_lists\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from 3 to n\n    for i in range(3, n + 1):\n        # The number of ways to paint the current post is the sum of the number of ways to paint the previous two posts\n        ways[i] = ways[i - 1] + ways[i - 2] * (k - 1)\n\n    # Return the number of ways to paint the last post\n    return ways[n]\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [i for i in range(1, number) if number % i == 0]\n    return sum(divisors)\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for i in l1:\n        if isinstance(i, list):\n            for j in i:\n                if j in l2:\n                    result.append(j)\n        else:\n            if i in l2:\n                result.append(i)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_aggregates = defaultdict(int)\n    \n    # Iterate over the list of tuples\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_aggregates[num] = max(max_aggregates[num], aggregate)\n    \n    # Return the maximum aggregate for each number\n    return max_aggregates\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return 2 * count_binary_seq(n - 1)\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    return n.bit_length() - 1\n"}
{"task_id": "MBPP/303", "completion": "\n    inversion_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversion_count += 1\n    return inversion_count\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Check if the index is within the range of the array\n    if index < 0 or index >= len(arr):\n        return None\n\n    # Check if the index is within the range of the rotated array\n    if index < rotations:\n        return arr[index]\n\n    # Calculate the new index after rotation\n    new_index = index - rotations\n\n    # Check if the new index is within the range of the array\n    if new_index < 0:\n        new_index += len(arr)\n\n    # Return the element at the new index\n    return arr[new_index]\n\n"}
{"task_id": "MBPP/305", "completion": "\n    return [word for word in words if word.startswith('p')]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == 0:\n        return a[0]\n    elif index == n:\n        return 0\n    else:\n        # Recursive call for including the current element\n        include = a[index] + max_sum_increasing_subseq(a, n, index - 1, k)\n        # Recursive call for excluding the current element\n        exclude = max_sum_increasing_subseq(a, n, index - 1, k)\n        # Return the maximum of the two values\n        return max(include, exclude)\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort the lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize the result list\n    result = []\n\n    # Iterate over the lists\n    for i in range(N):\n        # Calculate the product of the current elements\n        product = nums1[i] * nums2[i]\n\n        # Append the product to the result list\n        result.append(product)\n\n    # Sort the result list in descending order\n    result.sort(reverse=True)\n\n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n\n    return max(dp[0][n-1], dp[1][n-1])  # return max of last row\n\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    encoded = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        encoded.append((key, count))\n    return encoded\n\n"}
{"task_id": "MBPP/318", "completion": "\n    a, b, c = map(int, s.split('+'))\n    return max(a*b, b*c, c*a)  # return max volume of cuboid\n"}
{"task_id": "MBPP/319", "completion": "\n    pattern = r'\\b\\w{5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n\ntext = \"Hello, my name is John. I am 25 years old. I am from New York.\""}
{"task_id": "MBPP/320", "completion": "\n    sum_natural = n * (n + 1) // 2\n    sum_squared = n * (n + 1) * (2 * n + 1) // 6\n    return sum_natural ** 2 - sum_squared\n"}
{"task_id": "MBPP/321", "completion": "\n    # Convert the number to string\n    s = str(s)\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through each character in the string\n    for i in range(len(s)):\n        # Add the value of the character to the demlo number\n        demlo += int(s[i]) * (10 ** (len(s) - i - 1))\n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        arr = arr[::-1]\n\n    for i in range(n):\n        if i % 2 == 0:\n            arr[i], arr[n - i - 1] = arr[n - i - 1], arr[i]\n    return arr\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[i] for i in range(0, len(test_tuple), 2))\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number up to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current number is greater than or equal to the square\n            if i >= j ** 2:\n                # Update the minimum number of squares for the current number\n                min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word_count[word] += 1\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return most_common_words\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles\")\n    else:\n        print(\"The triangle is not isosceles\")\n"}
{"task_id": "MBPP/328", "completion": "\n    n = n % len(list1)\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return list.count(-1)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,4}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if all sides are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    # Check if the sum of the lengths of any two sides is greater than or equal to the length of the third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    return True\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n/2) * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b'\n    return re.search(pattern, text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    divisors = []\n    for i in range(1, y+1):\n        if x % i == 0:\n            divisors.append(i)\n    return max(set(divisors), key=divisors.count)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we filter out non-positive numbers from the list\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Then, we sort the list of positive numbers in ascending order\n    positive_nums.sort()\n    \n    # Finally, we return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])  # We use list slicing to get the first three elements of the sorted list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_val = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_val = max(max_val, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if -max_heap[0].value < min_range:\n            min_range = -max_heap[0].value - node.value\n        if node.index + 1 < len(list[node.list_num]):\n            next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n            heappush(min_heap, next_node)\n            heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n            max_val = max(max_val, -list[node.list_num][node.index + 1])\n        else:\n            break\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    num = 0\n    let = 0\n    for char in s:\n        if char.isdigit():\n            num += 1\n        elif char.isalpha():\n            let += 1\n    return num, let\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    if n == 9:\n        return 256\n    if n == 10:\n        return 512\n    if n == 11:\n        return 1024\n    if n == 12:\n        return 2048\n    if n == 13:\n        return 4096\n    if n == 14:\n        return 8192\n    if n == 15:\n        return 16384\n    if n == 16:\n        return 32768\n    if n == 17:\n        return 65536\n    if n == 18:\n        return 131072\n    if n == 19:\n        return 262144\n    if n == 20:\n        return 524288\n    if n == 21:\n        return 1048576\n    if n == 22:\n        return 2097152\n    if n == 23:\n        return 4194304\n    if n == 24:\n        return 8388608\n    if n == 25:\n        return 16777216\n    if n == 26:\n        return 33554432\n    if n == 27:\n        return 67108864\n    if n == 28:\n        return 134217728\n    if n == 29:\n        return 268435456\n    if n == 30:\n        return 536870912\n    if n == 31:\n        return 1073741824\n    if n == 32:\n        return 2147483648\n    if n == 33:\n        return 4294967296\n    if n == 34:\n        return 8589934592\n    if n == 35:\n        return 17179869184\n    if n == 36:\n        return 34359738368\n    if n == 37:\n        return 68719476736\n    if n == 38:\n        return 137438953472\n    if"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < 0:\n        return 0\n    if n == r:\n        return 1\n    if n > r:\n        return 0\n    return bin_coff(n - 1, r - 1) + bin_coff(n - 1, r - 1 + n)\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element that occurs k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [i[:n] + i[n+1:] for i in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    return 4 * (radius ** 2) / (2 * radius) ** 2\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - a - b\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = test_list[0]\n    for i in test_list:\n        if i > max_val:\n            max_val = i\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n\n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n\n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n\n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n):\n        carol = carol + i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the number with the maximum count\n    max_count = max(count_dict.values())\n    max_nums = [num for num, count in count_dict.items() if count == max_count]\n\n    return max_nums\n"}
{"task_id": "MBPP/363", "completion": "\n    return [i + K for i in test_list]\n"}
{"task_id": "MBPP/364", "completion": "\n    flips = 0\n    for i in range(1, len(ch)):\n        if ch[i] != ch[i - 1]:\n            flips += 1\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup for _ in range(N))\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))\n"}
{"task_id": "MBPP/371", "completion": "\n    A.sort()\n    for i in range(len(A)):\n        if A[i] != i + left_element:\n            return i + left_element\n    return len(A) + left_element\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return n + (m - n % m) % m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with the elements that occur only once\n    new_tup = []\n    for element in test_tup:\n        if count_dict[element] == 1:\n            new_tup.append(element)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 1:\n        return [test_list[-1]] + test_list[:-1]\n    else:\n        return test_list\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    # Initialize two empty lists\n    list1 = []\n    list2 = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append the current row and column to the lists\n            list1.append(i)\n            list2.append(j)\n    \n    # Return the two lists\n    return list1, list2\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    low = 0\n    high = n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if A[mid] > A[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n"}
{"task_id": "MBPP/383", "completion": "\n    return n ^ (n & (n - 1))\n"}
{"task_id": "MBPP/384", "completion": "\n    # Find the smallest value in the array\n    smallest = min(arr)\n    \n    # Count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b = 3, 0\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(s[i])\n        elif s[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    hex_num = hex(N)[2:]\n    if hex_num[-1] in ['0', '2', '4', '6', '8']:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return 2 ** (n.bit_length() - 1)\n"}
{"task_id": "MBPP/389", "completion": "\n    a, b = 2, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n"}
{"task_id": "MBPP/390", "completion": "\n    list.insert(0, string)\n    return list\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create a dictionary with keys from l1 and values as another dictionary\n    d = {k: {} for k in l1}\n    \n    # Iterate over l2 and l3 to populate the inner dictionary\n    for k1, k2 in zip(l2, l3):\n        for k in l1:\n            d[k][k1] = k2\n    \n    return d\n"}
{"task_id": "MBPP/392", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return max((get_max_sum(n-1) / 2) + get_max_sum(n-3), get_max_sum(n-2))\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return sum(int(digit) for num in nums for digit in str(num))  # <--- changed here\n\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for item in test_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Initialize an empty list to store the result of the current iteration\n        inner_result = []\n        \n        # Iterate over the elements of the current tuples in parallel using zip\n        for elem1, elem2 in zip(tup1, tup2):\n            # Add the elements and append the result to the inner result list\n            inner_result.append(elem1 + elem2)\n        \n        # Append the inner result list to the result list\n        result.append(tuple(inner_result))\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/402", "completion": "\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if r == 1:\n        return n\n    pwr = [1] * (n + 1)\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pwr[i] = (pwr[i - 1] * p) % p\n        fact[i] = (fact[i - 1] * i) % p\n        inv[i] = pow(fact[i], p - 2, p)\n    ans = 1\n    for i in range(r):\n        ans = (ans * (n - i)) % p\n        ans = (ans * inv[i + 1]) % p\n    return ans\n"}
{"task_id": "MBPP/403", "completion": "\n    url = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url.match(str)\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    for i in range(len(n) - 2, -1, -1):\n        if n[i] < n[i + 1]:\n            break\n    else:\n        return -1\n    for j in range(len(n) - 1, i, -1):\n        if n[j] > n[i]:\n            break\n    else:\n        return -1\n    n = list(n)\n    n[i], n[j] = n[j], n[i]\n    n[i + 1:] = sorted(n[i + 1:])\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    min_heap = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(min_heap, (num1 + num2, num1, num2))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n    return [pair[1:] for pair in min_heap]\n\n"}
{"task_id": "MBPP/409", "completion": "\n    min_product = float('inf')\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i] * list1[j]\n            if product < min_product:\n                min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'_([a-z])', lambda x: x.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/416", "completion": "\n    if n < 3:\n        return 0\n    if n == 3:\n        return 1\n    if n == 4:\n        return 3\n    if n == 5:\n        return 8\n    if n == 6:\n        return 13\n    if n == 7:\n        return 24\n    if n == 8:\n        return 44\n    if n == 9:\n        return 81\n    if n == 10:\n        return 149\n    if n == 11:\n        return 274\n    if n == 12:\n        return 504\n    if n == 13:\n        return 927\n    if n == 14:\n        return 1705\n    if n == 15:\n        return 3136\n    if n == 16:\n        return 5768\n    if n == 17:\n        return 10609\n    if n == 18:\n        return 19513\n    if n == 19:\n        return 35850\n    if n == 20:\n        return 66012\n    if n == 21:\n        return 121415\n    if n == 22:\n        return 223317\n    if n == 23:\n        return 410432\n    if n == 24:\n        return 752727\n    if n == 25:\n        return 1386000\n    if n == 26:\n        return 2540163\n    if n == 27:\n        return 4663276\n    if n == 28:\n        return 8575119\n    if n == 29:\n        return 15811542\n    if n == 30:\n        return 29117165\n    if n == 31:\n        return 53638788\n    if n == 32:\n        return 98656221\n    if n == 33:\n        return 182111344\n    if n == 34:\n        return 335673567\n    if n == 35:\n        return 618345910\n    if n == 36:\n        return 1141115223\n    if n == 37:\n        return 2104870836\n    if n == 38:\n        return 3869971609\n    if n == 39:\n        return 7114943212\n    if n == 40:\n        return 130"}
{"task_id": "MBPP/417", "completion": "\n    return [list(x) for x in set(tuple(sorted(x)) for x in Input)]\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    # Round every number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of the rounded numbers\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    return result\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum([i**3 for i in range(2, n+2, 2)])\n"}
{"task_id": "MBPP/421", "completion": "\n    return delim.join(map(str, test_tup))\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    # Loop through first n natural numbers\n    for i in range(1, n + 1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill in the rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum gold that can be collected at this cell is the maximum of the gold that can be collected from the cell above, the cell to the left, and the cell diagonally above and to the left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple([string[-1] for string in test_tuple])\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to find the pattern of the date\n    pattern = re.compile(r'(\\d{2})-(\\d{2})\\d{2}')\n    # Using the sub function to replace the pattern with the desired format\n    new_date = pattern.sub(r'\\2-\\1\\3', dt)\n    return new_date\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Extract the elements of the tuples\n    tup1_elements = test_tup1\n    tup2_elements = test_tup2\n    \n    # Use zip to pair up the elements of the tuples\n    paired_elements = list(zip(tup1_elements, tup2_elements))\n    \n    # Use a list comprehension to extract the elements of the tuples\n    extracted_elements = [element for pair in paired_elements for element in pair]\n    \n    return extracted_elements\n"}
{"task_id": "MBPP/430", "completion": "\n    # Directrix is y = -1/(4a)\n    return -1/(4*a)\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > i for i in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return [i for i in L if i % 2 == 0]\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a regular expression pattern to match adverbs\n    pattern = r'\\b(quickly|slowly|well|badly|happily|sadly|wisely|carefully|loudly|silently|quietly|loud|soft|fast|slow|hard|easy|well|bad|good|great|excellent|wonderful|beautiful|ugly|awful|terrible|horrible|amazing|awesome|fantastic|superb|outstanding|exceptional|remarkable|impressive|incredible|unbelievable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable|unforgettable"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    return sum(1 for num in nums if num > 0)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    return max([num for num in list1 if num < 0])\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][:-K]) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over the two tuples in parallel using zip\n    for i in zip(test_tup1, test_tup2):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(i[0] * i[1])\n    # Convert the list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "MBPP/446", "completion": "\n    return Counter(tup) == Counter(lst)\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    else:\n        a, b = 2, 5\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return str[:l]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    # Use regular expression to find words containing 'z'\n    pattern = r'\\b\\w*z\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub(r'[A-Z]', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return low\n\n    # See if pivot is peak\n    pivot = (high + low) // 2\n\n    # If element just before pivot is smaller than pivot,\n    # then pivot could be peak\n    if (pivot == 0 or arr[pivot] >= arr[pivot - 1]) and \\\n       (pivot == n - 1 or arr[pivot] >= arr[pivot + 1]):\n        return pivot\n\n    # If element just before pivot is greater than pivot,\n    # then peak must be in left subarray\n    if arr[pivot] < arr[pivot - 1]:\n        return find_peak_util(arr, low, pivot - 1, n)\n\n    # If element just after pivot is greater than pivot,\n    # then peak must be in right subarray\n    return find_peak_util(arr, pivot + 1, high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    if n == 0:\n        return 0\n    max_product = float('-inf')\n    current_product = 1\n    for i in range(n):\n        if arr[i] == 0:\n            max_product = max(max_product, current_product)\n            current_product = 1\n        else:\n            current_product *= arr[i]\n    max_product = max(max_product, current_product)\n    return max_product\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, price[i] - price[i - 1]) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over the tuple\n    for i in range(len(test_tup)):\n        # Iterate over the tuple starting from the next index\n        for j in range(i + 1, len(test_tup)):\n            # Add the elements and append to the result list\n            result.append(test_tup[i] + test_tup[j])\n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Multiply all elements in the array\n    product = 1\n    for i in range(lens):\n        product *= arr[i]\n    \n    # Find the remainder of the product divided by n\n    remainder = product % n\n    \n    return remainder\n"}
{"task_id": "MBPP/472", "completion": "\n    if len(l) == 0:\n        return False\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] != 1:\n            return False\n    return True\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return sum(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    max_char = max(char_count, key=char_count.get)\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if sum < 0 or len(set) == 0:\n        return False\n    return is_subset_sum(set[1:], n, sum - set[0]) or is_subset_sum(set[1:], n, sum)\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/483", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    i = 1\n    while True:\n        if factorial(i) % x == 0:\n            return i\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Remove the intersection from the first set\n    set1 -= intersection\n    \n    # Convert the set back to a list and return it\n    return list(set1)\n"}
{"task_id": "MBPP/485", "completion": "\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = 0\n    for i in range(n-1, -1, -1):\n        for j in range(i, -1, -1):\n            num = int(str(i) + str(j) + str(i) + str(j))\n            if is_palindrome(num) and num > max_palindrome:\n                max_palindrome = num\n    return max_palindrome\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    else:\n        return nCr(n - 1, r - 1) + nCr(n - 1, r)\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    if n == 0:\n        return 0\n    max_val = max(arr)\n    return arr.count(max_val)\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if item_list[mid] == item:\n            return mid\n        elif item_list[mid] < item:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid of hexagons\n    grid = [[None for _ in range(num_hexagons_x)] for _ in range(num_hexagons_y)]\n\n    # Calculate the coordinates of each hexagon\n    for y in range(num_hexagons_y):\n        for x in range(num_hexagons_x):\n            # Calculate the center of the hexagon\n            center_x = startx + x * 2 * radius\n            center_y = starty + y * 2 * radius\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = center_x + math.cos(angle) * radius\n                point_y = center_y + math.sin(angle) * radius\n                points.append((point_x, point_y))\n\n            # Store the coordinates of the hexagon in the grid\n            grid[y][x] = points\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    return int(''.join(map(str, test_tup)), 2)\n"}
{"task_id": "MBPP/495", "completion": "\n    # Using regex to find all lowercase letters in the string\n    lower_case = re.findall(r'[a-z]', str1)\n    # Removing the lowercase letters from the string\n    str1 = re.sub(r'[a-z]', '', str1)\n    return str1, lower_case\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate slant height\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate surface area\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    return abs(x-y)\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return [sum(nums[i:i+2]) for i in range(len(nums)-1)]\n\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    return [word for word in list1 if word not in removewords]\n"}
{"task_id": "MBPP/508", "completion": "\n    return sorted(l1) == sorted(l2)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_sum = 0\n    count = 0\n    odd_num = 1\n    while odd_num <= n:\n        if odd_num % 2 != 0:\n            odd_sum += odd_num\n            count += 1\n        odd_num += 1\n    return odd_sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product <= k:\n            count += 1\n    return count\n"}
