{"task_id": "EvoEval/0", "completion": "\n    # Initialize the total cost to 0\n    total_cost = 0\n    \n    # Initialize the factor based on the location\n    if location == \"Local\":\n        factor = 1\n    elif location == \"National\":\n        factor = 1\n    elif location == \"International\":\n        factor = 2\n    else:\n        factor = 1\n    \n    # Iterate over each item in the list\n    for item in items:\n        # If the item is a string, consider its weight as 1kg\n        if isinstance(item, str):\n            weight = 1\n        # If the item is a float, use its value as the weight\n        else:\n            weight = item\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 50\n        \n        # If the item's weight is more than 5kg, add an additional charge\n        if weight > 5:\n            total_cost += 10\n        \n        # Multiply the total cost by the factor based on the location\n        total_cost *= factor\n    \n    # Return the total shipping cost rounded to two decimal places as a string\n    return \"{:.2f}\".format(total_cost)  # Use format() to round the number to two decimal places\n"}
{"task_id": "EvoEval/1", "completion": "\n    # Initialize the total cost to 0\n    total_cost = 0\n    \n    # Iterate over each item in the list\n    for item in items:\n        # Check if the item is a string\n        if isinstance(item, str):\n            # If the item is a string, consider its weight as 1kg\n            weight = 1\n        else:\n            # If the item is a float, use its value as the weight\n            weight = item\n        \n        # Check if the weight is more than 5kg\n        if weight > 5:\n            # If the weight is more than 5kg, add 10 to the total cost\n            total_cost += 10\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 50\n    \n    # Check the location and multiply the total cost by the corresponding factor\n    if location == \"Local\":\n        # For local location, no additional factor\n        pass\n    elif location == \"National\":\n        # For national location, multiply the total cost by 1\n        total_cost *= 1\n    elif location == \"International\":\n        # For international location, multiply the total cost by 2\n        total_cost *= 2\n    else:\n        # For other locations, no additional factor\n        pass\n    \n    # Return the total shipping cost rounded to two decimal places\n    return round(total_cost, 2)  # Changed to round() function\n"}
{"task_id": "EvoEval/2", "completion": "\n    # Convert the key to an integer if it's a string\n    if isinstance(key, str):\n        key = sum(ord(c) for c in key)\n    \n    # Initialize an empty list to store the encrypted words\n    encrypted_words = []\n    \n    # Iterate over each word in the input list\n    for word in words:\n        # Initialize an empty string to store the encrypted word\n        encrypted_word = \"\"\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is an alphabet letter\n            if char.isalpha():\n                # Find the ASCII value of 'a' or 'A' depending on the case of the character\n                ascii_offset = ord('a') if char.islower() else ord('A')\n                \n                # Calculate the new character by shifting the current character by the key value\n                new_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n                \n                # Add the new character to the encrypted word\n                encrypted_word += new_char\n            else:\n                # If the character is not a letter, add it to the encrypted word as is\n                encrypted_word += char\n        \n        # Add the encrypted word to the list of encrypted words\n        encrypted_words.append(encrypted_word)\n    \n    # Return the list of encrypted words\n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    # Convert the input string to a list of integers\n    digits = [int(d) for d in input_string]\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Define a recursive function to generate all combinations\n    def generate_combinations(current_combination, remaining_digits):\n        # If there are no remaining digits, add the current combination to the result\n        if not remaining_digits:\n            result.append(current_combination)\n            return\n        \n        # For each digit, generate combinations for the remaining digits\n        for i in range(1, remaining_digits[0] + 1):\n            # Add the current digit to the current combination\n            new_combination = current_combination + alphabet[i - 1]\n            \n            # Recursively generate combinations for the remaining digits\n            generate_combinations(new_combination, remaining_digits[1:])\n    \n    # Call the recursive function\n    generate_combinations('', digits)\n    \n    # Return the result\n    return result\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n\n    max_height = max(candles)\n    count = 0\n    for height in candles:\n        if height == max_height:\n            count += 1\n        elif height < max_height:\n            break\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    up, down = -1, 1\n\n    while left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[up][i])\n        up += down\n\n        for i in range(up, right + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if up > 0:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[up][i])\n            up -= down\n\n        if up < 0:\n            for i in range(up, left - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Get the x and y coordinates of the clicked cell\n    x, y = position\n    \n    # Check if the clicked cell is out of the grid\n    if x < 0 or x >= rows or y < 0 or y >= cols:\n        return grid\n    \n    # Check if the clicked cell is a mine\n    if grid[x][y] == 1:\n        return grid\n    \n    # Check if the clicked cell is already revealed\n    if grid[x][y] == 0:\n        return grid\n    \n    # Mark the clicked cell as revealed\n    grid[x][y] = 0\n    \n    # Check all adjacent cells (horizontally, vertically, and diagonally)\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            # Skip the current cell\n            if dx == 0 and dy == 0:\n                continue\n            \n            # Calculate the coordinates of the adjacent cell\n            nx, ny = x + dx, y + dy\n            \n            # Check if the adjacent cell is within the grid\n            if 0 <= nx < rows and 0 <= ny < cols:\n                # Check if the adjacent cell is a mine\n                if grid[nx][ny] == 1:\n                    # If it's a mine, don't change its value\n                    continue\n                \n                # If the adjacent cell is not a mine, recursively call the function\n                grid = minesweeper_clicked(grid, (nx, ny))\n    \n    # Return the updated grid\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize the current position as (0, 0)\n    current_position = [0, 0]\r\n    # Iterate over each direction in the code sequence\r\n    for direction in code_sequence:\r\n        # Update the current position based on the direction\r\n        if direction == 0:\r\n            current_position[0] += 1\r\n        elif direction == 1:\r\n            current_position[1] += 1\r\n        elif direction == 2:\r\n            current_position[0] -= 1\r\n        elif direction == 3:\r\n            current_position[1] -= 1\r\n        # If the current position is back at the starting point, return 'Shangri-La found'\r\n        if current_position == [0, 0]:\r\n            return 'Shangri-La found'\r\n    # If the function has iterated over the entire code sequence without returning, return 'Shangri-La not found'\r\n    return 'Shangri-La not found'  # Changed the return statement to match the problem description\r\n\r"}
{"task_id": "EvoEval/8", "completion": "\n    canvas = canvas.split('\\n')\n    rows = len(canvas)\n    cols = len(canvas[0])\n    painter = None\n    painted = set()\n    for i in range(rows):\n        for j in range(cols):\n            if canvas[i][j] == 'P':\n                painter = (i, j)\n                break\n        if painter:\n            break\n    if not painter:\n        return '\\n'.join(canvas)\n    queue = [painter]\n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) not in painted:\n            painted.add((x, y))\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and canvas[nx][ny] == '-':\n                    queue.append((nx, ny))\n    for i in range(rows):\n        for j in range(cols):\n            if canvas[i][j] == '-':\n                if (i, j) not in painted:\n                    canvas[i] = canvas[i][:j] + '*' + canvas[i][j+1:]\n    return '\\n'.join(canvas)\n    return 'Invalid canvas' if len(painted) % (rows * cols - len(painted)) == 0 else '\\n'.join(canvas) if len(painted) == rows * cols else 'Invalid canvas' if len(painted) > rows * cols else '\\n'.join(canvas) if painter not in painted else '\\n'.join(canvas) if len(painted) % (rows * cols - len(painted)) == 0 else 'Invalid canvas'"}
{"task_id": "EvoEval/9", "completion": "\n    # Remove punctuation and convert to lower case\n    string = ''.join(e for e in string if e.isalnum() or e.isspace()).lower()\n    \n    # Split the string into words\n    words = string.split()\n    \n    # Create a dictionary to store word frequencies\n    frequency = {}\n    \n    # Iterate over each word in the list\n    for word in words:\n        # If the word is already in the dictionary, increment its count\n        if word in frequency:\n            frequency[word] += 1\n        # Otherwise, add the word to the dictionary with a count of 1\n        else:\n            frequency[word] = 1\n    \n    # Return the dictionary of word frequencies\n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    # Initialize a dictionary to store the count of each animal\n    animal_count = {}\r\n    \r\n    # Split the input string into a list of animal-sound pairs\r\n    animal_pairs = animal_string.split()\r\n    \r\n    # Initialize a counter to keep track of the total number of animals\r\n    total_animals = 0\r\n    \r\n    # Iterate over each animal-sound pair\r\n    for pair in animal_pairs:\r\n        # Check if the pair is not empty\r\n        if pair:\r\n            # Extract the animal and sound from the pair\r\n            animal, sound = pair[0], pair[1:].count('|')\r\n            \r\n            # Check if the animal is valid and has not appeared twice before\r\n            if animal in ['C', 'D', 'B'] and animal not in animal_count or animal_count[animal] < 2:\r\n                # Increment the count of the animal in the dictionary\r\n                animal_count[animal] = animal_count.get(animal, 0) + 1\r\n                \r\n                # Increment the total number of animals\r\n                total_animals += 1\r\n                \r\n                # If the total number of animals has reached 5, break the loop\r\n                if total_animals == 5:\r\n                    break\r\n                    \r\n    # Return the counts of the animals as a list\r\n    return [animal_count.get('C', 0), animal_count.get('D', 0), animal_count.get('B', 0)]\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    if len(fruits) == 1:\n        return f\"Oh are those {fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"Oh are those {', '.join(fruits[:-1])} from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Find the maximum occurrence of an element in the list\n    max_occurrence = max(flux_values.count(x) for x in set(flux_values))\n    \n    # If there are multiple elements with the maximum occurrence, select the smallest one\n    most_occurred = min(x for x in set(flux_values) if flux_values.count(x) == max_occurrence)\n    \n    # Find the sum of all elements in the list\n    total_sum = sum(flux_values)\n    \n    # Multiply the sum of elements with the most occurred number\n    energy_signature = total_sum * most_occurred\n    \n    return energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for elem in elems:\n        # If the element is already in the dictionary, increment its count\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[elem] = 1\n\n    # Find the minimum frequency\n    min_freq = min(freq_dict.values())\n\n    # Find the first element with the minimum frequency\n    rarest_elem = next((elem for elem, freq in freq_dict.items() if freq == min_freq), None)\n\n    return rarest_elem\n"}
{"task_id": "EvoEval/14", "completion": "\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                if alias and alias[-1].lower() in 'aeiou':\n                    alias += 'u' if alias[-1].lower() == 'o' else 'a' if alias[-1].lower() == 'e' else 'i' if alias[-1].lower() == 'a' else 'o'\n                else:\n                    alias += 'a' if char.islower() else 'A'\n            else:\n                if char.lower() == 'z':\n                    alias += 'b'\n                else:\n                    alias += chr(ord(char) + 1)\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Create a dictionary to store the count of each card value\n    card_count = {}\n    for card in hand:\n        value = card[0]\n        if value in card_count:\n            card_count[value] += 1\n        else:\n            card_count[value] = 1\n\n    # Initialize the score\n    score = 0\n\n    # Check for pairs\n    for value, count in card_count.items():\n        if count == 2:\n            score += int(value)\n\n    # Check for triples\n    for value, count in card_count.items():\n        if count == 3:\n            score += int(value) * 2\n\n    # Check for four of a kind\n    for value, count in card_count.items():\n        if count == 4:\n            score += int(value) * 3\n\n    # Check for five of a kind\n    for value, count in card_count.items():\n        if count == 5:\n            score += int(value) * 4\n\n    return score"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return \"Input should be a positive integer\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        while len(fib_sequence) < n:\n            fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n        return sum(fib_sequence)\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard, magic in wizards:\n        dragon_hp -= magic\n        if dragon_hp <= 0:\n            return wizard\n    return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    i = 1\n    while True:\n        if i % 7 == 0 and sum(int(digit) for digit in str(i)) == 7:\n            return i\n        i += 1\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize a variable to store the number of humans in danger\n    humans_in_danger = 0\n\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a vampire (2), increment the humans_in_danger counter\n            if cell == 2:\n                # Increment the humans_in_danger counter by the number of humans in the same row\n                humans_in_danger += row.count(1)\n                # Increment the humans_in_danger counter by the number of humans in the same column\n                humans_in_danger += sum(1 for r in m if 1 in r and m.index(r) != m.index(row))\n\n    # Return the total number of humans in danger\n    return humans_in_danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join(map(str, range(i, 0, -1))))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Get the size of the grid\n    n = len(grid)\n    \n    # Define the directions to search for words\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Function to check if a word can be found in the grid\n    def can_find_word(word, x, y, direction):\n        # Check if the word can be found in the grid\n        for i, char in enumerate(word):\n            if direction == 0:  # left to right\n                if x + i >= n or grid[x + i][y] != char:\n                    return False\n            elif direction == 1:  # right to left\n                if x - i < 0 or grid[x - i][y] != char:\n                    return False\n            elif direction == 2:  # top to bottom\n                if y + i >= n or grid[x][y + i] != char:\n                    return False\n            elif direction == 3:  # bottom to top\n                if y - i < 0 or grid[x][y - i] != char:\n                    return False\n            elif direction == 4:  # top left to bottom right\n                if x + i >= n or y + i >= n or grid[x + i][y + i] != char:\n                    return False\n            elif direction == 5:  # bottom left to top right\n                if x - i < 0 or y + i >= n or grid[x - i][y + i] != char:\n                    return False\n            elif direction == 6:  # top right to bottom left\n                if x + i >= n or y - i < 0 or grid[x + i][y - i] != char:\n                    return False\n            elif direction == 7:  # bottom right to top left\n                if x - i < 0 or y - i < 0 or grid[x - i][y - i] != char:\n                    return False\n        return True\n    \n    # Check if all words can be found in the grid\n    for word in words:\n        found = False\n        for i in range(n):\n            for j in range(n):\n                for direction in directions:\n                    if can_find_word(word, i, j"}
{"task_id": "EvoEval/22", "completion": "\n    return t * v / 946100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}
{"task_id": "EvoEval/23", "completion": "\n    # Create a dictionary to store the prime numbers\n    prime_dict = {}\n    num = 2\n    while len(prime_dict) < 26:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            prime_dict[num] = chr(num + 96)\n        num += 1\n\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a lowercase letter\n        if char.islower():\n            # Get the corresponding prime number from the dictionary\n            prime_num = prime_dict.get(ord(char) - 96)\n            # If the prime number exists, add it to the result\n            if prime_num:\n                result += str(prime_num)\n        else:\n            # If the character is not a lowercase letter, add it to the result as is\n            result += char\n\n    # Return the resulting string\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    alien_word = ''\n    for char in english_word:\n        alien_word += alien_dict.get(char.lower(), '')\n    return alien_word\n"}
{"task_id": "EvoEval/25", "completion": "\n    words = text.split()\r\n    word_count = {}\r\n    max_count = 0\r\n    max_sentence = \"\"\r\n    for i in range(len(words)):\r\n        if words[i] == \".\":\r\n            sentence = \" \".join(words[:i+1])\r\n            for w in words[:i+1]:\r\n                if w in word_count:\r\n                    word_count[w] += 1\r\n                else:\r\n                    word_count[w] = 1\r\n            max_count = max(max_count, word_count[word])\r\n            max_sentence = sentence\r\n    if word in word_count:\r\n        return (word_count[word], max_sentence)\r\n    else:\r\n        return (0, \"\")\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    # Define the possible movements in the maze\n    movements = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n    \n    # Create a queue for BFS and add the start position\n    queue = [(start, [start])]\n    \n    # Create a set to store the visited positions\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the next position and the path that led to it\n        (x, y), path = queue.pop(0)\n        \n        # If this is the end position, return the path\n        if (x, y) == end:\n            return path\n        \n        # For each possible movement\n        for dx, dy, direction in movements:\n            # Calculate the new position\n            nx, ny = x + dx, y + dy\n            \n            # If the new position is within the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                # Mark the new position as visited\n                visited.add((nx, ny))\n                \n                # Add the new position and the updated path to the queue\n                queue.append(((nx, ny), path + [direction]))\n    \n    # If there is no path to the end position, return an empty list\n    return []  # This line is not necessary, but it's here to make the function return something\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Define the tax rates and deductions\n    tax_rates = [(0, 0.0), (10000, 0.0), (25000, 0.15), (50000, 0.30)]\n    deductions = [(0, 0.0), (1000, 0.1), (2000, 0.2), (3000, 0.3)]\n\n    # Calculate the taxable income\n    taxable_income = income - deductions[0][1] * min(income, deductions[0][0])\n\n    # Calculate the tax for each bracket\n    tax = 0\n    for i in range(1, len(tax_rates)):\n        bracket_income = min(taxable_income, tax_rates[i][0] - tax_rates[i-1][0])\n        tax += bracket_income * tax_rates[i][1]\n        taxable_income -= bracket_income\n\n    # Add the tax for the last bracket\n    tax += taxable_income * tax_rates[-1][1]\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    n = len(s)\n    palindrome_substrings = set()\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            substring = s[i:i + length]\n            if substring == substring[::-1]:\n                palindrome_substrings.add(substring)\n    return sorted(list(palindrome_substrings))  # Convert set to list and sort it\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements in the maze (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Create a queue for BFS, containing the start point\n    queue = [(start, [start])]\n    \n    # Create a set to store visited points\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the next point\n        (x, y), path = queue.pop(0)\n        \n        # If this is the end point, return the path\n        if (x, y) == end:\n            return path\n        \n        # For each possible movement\n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n            \n            # If the new point is inside the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new point as visited\n                visited.add((nx, ny))\n                \n                # Enqueue the new point\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    \n    # If no path is found, return an empty list\n    return []  # This line is not needed, but it's here to make the code compile\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # There is only one way to reach any cell in the first row or column\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 1\n    \n    # Fill in the rest of the 2D array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # The number of unique paths to a cell is the sum of the number of unique paths to the cell above it and the cell to its left\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    # The number of unique paths to the bottom-right cell is stored in the bottom-right cell of the 2D array\n    return dp[m][n]  # return the value at the bottom-right cell of the 2D array\n"}
{"task_id": "EvoEval/32", "completion": "\n    playlist_length = len(playlist)\n    new_playlist = playlist.copy()\n    seed = seed % 2147483647\n    for i in range(playlist_length):\n        if \"Rock\" in new_playlist[i]:\n            continue\n        swap_index = (seed * 16807) % playlist_length\n        new_playlist[i], new_playlist[swap_index] = new_playlist[swap_index], new_playlist[i]\n        seed = (seed * 16807) % 2147483647\n    return new_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    dp = [0] * (n + 1)\r\n    dp[0] = 1\r\n    for i in range(1, n + 1):\r\n        for stone in magic_stones:\r\n            if i - stone >= 0:\r\n                dp[i] += dp[i - stone]\r\n    return dp[n]\r\n\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize an empty list to store the transformation percentages\n    transformation_percentages = []\n    \n    # Calculate the transformation percentage for each day in the cycle\n    for i in range(n):\n        # If it's the most intense day, the transformation percentage doubles\n        if i == m - 1:\n            # Calculate the transformation percentage for the most intense day\n            transformation_percentage = min(100, 2 * (i + 1))\n        # If it's before the most intense day, the transformation percentage increases by 10 each day\n        elif i < m - 1:\n            # Calculate the transformation percentage for the days before the most intense day\n            transformation_percentage = min(100, 10 * (i + 1))\n        # If it's after the most intense day, the transformation percentage decreases by 10 each day\n        else:\n            # Calculate the transformation percentage for the days after the most intense day\n            transformation_percentage = max(0, 100 - 10 * (i - m + 1))\n        \n        # Append the transformation percentage to the list\n        transformation_percentages.append(transformation_percentage)\n    \n    # Return the list of transformation percentages\n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email or email.index(\"@\") == 0 or email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\".\") == len(email) - 1 or email.index(\".\") == email.index(\"@\"):\r\n        return False\r\n    return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    n = len(xs)\n    integral_coefficients = [0] * n\n    integral_coefficients[0] = xs[0]\n    for i in range(1, n):\n        integral_coefficients[i] = xs[i] / (i + 1)\n    return integral_coefficients\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for char in s:\n        if char.isalpha():\n            if char.lower() in vowels:\n                idx = vowels.index(char.lower())\n                result += vowels[(idx + 1) % len(vowels)]\n            else:\n                idx = consonants.index(char.lower())\n                result += consonants[(idx + 1) % len(consonants)]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ufffd\ufffd\",\n        \":(\": \"\ufffd\ufffd\",\n        \";)\": \"\ufffd\ufffd\"\n    }\n    for emot, unicode in emoticons.items():\n        sentence = sentence.replace(emot, unicode)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # First, we create the top and bottom frames of the ASCII art\n    top_bottom_frame = \"*\" * (n * len(s) + 3)\n    \n    # Then, we create the middle part of the ASCII art\n    middle_frame = \"*\" + \"*\" * (n * len(s) + 2) + \"*\\n\"\n    \n    # We initialize an empty string to store the ASCII art\n    ascii_art = \"\"\n    \n    # We loop over each character in the string\n    for char in s:\n        # For each character, we create a row with n copies of the character\n        row = \"*\" + char * n + \"*\" + \"\\n\"\n        \n        # We add the row to the ASCII art\n        ascii_art += row\n        \n    # Finally, we add the top and bottom frames to the ASCII art and return it\n    return top_bottom_frame + middle_frame * (len(s) - 1) + ascii_art + middle_frame + top_bottom_frame\n"}
{"task_id": "EvoEval/40", "completion": "\n    # Create a dictionary to store the power level of each potion\n    potion_dict = {}\n    for potion in potions:\n        name, power = potion.split()\n        power = int(power)\n        potion_dict[name] = power\n\n    # Initialize a list to store the result\n    result = []\n\n    # Define a helper function to perform the backtracking\n    def backtrack(target, current_potions):\n        # If the target is reached, return the current potions\n        if target == 0:\n            return current_potions\n        # If the target cannot be reached, return an empty list\n        if target < 0:\n            return []\n        # Initialize the minimum number of potions and the result\n        min_potions = float('inf')\n        min_result = []\n        # Iterate over the potions\n        for name, power in potion_dict.items():\n            # If the potion's power is greater than the target, skip it\n            if power > target:\n                continue\n            # Recursively call the backtrack function\n            new_potions = backtrack(target - power, current_potions + [name])\n            # If the new potions are not empty and the number of potions is less than the minimum, update the result\n            if new_potions and len(new_potions) < min_potions:\n                min_potions = len(new_potions)\n                min_result = new_potions\n        # Return the result\n        return min_result\n\n    # Call the backtrack function and return the result\n    return backtrack(target, [])\n"}
{"task_id": "EvoEval/41", "completion": "\n    rows, cols = len(arr), len(arr[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = arr[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + arr[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + arr[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]\n    return dp[-1][-1]\n"}
{"task_id": "EvoEval/42", "completion": "\n\n    \"\"\"\n    def find_legitem(player_input):\n        # Check if the player has acquired a legendary item\n        if 5 in player_input:\n            # Remove the legendary item from the list\n            player_input.remove(5)\n            # Sort the list in descending order\n            player_input.sort(reverse=True)\n            # Return True and the second most valuable item\n            return True, player_input[1] if player_input else None\n        else:\n            # If no legendary item is found, return False and None\n            return False, None\n    \"\"\"\n    \"\"\"\n    def find_legitem(player_input):\n        # Check if the player has acquired a legendary item\n        if 5 in player_input:\n            # Remove the legendary item from the list\n            player_input.remove(5)\n            # Sort the list in descending order\n            player_input.sort(reverse=True)\n            # Return True and the second most valuable item\n            return True, player_input[1] if player_input else None\n        else:\n            # If no legendary item is found, return False and None\n            return False, None\n    \"\"\"\n    \"\"\"\n    def find_legitem(player_input):\n        # Check if the player has acquired a legendary item\n        if 5 in player_input:\n            # Remove the legendary item from the list\n            player_input.remove(5)\n            # Sort the list in descending order\n            player_input.sort(reverse=True)\n            # Return True and the second most valuable item\n            return True, player_input[1] if player_input else None\n        else:\n            # If no legendary item is found, return False and None\n            return False, None\n    \"\"\"\n    \"\"\"\n    def find_legitem(player_input):\n        # Check if the player has acquired a legendary item\n        if 5 in player_input:\n            # Remove the legendary item from the list\n            player_input.remove(5)\n            # Sort the list in descending order\n            player"}
{"task_id": "EvoEval/43", "completion": "\n    # Calculate the duration of the trip\n    trip_duration = distance / speed\n    \n    # Calculate the fuel consumption for the trip\n    fuel_consumption = (spaceship_weight * planet_gravity) * trip_duration\n    \n    # Check if the spaceship has enough fuel for the trip\n    if fuel >= fuel_consumption:\n        # Calculate the remaining fuel\n        remaining_fuel = fuel - fuel_consumption\n        # Return the remaining fuel rounded to 2 decimal points\n        return round(remaining_fuel, 2)\n    else:\n        # Return 'Insufficient fuel' if the spaceship cannot reach the planet\n        return 'Insufficient fuel'\n"}
{"task_id": "EvoEval/44", "completion": "\n    def fairy_taletransport(q,w,e):\n        unic = 0\n        dragon = 0\n        griffe = 0\n        for i in q:\n            if i <= w:\n                unic += i\n            elif i <= e:\n                dragon += i\n            else:\n                griffe += i\n        if unic + dragon + griffe == sum(q):\n            return True\n        else:\n            return False\n    print(fairy_taletransport([5, 10, 15], 5, 20))  # False\n    print(fairy_taletransport([10, 20, 30], 10, 20))  # False\n    print(fairy_taletransport([1, 2, 1, 5], 5, 20))  # True\n    print(fairy_taletransport([5, 15, 15], 5, 20))  # True\n"}
{"task_id": "EvoEval/45", "completion": "\n    max_hills = 0\n    for i in range(len(arr)):\n        count = 0\n        for j in range(i-1, -1, -1):\n            if arr[j] < arr[i]:\n                count += 1\n            else:\n                break\n        max_hills = max(max_hills, count)\n    return max_hills\n"}
{"task_id": "EvoEval/46", "completion": "\n    def hiddenmessage(testcases):\n        secret = \"Take the cannoli.\"\n        result = []\n        for case in testcases:\n            words = [word.replace(\"?\", \"\").replace(\"!\", \"\").replace(\".\", \"\").lower() for word in case]\n            secret_message = \"\"\n            for word in words:\n                if secret in word:\n                    secret_message += word[0]\n            result.append(secret_message)\n        return result\n    # Test cases\n    print(hiddenmessage([['Hello,!ok?', 'ok'], ['Every', 'good', 'boy', 'does', 'fine']]))  # -> ['ho', 'egbdf']\n    print(hiddenmessage(['Bang', 'kimelon', 'Take the cann.', 'This', 'is?atestcase??', 'hi']))  # -> ['bgkm', 'Take cann']\n    print(hiddenmessage([['apple', 'B'], ['B', 'an', 'g', 'ki', 'melon'], ['Take the cann.', 'This', 'is?atestcase??', 'hi']]))  # -> ['a', 'an', 'Take cann']\n    print(hiddenmessage([['apple', 'B'], ['B', 'an', 'g', 'ki', 'melon'], ['Take the cann.', 'This', 'is?atestcase??', 'hi'], ['apple', 'B', 'an', 'g', 'ki', 'melon']]))  # -> ['a', 'an', 'Take cann', 'a']\n    print(hiddenmessage([['apple', 'B'], ['B', 'an', 'g', 'ki', 'melon'], ['Take the cann.', 'This', 'is?atestcase??', 'hi'], ['apple', 'B', 'an', 'g', 'ki', 'melon'], ['apple', 'B', 'an', 'g', 'ki', 'melon']]))  # -> ['a', 'an', 'Take cann', 'a', 'a']\n    print(hiddenmessage([['apple', 'B'], ['B', 'an', 'g', 'ki', 'melon'], ['Take the cann.', 'This', 'is?atestcase??', 'hi'], ['apple', 'B', 'an', 'g', 'ki', 'melon'], ['apple', 'B', 'an', 'g', 'ki', 'melon'], ['apple', 'B', 'an', 'g', 'ki', 'melon']]))  # -> ['a',"}
{"task_id": "EvoEval/47", "completion": "\n    # Check if the recipe is a dictionary\n    if not isinstance(recipe, dict):\n        raise TypeError(\"Recipe must be a dictionary\")\n    \n    # Check if the available ingredients are a dictionary\n    if not isinstance(available, dict):\n        raise TypeError(\"Available ingredients must be a dictionary\")\n    \n    # Check if all ingredients in the recipe are available\n    for ingredient, quantity in recipe.items():\n        # Check if the ingredient is available\n        if ingredient not in available:\n            return False\n        # Check if the quantity of the ingredient is sufficient\n        if available[ingredient] < quantity:\n            return False\n    \n    # If all ingredients are available and sufficient, return True\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quant = log['quant']\n        if item in inventory:\n            inventory[item] += quant\n        else:\n            inventory[item] = quant\n        if inventory[item] <= 0:\n            del inventory[item]\n    return inventory\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code = {'A': '01', 'B': '10001010100', 'C': '000101100000000111101', 'D': '010011', 'E': '1011101101101010000', 'F': '10010001011100110111100', 'G': '10000110001110011110', 'H': '011111', 'I': '011110011100011000000000', 'J': '10000110001110011110', 'K': '011111', 'L': '10001010100', 'M': '000101100000000111101', 'N': '010011', 'O': '1011101101101010000', 'P': '10010001011100110111100', 'Q': '10000110001110011110', 'R': '011111', 'S': '011110011100011000000000', 'T': '10000110001110011110', 'U': '011111', 'V': '10001010100', 'W': '000101100000000111101', 'X': '010011', 'Y': '1011101101101010000', 'Z': '10010001011100110111100', '0': '10000110001110011110', '1': '011111', '2': '10001010100', '3': '000101100000000111101', '4': '010011', '5': '1011101101101010000', '6': '10010001011100110111100', '7': '10000110001110011110', '8': '011111', '9': '011110011100011000000000', ' ': '/'}\n    msg = msg.split('/')\n    result = ''\n    for word in msg:\n        word = word.split()\n        for char in word:\n            for key, value in morse_code.items():\n                if char == value:\n                    result += key\n    return result\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ', ': '--..--', '.': '.-.-.-', '?': '..--..', '/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-'}\n    result = ''\n    for char in text.upper():\n        if char == ' ':\n            result += '   '\n        else:\n            result += morse_code[char] + ' '\n    return result.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not list_of_alphabets:\n        return string\n    if not string:\n        return ''\n    result = ''\n    for i, char in enumerate(string):\n        result += list_of_alphabets[i % len(list_of_alphabets)][ord(char) - ord('a')])\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    orders.sort(reverse=True)\n    batches = 0\n    for order in orders:\n        if order <= n:\n            batches += 1\n        else:\n            break\n    return batches\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for i, char in enumerate(s):\n        if char in vowels:\n            if i % 2 == 0:\n                result += 'e' if char.islower() else 'E'\n            else:\n                result += 'i' if char.islower() else 'I'\n        elif char.isalpha():\n            if char.islower():\n                result += chr((ord(char) - ord('a') + 1) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + 1) % 26 + ord('A'))\n        elif char == '?':\n            if i % 2 == 0:\n                result += '!'\n            else:\n                result += '?'\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = \"\"\n    shift = shift % 26\n    for i, char in enumerate(message):\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + (i + shift) % 26) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', ' ': '/'}\n    morse_code = ''\n    for char in s:\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n        else:\n            morse_code += char + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        transformed_dish = ''\n        for i, letter in enumerate(dish):\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        new_menu[transformed_dish] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    # Define the rules for translation\n    rules = {\n        'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a',\n        'b': 'c', 'c': 'd', 'd': 'f', 'f': 'g', 'g': 'h', 'h': 'j', 'j': 'k', 'k': 'l', 'l': 'm', 'm': 'n', 'n': 'p', 'p': 'q', 'q': 'r', 'r': 's', 's': 't', 't': 'v', 'v': 'w', 'w': 'x', 'x': 'y', 'y': 'z', 'z': 'b'\n    }\n    \n    # Split the input string into words\n    words = earth_phrase.split()\n    \n    # Initialize an empty list to store the translated words\n    translated_words = []\n    \n    # Iterate over each word in the input string\n    for word in words:\n        # Initialize an empty string to store the translated word\n        translated_word = ''\n        \n        # Check if the word starts with a vowel\n        if word[0] in 'aeiou':\n            # Append 'xy' to the translated word\n            translated_word += 'xy'\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is a vowel\n            if char in 'aeiou':\n                # Replace the vowel with the next vowel in sequence\n                translated_word += rules[char]\n            # Check if the character is a consonant\n            elif char in rules:\n                # Replace the consonant with the next consonant in sequence\n                translated_word += rules[char]\n            # If the character is not a vowel or consonant, append it as is\n            else:\n                translated_word += char\n        \n        # Capitalize the first letter of the translated word\n        translated_word = translated_word.capitalize()\n        \n        # Append the translated word to the list of translated words\n        translated_words.append(translated_word)\n    \n    # Join the translated words back into a string with '@' as the separator\n    translated_string = '@'.join(translated_words)\n    \n    # Return the translated string\n    return translated_string\n"}
{"task_id": "EvoEval/59", "completion": "\n    # First, we sort the ingredients based on the number of recipes they can be used in\n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: x[1], reverse=True)\n    \n    # Then, we sort the ingredients with the same number of recipes in ascending order\n    sorted_ingredients = sorted(sorted_ingredients, key=lambda x: x[1])\n    \n    # We initialize an empty list to store the result\n    result = []\n    \n    # We iterate over the sorted ingredients\n    for ingredient, num_recipes in sorted_ingredients:\n        # We add the ingredient and the number of recipes to the result list\n        result.append((ingredient, num_recipes))\n    \n    # Finally, we return the result list\n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    sugar_locations = set(sugar_locations)\n    ant_positions = [(x, y, direction) for x, y, direction in ant_positions]\n    happy_ants_count = 0\n    for x, y, direction in ant_positions:\n        if (x, y) in sugar_locations:\n            happy_ants_count += 1\n            sugar_locations.remove((x, y))\n    return happy_ants_count\n"}
{"task_id": "EvoEval/61", "completion": "\n    result = []\n    for i, c in enumerate(s):\n        if c.isalpha():\n            if i % 2 == 1:\n                c = c.swapcase()\n            elif c.lower() in 'aeiou':\n                if i == 0 or s[i - 1].lower() not in 'aeiou':\n                    c = 'e' if c.lower() == 'a' else 'i' if c.lower() == 'e' else 'o' if c.lower() == 'i' else 'u' if c.lower() == 'o' else 'a'\n            else:\n                if i == 0 or s[i - 1].lower() in 'aeiou':\n                    c = chr(ord(c) + 1)\n                    if c == '{':\n                        c = 'z'\n        result.append(c)\n    return ''.join(result)  # Return the transformed string\n"}
{"task_id": "EvoEval/62", "completion": "\n    def recipe_conver(reci, conversionfactor):\n        new_recipe = {}\n        for ingredient, quantity in reci.items():\n            new_recipe[ingredient] = quantity * conversionfactor\n        return new_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\r\n    while p > 0:\r\n        pyramid.append(p)\r\n        if p % 2 == 0:\r\n            p -= 2\r\n        else:\r\n            p -= 3\r\n    return pyramid[::-1]  # Return the list in reverse order\r"}
{"task_id": "EvoEval/64", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the range from 'start' to 'end' (inclusive)\n    for num in range(start, end + 1):\n        # Check if the number is divisible by 'divisor'\n        if num % divisor == 0:\n            # Check if the number is prime\n            if is_prime(num):\n                # If the number is prime, add it to the result list\n                result.append(num)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Create a copy of the original menu to avoid modifying it directly\n    final_order = menu.copy()\n    \n    # Iterate over each food item in the order\n    for food, ingredients in order.items():\n        # Check if the food item exists in the menu\n        if food in final_order:\n            # If the ingredients list is empty, remove the food item from the final order\n            if not ingredients:\n                del final_order[food]\n            else:\n                # Iterate over each ingredient to be added or removed\n                for ingredient in ingredients:\n                    # Check if the ingredient is to be added\n                    if ingredient.startswith('add'):\n                        # Add the ingredient to the food item in the final order\n                        final_order[food].append(ingredient[3:])\n                    # Check if the ingredient is to be removed\n                    elif ingredient.startswith('remove'):\n                        # Remove the ingredient from the food item in the final order\n                        final_order[food].remove(ingredient[6:])\n    \n    # Return the final order\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    primes = [i for i in range(2, n + 1) if is_prime(i)]\n    anagram_pairs = set()\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if is_anagram(primes[i], primes[j]):\n                anagram_pairs.add(tuple(sorted((primes[i], primes[j]))))\n    return sorted(list(anagram_pairs))  # sorted by first number, then second number"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        result[customer] = 0\n    for customer, meals_list in meals.items():\n        for meal in meals_list:\n            result[customer] += meal['calories']\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    n = len(arr)\n    if n == 0:\n        return True\n    if n == 1:\n        return True\n    if n == 2:\n        if arr[0] <= arr[1]:\n            return True\n        else:\n            return False\n    for i in range(n):\n        if arr[i] > arr[i + 1]:\n            return False\n    return True\n"}
{"task_id": "EvoEval/69", "completion": "\n    # Create a dictionary to store the indices of the cards\n    card_indices = {card: i for i, card in enumerate(cards)}\n    \n    # Iterate over the cards\n    for i in range(len(cards)):\n        # For each card, iterate over the remaining cards\n        for j in range(i + 1, len(cards)):\n            # If the product of the two cards equals the magic number, return their indices\n            if cards[i] * cards[j] == magicNumber:\n                return (card_indices[cards[i]], card_indices[cards[j]])\n    \n    # If no pair of cards multiplies to the magic number, return \"No magic today\"\n    return \"No magic today\"  # This line will never be reached, but it's required by the problem statement\n"}
{"task_id": "EvoEval/70", "completion": "\n    # Check if the path list is empty or if the planet does not exist in the dictionary\n    if not path or path[0] not in planets or path[-1] not in planets:\r\n        return False\r\n\r\n    # Iterate over the path list to check if each planet connects directly to the next one\r\n    for i in range(len(path) - 1):\r\n        # If the current planet does not connect to the next one, return False\r\n        if path[i] not in planets or path[i + 1] not in planets[path[i]]:\r\n            return False\r\n\r\n    # If the function has not returned False, the path is valid, so return True\r\n    return True\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    # Initialize an empty string to store the encrypted message\n    encrypted_message = \"\"\n    \n    # Initialize a counter for the number of vowels\n    num_vowels = 0\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Calculate the ASCII value of 'a' or 'A' depending on the case of the character\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            \n            # Calculate the new character by shifting the current character by 'n' places\n            new_char = chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            \n            # Add the new character to the encrypted message\n            encrypted_message += new_char\n            \n            # Check if the new character is a vowel\n            if new_char in 'aeiouAEIOU':\n                # Increment the vowel counter\n                num_vowels += 1\n        else:\n            # If the character is not a letter, add it to the encrypted message as is\n            encrypted_message += char\n    \n    # Return a tuple containing the encrypted message and the number of vowels\n    return encrypted_message, num_vowels\n"}
{"task_id": "EvoEval/72", "completion": "\n    output = []\n    for i, string in enumerate(lst):\n        count = sum(c.isdigit() for c in string)\n        story = f\"Once upon, in a kingdom far away, lived a magical creature with the name of '{string}' who was known for telling {count} tales a day, where {string} is the {i+1}th string of the input and {count} is count of digits in that string.\"\n        output.append(story)\n    return output\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Initialize variables to keep track of the total number of trips and the current number of chests in the bag\n    total_trips = 0\r\n    current_chests = 0\r\n\r\n    # Iterate over each chamber in the pyramid\n    for chamber in grid:\r\n        # Iterate over each chest in the chamber\n        for chest in chamber:\r\n            # If the chest is not empty\n            if chest == 1:\r\n                # If the bag is not full, add the chest to the bag\n                if current_chests < bag_capacity:\r\n                    current_chests += 1\r\n                # If the bag is full, make a trip back to the entrance and reset the bag\n                else:\r\n                    total_trips += 1\r\n                    current_chests = 1\r\n\r\n    # Make one final trip back to the entrance if the bag is not empty\n    if current_chests > 0:\r\n        total_trips += 1\r\n\r\n    return total_trips\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    result = \"\"\n    for char in s:\n        if char in cipher:\n            result += cipher[char]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    digits = '0123456789'\n    punctuation = '!@#$%^&*()_+-={}:<>?,./;[]\\\\|~`'\n    result = ''\n    for i, char in enumerate(input_str):\n        if char in vowels:\n            idx = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[idx]\n        elif char in consonants:\n            idx = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[idx]\n        elif char in digits:\n            idx = (int(char) + 1) % 10\n            result += str(idx)\n        elif char in punctuation:\n            if i % 2 == 0:\n                if char == '?':\n                    result += '!'\n                else:\n                    result += char\n            else:\n                result += char\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/76", "completion": "\n\n    \"\"\"\n    def createpyramid(lst ''' You are given list positive.Your task create pyramid out the numbers, where every level of the represented string equal length.The number characters a string equals sum positive in corresponding level pyramidThe pyramid should built from bottom, i the first element of list should form bottom levelReturn the pyramid as a list stringsIf the list integers empty return anNote Use character '# represent numbers.Examples: create_pyramid([3 2]) == ['#',#####'] create5 4 2###########]) [] '''\n    \"\"\"\n    if not lst:\n        return []\n    pyramid = []\n    level = 1\n    while lst:\n        level_str = '#' * lst.pop()\n        while len(level_str) < level:\n            level_str = '#' + level_str\n        pyramid.append(level_str)\n        level += 1\n    return pyramid[::-1]\n    \"\"\"\n    \"\"\"\n    def createpyramid(lst ''' You are given list positive.Your task create pyramid out the numbers, where every level of the represented string equal length.The number characters a string equals sum positive in corresponding level pyramidThe pyramid should built from bottom, i the first element of list should form bottom levelReturn the pyramid as a list stringsIf the list integers empty return anNote Use character '# represent numbers.Examples: create_pyramid([3 2]) == ['#',#####'] create5 4 2###########]) [] '''\n    \"\"\"\n    if not lst:\n        return []\n    pyramid = []\n    level = 1\n    while lst:\n        level_str = '#' * lst.pop()\n        while len(level_str) < level:\n            level_str = '#' + level_str\n        pyramid.append(level_str)\n        level += 1\n    return pyramid[::-1]\n    \"\"\"\n    \"\"\"\n    def createpyramid(lst ''' You are given list positive.Your task create pyramid out the numbers, where every level of the represented string equal length.The number characters a string equals sum positive in corresponding level pyramidThe pyramid should built from bottom, i the first element of list should form bottom levelReturn the pyramid as a list stringsIf the list integers empty return anNote Use character '# represent numbers.Examples: create"}
{"task_id": "EvoEval/77", "completion": "\n    n = len(sequence)\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(1, k + 1):\n            if i == 0:\n                dp[i][j] = sequence[i] // j\n            else:\n                dp[i][j] = max(dp[i - 1][j], sequence[i] // j + dp[i - 1][j - 1])\n    return [dp[i][k] for i in range(n)]\n\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                result.append(mat[i][j])\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n    n = len(prices)\r\n    dp = [0] * (days + 1)\r\n    for i in range(1, n + 1):\r\n        for j in range(days, i - 1, -1):\r\n            dp[j] = max(dp[j], dp[j - i] + prices[i - 1])\r\n    return dp[days]\r\n\r"}
{"task_id": "EvoEval/80", "completion": "\n    def adventure_game(map, instructions):\n        # Initialize the player's position and path\n        player_row, player_col = 0, 0\n        path = [(player_row, player_col)]\n        \n        # Iterate over the instructions\n        for instruction in instructions:\n            # Get the current player position\n            current_row, current_col = player_row, player_col\n            \n            # Move the player according to the instruction\n            if instruction == 'up':\n                current_row -= 1\n            elif instruction == 'down':\n                current_row += 1\n            elif instruction == 'left':\n                current_col -= 1\n            elif instruction == 'right':\n                current_col += 1\n            \n            # Check if the player has moved into a wall or the edge of the map\n            if (current_row < 0 or current_row >= len(map) or\n                current_col < 0 or current_col >= len(map[0]) or\n                map[current_row][current_col] == 'X'):\n                # If the player has moved into a wall or the edge of the map, stay in the current position\n                player_row, player_col = current_row, current_col\n            else:\n                # If the player has moved into a new position, update the player's position and path\n                player_row, player_col = current_row, current_col\n                path.append((player_row, player_col))\n            \n            # Check if the player has found the end 'E'\n            if map[player_row][player_col] == 'E':\n                # If the player has found the end 'E', return the path so far\n                return path\n        \n        # If the list instructions ends before the player finds 'E', return the player path so far\n        return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"COR\"\n    for i in range(len(word_list) - 1):\n        if not is_sorted(word_list[i], word_list[i + 1], alien_dictionary):\n            return \"INCOR\"\n    return \"CORRECT\"\n\n"}
{"task_id": "EvoEval/82", "completion": "\n    zodiac_signs = {\n        \"Aries\": [\"2000-03-21\", \"2000-04-19\"],\n        \"Taurus\": [\"2000-04-20\", \"2000-05-20\"],\n        \"Gemini\": [\"2000-05-21\", \"2000-06-20\"],\n        \"Cancer\": [\"2000-06-21\", \"2000-07-22\"],\n        \"Leo\": [\"2000-07-23\", \"2000-08-22\"],\n        \"Virgo\": [\"2000-09-23\", \"2000-10-22\"],\n        \"Libra\": [\"2000-10-23\", \"2000-11-21\"],\n        \"Scorpio\": [\"2000-10-21\", \"2000-11-21\"],\n        \"Sagittarius\": [\"2000-11-22\", \"2000-12-21\"],\n        \"Capricorn\": [\"2000-01-19\", \"2000-02-18\"],\n        \"Aquarius\": [\"2000-01-20\", \"2000-02-18\"],\n        \"Pisces\": [\"2000-02-19\", \"2000-03-20\"]\n    }\n    elements = {\"Fire\": [\"Aries\", \"Leo\", \"Sagittarius\"], \"Water\": [\"Cancer\", \"Scorpio\", \"Pisces\"], \"Earth\": [\"Taurus\", \"Virgo\", \"Capricorn\"], \"Air\": [\"Gemini\", \"Libra\", \"Aquarius\"]}\n    result = {}\n    for element, signs in elements.items():\n        count = 0\n        for sign in signs:\n            for birthday in birthdays:\n                if zodiac_signs[sign][0] <= birthday <= zodiac_signs[sign][1]:\n                    count += 1\n                    break\n        if count > 0:\n            result[element] = count\n    return result if birthdays else None\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n    return ''.join(s)\n"}
{"task_id": "EvoEval/84", "completion": "\n\n    def tree_travers(tree):\n        def dfs(node, path):\n            if not node:\n                return []\n            if not node[1]:\n                return [path + [node[0]]]\n            return dfs(node[1], path + [node[0]]) + dfs(node[2], path + [node[0]])\n        return dfs(tree, [])\n    tree = {1: {4: {}}, 2: {5: {}, 6: {}}}\n    assert tree_travers(tree) == [[1, 4], [1, 5], [1, 6, 3, 7], [2, 5, 3], [2, 6, 3, 7]]\n    tree = {7: {8: {}}, 7: {8: {}}}\n    assert tree_travers(tree) == [[7, 8], [7, 8]]\n    tree = {7: {8: {}}, 7: {8: {}}}\n    assert tree_travers(tree) == [[7, 8], [7, 8]]  # This test case is not possible with the given tree structure\n    return tree_travers(tree)  # Use return statement to get the result of the function\n"}
{"task_id": "EvoEval/85", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a 2D array to store the minimum number of moves to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Initialize the first cell as 0, since we are starting from there\n    dp[0][0] = 0\n    \n    # Fill the first row\n    for j in range(1, cols):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1] + 1\n        else:\n            dp[0][j] = float('inf')\n    \n    # Fill the first column\n    for i in range(1, rows):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0] + 1\n        else:\n            dp[i][0] = float('inf')\n    \n    # Fill the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n            else:\n                dp[i][j] = float('inf')\n    \n    # If the princess's coordinate is out of bounds, return -1\n    if coord[0] < 0 or coord[0] >= rows or coord[1] < 0 or coord[1] >= cols:\n        return -1\n    \n    # Return the minimum number of moves to reach the princess\n    return dp[coord[0]][coord[1]] if dp[coord[0]][coord[1]] != float('inf') else -1\n"}
{"task_id": "EvoEval/86", "completion": "\n\n    # First, we sort the dictionary items based on the rating in descending order and then the release year in ascending order\n    sorted_movies = sorted(m_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n    \n    # Then, we extract the movie names from the sorted items\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n    \n    # Finally, we return the sorted list of movie names\n    return sorted_movie_names\n"}
{"task_id": "EvoEval/87", "completion": "\n    result = []\n    while arr:\n        result += ''.join(arr.pop(0))\n        if arr and arr[0]:\n            for row in arr:\n                result += row.pop()\n        if arr:\n            result += ''.join(arr.pop()[::-1])\n        if arr and arr[0]:\n            for row in arr[::-1]:\n                result += row.pop(0)\n    return result\n"}
{"task_id": "EvoEval/88", "completion": "\n\n    def planet_population(planet_dict):\n        result = {}\n        for planet, features in planet_dict.items():\n            if len(features) == 2 and features[0] is not None and features[1] is not None:\n                population, size = features\n                if population > 0 and size > 0:\n                    density = round(population / size, 2)\n                    result[planet] = density\n        return result\n    \"\"\"\n    def planet_population(planet_dict):\n        result = {}\n        for planet, features in planet_dict.items():\n            if len(features) == 2 and features[0] is not None and features[1] is not None:\n                population, size = features\n                if population > 0 and size > 0:\n                    density = round(population / size, 2)\n                    result[planet] = density\n        return result\n    \"\"\"\n    def planet_population(planet_dict):\n        result = {}\n        for planet, features in planet_dict.items():\n            if len(features) == 2 and features[0] is not None and features[1] is not None:\n                population, size = features\n                if population > 0 and size > 0:\n                    density = round(population / size, 2)\n                    result[planet] = density\n        return result\n    \"\"\"\n    def planet_population(planet_dict):\n        result = {}\n        for planet, features in planet_dict.items():\n            if len(features) == 2 and features[0] is not None and features[1] is not None:\n                population, size = features\n                if population > 0 and size > 0:\n                    density = round(population / size, 2)\n                    result[planet] = density\n        return result\n    \"\"\"\n    def planet_population(planet_dict):\n        result = {}\n        for planet, features in planet_dict.items():\n            if len(features) == 2 and features[0] is not None and features[1] is not None:\n                population, size ="}
{"task_id": "EvoEval/89", "completion": "\n    # Create a set to store the remaining aliens' positions\n    remaining_aliens = set()\n    \n    # Iterate over each alien's position\n    for alien in aliens:\n        # If the alien is not in the adjacent positions of the ray gun, add it to the set\n        if alien not in [ray - 1, ray, ray + 1]:\n            remaining_aliens.add(alien)\n    \n    # Convert the set to a list and return it\n    return list(remaining_aliens) + [ray + 1]  # Add the position of the ray gun to the list\n"}
{"task_id": "EvoEval/90", "completion": "\n    # Convert the input strings to integers\n    num1 = int(s1)\n    num2 = int(s2)\n\n    # Initialize an empty list to store the unique digit combinations\n    combinations = []\n\n    # Function to generate all unique combinations of digits\n    def get_combinations(n, current_combination, start_index):\n        if start_index == len(str(n)):\n            combinations.append(current_combination)\n            return\n        get_combinations(n, current_combination + [str(n)[start_index]], start_index + 1)\n        get_combinations(n, current_combination, start_index + 1)\n\n    # Generate all unique combinations of digits for both numbers\n    get_combinations(num1, [], 0)\n    get_combinations(num2, [], 0)\n\n    # Initialize a set to store the unique sums of combinations\n    unique_sums = set()\n\n    # Calculate the sum of each combination and add it to the set\n    for combination1 in combinations:\n        for combination2 in combinations:\n            unique_sums.add(sum(int(digit) for digit in combination1) + sum(int(digit) for digit in combination2))\n\n    # Return the sum of all unique sums\n    return sum(unique_sums)  # Return the sum of all unique sums\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceship_data:\n        if status == 'On Ground' and action == 'Launch':\n            status = 'In Space'\n        elif status == 'In Space' and action == 'Land':\n            status = 'On Ground'\n        elif status == 'On Ground' and action == 'Land':\n            status = 'Invalid Action Sequence'\n        elif status == 'In Space' and action == 'Launch':\n            status = 'Invalid Action Sequence'\n        elif status == 'In Space' and action == 'Move':\n            status = 'In Space'\n        elif status == 'On Ground' and action == 'Move':\n            status = 'On Ground'\n        else:\n            status = 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Loop through each layer of the fountain\n    for i in range(1, n + 1):\n        # Calculate the width of the current layer\n        width = 2 * i - 1\n        \n        # Calculate the number of spaces needed to center the layer\n        spaces = (n - i) // 2\n        \n        # Generate the current layer\n        layer = ' ' * spaces + 'A' * (2 * i - 1) + ' ' * spaces\n        \n        # Add the current layer to the result\n        result += layer + '\\n'\n    \n    # Return the result\n    return result.strip()  # Remove the trailing newline character\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i in range(len(message)):\n        if message[i].isalpha():\n            shift = n_values[i % len(n_values)]\n            if message[i].isupper():\n                result += chr((ord(message[i]) - 65 + shift) % 26 + 65)\n            else:\n                result += chr((ord(message[i]) - 97 + shift) % 26 + 97)\n        else:\n            result += message[i]\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(word.split(), key=len)) for word in strings]  # Your code here\n"}
{"task_id": "EvoEval/95", "completion": "\n    # Check if the matrix is square\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n\n    # Initialize the sum of the main diagonal and the sum of the anti-diagonal\n    main_diagonal_sum = 0\n    anti_diagonal_sum = 0\n\n    # Calculate the sum of the main diagonal\n    for i in range(len(m)):\n        main_diagonal_sum += m[i][i]\n\n    # Calculate the sum of the anti-diagonal\n    for i in range(len(m)):\n        anti_diagonal_sum += m[i][len(m) - i - 1]\n\n    # Return the absolute difference between the sums of the diagonals\n    return abs(main_diagonal_sum - anti_diagonal_sum)  # Corrected the formula to calculate the absolute difference\n\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] % i == 0 and lst[i] != 0 and lst[i] == int(''.join(sorted(str(abs(lst[i]))))):\n            magic_indices.append(i)\n    return sorted(magic_indices) if magic_indices else []  # return an empty list if no magic indices are found\n"}
{"task_id": "EvoEval/97", "completion": "\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    continents = [\"Asia\", \"Africa\", \"Europe\", \"North\", \"South\"]\n    order = [\"Asia\", \"Africa\", \"Europe\", \"North\", \"South\"]\n    result = []\n    for human, continent in humans.items():\n        if continent in order and order.index(continent) >= order.index(alien):\n            result.append(human)\n    return sorted(result)\n"}
{"task_id": "EvoEval/98", "completion": "\n    sequence = [a, b]\n    while len(sequence) < n:\n        next_number = sequence[-1] + sequence[-2]\n        if next_number > 1:  # 1 is not considered a prime number\n            is_prime = True\n            for i in range(2, int(next_number ** 0.5) + 1):\n                if next_number % i == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                sequence.append('prime')\n            else:\n                sequence.append(next_number)\n        else:\n            sequence.append('prime')\n    return sequence  # return the sequence as integers and strings\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    for i, round_time in enumerate(rounds):\n        for _ in range(round_time):\n            music_speed = music\n            for j in range(len(players) - 1):\n                players[j], players[j + 1] = players[j + 1], players[j]\n                music_speed -= 1\n                if music_speed <= 0:\n                    music_speed = music\n                    players.pop()\n                    break\n        if not players:\n            players = list(range(1, n + 1))\n    return players\n"}
