{"task_id": "EvoEval/0", "completion": "\n    base_cost = 5.0\n    total_weight = 0.0\n    total_cost = 0.0\n    factor = 1.0\n\n    if location == \"National\":\n        factor = 1.5\n    elif location == \"International\":\n        factor = 2.5\n\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0\n            total_cost += base_cost * 1.5\n        else:\n            weight = item\n            total_cost += base_cost\n\n        if weight > 5.0:\n            total_cost += 10.0\n\n        total_weight += weight\n\n    total_cost *= factor\n    total_cost = round(total_cost, 2)\n\n    return f\"{total_cost:.2f}\"\n"}
{"task_id": "EvoEval/1", "completion": "\n    base_cost = 5.0\n    total_cost = 0.0\n\n    # Determine the location factor\n    if location == \"Local\":\n        location_factor = 1.0\n    elif location == \"National\":\n        location_factor = 1.5\n    elif location == \"International\":\n        location_factor = 2.5\n    else:\n        location_factor = 1.0\n\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0  # Assume weight of string items is 1kg\n        else:\n            weight = item\n\n        item_cost = base_cost * location_factor\n        if weight > 5.0:\n            item_cost += 10.0  # Additional charge for items over 5kg\n\n        total_cost += item_cost\n\n    return round(total_cost, 2)\n"}
{"task_id": "EvoEval/2", "completion": "\n    def calculate_key(key: Union[str, int]) -> int:\n        if isinstance(key, int):\n            return key\n        return sum(ord(char) for char in key)\n\n    def caesar_cipher(word: str, shift: int) -> str:\n        encrypted_word = []\n        for char in word:\n            if char.isalpha():\n                shifted = ord(char) + shift\n                if char.islower():\n                    if shifted > ord('z'):\n                        shifted -= 26\n                elif char.isupper():\n                    if shifted > ord('Z'):\n                        shifted -= 26\n                encrypted_word.append(chr(shifted))\n            else:\n                encrypted_word.append(char)\n        return ''.join(encrypted_word)\n\n    key_value = calculate_key(key)\n    return [caesar_cipher(word.lower(), key_value) for word in words]\n"}
{"task_id": "EvoEval/3", "completion": "\n    def backtrack(index: int, path: str):\n        if index == len(input_string):\n            combinations.append(path)\n            return\n        \n        # Single digit decoding\n        single_digit = int(input_string[index])\n        if 1 <= single_digit <= 26:\n            backtrack(index + 1, path + chr(single_digit + 96))\n        \n        # Double digit decoding\n        if index + 1 < len(input_string):\n            double_digit = int(input_string[index:index + 2])\n            if 10 <= double_digit <= 26:\n                backtrack(index + 2, path + chr(double_digit + 96))\n\n    combinations = []\n    backtrack(0, \"\")\n    return combinations\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n\n    max_height = max(candles)\n    lit_candles = 0\n\n    for height in candles:\n        if height >= max_height:\n            lit_candles += 1\n            max_height = height\n\n    return lit_candles\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n\n    result = []\n    rows = len(matrix)\n    for i in range(rows):\n        if i % 2 == 0:\n            # Traverse left to right\n            result.extend(matrix[i])\n        else:\n            # Traverse right to left\n            result.extend(reversed(matrix[i]))\n\n    return result\n"}
{"task_id": "EvoEval/6", "completion": "\n    if not (0 <= position[0] < len(grid)) or not (0 <= position[1] < len(grid[0])):\n        return grid\n\n    x, y = position\n\n    if grid[x][y] == 1:  # clicked on a mine\n        return grid\n\n    if grid[x][y] == -1:  # clicked on an unknown cell\n        return grid\n\n    if grid[x][y] == 0:  # clicked on an empty cell\n        def reveal_adjacent_cells(i, j):\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 0:\n                grid[i][j] = 0  # keep it as 0\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if (di != 0 or dj != 0):\n                            reveal_adjacent_cells(i + di, j + dj)\n\n        reveal_adjacent_cells(x, y)\n\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    x, y = 0, 0\n    \n    for code in code_sequence:\n        if code == 0:  # North\n            y += 1\n        elif code == 1:  # East\n            x += 1\n        elif code == 2:  # South\n            y -= 1\n        elif code == 3:  # West\n            x -= 1\n\n    if (x, y) == (0, 0) and len(code_sequence) > 0:\n        return 'Shangri-La found'\n    else:\n        return 'Shangri-La not found'\n"}
{"task_id": "EvoEval/8", "completion": "\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    \n    painter_index = canvas.index('P')\n    left_index = painter_index\n    right_index = painter_index\n    \n    # Move left until hitting a wall or the start of the canvas\n    while left_index > 0 and canvas[left_index - 1] != '#':\n        left_index -= 1\n    \n    # Move right until hitting a wall or the end of the canvas\n    while right_index < len(canvas) - 1 and canvas[right_index + 1] != '#':\n        right_index += 1\n    \n    # Check if there are any walls that divide the empty spaces\n    if canvas[left_index:right_index + 1].count('-') != (right_index - left_index):\n        return 'Invalid canvas'\n    \n    # Create the transformed canvas\n    transformed_canvas = list(canvas)\n    for i in range(left_index, right_index + 1):\n        if transformed_canvas[i] == '-':\n            transformed_canvas[i] = '*'\n    \n    return ''.join(transformed_canvas)\n"}
{"task_id": "EvoEval/9", "completion": "\n    import string as str_lib\n\n    # Normalize the string to lower case and remove punctuation\n    normalized_string = string.lower().translate(str.maketrans('', '', str_lib.punctuation))\n    \n    # Split the string into words\n    words = normalized_string.split()\n    \n    # Calculate frequency of each word\n    frequency = {}\n    for word in words:\n        frequency[word] = frequency.get(word, 0) + 1\n    \n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_count = {'C': 0, 'D': 0, 'B': 0}\n    sounds = animal_string.split()\n    result = []\n    total_animals = 0\n\n    for sound in sounds:\n        if total_animals >= 5:\n            break\n        \n        animal = sound[0]\n        sound_count = sound.count('|')\n\n        if animal in animal_count and animal_count[animal] < 2:\n            animal_count[animal] += 1\n            result.append(sound_count)\n            total_animals += 1\n\n    return result\n"}
{"task_id": "EvoEval/11", "completion": "\n    if not fruits:\n        return \"\"\n\n    if len(fruits) == 1:\n        return f\"Oh {fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"Oh {', '.join(fruits[:-1])}, and {fruits[-1]} from {location}? Marvelous!\"\n"}
{"task_id": "EvoEval/12", "completion": "\n    from collections import Counter\n\n    # Count occurrences of each element\n    count = Counter(flux_values)\n    \n    # Find the element with maximum occurrence\n    max_occurrence = max(count.values())\n    most_occurred_numbers = [num for num, occ in count.items() if occ == max_occurrence]\n    \n    # Select the smallest one if there are multiple\n    most_occurred_number = min(most_occurred_numbers)\n    \n    # Calculate the sum of all elements\n    total_sum = sum(flux_values)\n    \n    # Calculate the unique energy signature\n    unique_energy_signature = total_sum * most_occurred_number\n    \n    return unique_energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n\n    frequency = {}\n    for elem in elems:\n        frequency[elem] = frequency.get(elem, 0) + 1\n\n    rarest_elem = None\n    min_count = float('inf')\n\n    for elem in elems:\n        if frequency[elem] < min_count:\n            min_count = frequency[elem]\n            rarest_elem = elem\n\n    return rarest_elem\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    \n    def next_vowel(c):\n        if c.lower() in vowels:\n            return vowels[(vowels.index(c.lower()) + 1) % len(vowels)].upper() if c.isupper() else vowels[(vowels.index(c.lower()) + 1) % len(vowels)]\n        return c\n\n    def next_consonant(c):\n        if c.lower() in consonants:\n            return consonants[(consonants.index(c.lower()) + 1) % len(consonants)].upper() if c.isupper() else consonants[(consonants.index(c.lower()) + 1) % len(consonants)]\n        return c\n\n    alias = []\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                alias.append(next_vowel(char))\n            else:\n                alias.append(next_consonant(char))\n        else:\n            alias.append(char)\n\n    return ''.join(alias)\n"}
{"task_id": "EvoEval/15", "completion": "\n    value_count = {}\n    \n    for card in hand:\n        value = card[:-1]  # Get the value part of the card\n        if value == 'A':\n            value = 1\n        elif value == 'J':\n            value = 11\n        elif value == 'Q':\n            value = 12\n        elif value == 'K':\n            value = 13\n        else:\n            value = int(value)\n        \n        if value in value_count:\n            value_count[value] += 1\n        else:\n            value_count[value] = 1\n\n    score = 0\n    pair_value = 0\n    triple_value = 0\n    four_value = 0\n    five_value = 0\n\n    for value, count in value_count.items():\n        if count == 2:\n            pair_value = max(pair_value, value)\n        elif count == 3:\n            triple_value = max(triple_value, value)\n        elif count == 4:\n            four_value = max(four_value, value)\n        elif count == 5:\n            five_value = max(five_value, value)\n\n    if five_value:\n        score += 4 * five_value\n    if four_value:\n        score += 3 * four_value\n    if triple_value:\n        score += 2 * triple_value\n    if pair_value:\n        score += pair_value\n\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    a, b = 0, 1\n    total_sum = a + b\n\n    for _ in range(2, n):\n        a, b = b, a + b\n        total_sum += b\n\n    return total_sum\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard in wizards:\n        dragon_hp -= wizard[1]\n        if dragon_hp <= 0:\n            return wizard[0]\n    return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    def digits_sum(num):\n        return sum(int(digit) for digit in str(num))\n\n    count = 0\n    current = 7\n    while count < n:\n        if digits_sum(current) == 7:\n            count += 1\n            if count == n:\n                return current\n        current += 7\n"}
{"task_id": "EvoEval/19", "completion": "\n    count = 0\n    rows = len(m)\n    cols = len(m[0]) if rows > 0 else 0\n\n    for j in range(cols):\n        for i in range(rows):\n            if m[i][j] == 2:  # Found a vampire\n                # Check all humans in the same column\n                for k in range(rows):\n                    if m[k][j] == 1:  # Found a human\n                        count += 1\n    return count\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    \n    pattern = []\n    \n    for i in range(1, n + 1):\n        pattern.append(','.join(str(x) for x in range(1, i + 1)))\n    \n    for i in range(n, 0, -1):\n        pattern.append(','.join(str(x) for x in range(i, 0, -1)))\n    \n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    def search_word(word, grid):\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == word[0]:\n                    # Check all 8 directions\n                    if (check_direction(word, grid, i, j, 0, 1) or  # right\n                        check_direction(word, grid, i, j, 0, -1) or  # left\n                        check_direction(word, grid, i, j, 1, 0) or  # down\n                        check_direction(word, grid, i, j, -1, 0) or  # up\n                        check_direction(word, grid, i, j, 1, 1) or  # down-right\n                        check_direction(word, grid, i, j, 1, -1) or  # down-left\n                        check_direction(word, grid, i, j, -1, 1) or  # up-right\n                        check_direction(word, grid, i, j, -1, -1)):  # up-left\n                        return True\n        return False\n\n    def check_direction(word, grid, row, col, row_dir, col_dir):\n        for k in range(len(word)):\n            new_row = row + k * row_dir\n            new_col = col + k * col_dir\n            if (new_row < 0 or new_row >= len(grid) or\n                new_col < 0 or new_col >= len(grid) or\n                grid[new_row][new_col] != word[k]):\n                return False\n        return True\n\n    for word in words:\n        if not search_word(word, grid):\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    distance_km = v * t * 365.25 * 24 * 3600  # Convert time to seconds and calculate distance in km\n    light_year_km = 9.461e12  # 1 light year in kilometers\n    distance_ly = distance_km / light_year_km  # Convert distance to light years\n    return distance_ly\n"}
{"task_id": "EvoEval/23", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def generate_primes(n):\n        primes = []\n        candidate = 2\n        while len(primes) < n:\n            if is_prime(candidate):\n                primes.append(candidate)\n            candidate += 1\n        return primes\n\n    primes = generate_primes(26)\n    result = []\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            result.append(str(primes[ord(char) - ord('a')]))\n        else:\n            result.append(char)\n\n    return ''.join(result)\n"}
{"task_id": "EvoEval/24", "completion": "\n    translation_map = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', \n        'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', \n        'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', \n        'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'\n    }\n    \n    alien_word = ''.join(translation_map.get(char, char) for char in english_word)\n    return alien_word\n"}
{"task_id": "EvoEval/25", "completion": "\n    sentences = text.split('.')\n    max_frequency = 0\n    max_sentence = \"\"\n\n    for sentence in sentences:\n        sentence = sentence.strip()\n        frequency = sentence.lower().split().count(word.lower())\n        \n        if frequency > max_frequency:\n            max_frequency = frequency\n            max_sentence = sentence\n\n    return (max_frequency, max_sentence)\n"}
{"task_id": "EvoEval/26", "completion": "\n    if start == end:\n        return []\n\n    directions = []\n    visited = set()\n    queue = [(start, directions)]\n\n    while queue:\n        (current_row, current_col), path = queue.pop(0)\n\n        if (current_row, current_col) == end:\n            return path\n\n        visited.add((current_row, current_col))\n\n        for dr, dc, direction in [(-1, 0, \"up\"), (1, 0, \"down\"), (0, -1, \"left\"), (0, 1, \"right\")]:\n            new_row, new_col = current_row + dr, current_col + dc\n\n            if (0 <= new_row < len(maze) and\n                0 <= new_col < len(maze[0]) and\n                maze[new_row][new_col] == 0 and\n                (new_row, new_col) not in visited):\n                queue.append(((new_row, new_col), path + [direction]))\n\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Apply deductions to income\n    if deductions <= 1000:\n        taxable_income = income - deductions\n    elif deductions <= 3000:\n        taxable_income = income - 1000 - (deductions - 1000) / 2\n    else:\n        taxable_income = income - 1000 - 1000 - (deductions - 3000) / 3\n\n    # Calculate tax based on progressive rates\n    tax = 0\n    if taxable_income <= 10000:\n        tax = 0\n    elif taxable_income <= 35000:\n        tax = (taxable_income - 10000) * 0.15\n    elif taxable_income <= 80000:\n        tax = (25000 * 0.15) + (taxable_income - 35000) * 0.25\n    else:\n        tax = (25000 * 0.15) + (45000 * 0.25) + (taxable_income - 80000) * 0.30\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    def is_palindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    unique_palindromes = set()\n\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i:j + 1]\n            if is_palindrome(substring):\n                unique_palindromes.add(substring)\n\n    return sorted(unique_palindromes)\n"}
{"task_id": "EvoEval/30", "completion": "\n    from collections import deque\n\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 1\n\n    queue = deque([(start, [start])])\n    visited = set()\n    visited.add(start)\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) == end:\n            return path\n\n        for dx, dy in directions:\n            next_x, next_y = current_x + dx, current_y + dy\n            if is_valid(next_x, next_y) and (next_x, next_y) not in visited:\n                visited.add((next_x, next_y))\n                queue.append(((next_x, next_y), path + [(next_x, next_y)]))\n\n    return []\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[1] * n for _ in range(m)]\n    \n    # Fill the array\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    return dp[m - 1][n - 1]\n"}
{"task_id": "EvoEval/32", "completion": "\n    playlist_length = len(playlist)\n    for i in range(playlist_length):\n        if \"Rock\" in playlist[i]:\n            continue\n        swap_index = seed % playlist_length\n        playlist[i], playlist[swap_index] = playlist[swap_index], playlist[i]\n        seed = (seed * 16807) % 2147483647\n    return playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    dp = [0] * (n + 1)\n    dp[0] = 1  # There's one way to stay at the ground (do nothing)\n\n    for step in range(1, n + 1):\n        for power in magic_stones:\n            if step - power >= 0:\n                dp[step] += dp[step - power]\n\n    return dp[n]\n"}
{"task_id": "EvoEval/34", "completion": "\n    percentages = []\n    \n    for day in range(1, n + 1):\n        if day < m:\n            percentage = (day - 1) * 10\n        elif day == m:\n            percentage = min((day - 1) * 10 * 2, 100)\n        else:\n            percentage = max(100 - (day - m) * 10, 0)\n        \n        percentages.append(percentage)\n    \n    return percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if email.count('@') != 1:\n        return False\n    if email.startswith('@') or email.endswith('@'):\n        return False\n    local_part, domain_part = email.split('@')\n    if '.' not in domain_part:\n        return False\n    return True\n"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coeffs = [0]  # Start with the constant of integration set to zero\n    for i, coeff in enumerate(xs):\n        integral_coeffs.append(coeff / (i + 1))\n    return integral_coeffs\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = []\n\n    for char in s:\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed.append(next_vowel.upper() if char.isupper() else next_vowel)\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            transformed.append(next_consonant.upper() if char.isupper() else next_consonant)\n        else:\n            transformed.append(char)\n\n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticon_dict = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \"\ud83d\ude00\",\n        \";)\": \"\ud83d\ude09\"\n    }\n    \n    for text_emoticon, emoji in emoticon_dict.items():\n        sentence = sentence.replace(text_emoticon, emoji)\n    \n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Create the repeated string\n    repeated_string = ''.join(char * n for char in s)\n    \n    # Create the framed rows\n    framed_row = '*' + repeated_string + '*'\n    \n    # Create the bottom border\n    bottom_border = '*' * (len(framed_row))\n    \n    # Return the result as a list of strings\n    return [framed_row] * n + [bottom_border]\n"}
{"task_id": "EvoEval/40", "completion": "\n    from itertools import combinations\n\n    def parse_potion(potion):\n        name, power = potion.rsplit(' ', 1)\n        return name, int(power)\n\n    potions = [parse_potion(potion) for potion in potions]\n    potions.sort(key=lambda x: (x[1], x[0]))  # Sort by power level, then by name\n\n    best_combination = None\n\n    for r in range(1, len(potions) + 1):\n        for combo in combinations(potions, r):\n            total_power = sum(p[1] for p in combo)\n            if total_power == target:\n                if best_combination is None or len(combo) < len(best_combination) or (len(combo) == len(best_combination) and sorted(combo) < sorted(best_combination)):\n                    best_combination = combo\n\n    if best_combination is None:\n        return []\n\n    return sorted([f\"{name} {power}\" for name, power in best_combination])\n"}
{"task_id": "EvoEval/41", "completion": "\n    from collections import deque\n\n    def is_valid(x, y):\n        return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_energy = [[float('inf')] * len(arr[0]) for _ in range(len(arr))]\n    min_energy[0][0] = arr[0][0]\n    queue = deque([(0, 0)])\n\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                new_energy = min_energy[x][y] + arr[nx][ny]\n                if new_energy < min_energy[nx][ny]:\n                    min_energy[nx][ny] = new_energy\n                    queue.append((nx, ny))\n\n    safe_cell_energy = float('inf')\n    for i in range(len(arr)):\n        for j in range(len(arr[0])):\n            if arr[i][j] == 0:\n                safe_cell_energy = min(safe_cell_energy, min_energy[i][j])\n\n    return safe_cell_energy\n"}
{"task_id": "EvoEval/42", "completion": "\n    def find_legendary_item(player_input):\n    if not player_input:\n        return (False, None)\n    \n    player_input = list(set(player_input))  # Remove duplicates\n    has_legendary = 5 in player_input\n    \n    if has_legendary:\n        player_input.remove(5)  # Remove legendary item\n        if player_input:\n            second_most_valuable = max(player_input)\n            return (True, second_most_valuable)\n        else:\n            return (True, -1)\n    \n    return (False, None)\n"}
{"task_id": "EvoEval/43", "completion": "\n    trip_duration = distance / speed\n    fuel_consumption_per_year = spaceship_weight * planet_gravity * 0.1\n    total_fuel_consumed = fuel_consumption_per_year * trip_duration\n\n    if fuel < trip_duration:\n        return 'Insufficient fuel'\n    \n    remaining_fuel = fuel - total_fuel_consumed\n    return round(remaining_fuel, 2)\n"}
{"task_id": "EvoEval/44", "completion": "\n    def fairy_tale_transport(q, w, e):\n    total_weight = sum(q)\n    unicorn_capacity = w\n    dragon_griffin_capacity = 2 * e  # dragons and griffins together\n    \n    # Calculate the total carrying capacity\n    total_capacity = unicorn_capacity + dragon_griffin_capacity\n    \n    return total_weight <= total_capacity\n"}
{"task_id": "EvoEval/45", "completion": "\n    def count_visible_hills(index):\n        count = 0\n        height = arr[index]\n\n        # Count visible hills to the left\n        for i in range(index - 1, -1, -1):\n            if arr[i] < height:\n                count += 1\n            elif arr[i] == height:\n                count += 1\n                break\n            else:\n                break\n\n        # Count visible hills to the right\n        for i in range(index + 1, len(arr)):\n            if arr[i] < height:\n                count += 1\n            elif arr[i] == height:\n                count += 1\n                break\n            else:\n                break\n\n        return count\n\n    max_visible = 0\n    for i in range(len(arr)):\n        visible_count = count_visible_hills(i)\n        max_visible = max(max_visible, visible_count)\n\n    return max_visible\n"}
{"task_id": "EvoEval/46", "completion": "\n    def hidden_message(test_cases):\n    secret_messages = []\n    for case in test_cases:\n        message = ''.join(word[0].lower() for word in case if word and word[0].isalpha())\n        if 't' in message and 'a' in message and 'k' in message and 'e' in message and 'c' in message and 'n' in message and 'o' in message and 'l' in message and 'i' in message:\n            secret_messages.append(\"Take the cannoli.\")\n        else:\n            secret_messages.append(message)\n    return secret_messages\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if available.get(ingredient, 0) < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    def wizard_inventory(inventory_logs):\n    inventory = {}\n    \n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        \n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n            \n    # Remove items with zero or negative quantity\n    final_inventory = {item: qty for item, qty in inventory.items() if qty > 0}\n    \n    return final_inventory\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code_dict = {\n        '01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F',\n        '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L',\n        '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R',\n        '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X',\n        '1011': 'Y', '1100': 'Z', '01111': '2', '00111': '3', '00011': '4',\n        '00001': '5', '00000': '6', '10000': '7', '11000': '8', '11100': '9',\n        '11110': '0', '11111': ' '\n    }\n\n    words = msg.split('/')\n    decoded_message = []\n\n    for word in words:\n        characters = word.split()\n        decoded_word = ''.join(morse_code_dict.get(char, '') for char in characters)\n        decoded_message.append(decoded_word)\n\n    return ' '.join(decoded_message)\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',\n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',\n        '8': '---..', '9': '----.', ' ': ' '\n    }\n    \n    text = text.upper()\n    morse_code = []\n    \n    for char in text:\n        if char in morse_code_dict:\n            morse_code.append(morse_code_dict[char])\n    \n    return ' '.join(morse_code)\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not string:\n        return \"\"\n    if not list_of_alphabets:\n        return string\n\n    encoded_string = []\n    for i, char in enumerate(string):\n        encoded_char = list_of_alphabets[i % len(list_of_alphabets)]\n        encoded_string.append(encoded_char)\n\n    return ''.join(encoded_string)\n"}
{"task_id": "EvoEval/52", "completion": "\n    total_batches = m\n    total_cookies = n * total_batches\n    fulfilled_orders = 0\n\n    for order in orders:\n        if order <= total_cookies:\n            fulfilled_orders += 1\n            total_cookies -= order\n\n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = \"aeiouAEIOU\"\n    next_vowel = str.maketrans(\"aeiouAEIOU\", \"eiouaEIOUA\")\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    next_consonant = str.maketrans(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\", \n                                    \"cdfghjklmnpqrstvwxyzbCDFGHJKLMNPQRSTVWXYZA\")\n    \n    transformed = []\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            transformed.append(char.translate(next_vowel))\n        elif char in consonants:\n            transformed.append(char.translate(next_consonant))\n        elif char == '?':\n            transformed.append('!' if i % 2 == 1 else '?')\n        else:\n            transformed.append(char)\n    \n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/54", "completion": "\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                coordinates.append((i, j))\n    return coordinates\n"}
{"task_id": "EvoEval/55", "completion": "\n    encrypted_message = []\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift_amount = shift + i\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n            encrypted_message.append(new_char)\n        else:\n            encrypted_message.append(char)\n    return ''.join(encrypted_message)\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {\n        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.',\n        'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..',\n        'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.',\n        's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-',\n        'y': '-.--', 'z': '--..', ' ': '/'\n    }\n    \n    morse_code = ''\n    for char in s:\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    \n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    transformed_menu = {}\n    spell_length = len(magic_spell)\n\n    for dish, price in menu.items():\n        transformed_dish = ''.join(magic_spell[i % spell_length] for i in range(len(dish)))\n        transformed_menu[transformed_dish] = price\n\n    return transformed_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    \n    def translate_word(word):\n        if not word:\n            return ''\n        \n        first_char = word[0]\n        translated_word = ''\n        \n        for char in word:\n            if char in vowels:\n                translated_word += vowels[(vowels.index(char) + 1) % len(vowels)]\n            elif char in consonants:\n                translated_word += consonants[(consonants.index(char) + 1) % len(consonants)]\n            else:\n                translated_word += char  # This should not happen as per the problem statement\n        \n        if first_char in vowels:\n            translated_word += 'xy'\n        else:\n            translated_word += 'yz'\n        \n        return translated_word.capitalize()\n    \n    words = earth_phrase.split(' ')\n    translated_words = [translate_word(word) for word in words]\n    \n    return '@'.join(translated_words)\n"}
{"task_id": "EvoEval/59", "completion": "\n    if not ingredient_dict:\n        return []\n    \n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_ingredients\n"}
{"task_id": "EvoEval/60", "completion": "\n    sugar_set = set(sugar_locations)\n    happy_count = 0\n\n    for position, direction in ant_positions:\n        if direction == \"right\":\n            for pos in range(position, path_length):\n                if pos in sugar_set:\n                    happy_count += 1\n                    sugar_set.remove(pos)\n        elif direction == \"left\":\n            for pos in range(position, -1, -1):\n                if pos in sugar_set:\n                    happy_count += 1\n                    sugar_set.remove(pos)\n\n    return happy_count\n"}
{"task_id": "EvoEval/61", "completion": "\n    def transform_string(s):\n    vowels = 'aeiou'\n    next_vowel = {vowels[i]: vowels[(i + 1) % len(vowels)] for i in range(len(vowels))}\n    prev_consonant = {chr(i): chr(i - 1) for i in range(ord('b'), ord('z') + 1)}\n    prev_consonant['b'] = 'z'\n    prev_consonant['B'] = 'Z'\n    \n    result = []\n    \n    for i, char in enumerate(s):\n        if char.isalpha():\n            if i % 2 == 1:  # Odd index\n                char = char.swapcase()\n            if char.lower() in next_vowel:\n                char = next_vowel[char.lower()]\n            elif char.lower() in prev_consonant:\n                char = prev_consonant[char.lower()]\n        result.append(char)\n    \n    return ''.join(result)\n"}
{"task_id": "EvoEval/62", "completion": "\n    def recipe_converter(recipe, conversion_factor):\n    return {ingredient: quantity * conversion_factor for ingredient, quantity in recipe.items()}\n"}
{"task_id": "EvoEval/63", "completion": "\n    layers = []\n    while p > 0:\n        layers.append(p)\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n    return layers[::-1]\n"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [num for num in range(start, end + 1) if num % divisor == 0 and is_prime(num)]\n"}
{"task_id": "EvoEval/65", "completion": "\n    if not order:\n        return menu\n\n    final_order = {}\n\n    for food, ingredients in menu.items():\n        if food in order:\n            modifications = order[food]\n            modified_ingredients = ingredients[:]\n\n            if \"remove\" in modifications:\n                for ingredient in modifications[\"remove\"]:\n                    if ingredient in modified_ingredients:\n                        modified_ingredients.remove(ingredient)\n\n            if \"add\" in modifications:\n                for ingredient in modifications[\"add\"]:\n                    modified_ingredients.append(ingredient)\n\n            final_order[food] = modified_ingredients\n        else:\n            final_order[food] = ingredients\n\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def are_anagrams(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    primes = [i for i in range(2, n) if is_prime(i)]\n    anagram_pairs = []\n\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if are_anagrams(primes[i], primes[j]):\n                anagram_pairs.append((primes[i], primes[j]))\n\n    return sorted(anagram_pairs)\n"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum(meal['calories'] for meal in meals[customer])\n            result[customer] = total_calories\n        else:\n            result[customer] = 0\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n\n    # Check if already sorted\n    if arr == sorted_arr:\n        return True\n\n    # Check for the number of positions where arr and sorted_arr differ\n    diff_indices = [i for i in range(n) if arr[i] != sorted_arr[i]]\n\n    # If there are more than 4 differences, we cannot fix it with one swap\n    if len(diff_indices) > 4:\n        return False\n\n    # If there are exactly 2 differences, we can swap them\n    if len(diff_indices) == 2:\n        i, j = diff_indices\n        arr[i], arr[j] = arr[j], arr[i]\n        return arr == sorted_arr\n\n    # If there are exactly 3 differences, we cannot fix it with one swap\n    if len(diff_indices) == 3:\n        return False\n\n    # If there is exactly 1 difference, we cannot fix it with one swap\n    if len(diff_indices) == 1:\n        return False\n\n    return False\n"}
{"task_id": "EvoEval/69", "completion": "\n    card_indices = {}\n    \n    for index, card in enumerate(cards):\n        if card != 0 and magicNumber % card == 0:\n            complement = magicNumber // card\n            if complement in card_indices:\n                return (card_indices[complement], index)\n            card_indices[card] = index\n            \n    return \"No magic today\"\n"}
{"task_id": "EvoEval/70", "completion": "\n    if not planets or not path:\n        return False\n    \n    for i in range(len(path) - 1):\n        if path[i] not in planets or path[i + 1] not in planets[path[i]]:\n            return False\n            \n    return True\n"}
{"task_id": "EvoEval/71", "completion": "\n    def shift_char(c, n):\n        if c.isalpha():\n            start = ord('a') if c.islower() else ord('A')\n            return chr(start + (ord(c) - start + n) % 26)\n        return c\n\n    encrypted_string = ''.join(shift_char(c, n) for c in s)\n    vowel_count = sum(1 for c in encrypted_string.lower() if c in 'aeiou')\n    \n    return (encrypted_string, vowel_count)\n"}
{"task_id": "EvoEval/72", "completion": "\n    result = []\n    for item in lst:\n        count_digits = sum(c.isdigit() for c in item)\n        story = f\"Once upon a time, in a kingdom far away, lived a magical creature named '{item}' known for telling {count_digits} tales a day.\"\n        result.append(story)\n    return result\n"}
{"task_id": "EvoEval/73", "completion": "\n    total_treasures = sum(sum(row) for row in grid)\n    \n    if total_treasures == 0:\n        return 0\n    \n    trips_per_chamber = math.ceil(total_treasures / bag_capacity)\n    total_trips = trips_per_chamber * 2  # Going in and out for each trip\n    \n    return total_trips\n"}
{"task_id": "EvoEval/74", "completion": "\n    if not s:\n        return \"\"\n    \n    return ''.join(cipher.get(char, char) for char in s)\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n\n    for index, char in enumerate(input_str):\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            result.append(next_vowel.upper() if char.isupper() else next_vowel)\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            result.append(next_consonant.upper() if char.isupper() else next_consonant)\n        elif char.isdigit():\n            next_digit = str((int(char) + 1) % 10)\n            result.append(next_digit)\n        elif char in ['?', '!']:\n            if index % 2 == 0:\n                result.append('!' if char == '?' else '?')\n            else:\n                result.append('?' if char == '!' else '!')\n        else:\n            result.append(char)\n\n    return ''.join(result)\n"}
{"task_id": "EvoEval/76", "completion": "\n    def create_pyramid(lst):\n    if not lst:\n        return []\n    \n    pyramid = []\n    for num in reversed(lst):\n        pyramid.append('#' * num)\n    \n    return pyramid\n"}
{"task_id": "EvoEval/77", "completion": "\n    def points(n, k):\n        count = 0\n        while n > 1:\n            n //= k\n            count += 1\n        return count\n\n    total_points = [points(num, k) for num in sequence]\n    return sorted(total_points, reverse=True)\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    if n % 2 == 0:\n        raise ValueError(\"Matrix dimension must be an odd number.\")\n    \n    pattern = []\n    \n    for i in range(n):\n        row = []\n        for j in range(n):\n            if j == i or j == n - 1 - i:\n                row.append(mat[i][j])\n            else:\n                row.append(\" \")\n        pattern.append(row)\n    \n    return pattern\n"}
{"task_id": "EvoEval/79", "completion": "\n    max_profit = 0\n    for i in range(days):\n        for j in range(i + 1, days):\n            profit = prices[j] - prices[i]\n            if profit > max_profit:\n                max_profit = profit\n    return max_profit\n"}
{"task_id": "EvoEval/80", "completion": "\n    def adventure_game(game_map, instructions):\n    # Find the starting position\n    start_row, start_column = next((r, c) for r, row in enumerate(game_map) for c, val in enumerate(row) if val == 'S')\n    path = [(start_row, start_column)]\n    current_position = (start_row, start_column)\n\n    # Define movement directions\n    directions = {\n        'up': (-1, 0),\n        'down': (1, 0),\n        'left': (0, -1),\n        'right': (0, 1)\n    }\n\n    for instruction in instructions:\n        if current_position == (start_row, start_column) and len(path) == 1 and game_map[start_row][start_column] == 'S':\n            path.append(current_position)\n\n        # Calculate new position\n        move = directions.get(instruction)\n        if move:\n            new_row = current_position[0] + move[0]\n            new_column = current_position[1] + move[1]\n\n            # Check if new position is within bounds\n            if 0 <= new_row < len(game_map) and 0 <= new_column < len(game_map[0]):\n                # Check if new position is not a wall\n                if game_map[new_row][new_column] != 'X':\n                    current_position = (new_row, new_column)\n\n        # Add current position to path\n        path.append(current_position)\n\n        # Check if player has reached the end\n        if game_map[current_position[0]][current_position[1]] == 'E':\n            break\n\n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n\n    # Create a mapping of each character to its index in the alien dictionary\n    index_map = {char: index for index, char in enumerate(alien_dictionary)}\n\n    # Convert words to their corresponding indices based on the alien dictionary\n    def convert_word(word):\n        return [index_map[char] for char in word]\n\n    # Check if the list of words is sorted\n    for i in range(len(word_list) - 1):\n        if convert_word(word_list[i]) > convert_word(word_list[i + 1]):\n            return \"INCORRECT\"\n\n    return \"CORRECT\"\n"}
{"task_id": "EvoEval/82", "completion": "\n    if not birthdays:\n        return None\n\n    zodiac_signs = {\n        \"Aries\": (\"03-21\", \"04-19\", \"Fire\"),\n        \"Taurus\": (\"04-20\", \"05-20\", \"Earth\"),\n        \"Gemini\": (\"05-21\", \"06-20\", \"Air\"),\n        \"Cancer\": (\"06-21\", \"07-22\", \"Water\"),\n        \"Leo\": (\"07-23\", \"08-22\", \"Fire\"),\n        \"Virgo\": (\"08-23\", \"09-22\", \"Earth\"),\n        \"Libra\": (\"09-23\", \"10-22\", \"Air\"),\n        \"Scorpio\": (\"10-23\", \"11-21\", \"Water\"),\n        \"Sagittarius\": (\"11-22\", \"12-21\", \"Fire\"),\n        \"Capricorn\": (\"12-22\", \"01-19\", \"Earth\"),\n        \"Aquarius\": (\"01-20\", \"02-18\", \"Air\"),\n        \"Pisces\": (\"02-19\", \"03-20\", \"Water\"),\n    }\n\n    elements = {\n        \"Fire\": [],\n        \"Earth\": [],\n        \"Air\": [],\n        \"Water\": []\n    }\n\n    for birthday in birthdays:\n        month_day = birthday[5:10]\n        for sign, (start, end, element) in zodiac_signs.items():\n            if (start <= month_day <= end) or (start > end and (month_day >= start or month_day <= end)):\n                elements[element].append(birthday)\n                break\n\n    return {element: len(birthdays) for element, birthdays in elements.items() if birthdays}\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s_list[left] in vowels and s_list[right] in vowels:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n        if s_list[left] not in vowels:\n            left += 1\n        if s_list[right] not in vowels:\n            right -= 1\n\n    return ''.join(s_list)\n"}
{"task_id": "EvoEval/84", "completion": "\n    def tree_traversal(tree):\n    def dfs(node, path):\n        if not node:\n            return\n        path.append(node)\n        if not tree[node]:  # If there are no children\n            paths.append(path.copy())\n        else:\n            for child in tree[node]:\n                dfs(child, path)\n        path.pop()  # Backtrack\n\n    paths = []\n    root = next(iter(tree))  # Get the root node\n    dfs(root, [])\n    return paths\n"}
{"task_id": "EvoEval/85", "completion": "\n    from collections import deque\n\n    rows, cols = len(grid), len(grid[0])\n    if grid[0][0] == 1 or grid[coord[0]][coord[1]] == 1:\n        return -1\n\n    queue = deque([(0, 0, 0)])  # (row, col, moves)\n    visited = set((0, 0))\n\n    while queue:\n        r, c, moves = queue.popleft()\n\n        if (r, c) == coord:\n            return moves\n\n        for dr, dc in [(1, 0), (0, 1)]:  # down, right\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0:\n                visited.add((nr, nc))\n                queue.append((nr, nc, moves + 1))\n\n    return -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    def sort_movies_by_ratings_and_release_date(movies_dict):\n    sorted_movies = sorted(movies_dict.items(), key=lambda item: (-item[1][0], -item[1][1]))\n    return [movie[0] for movie in sorted_movies]\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr or not arr[0]:\n        return \"\"\n    \n    result = []\n    top, bottom = 0, len(arr) - 1\n    left, right = 0, len(arr[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result.append(arr[top][i])\n        top += 1\n\n        # Traverse from top to bottom\n        for i in range(top, bottom + 1):\n            result.append(arr[i][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse from right to left\n            for i in range(right, left - 1, -1):\n                result.append(arr[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse from bottom to top\n            for i in range(bottom, top - 1, -1):\n                result.append(arr[i][left])\n            left += 1\n\n    return ''.join(result)\n"}
{"task_id": "EvoEval/88", "completion": "\n    def planet_population(dict_of_planets):\n    if not dict_of_planets:\n        return {}\n    \n    population_density = {}\n    \n    for planet, features in dict_of_planets.items():\n        population, size = features\n        if isinstance(population, int) and isinstance(size, int) and size > 0:\n            density = round(population / size, 2)\n            population_density[planet] = density\n    \n    return population_density\n"}
{"task_id": "EvoEval/89", "completion": "\n    remaining_aliens = []\n    for alien in aliens:\n        if alien == ray:\n            remaining_aliens.append(alien)\n        elif alien == ray - 1 or alien == ray + 1:\n            continue\n        elif alien % 2 == 1:\n            continue\n        remaining_aliens.append(alien)\n    return remaining_aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    def get_combinations(digits1, digits2):\n        from itertools import product\n        return [sum(comb) for comb in product(digits1, digits2)]\n\n    digits1 = [int(d) for d in s1]\n    digits2 = [int(d) for d in s2]\n    \n    combinations_sum = get_combinations(digits1, digits2)\n    \n    return sum(combinations_sum)\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n\n    for action, distance in spaceship_data:\n        if action == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Move':\n            if status == 'In Space':\n                continue  # Moving is valid in space\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status == 'In Space':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    result = []\n    for i in range(n):\n        letter = chr(ord('A') + (i % 26))\n        layer = letter * (2 * i + 1)\n        centered_layer = layer.center(2 * n - 1)\n        result.append(centered_layer)\n    return '\\n'.join(result)\n"}
{"task_id": "EvoEval/93", "completion": "\n    encoded_message = []\n    n_length = len(n_values)\n\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift = n_values[i % n_length]\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n\n    return ''.join(encoded_message)\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(spell.split(), key=lambda word: (len(word), spell.split().index(word)))) for spell in strings]\n"}
{"task_id": "EvoEval/95", "completion": "\n    if not all(len(row) == len(m) for row in m):\n        return 'Invalid Matrix'\n    \n    n = len(m)\n    primary_diagonal_sum = sum(m[i][i] for i in range(n))\n    secondary_diagonal_sum = sum(m[i][n - i - 1] for i in range(n))\n    \n    return abs(primary_diagonal_sum - secondary_diagonal_sum)\n"}
{"task_id": "EvoEval/96", "completion": "\n    def product_of_digits(n):\n        n = abs(n)\n        product = 1\n        while n > 0:\n            product *= n % 10\n            n //= 10\n        return product\n\n    magic_indices = []\n    for index, value in enumerate(lst):\n        if value % index == 0 and product_of_digits(value) == index:\n            magic_indices.append(index)\n\n    return sorted(magic_indices)\n"}
{"task_id": "EvoEval/97", "completion": "\n    def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n\n    encounter_order = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n    encountered_humans = []\n\n    for continent in encounter_order:\n        for human, location in humans.items():\n            if location == continent:\n                encountered_humans.append(human)\n\n    return encountered_humans\n"}
{"task_id": "EvoEval/98", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sequence = [a, b]\n    for i in range(1, n - 1):\n        next_number = sequence[i] + sequence[i - 1] + (i + 1)\n        sequence.append(next_number)\n\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    current_position = 0\n\n    for round_time in rounds:\n        # Calculate the position of the player to be eliminated\n        current_position = (current_position + (round_time * music) - 1) % len(players)\n        players.pop(current_position)\n\n    return players\n"}
