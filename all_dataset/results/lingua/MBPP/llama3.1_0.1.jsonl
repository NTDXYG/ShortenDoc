{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    s.remove(ch)\n    s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum)\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the text into words\n    words = words.split()\n    # Count the frequency of each word\n    word_count = Counter(words)\n    # Get the most common word and its count\n    most_common = word_count.most_common(1)\n    # Return the count of the most common word\n    return most_common[0][1]\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'([a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'(\\w)(\\w)', r'\\1_\\2', text).lower()\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string2]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # Check if number is less than 1\n    if x < 1:\n        return False\n    # Check if number is 1\n    elif x == 1:\n        return True\n    # Check if number is even\n    elif x % 2 == 0:\n        return False\n    # Check if number is woodall\n    else:\n        # Calculate woodall number\n        woodall_num = 2 * (2 ** (x - 1)) - 1\n        # Check if number is equal to woodall number\n        if x == woodall_num:\n            return True\n        else:\n            return False\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i * n for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            return num\n        num_set.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(lst) for lst in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize product as 1\n    product = 1\n    # Iterate over the dictionary\n    for num, count in freq.items():\n        # If the count is 1, multiply the product by the number\n        if count == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # Taking advantage of symmetry\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element with odd frequency is found\n    return -1\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a heap to store the integers and their frequencies\n    heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(heap, (-count, num))\n\n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        if heap:\n            top_k.append(heapq.heappop(heap)[1])\n\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    # Initialize the largest prime factor\n    max_prime_factor = 1\n\n    # Iterate from 2 to sqrt(n)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # Update the largest prime factor\n            max_prime_factor = i\n            # Divide n by i\n            n = n // i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        # Update the largest prime factor\n        max_prime_factor = n\n\n    return max_prime_factor\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    for i in range(N - 1):\n        if ar[i + 1] - ar[i] > 1:\n            return ar[i] + 1\n    return ar[-1] + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    # Initialize the counter and the current number\n    count = 0\n    num = 1\n\n    # Loop until we find the n-th rectangular number\n    while True:\n        # Check if the current number is a rectangular number\n        if is_rectangular(num):\n            # If it is, increment the counter\n            count += 1\n            # If the counter is equal to n, return the current number\n            if count == n:\n                return num\n        # If the current number is not a rectangular number, increment it\n        num += 1\n\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a decimal\n    decimal = p / q\n    # Convert the decimal to a string\n    decimal_str = str(decimal)\n    # Remove the leading 0.\n    decimal_str = decimal_str[2:]\n    # Find the Nth digit\n    Nth_digit = decimal_str[N-1]\n    return Nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate integers and strings into two lists\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort integers and strings separately\n    integers.sort()\n    strings.sort()\n\n    # Combine sorted integers and strings into a single list\n    sorted_list = integers + strings\n\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even = 0\n    odd = 0\n    for i in list1:\n        if i % 2 == 0:\n            even = i\n        else:\n            odd = i\n    if even == 0:\n        return \"No even number found\"\n    elif odd == 0:\n        return \"No odd number found\"\n    else:\n        return even / odd\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    while len(max_heap) > 1:\n        freq1, char1 = heapq.heappop(max_heap)\n        freq2, char2 = heapq.heappop(max_heap)\n        if freq1 + 1 < 0:\n            heapq.heappush(max_heap, (freq1 + 1, char1))\n        if freq2 + 1 < 0:\n            heapq.heappush(max_heap, (freq2 + 1, char2))\n        if -freq1 == 1 and -freq2 == 1:\n            return False\n    return True\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = list(chain(*nums))\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"[a-z]+_[a-z]+\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in x[1:]:\n        result = gcd(result, i)\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) != len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(A) % factorial(B)\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n >> 1\n"}
{"task_id": "MBPP/49", "completion": "\n    return [nums[i][0] for i in range(N)]\n\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if str[0] == str[-1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum element in the array\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrences of each element in the array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, len(count_array)):\n        count_array[i] += count_array[i - 1]\n    \n    # Create a sorted array\n    sorted_array = [0] * len(my_list)\n    \n    # Build the sorted array\n    for num in my_list:\n        sorted_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return sorted_array\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    rev_num = rev(n) return n == 2 * rev_num - 1"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    return int(''.join(map(str, arr)))\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 1) // 2\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n\n    max_len = 1\n    curr_len = 1\n\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] == 1:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n\n    return max(max_len, curr_len)\n\n"}
{"task_id": "MBPP/61", "completion": "\n    # Initialize a dictionary to store the frequency of each substring sum\n    freq = defaultdict(int)\n    # Initialize the count of substrings with sum equal to their length\n    count = 0\n    # Iterate over all possible substring lengths\n    for length in range(1, n + 1):\n        # Iterate over all possible substrings of the current length\n        for i in range(n - length + 1):\n            # Calculate the sum of the current substring\n            substring_sum = sum(int(digit) for digit in s[i:i + length])\n            # If the sum of the current substring is equal to its length, increment the count\n            if substring_sum == length:\n                count += 1\n            # Increment the frequency of the current substring sum\n            freq[substring_sum] += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize max_diff with negative infinity\n    max_diff = float('-inf')\n    \n    # Iterate over the sorted list to find the maximum difference\n    for i in range(1, len(test_list)):\n        # Calculate the difference between current and previous element\n        diff = test_list[i] - test_list[i-1]\n        \n        # Update max_diff if current difference is greater\n        max_diff = max(max_diff, diff)\n    \n    # Return the maximum difference found\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n\nsubjectmarks = [('Maths', 90), ('Science', 85), ('English', 95)]"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [0, 1, 1]\n    for i in range(2, n):\n        bell.append(bell[i-1] + sum(bell[:i-1]))\n    return bell[n-1]  # return the nth Bell number\n\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n    for i in range(1, n):\n        if A[i] < A[i - 1]:\n            increasing = False\n        if A[i] > A[i - 1]:\n            decreasing = False\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in (l[i:i+len(s)] for i in range(len(l)-len(s)+1))\n"}
{"task_id": "MBPP/70", "completion": "\n    # Check if the input is a list\n    if not isinstance(Input, list):\n        raise TypeError(\"Input should be a list of tuples.\")\n    \n    # Check if all elements in the list are tuples\n    if not all(isinstance(i, tuple) for i in Input):\n        raise TypeError(\"All elements in the list should be tuples.\")\n    \n    # Check if all tuples have the same length\n    if len(set(map(len, Input))) != 1:\n        return False\n    \n    # Check if all tuples have length k\n    if len(Input[0]) != k:\n        return False\n    \n    return True\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    else:\n        return (n + 1) % 8 == 0\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,\\s]+'\n    # Split the text using the delimiters\n    result = re.split(delimiters, text)\n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m * n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum - odd_sum\n"}
{"task_id": "MBPP/78", "completion": "\n    # Initialize count of integers with odd number of set bits\n    count = 0\n    # Iterate over all possible integers\n    for i in range(1, 2**32):\n        # Count the number of set bits in the integer\n        set_bits = bin(i).count('1')\n        # If the number of set bits is odd, increment the count\n        if set_bits % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return dict(freq)\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max([i for i in range(1, N) if i < N])\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to string to check each digit\n    str_n = str(n)\n    # Check if the number has at least 3 digits\n    if len(str_n) < 3:\n        return False\n    # Check if the number is undulating\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is greater than the next digit\n        if int(str_n[i]) > int(str_n[i + 1]):\n            # If the current digit is greater than the next digit, check if the next digit is greater than the digit after the next digit\n            if i < len(str_n) - 2 and int(str_n[i + 1]) > int(str_n[i + 2]):\n                continue\n            else:\n                return False\n        # Check if the current digit is less than the next digit\n        elif int(str_n[i]) < int(str_n[i + 1]):\n            # If the current digit is less than the next digit, check if the next digit is less than the digit after the next digit\n            if i < len(str_n) - 2 and int(str_n[i + 1]) < int(str_n[i + 2]):\n                continue\n            else:\n                return False\n        # If the current digit is equal to the next digit, return False\n        else:\n            return False\n    # If the number passes all checks, return True\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    # Return the index of the first tuple in the sorted list\n    return sorted_list[0][0]\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_list = lst[i:j]\n            if len(sub_list) < min_length:\n                min_length = len(sub_list)\n    return min_length\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('[_-]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    # Initialize the result\n    result = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the number of divisors of i\n        num_divisors = 0\n        for j in range(1, int(i ** 0.5) + 1):\n            if i % j == 0:\n                if i // j == j:\n                    num_divisors += 1\n                else:\n                    num_divisors += 2\n        \n        # Add the number of divisors to the result\n        result += num_divisors\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/104", "completion": "\n    return sorted(input_list, key=lambda x: x[0])\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup_list = list(test_tup)\n    # Add the list to the tuple list\n    test_tup_list.extend(test_list)\n    # Convert the list back to a tuple\n    test_tup_list = tuple(test_tup_list)\n    return test_tup_list\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap to store the elements from the three lists\n    min_heap = []\n    # Push the first element from each list into the heap along with the list index and element index\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 1, 0))\n    heapq.heappush(min_heap, (num3[0], 2, 0))\n\n    # Initialize an empty list to store the merged result\n    merged_list = []\n\n    # Continue the process until the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, list_index, element_index = heapq.heappop(min_heap)\n        # Push the next element from the same list into the heap\n        if element_index + 1 < len(num1) and num1[element_index + 1] < val:\n            heapq.heappush(min_heap, (num1[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num2) and num2[element_index + 1] < val:\n            heapq.heappush(min_heap, (num2[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num3) and num3[element_index + 1] < val:\n            heapq.heappush(min_heap, (num3[element_index + 1], list_index, element_index + 1))\n        # Append the popped element into the merged list\n        merged_list.append(val)\n\n    return merged_list\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(int(s[i:], 2) + int(s[:i], 2)).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_list = []\n    for i in range(strt_val, stop_val + 1):\n        if i not in test_list:\n            missing_list.append(i)\n    return missing_list\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n\nnestedlist = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for dict1 in list1:\n        if dict1:\n            return False\n    return True\n"}
{"task_id": "MBPP/116", "completion": "\n    # Convert the tuple into a list\n    nums_list = list(nums)\n    \n    # Multiply the numbers in the list\n    result = 1\n    for num in nums_list:\n        result *= num\n    \n    return result\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) if isinstance(i, (int, float)) else i for i in test_list]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split(')(')\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if mid == 0 or arr[mid] != arr[mid - 1]:\n            if mid == n - 1 or arr[mid] != arr[mid + 1]:\n                return arr[mid]\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize the list to store smart numbers\n    smartNumbers = []\n    # Initialize the counter\n    count = 0\n    # Initialize the number\n    num = 1\n    # Loop until we find n smart numbers\n    while count < n:\n        # Check if the number is smart\n        if isSmart(num):\n            # If the number is smart, add it to the list\n            smartNumbers.append(num)\n            # Increment the counter\n            count += 1\n        # Increment the number\n        num += 1\n    # Return the nth smart number\n    return smartNumbers[-1]\n\n"}
{"task_id": "MBPP/123", "completion": "\nFind amicable number for given number.\"\"\"\n        sum_of_divisors = sum(i for i in range(1, n) if n % i == 0)\n        return sum_of_divisors if sum_of_divisors != n and sum(i for i in range(1, sum_of_divisors) if sum_of_divisors % i == 0) == n else 0\n\n    amicable_numbers = [find_amicable(i) for i in range(1, limit)]\n    return sum(i for i in amicable_numbers if i != 0)\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    for i in range(n):\n        if string[i] == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        max_diff = max(max_diff, abs(count_0 - count_1))\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Find all divisors of a and b\n    divisors_a = [i for i in range(1, a + 1) if a % i == 0]\n    divisors_b = [i for i in range(1, b + 1) if b % i == 0]\n    \n    # Find common divisors\n    common_divisors = list(set(divisors_a) & set(divisors_b))\n    \n    # Calculate sum of common divisors\n    sum_common_divisors = sum(common_divisors)\n    \n    return sum_common_divisors\n"}
{"task_id": "MBPP/127", "completion": "\n    if x == 0 or y == 0:\n        return 0\n    if x < 0:\n        return -multiply_int(-x, y)\n    if y < 0:\n        return -multiply_int(x, -y)\n    if y == 1:\n        return x\n    if y % 2 == 0:\n        return multiply_int(x, y // 2) + multiply_int(x, y // 2)\n    return multiply_int(x, y // 2) + multiply_int(x, y // 2) + x\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return \"Error: The input is not a square matrix.\"\n\n    # Check if the matrix is a magic square\n    for i in range(len(my_matrix)):\n        # Check each row\n        if sum(my_matrix[i]) != sum(my_matrix[0]):\n            return \"Error: The input is not a magic square.\"\n        # Check each column\n        if sum([my_matrix[j][i] for j in range(len(my_matrix))]) != sum(my_matrix[0]):\n            return \"Error: The input is not a magic square.\"\n    # Check the main diagonal\n    if sum([my_matrix[i][i] for i in range(len(my_matrix))]) != sum(my_matrix[0]):\n        return \"Error: The input is not a magic square.\"\n    # Check the secondary diagonal\n    if sum([my_matrix[i][len(my_matrix) - i - 1] for i in range(len(my_matrix))]) != sum(my_matrix[0]):\n        return \"Error: The input is not a magic square.\"\n    return \"The input is a magic square.\"\n\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store frequency of each item\n    freq_dict = defaultdict(int)\n    for num in nums:\n        freq_dict[num] += 1\n\n    # Find the item with maximum frequency\n    max_freq = max(freq_dict.values())\n    max_items = [item for item, freq in freq_dict.items() if freq == max_freq]\n\n    return max_items\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left = 0\n    right = len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    for _ in range(p):\n        arr[-1] = arr[-1] % n\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    # Define the base rate and the rate per unit\n    base_rate = 100\n    rate_per_unit = 1.20\n\n    # Calculate the total bill\n    total_bill = base_rate + (units * rate_per_unit)\n\n    return total_bill\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of boolean values from the input list\n    bool_array = array('b', [num == 0 for num in nums])\n    \n    # Count the number of True values in the array\n    zero_count = bool_array.count(False)\n    \n    # Return the ratio of zeroes\n    return 1 - (zero_count / len(nums))\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0's\n    return '0' not in binary\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    singly_list = []\n    for i in test_list:\n        if test_list.count(i) == 1:\n            singly_list.append(i)\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find index of maximum element in unsorted part of list\n        max_index = nums.index(max(nums[:size]))\n        \n        # If max element is not at the beginning of unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip max element to the beginning\n            nums[:max_index + 1] = nums[:max_index + 1][::-1]\n            # Flip max element to the end of unsorted part\n            nums[:size] = nums[:size][::-1]\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for same pairs\n    count = 0\n    \n    # Iterate over the first list\n    for i in range(len(list1)):\n        # Iterate over the second list\n        for j in range(len(list2)):\n            # Check if the pair is present in the third list\n            if [list1[i], list2[j]] in list3:\n                # If the pair is found, increment the counter\n                count += 1\n                \n    # Return the count of same pairs\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += abs(arr[i] - arr[j])\n    return sum\n"}
{"task_id": "MBPP/145", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Initialize max_diff as the difference between the last and first element\n    max_diff = arr[n-1] - arr[0]\n    \n    # Iterate over the array to find the maximum difference\n    for i in range(1, n):\n        # Calculate the difference between the current and previous element\n        diff = arr[i] - arr[i-1]\n        \n        # Update max_diff if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 1):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    return sum(int(digit) for digit in str(x))  # convert x to string, iterate over each character (digit), convert it back to integer and sum them up\n\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    n = 1\n    while True:\n        if a in (n, n + 1, n + 2, n + 3):\n            return True\n        n += 4\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1: return x else: a = x[:len(x)//2] b = x[len(x)//2:] return merge(merge_sort(a), merge_sort(b)) # Test the function print(merge_sort([3, 6, 8, 10, 1, 2, 1]))  # Output: [1, 1, 2, 3, 6, 8, 10] "}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    # Initialize an empty list to store the specified elements\n    specified_elements = []\n    \n    # Iterate over each row in the 2D list\n    for row in nums:\n        # Iterate over each element in the row\n        for element in row:\n            # Check if the element is specified (i.e., it is equal to N)\n            if element == N:\n                # If the element is specified, add it to the list of specified elements\n                specified_elements.append(element)\n    \n    # Return the list of specified elements\n    return specified_elements\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    if not list1:\n        return []\n\n    result = []\n    count = 1\n\n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            result.append((list1[i - 1], count))\n            count = 1\n\n    result.append((list1[-1], count))\n    return result\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    # Initialize the result variable\n    res = 0\n    # Calculate the median of the array\n    median = arr[n // 2] if n % 2 else (arr[n // 2 - 1] + arr[n // 2]) / 2\n    # Iterate over the array to find the number of operations required\n    for i in range(n):\n        # Calculate the absolute difference between the current element and the median\n        res += abs(arr[i] - median)\n    # Return the total number of operations required\n    return res\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    # Create a 2D array to store the results of subproblems\n    dp = [[0] * (n + 1) for _ in range(b + 1)]\n\n    # Initialize the base case\n    for i in range(b + 1):\n        dp[i][0] = 1\n\n    # Fill up the dp array\n    for i in range(1, b + 1):\n        for j in range(1, n + 1):\n            if i >= a:\n                dp[i][j] = dp[i - a][j] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    # Return the result\n    return dp[b][n]  # This is the number of ways to get n using a and b\n\n"}
{"task_id": "MBPP/161", "completion": "\n    return [value for value in list1 if value not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    sum = 0\n    x = 1\n    while n - x >= 0:\n        sum += n - x\n        x += 2\n    return sum\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * s * tan(pi / l)) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    count = 0\n    for i in range(len(str1)):\n        if str1[i] == chr(97 + i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])  # Include n in the range\n"}
{"task_id": "MBPP/171", "completion": "\n    # The perimeter of a pentagon is the sum of the lengths of its five sides.\n    # Since all sides of a regular pentagon are equal, we can simply multiply the length of one side by 5.\n    return a * 5\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for char in s:\n        if char in 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^A-Za-z0-9]+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    for i in range(L, R+1):\n        for j in range(i+1, R+1):\n            if math.gcd(i, j) == 1:\n                lcm = (i*j)//math.gcd(i,j)\n                if L <= lcm <= R:\n                    return [i, j]\n    return None\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Initialize sum of divisors\n    sum_divisors = 0\n    \n    # Loop through all numbers from 1 to x\n    for i in range(1, x):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, add it to sum_divisors\n            sum_divisors += i\n    \n    # Check if sum of divisors is equal to x\n    if sum_divisors == x:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude to radians\n    slat, slon = radians(slat), radians(slon)\n    elat, elon = radians(elat), radians(elon)\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n\n    # Radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate the distance\n    distance = R * c\n\n    return distance\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Define the pattern for uppercase, lowercase, special character, numeric values\n    pattern = r\"[A-Z]|[a-z]|[!@#$%^&*()_+=-{};:'<>,./?]\"\n    \n    # Use finditer to find all matches of the pattern in the string\n    matches = re.finditer(pattern, string)\n    \n    # Create a list to store the matches\n    result = []\n    \n    # Iterate over the matches and add them to the list\n    for match in matches:\n        result.append(match.group())\n    \n    # Return the list of matches\n    return result\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    count = 0\n    i = 0\n    j = 1\n    while j < n:\n        if arr[j] - arr[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif arr[j] - arr[i] < k:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus\n    focus = (focal_length, 0)\n    \n    return focus\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequence of substrings.\n    L = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index+1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i-1][j] > L[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    for i in range(1, int(n**0.5) + 1):\n        if n % (i * i) == 0:\n            return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store unique positive numbers\n    num_set = set()\n    \n    # Iterate over the array and add positive numbers to the set\n    for num in arr:\n        if num > 0:\n            num_set.add(num)\n    \n    # Initialize the first missing positive number as 1\n    first_missing = 1\n    \n    # Iterate from 1 to n (inclusive) and check if the number is in the set\n    while first_missing <= n:\n        if first_missing not in num_set:\n            return first_missing\n        first_missing += 1\n    \n    # If all numbers from 1 to n are present in the set, return n + 1\n    return first_missing\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points in the square\n    count = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if any(char.isalpha() for char in str) and any(char.isdigit() for char in str):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Initialize result as 1\n    result = 1\n    \n    # Iterate over the elements of the first tuple\n    for i in test_tup1:\n        # Multiply the result with the element from the second tuple\n        result *= test_tup2[i]\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major axis\n    a = a / 2\n    # Calculate the semi-minor axis\n    b = b / 2\n    # Calculate the area of the ellipse\n    area = math.pi * a * b\n    # Calculate the area of the triangle\n    triangle_area = area / 2\n    # Calculate the side length of the triangle\n    side_length = math.sqrt(4 * triangle_area / math.pi)\n    return side_length\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (n > 1):\n        n = n // 2\n        i += 1\n    return 2 ** i\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    inversions = []\n    for i in range(len(test_tup)):\n        for j in range(i + 1, len(test_tup)):\n            if test_tup[i] > test_tup[j]:\n                inversions.append((test_tup[i], test_tup[j]))\n    return inversions\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for tup in test_tup:\n        new_tup = []\n        for i in range(len(tup)):\n            if i == len(tup) - 1:\n                new_tup.append(tup[i])\n            else:\n                new_tup.append(tup[i] + tup[i + 1])\n        result.append(new_tup)\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1] if i + 1 < j - 1 else 2\n                max_len = max(max_len, dp[i][j])\n    return max_len\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(n):\n        if (i & n) == (i & (i & n)):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum(i**4 for i in range(1, n+1))\n\n"}
{"task_id": "MBPP/213", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Concatenate the lists\n    result = list1 + list2\n    \n    # Convert the result back to a tuple\n    result = tuple(result)\n    \n    return result\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.extend([char] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    # Check if both lists are of the same type\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    # Check if both lists are empty\n    if len(list1) == 0 and len(list2) == 0:\n        return True\n\n    # Check if the first element of list1 is in list2\n    if list1[0] not in list2:\n        return False\n\n    # Recursively check the rest of the lists\n    return check_subset_list(list1[1:], [x for x in list2 if x != list1[0]])\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    \n    # Calculate the minimum number of operations required\n    # This is done by dividing the difference by 2 and rounding up to the nearest integer\n    # This is because we can either add or subtract the smaller number from the larger number\n    # to make them equal, and we need to do this operation as many times as the difference\n    # between the two numbers\n    min_operations = math.ceil(diff / 2)\n    \n    return min_operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple into a list\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the minimum k elements\n    min_k = test_list[:K]\n    \n    # Extract the maximum k elements\n    max_k = test_list[-K:]\n    \n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, and dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n    \n    # Sort matches by frequency\n    freq = {}\n    for match in matches:\n        if match in freq:\n            freq[match] += 1\n        else:\n            freq[match] = 1\n    \n    # Sort by frequency in descending order\n    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Replace the most frequent characters with a colon\n    for char, count in sorted_freq[:n]:\n        text = text.replace(char, ':')\n    \n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    # Get the data type of the first element in the tuple\n    data_type = type(test_tuple[0])\n    \n    # Iterate over each element in the tuple\n    for element in test_tuple:\n        # If the data type of the current element is different from the data type of the first element\n        if type(element) != data_type:\n            # Return False\n            return False\n    \n    # If the function hasn't returned False, it means all elements have the same data type\n    return True\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count of given element\n    count = 0\n    # Traverse through the array\n    for i in range(n):\n        # If element is equal to x, increment count\n        if arr[i] == x:\n            count += 1\n        # If element is not equal to x, decrement count\n        else:\n            count -= 1\n        # If count becomes zero, reset count to 1\n        if count == 0:\n            count = 1\n    # Return True if count is greater than zero, else return False\n    return count > 0\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    if arr[low] < arr[high]:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    else:\n        return find_Min(arr, low, mid)\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Pad the binary string with leading zeros to make it of length r-l+1\n    binary = binary.zfill(r-l+1)\n    \n    # Check if all bits in the given range are unset\n    return all(bit == '0' for bit in binary[l-1:r])\n"}
{"task_id": "MBPP/229", "completion": "\n    # Initialize two lists, one for negative numbers and one for positive numbers\n    negative = []\n    positive = []\n\n    # Iterate over the array\n    for num in arr:\n        # If the number is negative, add it to the negative list\n        if num < 0:\n            negative.append(num)\n        # If the number is positive, add it to the positive list\n        else:\n            positive.append(num)\n\n    # Combine the two lists\n    result = negative + positive\n\n    # Return the result\n    return result\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Create a 2D list to store the maximum sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of dp\n    for i in range(n):\n        dp[0][i] = tri[0][i]\n        if i > 0:\n            dp[0][i] += dp[0][i-1]\n    \n    for i in range(1, n):\n        dp[i][0] = tri[i][0]\n        for j in range(1, n):\n            dp[i][j] = max(tri[i][j] + dp[i-1][j], tri[i][j] + dp[i][j-1])\n    \n    # The maximum sum is stored in the bottom right corner of dp\n    return dp[n-1][n-1]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n | (n & -n)\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of triangles that can be formed\n    # The number of triangles that can be formed is equal to the number of ways to choose 3 points from the total number of points\n    # This can be calculated using the combination formula: nC3 = n*(n-1)*(n-2)/6\n    # In this case, n is the number of points on the side of the triangle\n    # Since the triangle is equilateral, the number of points on each side is equal to the number of points on the other sides\n    # Therefore, the number of points on each side is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the"}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(test_list)\n    # Find the maximum count\n    max_count = max(record_count.values())\n    # Find the records with the maximum count\n    max_records = [record for record, count in record_count.items() if count == max_count]\n    return max_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    # Create a list to store the number of sequences of length i\n    dp = [0] * (n + 1)\n    # There is only one way to have a sequence of length 0\n    dp[0] = 1\n    # Iterate over the length of the sequence\n    for i in range(1, n + 1):\n        # Iterate over the possible last element of the sequence\n        for j in range(1, m + 1):\n            # If the last element is greater than or equal to twice the previous element, add the number of sequences of length i - 1 to dp[i]\n            if j >= 2 * (i - 1):\n                dp[i] += dp[i - 1]\n    # Return the total number of sequences of length n\n    return dp[n] - 1  # subtract 1 because we counted the empty sequence\n\n"}
{"task_id": "MBPP/240", "completion": "\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1] = list2\n        return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: lst.count(x[0]))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    # Calculate the next integer greater than sqrt_N\n    next_int = math.ceil(sqrt_N)\n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of bi-tonic sub-sequence\n    # ending at the current position and the maximum sum of bi-tonic sub-sequence\n    # ending at the previous position\n    max_ending_here = arr[0]\n    max_so_far = arr[0]\n    min_ending_here = arr[0]\n    min_so_far = arr[0]\n\n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        # by considering the maximum of the current element and the sum of the current\n        # element and the maximum sum of bi-tonic sub-sequence ending at the previous position\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n\n        # Update the maximum sum of bi-tonic sub-sequence ending at the current position\n        # by considering the minimum of the current element and the sum of the current\n        # element and the minimum sum of bi-tonic sub-sequence ending at the previous position\n        min_ending_here = min(arr[i], min_ending_here + arr[i])\n\n        # Update the maximum sum of bi-tonic sub-sequence ending at the previous position\n        # by considering the maximum of the maximum sum of bi-tonic sub-sequence ending at\n        # the current position and the maximum sum of bi-tonic sub-sequence ending at the\n        # previous position\n        max_so_far = max(max_so_far, max_ending_here)\n\n        # Update the minimum sum of bi-tonic sub-sequence ending at the previous position\n        # by considering the minimum of the minimum sum of bi-tonic sub-sequence ending at\n        # the current position and the minimum sum of bi-tonic sub-sequence ending at the\n        # previous position\n        min_so_far = min(min_so_far, min_ending_here)\n\n    # Return the maximum sum of bi-tonic sub-sequence\n    return max_so_far\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    elif number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.000001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(set(array_nums1) & set(array_nums2))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    new_list = []\n    for i in range(len(list)):\n        new_list.append(element)\n        new_list.append(list[i])\n    return new_list\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = []\n    for number in numbers:\n        r = cmath.polar(number)[0]\n        theta = cmath.polar(number)[1]\n        polar_coordinates.append((r, theta))\n    return polar_coordinates\n\n\nnumbers = [1 + 2j, 2 + 3j, 3 + 4j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\b[aAeE]\\w*\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    return list(combinations_with_replacement(l, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum of the two maximum elements\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(\"Error: Division by zero is not allowed.\")\n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # Calculate dog's age in dog's years\n    d_age = h_age * 7\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    sum_of_squares = 0\n    for i in range(1, n+1):\n        sum_of_squares += (2*i - 1)**2\n    return sum_of_squares\n"}
{"task_id": "MBPP/268", "completion": "\n    # Initialize the first star number\n    star_num = 1\n    # Initialize the number of stars\n    num_stars = 1\n    # Initialize the current number\n    current_num = 1\n    # Loop until we find the nth star number\n    while True:\n        # If the current number is equal to the nth star number, return it\n        if current_num == star_num:\n            return current_num\n        # Otherwise, increment the number of stars\n        num_stars += 1\n        # Calculate the next star number\n        star_num = (num_stars * (num_stars + 1)) // 2\n        # Increment the current number\n        current_num += 1\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    sum = 0\n    for i in range(2, n+1, 2):\n        sum += i ** 5\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return [record[-1] for record in test_list]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a + n) % m\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return test_tup.count(test_tup[0])\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * (n + 1) + 2 * (n * (n + 1) * (2 * n + 1)) // 6\n\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if count > int(digit):\n            return False\n    \n    # If the function has not returned False, return True\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # Repeat the array k times and find the maximum sum\n    max_sum_repeated = float('-inf')\n    for i in range(k):\n        for j in range(n):\n            current_sum += a[j]\n            if current_sum > max_sum_repeated:\n                max_sum_repeated = current_sum\n            if current_sum < 0:\n                current_sum = 0\n\n    # Return the maximum sum\n    return max(max_sum, max_sum_repeated)  # Return the maximum of the two sums\n\n"}
{"task_id": "MBPP/287", "completion": "\n    sum = 0\n    for i in range(2, n+1, 2):\n        sum += i ** 2\n    return sum\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate the number of odd days in a year\n    odd_days = (N + 1) // 2\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(list1, key=len)\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from 3 to n\n    for i in range(3, n + 1):\n        # The number of ways for this post is the sum of the number of ways for the previous two posts\n        ways[i] = ways[i - 1] + ways[i - 2] * (k - 1)\n\n    # Return the number of ways for the nth post\n    return ways[n]  # Return the number of ways for the nth post\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    sum_div = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum_div += i\n    return sum_div\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    return [element for element in l1 if element in l2]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_aggregates = defaultdict(int)\n    \n    # Iterate over each tuple in the list\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_aggregates[num] = max(max_aggregates[num], aggregate)\n    \n    # Return the maximum aggregate\n    return max(max_aggregates.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return 2 * count_binary_seq(n - 1)\n\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize the most significant bit number\n    msb = 0\n    \n    # Iterate over the binary string from right to left\n    for i in range(len(binary) - 1, -1, -1):\n        # If the current bit is 1, update the most significant bit number\n        if binary[i] == '1':\n            msb = len(binary) - i - 1\n            break\n    \n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversions += 1\n    return inversions\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Calculate the effective index after rotations\n    effective_index = (index + rotations) % len(arr)\n    \n    # Check if the effective index is within the given range\n    if effective_index >= ranges[0] and effective_index <= ranges[1]:\n        return arr[effective_index]\n    else:\n        return None\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = re.compile(r'^p')\n    return [word for word in words if pattern.match(word)]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    # Create a table to store the maximum sum of increasing subsequence\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table in a bottom-up manner\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = a[i]\n            elif j == 1:\n                dp[i][j] = max(a[i], dp[i - 1][j])\n            else:\n                dp[i][j] = max(dp[i - 1][j], a[i] + dp[i - 1][j - 1])\n    \n    # Return the maximum sum of increasing subsequence\n    return dp[n - 1][index] + max_sum_increasing_subseq(a, n, index + 1, k)\n\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize an empty list to store the products\n    products = []\n\n    # Iterate over the range of N\n    for i in range(N):\n        # Calculate the product of the current elements from both lists\n        product = nums1[i] * nums2[i]\n        # Append the product to the list\n        products.append(product)\n\n    # Return the list of products\n    return products\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    # Calculate the volume of the cone using the formula (1/3)\u03c0r\u00b2h\n    volume = (1/3) * math.pi * (r ** 2) * h\n    return volume\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    # Initialize the dp array\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n\n    # Fill the dp array\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n\n    # Return the maximum sum\n    return max(dp[0][n-1], dp[1][n-1])  # Return the maximum sum of the last row\n\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/316", "completion": "\n    low = 0\n    high = len(A) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            low = mid + 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    if not alist:\n        return []\n\n    result = []\n    count = 1\n\n    for i in range(1, len(alist)):\n        if alist[i] == alist[i - 1]:\n            count += 1\n        else:\n            result.append((alist[i - 1], count))\n            count = 1\n\n    result.append((alist[-1], count))\n    return result\n\n"}
{"task_id": "MBPP/318", "completion": "\n    # Initialize the maximum volume\n    max_volume = 0\n    \n    # Iterate over all possible combinations of sides\n    for a in range(1, s):\n        for b in range(a, s):\n            c = s - a - b\n            # Check if the current combination is valid (i.e., a <= b <= c)\n            if a <= b <= c:\n                # Calculate the volume of the cuboid\n                volume = a * b * c\n                # Update the maximum volume if the current volume is larger\n                max_volume = max(max_volume, volume)\n    \n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    # Regular expression to find all five characters long word\n    pattern = r'\\b\\w{5}\\b'\n    # Find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/320", "completion": "\n    # Calculate the sum of first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of squared first n natural numbers\n    sum_squared_n = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the squared sum of first n natural numbers\n    squared_sum_n = sum_n ** 2\n    \n    # Calculate the difference between squared sum and sum of squared first n natural numbers\n    difference = squared_sum_n - sum_squared_n\n    \n    return difference\n"}
{"task_id": "MBPP/321", "completion": "\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through each digit in the number\n    for i in range(len(s)):\n        # Add the digit to the demlo number\n        demlo += int(s[i]) * (10 ** (len(s) - i - 1))\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # If out_of_place is True, we can use extra space to store the elements\n        # We will store the first element in the array in the last index of the extra space\n        extra_space = [0] * n\n        for i in range(n):\n            if arr[i] >= 0:\n                extra_space[n - i - 1] = arr[i]\n            else:\n                extra_space[n - i - 1] = arr[i]\n        for i in range(n):\n            if arr[i] < 0:\n                extra_space[n - i - 1] = arr[i]\n            else:\n                extra_space[n - i - 1] = arr[i]\n        return extra_space\n\n    # If out_of_place is False, we cannot use extra space\n    # We will use two pointers, one at the start and one at the end of the array\n    # We will keep swapping the elements at these two pointers until we reach the middle of the array\n    left = 0\n    right = n - 1\n    while left < right:\n        # If the left element is negative and the right element is positive, swap them\n        if arr[left] < 0 and arr[right] > 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n        # If the left element is positive and the right element is negative, swap them\n        elif arr[left] > 0 and arr[right] < 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n        # If the left element is positive and the right element is positive, move the right pointer to the left\n        elif arr[left] > 0 and arr[right] > 0:\n            right -= 1\n        # If the left element is negative and the right element is negative, move the left pointer to the right\n        elif arr[left] < 0 and arr[right] < 0:\n            left += 1\n    return arr\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[i] for i in range(0, len(test_tuple), 2))\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current number is greater than or equal to the square\n            if i >= j ** 2:\n                # Update the minimum number of squares for the current number\n                min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n] if min_squares[n] != float('inf') else -1\n\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word = word.lower()\n        word_count[word] += 1\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return most_common_words\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")\n"}
{"task_id": "MBPP/328", "completion": "\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return sum(1 for num in list if num < 0)\n"}
{"task_id": "MBPP/330", "completion": "\n    # Using regex to find all words with 3, 4, 5 characters\n    pattern = r'\\b\\w{3,5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # reverse = None (Sorts in Ascending order)\n    # or reverse = True (Sorts in Descending order)\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # check if the sum of any two sides is greater than the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n/2) * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b[^\\w\\s]*$'\n    return re.search(pattern, text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty dictionary to store the frequency of divisors\n    freq = {}\n    \n    # Iterate over all numbers from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is already in the dictionary, increment its frequency\n            if i in freq:\n                freq[i] += 1\n            # Otherwise, add i to the dictionary with a frequency of 1\n            else:\n                freq[i] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq.values(), default=0)\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [i for i in freq if freq[i] == max_freq]\n    \n    # Return the maximum divisor\n    return max(max_divisors)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we filter out non-positive numbers from the list\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Then, we sort the list of positive numbers in ascending order\n    positive_nums.sort()\n    \n    # Finally, we return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])  # We use list slicing to get the first three elements of the sorted list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_range = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_range = max(max_range, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if max_range - node.value < min_range:\n            min_range = max_range - node.value\n        if node.index + 1 < len(list[node.list_num]):\n            next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n            heappush(min_heap, next_node)\n            heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n            max_range = max(max_range, -list[node.list_num][node.index + 1])\n        else:\n            break\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    return sum(c.isalpha() for c in s)\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    if n == 9:\n        return 256\n    if n == 10:\n        return 512\n    if n == 11:\n        return 1024\n    if n == 12:\n        return 2048\n    if n == 13:\n        return 4096\n    if n == 14:\n        return 8192\n    if n == 15:\n        return 16384\n    if n == 16:\n        return 32768\n    if n == 17:\n        return 65536\n    if n == 18:\n        return 131072\n    if n == 19:\n        return 262144\n    if n == 20:\n        return 524288\n    if n == 21:\n        return 1048576\n    if n == 22:\n        return 2097152\n    if n == 23:\n        return 4194304\n    if n == 24:\n        return 8388608\n    if n == 25:\n        return 16777216\n    if n == 26:\n        return 33554432\n    if n == 27:\n        return 67108864\n    if n == 28:\n        return 134217728\n    if n == 29:\n        return 268435456\n    if n == 30:\n        return 536870912\n    if n == 31:\n        return 1073741824\n    if n == 32:\n        return 2147483648\n    if n == 33:\n        return 4294967296\n    if n == 34:\n        return 8589934592\n    if n == 35:\n        return 17179869184\n    if n == 36:\n        return 34359738368\n    if n == 37:\n        return 68719476736\n    if n == 38:\n        return 137438953472\n    if"}
{"task_id": "MBPP/347", "completion": "\n    # Initialize count of squares\n    count = 0\n    # Iterate over each row in the rectangle\n    for i in range(m):\n        # Iterate over each column in the rectangle\n        for j in range(n):\n            # Check if the current cell is a square\n            if (i + 1) % 2 == 0 and (j + 1) % 2 == 0:\n                # If it is, increment the count\n                count += 1\n    # Return the count of squares\n    return count\n"}
{"task_id": "MBPP/348", "completion": "\n    # Create a list to store the count of sequences of length i with non-negative prefix sums\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one sequence of length 0 with non-negative prefix sum (empty sequence)\n\n    # Iterate over the given values\n    for i in range(1, n + 1):\n        for j in range(1, r + 1):\n            # If the current value is non-negative, add the count of sequences of length i - 1 to dp[i]\n            if j >= 0:\n                dp[i] += dp[i - j]\n\n    return dp[n]  # Return the count of sequences of length n with non-negative prefix sums\n\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    # Initialize a dictionary to store the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Initialize a variable to store the minimum length\n    min_len = len(s)\n\n    # Iterate over each character and its frequency\n    for char, count in freq.items():\n        # If the frequency is more than 1, update the minimum length\n        if count > 1:\n            min_len = min(min_len, len(s) - count + 1)\n\n    return min_len\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element that occurs k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [i[:n] + i[n+1:] for i in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    # Import necessary modules\n    import math\n\n    # Define the function\n    def count_rectangles(radius):\n        # Calculate the area of the circle\n        circle_area = math.pi * (radius ** 2)\n\n        # Calculate the area of a single rectangle\n        rectangle_area = 1\n\n        # Calculate the number of rectangles that can fit in the circle\n        num_rectangles = circle_area / rectangle_area\n\n        # Return the number of rectangles\n        return num_rectangles\n\n    # Call the function and print the result\n    print(count_rectangles(radius))\n"}
{"task_id": "MBPP/356", "completion": "\n    # Calculate the third angle\n    c = 180 - a - b\n    return c\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = float('-inf')\n    for record in test_list:\n        for value in record:\n            if value > max_val:\n                max_val = value\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n    \n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n    \n    # Check if one root is twice of other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n + 1):\n        carol = carol * i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum count\n    max_count = max(count_dict.values())\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_items\n"}
{"task_id": "MBPP/363", "completion": "\n    return [x + K for x in test_list]\n"}
{"task_id": "MBPP/364", "completion": "\n    # Initialize count of flips\n    flips = 0\n    \n    # Iterate over the string\n    for i in range(1, len(ch)):\n        # If current character is not equal to previous character\n        if ch[i] != ch[i-1]:\n            # Increment count of flips\n            flips += 1\n    \n    # Return total count of flips\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x[1]))\n\n"}
{"task_id": "MBPP/371", "completion": "\n    # Check if the array is sorted\n    if A != sorted(A):\n        raise ValueError(\"Array is not sorted\")\n\n    # Check if the array is empty\n    if len(A) == 0:\n        raise ValueError(\"Array is empty\")\n\n    # Check if the left and right elements are in the array\n    if left_element not in A or right_element not in A:\n        raise ValueError(\"Left or right element is not in the array\")\n\n    # Find the smallest missing element\n    for i in range(len(A) - 1):\n        if A[i + 1] - A[i] > 1:\n            return A[i] + 1\n\n    # If no missing element is found, return the next element after the right element\n    return A[-1] + 1\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with custom value for elements that occur more than once\n    new_tup = ()\n    for element in test_tup:\n        if count_dict[element] > 1:\n            new_tup += ('custom_value',)  # Add custom value for duplicates\n        else:\n            new_tup += (element,)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 0:\n        first_element = test_list.pop()\n        test_list.insert(0, first_element)\n    return test_list\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    # Initialize an empty list\n    arr = []\n    # Loop through the number of rows\n    for i in range(rownum):\n        # Initialize an empty list for each row\n        row = []\n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append a value to the row list\n            row.append(0)\n        # Append the row list to the array\n        arr.append(row)\n    # Return the array\n    return arr\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    for i in range(n):\n        if A[i] > A[(i+1)%n]:\n            return i\n    return n\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '1' (odd bit), toggle it to '0'\n        if char == '1':\n            result += '0'\n        # If the character is '0' (even bit), toggle it to '1'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # First, find the smallest value in the array\n    smallest = min(arr)\n    \n    # Then, count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    i = 0\n    while (1 << i) <= n:\n        i += 1\n    return i - 1\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create an empty dictionary\n    nested_dict = {}\n    \n    # Iterate over the lists\n    for i in range(len(l1)):\n        # Create a new dictionary for each list\n        nested_dict[l1[i]] = {}\n        \n        # Add the second list to the dictionary\n        nested_dict[l1[i]][l2[i]] = l3[i]\n    \n    return nested_dict\n"}
{"task_id": "MBPP/392", "completion": "\n    memo = {1: 1}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        else:\n            max_sum = n\n            for i in [2, 3, 4, 5]:\n                if n % i == 0:\n                    max_sum = max(max_sum, f(n // i) + f(n))\n            memo[n] = max_sum\n            return max_sum\n    return f(n) - n\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the elements are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function to add the nested tuples\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If the elements are not tuples, add them directly\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result as a tuple\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    def mul(a, b, p):\n        return (a * b) % p\n\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        if (x == 0):\n            return 0\n        while (y > 0):\n            if ((y & 1) == 1):\n                res = (res * x) % p\n            y = y >> 1\n            x = (x * x) % p\n        return res\n\n    def inverse(x, p):\n        return power(x, p - 2, p)\n\n    if (r > n or r < 0 or n < 0):\n        return 0\n    p = int(p)\n    if (r == 0):\n        return 1\n    else:\n        return mul(ncr_modp(n - 1, r - 1, p), p, p) % p\n"}
{"task_id": "MBPP/403", "completion": "\n    url = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url.match(str)\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return min(a, b)\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    # If the number is even, return 0\n    if x % 2 == 0:\n        return 0\n    # If the number is odd, return 1\n    else:\n        return 1\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    stack = []\n    for digit in n:\n        while stack and stack[-1] < digit:\n            stack.pop()\n        stack.append(digit)\n    return int(''.join(stack)) if stack else n\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    \n    # Push the first element of the first array into the heap\n    for num in nums1:\n        heapq.heappush(min_heap, (num, num, 0, nums2))\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Loop until we have k pairs\n    while min_heap and count < k:\n        # Get the smallest pair from the heap\n        num1, num2, idx1, nums2_list = heapq.heappop(min_heap)\n        \n        # Increment the count of pairs\n        count += 1\n        \n        # Push the next element of the first array into the heap\n        if idx1 + 1 < len(nums1):\n            heapq.heappush(min_heap, (nums1[idx1 + 1], num2, idx1 + 1, nums2_list))\n        \n        # Push the pairs of the current element of the first array with the elements of the second array into the heap\n        for num2 in nums2_list:\n            if num2 > num2:\n                heapq.heappush(min_heap, (num1, num2, idx1, nums2_list))\n    \n    # Return the k smallest pairs\n    return [[num1, num2] for num1, num2, _, _ in min_heap]\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize minimum product with a large number\n    min_product = float('inf')\n    \n    # Iterate over each pair of tuples in the list\n    for i in range(0, len(list1), 2):\n        # Check if the pair is valid (i.e., it has two elements)\n        if i + 1 < len(list1):\n            # Calculate the product of the pair\n            product = list1[i][0] * list1[i][1] * list1[i+1][0] * list1[i+1][1]\n            \n            # Update the minimum product if the current product is smaller\n            min_product = min(min_product, product)\n    \n    # Return the minimum product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the string\n    words = re.findall(r'\\w+', word)\n    # Use list comprehension to capitalize the first letter of each word except the first one\n    camel_case = [words[0]] + [word.capitalize() for word in words[1:]]\n    # Join the words together to form the camel case string\n    return ''.join(camel_case)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1][0]  # Return the first element of the nth tuple\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n < 0:\n        return -MAX\n    if n == 1:\n        return 1\n    max_sum = 0\n    for i in range(1, n):\n        max_sum = max(max_sum, breakSum(i-1) + breakSum(n-i-1) + i)\n    return max_sum\n\n"}
{"task_id": "MBPP/417", "completion": "\n    return [list(x) for x in set(tuple(sorted(x)) for x in Input)]\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(list1))\n    return total_sum * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum([i**3 for i in range(2, n*2+2, 2)])\n"}
{"task_id": "MBPP/421", "completion": "\n    return delimiter.join(test_tup)\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through first n natural numbers\n    for i in range(1, n+1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m):\n        for j in range(1, n):\n            # For each cell, the maximum gold that can be collected is the maximum of the gold in the current cell\n            # and the maximum gold that can be collected from the cell above it, the cell to its left, and the cell diagonally above-left\n            dp[i][j] = gold[i][j] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple(string[-1] for string in test_tuple)\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to find the pattern of date in the string\n    pattern = re.compile(r'(\\d{4})-(\\d{2})-(\\d{2})')\n    # Using sub function to replace the pattern with the desired format\n    new_date = pattern.sub(r'\\3-\\2-\\1', dt)\n    return new_date\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Append the tuple of elements to the result list\n        result.append((tup1, tup2))\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/430", "completion": "\n    # Directrix of parabola is y = -1/(4a)\n    return -1/(4*a)\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > i for i in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a list of adverbs\n    adverbs = [\"quickly\", \"slowly\", \"loudly\", \"wisely\", \"happily\", \"sadly\", \"carefully\", \"patiently\", \"gently\", \"strongly\"]\n    # Initialize an empty list to store the positions of adverbs\n    adverb_positions = []\n    # Iterate over the adverbs\n    for adverb in adverbs:\n        # Use regular expression to find the adverb in the text\n        match = re.search(r'\\b' + re.escape(adverb) + r'\\b', text)\n        # If the adverb is found, add its position to the list\n        if match:\n            adverb_positions.append((match.start(), match.end()))\n    # Return the list of adverb positions\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l**2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values indicating whether each number is positive\n    positive_array = array('b', [num > 0 for num in nums])\n    \n    # Count the number of True values in the array\n    positive_count = positive_array.count(True)\n    \n    # Calculate the ratio of positive numbers\n    ratio = positive_count / len(nums)\n    \n    return ratio\n\n"}
{"task_id": "MBPP/443", "completion": "\n    # Check if list is empty\n    if not list1:\n        return None\n    # Check if all numbers are positive\n    if all(num >= 0 for num in list1):\n        return None\n    # Find the largest negative number\n    largest_neg_num = max(num for num in list1 if num < 0)\n    return largest_neg_num\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][j] for j in range(len(test_list[i])-K, len(test_list[i]))) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Both tuples must have the same length.\"\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the first tuple\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index in both tuples and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Count the occurrence of each element in the tuple\n    tup_count = Counter(tup)\n    # Return the difference between the two counts\n    return count - tup_count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    else:\n        a, b, c = 2, 3, 0\n        for _ in range(3, n + 1):\n            c = a + b\n            a, b = b, c\n        return c\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    # Using regex to replace all whitespaces with empty string\n    text1 = re.sub(r'\\s+', '', text1)\n    return text1\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    return re.search(r'\\b\\w*z\\w*\\b', text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    # Using regex to find all uppercase substrings\n    upper_case = re.findall(r'[A-Z]+', str1)\n    \n    # Removing the found uppercase substrings from the original string\n    for substring in upper_case:\n        str1 = str1.replace(substring, '')\n    \n    return str1\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return low\n\n    # See the problem description for details\n    mid = (low + high) // 2\n\n    # If x is peak, then peak should be either in x-1 or x+1\n    if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == n - 1 or arr[mid] >= arr[mid + 1]):\n        return mid\n\n    # If x is not peak and it is smaller than previous element, then\n    # peak should be in left subarray\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    # If x is not peak and it is greater than next element, then\n    # peak should be in right subarray\n    return find_peak_util(arr, mid + 1, high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product of subsequence ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product of subsequence ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product and minimum product for the first element\n    max_product[0] = min_product[0] = arr[0]\n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        # For each element, the maximum product of subsequence ending at this position is the maximum of the current element and the product of the current element and the maximum product of subsequence ending at the previous position\n        max_product[i] = max(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n        # For each element, the minimum product of subsequence ending at this position is the minimum of the current element and the product of the current element and the minimum product of subsequence ending at the previous position\n        min_product[i] = min(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n    # The maximum product of the entire array is the maximum of the maximum product of subsequence ending at each position\n    return max(max_product)\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, price[i] - price[i - 1]) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next element\n            for j in range(i + 1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result array with zeros\n    result = [0] * lens\n    # Initialize the carry variable to 0\n    carry = 0\n    # Iterate over the array from right to left\n    for i in range(lens - 1, -1, -1):\n        # Multiply the current element with n and add the carry\n        temp = arr[i] * n + carry\n        # Update the carry for the next iteration\n        carry = temp // 10\n        # Update the result array\n        result[i] = temp % 10\n    # If there is a carry after the loop, add it to the result array\n    if carry > 0:\n        result.insert(0, carry)\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i]+1 != l[i+1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/473", "completion": "\n    # Convert the lists to sets for efficient lookup\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a list and return it\n    return list(intersection)\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    for char in str1:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Find the maximum frequency\n    max_freq = max(char_freq.values())\n\n    # Find the character with maximum frequency\n    max_char = [char for char, freq in char_freq.items() if freq == max_freq]\n\n    return max_char[0] if max_char else None\n"}
{"task_id": "MBPP/481", "completion": "\n    if n == 0:\n        return sum == 0\n    if sum == 0:\n        return True\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    i = 1\n    while True:\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        if factorial % x == 0:\n            return i\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [t for t in test_list1 if t not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    return str(n) == str(n)[::-1]\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r\n        r = n - r\n    ans = 1\n    for i in range(r):\n        ans = ans * (n - i) / (i + 1)\n    return ans\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) / 4) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Count the frequency of the maximum value\n    frequency = arr.count(max_val)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid of hexagons\n    grid = [[None for _ in range(num_hexagons_x)] for _ in range(num_hexagons_y)]\n\n    # Calculate the coordinates of each hexagon\n    for y in range(num_hexagons_y):\n        for x in range(num_hexagons_x):\n            # Calculate the x and y coordinates of the hexagon\n            hex_x = startx + x * 2 * radius\n            hex_y = starty + y * 2 * radius\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = hex_x + math.cos(angle) * radius\n                point_y = hex_y + math.sin(angle) * radius\n                points.append((point_x, point_y))\n\n            # Store the coordinates of the hexagon in the grid\n            grid[y][x] = points\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert binary tuple to string\n    binary_str = ''.join(map(str, test_tup))\n    \n    # Convert binary string to integer\n    integer = int(binary_str, 2)\n    \n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    # Find the greatest common divisor of two numbers\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the common divisor between two numbers\n    def common_divisor(a, b):\n        return gcd(a, b)\n\n    return common_divisor(x, y)\n\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(nums[i] + nums[i+1] for i in range(len(nums)-1))\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    elif k == 0 or k == n:\n        return 1\n    else:\n        return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    # Convert the list of words to remove to a set for efficient lookups\n    set2 = set(removewords)\n    # Use set difference to remove the words from the list\n    result = list(set1 - set2)\n    return result\n"}
{"task_id": "MBPP/508", "completion": "\n    return list(l1) == list(l2)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product < k:\n            count += 2 ** (n - i - 1)\n    return count\n"}
