{"task_id": "MBPP/11", "completion": "\n    s = s.replace(ch, '', 1)\n    s = s.replace(ch, '', -1)\n    return s\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum, reverse=False)\n"}
{"task_id": "MBPP/13", "completion": "\n    words = words.split()\n    word_count = Counter(words)\n    return dict(word_count.most_common(3))\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (l * b * h) / 2\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.findall(r'[a-z]+', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'([a-z])\\1+', r'\\1', text).lower().replace(' ', '_')\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string_to_list(string_to_list(string)[1])]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    return x == 1 or (x % 2 == 1 and is_woodall((x - 1) // 2) and is_prime(x * 2 - 1))\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i for i in range(m, n+1) if i % m == 0]\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(i) for i in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    return int(binary, 2)\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Create a list to store the product of non-repeated elements\n    product = 1\n    for num in freq:\n        if freq[num] == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return len(test_list) == K\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # take advantage of symmetry\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = result * (n - i) / (i + 1)\n    return result\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element has odd frequency, return None\n    return None\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.Counter(nums)\n    \n    # Create a heap to store the integers and their frequencies\n    heap = []\n    \n    # Push each integer and its frequency into the heap\n    for num, count in freq.items():\n        # Push a tuple (count, num) into the heap\n        heapq.heappush(heap, (-count, num))\n    \n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        # Pop the top integer with the highest frequency\n        top_k.append(heapq.heappop(heap)[1])\n    \n    # Return the top k integers\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    # Calculate the sum of first N natural numbers\n    total_sum = N * (N + 1) // 2\n\n    # Calculate the sum of the given array\n    array_sum = sum(ar)\n\n    # The missing number is the difference between the total sum and the array sum\n    missing_number = total_sum - array_sum\n\n    return missing_number\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1) // 2\n\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a string\n    fraction = str(p) + \"/\" + str(q)\n    # Split the fraction into numerator and denominator\n    numerator, denominator = fraction.split(\"/\")\n    # Remove the leading zero from the numerator\n    numerator = numerator.lstrip(\"0\")\n    # Find the Nth digit\n    Nth_digit = int(numerator[N-1])\n    return Nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    return sorted(mixed_list, key=lambda x: (isinstance(x, int), x))\n"}
{"task_id": "MBPP/38", "completion": "\n    even = []\n    odd = []\n    for i in list1:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return even, odd\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    prev_char = None\n    result = []\n    while max_heap:\n        freq, char = heapq.heappop(max_heap)\n        result.append(char)\n        if prev_char is not None:\n            heapq.heappush(max_heap, (prev_char, prev_char))\n        prev_char = char\n        if freq < -1:\n            heapq.heappush(max_heap, (freq + 1, char))\n    return ''.join(result)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    return Counter(nums)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of each element and its frequency to the sum\n    for num, count in freq.items():\n        total_sum += num * count\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r'[a-z_]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    match = re.match(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x\n    for i in range(1, len(y)):\n        result = gcd(result, y[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return list(set(data))\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    def find_last_digit_factorial_divides(a, b):\n        last_digit_factorial = factorial(a)\n        last_digit_b = b % 10\n        if last_digit_factorial % last_digit_b == 0:\n            return True\n        else:\n            return False\n    return find_last_digit_factorial_divides(A, B)\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/49", "completion": "\n    return nums[0][N]\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(len(i) for i in input_list)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if str[0] == str[-1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for num in my_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Create a list to store the sorted elements\n    sorted_list = []\n    for key in sorted(count_dict.keys()):\n        sorted_list.extend([key] * count_dict[key])\n\n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    rev_num = 0 while n > 0: rev_num = 10 * rev_num + n % 10 n = n // 10 if 2 * rev_num - 1 == n: return True else: return False\n    # Test the function\n    print(check_f(123))  # Expected output: True\n    print(check_f(125))  # Expected output: False\n    print(check_f(100))  # Expected output: False\n    print(check_f(9))    # Expected output: True\n    print(check_f(99))   # Expected output: True\n    print(check_f(999))  # Expected output: True\n    print(check_f(1000)) # Expected output: False\n    print(check_f(1001)) # Expected output: True\n    print(check_f(1002)) # Expected output: False\n    print(check_f(1003)) # Expected output: False\n    print(check_f(1004)) # Expected output: False\n    print(check_f(1005)) # Expected output: False\n    print(check_f(1006)) # Expected output: False\n    print(check_f(1007)) # Expected output: False\n    print(check_f(1008)) # Expected output: False\n    print(check_f(1009)) # Expected output: False\n    print(check_f(1010)) # Expected output: False\n    print(check_f(1011)) # Expected output: False\n    print(check_f(1012)) # Expected output: False\n    print(check_f(1013)) # Expected output: False\n    print(check_f(1014)) # Expected output: False\n    print(check_f(1015)) # Expected output: False\n    print(check_f(1016)) # Expected output: False\n    print(check_f(1017)) # Expected output: False\n    print(check_f(1018)) # Expected output: False\n    print(check_f(1019)) # Expected output: False\n    print(check_f(1020)) # Expected output: False\n    print(check_f(1021)) # Expected output: False\n    print(check_f(1022)) # Expected output: False\n    print(check_f(1023)) # Expected output: False\n    print(check_f(1024)) # Expected output: False\n    print(check_f(1025"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    max_num = 0\n    for i in range(n):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2) == 1\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        max_len = 1\n        curr_len = 1\n        for i in range(1, n):\n            if abs(arr[i] - arr[i - 1]) == 1:\n                curr_len += 1\n            else:\n                max_len = max(max_len, curr_len)\n                curr_len = 1\n        return max(max_len, curr_len)\n"}
{"task_id": "MBPP/61", "completion": "\n    # Create a dictionary to store the count of each possible sum\n    sum_count = defaultdict(int)\n    sum_count[0] = 1  # Base case: sum 0 has 1 way (empty substring)\n\n    # Initialize the count of substrings with length 1\n    count = 0\n\n    # Iterate over the string\n    for i in range(n):\n        # Get the current digit\n        digit = int(s[i])\n\n        # Update the count of substrings with length i+1\n        for j in range(10):\n            # Calculate the sum of the current substring\n            sum_val = j + digit\n\n            # Update the count of substrings with sum sum_val\n            count += sum_count[sum_val]\n\n        # Update the count of substrings with sum 0\n        count += sum_count[0]\n\n        # Update the count of substrings with sum 0 for the next iteration\n        sum_count[0] = 0\n\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize max difference and pair\n    max_diff = 0\n    pair = ()\n    \n    # Iterate over the sorted list\n    for i in range(len(test_list) - 1):\n        # Calculate the difference between current and next element\n        diff = test_list[i + 1] - test_list[i]\n        \n        # If the difference is greater than max difference, update max difference and pair\n        if diff > max_diff:\n            max_diff = diff\n            pair = (test_list[i], test_list[i + 1])\n    \n    return max_diff, pair\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for x in list if x > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return sum(bell_number(n - i) for i in range(n + 1))  # sum of all ways to partition n - i\n\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n    for i in range(n - 1):\n        if A[i] > A[i + 1]:\n            increasing = False\n        if A[i] < A[i + 1]:\n            decreasing = False\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in (l[i: j] for i in range(len(l)) for j in range(i + 1, len(l) + 1))\n"}
{"task_id": "MBPP/70", "completion": "\n    return [t for t in Input if len(t) == k]\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n\n    # Shrink factor\n    shrink = 1.3\n\n    # Perform comb sort\n    while gap != 1 or n > 1:\n        gap = int(gap / shrink)\n\n        # Compare adjacent elements\n        for i in range(0, n - gap):\n            j = i + gap\n\n            # Swap if elements are in wrong order\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    i = 1\n    while i * i <= n:\n        if (n - i * i) ** 0.5 == int((n - i * i) ** 0.5):\n            return True\n        i += 1\n    return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = [',', ';', '|', '&']\n    \n    # Create a regex pattern that matches any of the delimiters\n    pattern = '|'.join(map(re.escape, delimiters))\n    \n    # Split the text using the pattern\n    result = re.split(pattern, text)\n    \n    # Remove empty strings from the result\n    result = [s for s in result if s]\n    \n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    for i in range(len(colors) - 1):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(i % K == 0 for i in tup):\n            # If all elements are divisible, add the tuple to the result list\n            result.append(tup)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * j <= m * n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/77", "completion": "\n    even = 0\n    odd = 0\n    for i in str(n):\n        if int(i) % 2 == 0:\n            even += int(i)\n        else:\n            odd += int(i)\n    return even - odd\n"}
{"task_id": "MBPP/78", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a counter for odd set bits\n    odd_set_bits = 0\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1' and its position is odd, increment the counter\n        if bit == '1' and binary.index(bit) % 2 != 0:\n            odd_set_bits += 1\n    \n    # Return the count of odd set bits\n    return odd_set_bits\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return min([i for i in range(1, N) if N % i == 0])\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    return n % 2 == 0 and n % 3 == 0 and n % 5 == 0\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    return min(enumerate(test_list), key=itemgetter(1))\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    min_sublist = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_sublist = sublist\n    return min_sublist\n"}
{"task_id": "MBPP/96", "completion": "\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    return [numbers[i] * len(numbers) for i in range(len(numbers))]\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('[_-]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    return (m + 1) * n * (n + 1) // 2\n"}
{"task_id": "MBPP/104", "completion": "\n    return sorted(input_list, key=lambda x: x.lower())\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup = list(test_tup)\n    # Add the two lists together\n    result = test_list + test_tup\n    return result\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap\n    min_heap = []\n    # Push the first element of each list into the heap\n    heapq.heappush(min_heap, (num1[0], 0, num1))\n    heapq.heappush(min_heap, (num2[0], 0, num2))\n    heapq.heappush(min_heap, (num3[0], 0, num3))\n\n    # Initialize the result list\n    result = []\n\n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, idx, nums = heapq.heappop(min_heap)\n        # Add the popped element to the result list\n        result.append(val)\n        # If there are more elements in the list, push the next element into the heap\n        if idx + 1 < len(nums):\n            heapq.heappush(min_heap, (nums[idx + 1], idx + 1, nums))\n\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    # Convert the binary string to an integer\n    num = int(s, 2)\n    \n    # Check if the number is odd\n    if num % 2 != 0:\n        return 1\n    else:\n        return 0\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_list = []\n    for i in range(strt_val, stop_val):\n        if i not in test_list:\n            missing_list.append(i)\n    return missing_list\n"}
{"task_id": "MBPP/111", "completion": "\n    common = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common = common.intersection(set(sublist))\n    return list(common)\n\nnestedlist = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return False\n    except ValueError:\n        return True\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if i == {}:\n            return True\n        else:\n            return False\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list if isinstance(i, (int, float))]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == arr[mid - 1]:\n            low = mid + 1\n        elif arr[mid] == arr[mid + 1]:\n            high = mid - 1\n        else:\n            return arr[mid]\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    elif n == 1:\n        return True\n    elif n == 2:\n        return True\n    elif n == 3:\n        return True\n    elif n == 4:\n        return True\n    elif n == 5:\n        return True\n    elif n == 6:\n        return True\n    elif n == 7:\n        return True\n    elif n == 8:\n        return True\n    elif n == 9:\n        return True\n    elif n == 10:\n        return True\n    elif n == 11:\n        return True\n    elif n == 12:\n        return True\n    elif n == 13:\n        return True\n    elif n == 14:\n        return True\n    elif n == 15:\n        return True\n    elif n == 16:\n        return True\n    elif n == 17:\n        return True\n    elif n == 18:\n        return True\n    elif n == 19:\n        return True\n    elif n == 20:\n        return True\n    elif n == 21:\n        return True\n    elif n == 22:\n        return True\n    elif n == 23:\n        return True\n    elif n == 24:\n        return True\n    elif n == 25:\n        return True\n    elif n == 26:\n        return True\n    elif n == 27:\n        return True\n    elif n == 28:\n        return True\n    elif n == 29:\n        return True\n    elif n == 30:\n        return True\n    elif n == 31:\n        return True\n    elif n == 32:\n        return True\n    elif n == 33:\n        return True\n    elif n == 34:\n        return True\n    elif n == 35:\n        return True\n    elif n == 36:\n        return True\n    elif n == 37:\n        return True\n    elif n == 38:\n        return True\n    elif n == 39:\n        return True\n    elif n == 40:\n        return True\n    elif n == 41:\n        return True\n    elif n == 42:\n        return True\n    elif n == 43:\n        return True\n    elif n == 44:\n        return True\n    elif n == 45"}
{"task_id": "MBPP/123", "completion": "\nReturn the sum of proper divisors of n\"\"\"\n        return sum(i for i in range(1, n) if n % i == 0)\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        n = sum_proper_divisors(i)\n        if n < limit and sum_proper_divisors(n) == i:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    for i in range(len(string)):\n        count_ones = 0\n        count_zeros = 0\n        for j in range(i, len(string)):\n            if string[j] == '1':\n                count_ones += 1\n            else:\n                count_zeros += 1\n            diff = abs(count_ones - count_zeros)\n            max_diff = max(max_diff, diff)\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Find the common divisors of two numbers\n    common_divisors = [i for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0]\n    # Return the sum of the common divisors\n    return sum(common_divisors)  # <--- changed here\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    while y != 0:\n        if y % 2 == 1:\n            result += x\n        x <<= 1\n        y >>= 1\n    return result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    n = len(my_matrix)\n    if n != len(my_matrix[0]):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum(my_matrix[i][::-1]):\n            return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum([my_matrix[j][i] for j in range(n)]):\n            return False\n    if sum(my_matrix[i][i] for i in range(n)) != sum(my_matrix[i][n-i-1] for i in range(n)):\n        return False\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each item\n    freq_dict = defaultdict(int)\n    \n    # Iterate over the list to count the frequency of each item\n    for num in nums:\n        freq_dict[num] += 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_dict.values())\n    \n    return max_freq\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left = 0\n    right = len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    for i in range(p):\n        if arr[-1] % 2 == 0:\n            arr[-1] += 1\n        else:\n            arr[-1] -= 1\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units < 100:\n        return units * 1.20\n    elif units < 200:\n        return units * 1.50\n    else:\n        return units * 2.00\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of zeros with the same length as the input array\n    zero_array = array('i', [0] * len(nums))\n    \n    # Iterate over the input array and count the number of zeroes\n    for num in nums:\n        if num == 0:\n            zero_array[0] += 1\n    \n    # Return the ratio of zeroes\n    return zero_array[0] / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    while n > 0:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    return [i for i in test_list if test_list.count(i) == 1]\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find index of max element in unsorted part of list\n        max_index = nums.index(max(nums[:size]))\n        # If max element is not at the beginning of unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip max element to the beginning of unsorted part\n            nums[:max_index + 1] = nums[:max_index + 1][::-1]\n            # Flip max element to the end of unsorted part\n            nums[:size] = nums[:size][::-1]\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for same pairs\n    count = 0\n    # Iterate over the first list\n    for i in range(len(list1)):\n        # Iterate over the second list\n        for j in range(len(list2)):\n            # Check if the pair is the same in the third list\n            if (list1[i], list2[j]) in list3:\n                # If the pair is the same, increment the counter\n                count += 1\n    # Return the count of same pairs\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    lists = []\n    for i in Input:\n        if isinstance(i, list):\n            lists.append(i)\n    return lists\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_diff += abs(arr[i] - arr[j])\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    arr.sort()\n    max_diff = arr[n - 1] - arr[0]\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    # Create a 2D array to store the maximum path sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row of the dp array with the values from the first row of the triangle\n    dp[0] = tri[0]\n    \n    # Iterate over each row in the triangle starting from the second row\n    for i in range(1, m):\n        # Iterate over each element in the current row\n        for j in range(n):\n            # If the current element is the first element in the row, the maximum path sum is the sum of the current element and the maximum path sum of the element above it\n            if j == 0:\n                dp[i][j] = tri[i][j] + dp[i-1][j]\n            # If the current element is the last element in the row, the maximum path sum is the sum of the current element and the maximum path sum of the element above it\n            elif j == n - 1:\n                dp[i][j] = tri[i][j] + dp[i-1][j-1]\n            # For other elements, the maximum path sum is the maximum of the sum of the current element and the maximum path sum of the element above and to the left, and the sum of the current element and the maximum path sum of the element above and to the right\n            else:\n                dp[i][j] = tri[i][j] + max(dp[i-1][j-1], dp[i-1][j])\n    \n    # The maximum total path sum is the maximum value in the last row of the dp array\n    return max(dp[-1])\n"}
{"task_id": "MBPP/148", "completion": "\n    if x < 10:\n        return x\n    else:\n        return sum_digits_single(x // 10) + x % 10\n\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [0] * n\n    dp[0] = 1\n    dp[1] = 2\n    for i in range(2, n):\n        if abs(arr[i] - arr[i - 1]) == 1:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n    return dp[-1]\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    elif a > b:\n        return False\n    else:\n        return does_Contain_B(a + c, b, c)\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x)  2: return x\n    mid = len(x) // 2\n    left = merge_sort(x[:mid])\n    right = merge_sort(x[mid:])\n    return merge(left, right)"}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    return nums[N][0]\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '0', append '1' to the result\n        if bit == '0':\n            result += '1'\n        # If the bit is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    # Split the string by comma and space\n    str_list = tuple_str.split(', ')\n    # Convert each string to integer and return as a tuple\n    return tuple(int(i) for i in str_list)\n"}
{"task_id": "MBPP/157", "completion": "\n    if not list1:\n        return []\n\n    encoded_list = []\n    count = 1\n\n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            encoded_list.append((list1[i - 1], count))\n            count = 1\n\n    encoded_list.append((list1[-1], count))\n    return encoded_list\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    left, right = 0, n - 1\n    while left < right:\n        if arr[left] == arr[right]:\n            return 0\n        if arr[left] + arr[right] <= k:\n            left += 1\n        else:\n            right -= 1\n    return right - left + 1\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a * x + b * y == n:\n                return x, y\n    return None\n"}
{"task_id": "MBPP/161", "completion": "\n    return [value for value in list1 if value not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    total = 0\n    for i in range(n, 0, -2):\n        total += i\n    return total\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * s) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    char_count = {}\n    for i in range(len(str1)):\n        if str1[i] in char_count:\n            char_count[str1[i]] += 1\n        else:\n            char_count[str1[i]] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    # Initialize a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Return the count of the character 's'\n    return char_count.get('s', 0) + char_count.get('t', 0) + char_count.get('d', 0)\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^A-Za-z0-9]+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for i in l:\n        if i[0] in d:\n            d[i[0]].append(i[1])\n        else:\n            d[i[0]] = [i[1]]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    lcm = 1\n    for i in range(1, L + 1):\n        for j in range(i + 1, R + 1):\n            if gcd(i, j) == 1:\n                lcm = i * j\n                break\n        if lcm != 1:\n            break\n    return lcm\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    return x % 2 == 0\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude to radians\n    slat, slon = radians(slat), radians(slon)\n    elat, elon = radians(elat), radians(elon)\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n\n    # Radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate the distance\n    distance = R * c\n\n    return distance\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Regular expression to find uppercase, lowercase, special character, numeric values\n    pattern = r\"[A-Z]+|[a-z]+|[0-9]+|[^A-Za-z0-9]\"\n    matches = re.findall(pattern, string)\n    return matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    left, right = 0, n - 1\n    pairs = 0\n    while left < right:\n        if arr[right] - arr[left] == k:\n            pairs += 1\n            left += 1\n            right -= 1\n        elif arr[right] - arr[left] > k:\n            right -= 1\n        else:\n            left += 1\n    return pairs\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus coordinates\n    focus_x = -focal_length\n    focus_y = 0\n    \n    return focus_x, focus_y\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequences of\n    # substrings. dp[i][j] contains the length of the longest common\n    # subsequence of X[0..i-1] and Y[0..j-1]\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n    # To store the length of the longest common subsequence\n    lcs_length = 0\n\n    # Following steps build dp[][] in bottom up fashion\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n                lcs_length = max(lcs_length, dp[i][j])\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    # Following code is used to print LCS\n    index = dp[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index+1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store\n    # characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X and Y are same, then current character\n        # is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction\n        # of larger value\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Return the longest common subsequence\n    return \"\".join(lcs[:index+1])\n"}
{"task_id": "MBPP/188", "completion": "\n    i = 1\n    while i * i <= n:\n        if n % (i * i) == 0:\n            return True\n        i += 1\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers\n    num_set = set()\n    for num in arr:\n        if num > 0:\n            num_set.add(num)\n\n    # Iterate from 1 to n\n    for i in range(1, n + 1):\n        # If the number is not in the set, return it\n        if i not in num_set:\n            return i\n\n    # If no missing positive number is found, return n + 1\n    return n + 1\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points inside the square\n    # The square has side length of (x2 - x1) and (y2 - y1)\n    # The number of integral points is the product of the number of integral points on each side\n    # The number of integral points on each side is the side length plus 1\n    integral_points = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return integral_points\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if str.isalpha() or str.isdigit():\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Check if the tuples are of the same length\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Tuples are not of the same length\"\n\n    # Check if the tuples are empty\n    if len(test_tup1) == 0:\n        return \"Error: Tuples are empty\"\n\n    # Check if the tuples contain only numbers\n    if not all(isinstance(i, (int, float)) for i in test_tup1) or not all(isinstance(i, (int, float)) for i in test_tup2):\n        return \"Error: Tuples contain non-numeric values\"\n\n    # Perform exponentiation\n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] ** test_tup2[i])\n\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major and semi-minor axes of the ellipse\n    a = a\n    b = b\n\n    # Calculate the area of the ellipse\n    area_ellipse = math.pi * a * b\n\n    # Calculate the area of the triangle\n    area_triangle = (1/2) * a * b\n\n    # Calculate the ratio of the area of the triangle to the area of the ellipse\n    ratio = area_triangle / area_ellipse\n\n    # Return the ratio\n    return ratio\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while n >= 2**i:\n        i += 1\n    return i - 1\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_index = list1.index(max_val)\n    return max_index\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    # Initialize inversion counter\n    inversion_count = 0\n    \n    # Iterate over the tuple list\n    for i in range(len(test_tup)):\n        # Iterate over the remaining elements in the tuple list\n        for j in range(i + 1, len(test_tup)):\n            # Check if the current element is greater than the next element\n            if test_tup[i] > test_tup[j]:\n                # If true, increment the inversion counter\n                inversion_count += 1\n                \n    # Return the inversion count\n    return inversion_count\n"}
{"task_id": "MBPP/206", "completion": "\n    return ''.join(test_tup)\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                dp[i][j] = 2 if i == j else dp[i + 1][j - 1] + 2\n                max_length = max(max_length, dp[i][j])\n    return max_length\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^\\d{1,3}(?:\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'[^a-zA-Z0-9]')\n    if pattern.search(string):\n        return False\n    else:\n        return True\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([i**4 for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return test_tup1 + test_tup2\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    return set(list1).issubset(set(list2))\n"}
{"task_id": "MBPP/217", "completion": "\n    char_dict = {}\n    for char in str:\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = 1\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    # Calculate the minimum number of operations required\n    min_ops = math.ceil(diff / 2)\n    return min_ops\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Sort the tuple in ascending order\n    sorted_tup = sorted(test_tup)\n    \n    # Extract the minimum and maximum k elements from the sorted tuple\n    min_k = sorted_tup[:K]\n    max_k = sorted_tup[-K:]\n    \n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, dots, colon\n    pattern = r'[ ,.:]+'\n    matches = re.findall(pattern, text)\n    # Sort matches by length in descending order\n    matches.sort(key=len, reverse=True)\n    # Replace each match with a space\n    for match in matches:\n        text = text.replace(match, ' ')\n    # Replace n occurrences of spaces with a space\n    text = re.sub(r'\\s+', ' ', text, n)\n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if len(test_tuple) == 0:\n        return True\n    else:\n        first_type = type(test_tuple[0])\n        for i in test_tuple:\n            if type(i) != first_type:\n                return False\n        return True\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count of the element\n    count = 0\n    # Traverse the array\n    for i in range(n):\n        # If the element is equal to x, increment the count\n        if arr[i] == x:\n            count += 1\n        # If the element is not equal to x, decrement the count\n        else:\n            count -= 1\n        # If the count is zero, reset the count\n        if count == 0:\n            count = 1\n        # If the count is greater than n/2, return True\n        if count > n / 2:\n            return True\n    # If the count is not greater than n/2, return False\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    else:\n        return find_Min(arr, low, mid)\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([str[i] for i in range(len(str)) if i % 2 != 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Check if the range is valid\n    if l < 0 or r >= n:\n        return False\n\n    # Calculate the number of bits in the given range\n    num_bits = r - l + 1\n\n    # Calculate the number of bits that are set in the given range\n    num_set_bits = (n - 1) - (n - 1 - (1 << num_bits)) + 1\n\n    # Check if all bits are set\n    return num_set_bits == num_bits\n"}
{"task_id": "MBPP/229", "completion": "\n    return sorted(arr, key=lambda x: (x < 0, x))\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Initialize the maximum sum\n    max_sum = 0\n\n    # Iterate over the triangle numbers\n    for i in range(1, n + 1):\n        # Calculate the ith triangle number\n        tri_num = tri[i - 1]\n\n        # Update the maximum sum\n        max_sum = max(max_sum, tri_num)\n\n    # Return the maximum sum\n    return max_sum\n\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n & 0xAAAAAAAA  # 1010 1010 1010 1010 in binary\n"}
{"task_id": "MBPP/236", "completion": "\n    # Initialize count of equilateral triangles\n    count = 0\n\n    # Iterate over all possible side lengths\n    for side in range(1, N + 1):\n        # Calculate the area of the equilateral triangle with side length 'side'\n        area = (math.sqrt(3) / 4) * (side ** 2)\n\n        # Calculate the number of equilateral triangles that can fit in the given triangle\n        num_triangles = math.floor((K * area) / area)\n\n        # Update the count of equilateral triangles\n        count += num_triangles\n\n    return count\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a Counter object from the list of tuples\n    counter = Counter(test_list)\n    \n    # Get the most common elements\n    most_common = counter.most_common()\n    \n    # Get the maximum count\n    max_count = max(counter.values())\n    \n    # Get the elements with the maximum count\n    max_elements = [element for element, count in most_common if count == max_count]\n    \n    return max_elements\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    if n == 1:\n        return m\n    if n == 2:\n        return m * (m + 1) // 2\n    dp = [0] * (n + 1)\n    dp[1] = m\n    dp[2] = m * (m + 1) // 2\n    for i in range(3, n + 1):\n        dp[i] = sum(dp[j] * (m - 2 * (i - j) + 1) for j in range(1, i))\n    return dp[n]  # return the last element of dp array\n\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1] = list2[-1]\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [['*' for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: (x[0], lst.count(x[0])))\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.sqrt(N)\n    root = math.ceil(root)\n    return root * root\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of bi-tonic sub-sequence\n    # ending at the current position and the maximum sum of bi-tonic sub-sequence\n    # ending at the previous position\n    max_ending_here = max_ending_prev = float('-inf')\n    \n    # Traverse the array from left to right\n    for i in range(n):\n        # Update max_ending_here to be the maximum of the current element and the sum\n        # of max_ending_here and the current element\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        \n        # Update max_ending_prev to be the maximum of max_ending_prev and max_ending_here\n        max_ending_prev = max(max_ending_prev, max_ending_here)\n    \n    # Traverse the array from right to left\n    for i in range(n - 1, -1, -1):\n        # Update max_ending_here to be the maximum of the current element and the sum\n        # of max_ending_here and the current element\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        \n        # Update max_ending_prev to be the maximum of max_ending_prev and max_ending_here\n        max_ending_prev = max(max_ending_prev, max_ending_here)\n    \n    # Return the maximum sum of bi-tonic sub-sequence\n    return max_ending_prev\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"number must be non-negative\")\n    if number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.000001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return [num for num in array_nums1 if num in array_nums2]\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] + list\n"}
{"task_id": "MBPP/252", "completion": "\n    return [cmath.polar(num) for num in numbers]\n\n"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\ba\\w*|e\\w*', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    return list(combinations_with_replacement(l, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return list(filter(lambda x: x % 2 != 0, array_nums))\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum element from each list\n    return max1, max2\n"}
{"task_id": "MBPP/260", "completion": "\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if all(num % p > 0 for p in primes):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n"}
{"task_id": "MBPP/261", "completion": "\n    try:\n        result = tuple(test_tup1[i] / test_tup2[i] for i in range(len(test_tup1)))\n        return result\n    except ZeroDivisionError:\n        return \"Error: Division by zero is not allowed\"\n    except TypeError:\n        return \"Error: Both tuples must contain numbers\"\n    except Exception as e:\n        return f\"An error occurred: {str(e)}\"\n\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # Calculate dog's age in years\n    d_age = h_age * 7\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        if i % 2 != 0:\n            sum += i ** 2\n    return sum\n"}
{"task_id": "MBPP/268", "completion": "\n    return n * 2\n\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    even_index = 0\n    for i in range(n):\n        if arr[i] % 2 == 0:\n            even_sum += arr[i]\n            even_index += i\n    return even_sum, even_index\n"}
{"task_id": "MBPP/271", "completion": "\n    return sum([i**5 for i in range(1, n+1) if i % 2 == 0])\n"}
{"task_id": "MBPP/272", "completion": "\n    return test_list[-1]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    sum = 0\n    for k in range(0, n + 1):\n        # calculate binomial coefficient\n        binomial_coeff = math.comb(n, k)\n        # check if binomial coefficient is even\n        if binomial_coeff % 2 == 0:\n            sum += binomial_coeff\n    return sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    return n - a.count(a[-1])\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return test_tup.count(test_tup[0])\n"}
{"task_id": "MBPP/279", "completion": "\n    return n*(2*n-1) == 1\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    n = str(n)\n    for i in range(len(n)):\n        for j in range(i+1, len(n)):\n            if n[i] <= n[j]:\n                return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a(b{2,3})\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize variables\n    max_sum = float('-inf')\n    current_sum = 0\n    window_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the window sum\n        window_sum += a[i]\n\n        # If the window size is equal to k, update the current sum and max sum\n        if i >= k - 1:\n            current_sum = max(current_sum, window_sum)\n            max_sum = max(max_sum, current_sum)\n\n            # Remove the first element of the window\n            window_sum -= a[i - k + 1]\n\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum([i**2 for i in range(1, n+1)])\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    return N % 2 != 0\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(len(sublist) for sublist in list1)\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    for i in range(3, n + 1):\n        ways[i] = ways[i - 1] + ways[i - 2] * (k - 1)\n\n    return ways[n]\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w ** 2 + h ** 2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    sum_div = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum_div += i\n    return sum_div\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    return [item for sublist in l1 for item in sublist] & [item for sublist in l2 for item in sublist]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each tuple\n    max_aggregates = defaultdict(int)\n    \n    # Iterate over each tuple in the list\n    for tup in stdata:\n        # Calculate the aggregate for the current tuple\n        aggregate = sum(tup)\n        \n        # Update the maximum aggregate for the current tuple\n        max_aggregates[tup] = max(max_aggregates[tup], aggregate)\n    \n    # Return the maximum aggregate for each tuple\n    return max_aggregates\n\n"}
{"task_id": "MBPP/300", "completion": "\n    count = 0\n    for i in range(1 << n):\n        # Convert integer to binary and remove '0b' prefix\n        bin_i = bin(i)[2:]\n        # Pad with zeros to make length 2n\n        bin_i = bin_i.zfill(2 * n)\n        # Check if first n bits are the same as last n bits\n        if bin_i[:n] == bin_i[n:]:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    return n.bit_length() - 1\n"}
{"task_id": "MBPP/303", "completion": "\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversions += 1\n    return inversions\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Find the element at the given index after rotations\n    for i in range(rotations):\n        # Rotate the array to the right by one position\n        arr = [arr[-1]] + arr[:-1]\n        # Check if the index is within the range of the array\n        if index < len(arr):\n            return arr[index]\n    return None\n"}
{"task_id": "MBPP/305", "completion": "\n    return [word for word in words if word.startswith('p')]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == n:\n        return 0\n    if index == k:\n        return a[index]\n    if index > k:\n        return 0\n    return max(max_sum_increasing_subseq(a, n, index + 1, k), max_sum_increasing_subseq(a, n, index + 1, k) + a[index])\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Initialize the maximum product\n    max_product = 0\n\n    # Iterate over the first list\n    for i in range(N):\n        # Iterate over the second list\n        for j in range(N):\n            # Calculate the product of the current elements\n            product = nums1[i] * nums2[j]\n\n            # Update the maximum product if the current product is larger\n            max_product = max(max_product, product)\n\n    # Return the maximum product\n    return max_product\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    return [i for i in list1 if i > 0]\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n\n    return max(dp[0][n-1], dp[1][n-1])  # return max of last row\n\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(alist)]\n\n"}
{"task_id": "MBPP/318", "completion": "\n    a, b, c = map(int, s.split('+'))\n    return a * b * c\n"}
{"task_id": "MBPP/319", "completion": "\n    pattern = r'\\b\\w{5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_n = n * (n + 1) // 2\n    sum_n_squared = n * (n + 1) * (2 * n + 1) // 6\n    return sum_n_squared - sum_n ** 2\n"}
{"task_id": "MBPP/321", "completion": "\n    # Convert the string to a list of characters\n    s = list(s)\n    # Initialize the count of demlo numbers\n    count = 0\n    # Iterate over the list of characters\n    for i in range(len(s)):\n        # Check if the character is a digit\n        if s[i].isdigit():\n            # If the character is a digit, increment the count\n            count += 1\n    # Return the count of demlo numbers\n    return count\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_index = list1.index(min_val)\n    return min_index\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # Create a new array with the rotated elements\n        rotated_arr = [0] * n\n        for i in range(n):\n            rotated_arr[i] = arr[(i + cur) % n]\n    else:\n        # Rotate the array in-place\n        arr[:] = arr[cur:] + arr[:cur]\n\n    return rotated_arr if out_of_place else arr\n\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[i] for i in range(0, len(test_tuple), 2))\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares that sum up to each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square that is less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the square is less than or equal to the current number, update the minimum number of squares\n            if j * j <= i:\n                min_squares[i] = min(min_squares[i], min_squares[i - j * j] + 1)\n\n    return min_squares[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word_count[word] += 1\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return most_common_words\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    n = n % len(list1)\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return list.count(-1)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    return bin(n).count('0')\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n / 2) * (2 * a + (n - 1) * d)\n\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    return month_days.get(monthname1, None) == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i] == s[j - 1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty list to store the divisors\n    divisors = []\n    \n    # Iterate over the range from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, append it to the list\n            divisors.append(i)\n    \n    # Return the list of divisors\n    return divisors\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # We then select the three smallest numbers from the sorted list\n    three_smallest = sorted_lst[:3]\n    \n    # Finally, we sum the three smallest numbers\n    sum_of_three_smallest = sum(three_smallest)\n    \n    return sum_of_three_smallest\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    min_range_start = 0\n    min_range_end = 0\n\n    for i, num in enumerate(list):\n        heappush(min_heap, Node(num, i, 0))\n        heappush(max_heap, Node(num, i, 0))\n\n    while len(min_heap) > 0:\n        min_node = heappop(min_heap)\n        max_node = heappop(max_heap)\n\n        if min_node.value < max_node.value:\n            min_range = max(min_range, max_node.value - min_node.value)\n            if min_node.index + 1 < len(list[min_node.list_num]):\n                heappush(min_heap, Node(list[min_node.list_num][min_node.index + 1], min_node.list_num, min_node.index + 1))\n            if max_node.index + 1 < len(list[max_node.list_num]):\n                heappush(max_heap, Node(list[max_node.list_num][max_node.index + 1], max_node.list_num, max_node.index + 1))\n        else:\n            break\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    return sum(c.isdigit() for c in s)\n"}
{"task_id": "MBPP/344", "completion": "\n    # Initialize count of odd squares\n    count = 0\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if the number is odd\n        if i % 2 != 0:\n            # Calculate the square of the number\n            square = i ** 2\n            # Check if the square is within the range [m, n]\n            if m <= square <= n:\n                # Increment the count\n                count += 1\n                \n    # Return the count of odd squares\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    if len(nums) < 2:\n        return False\n    return all(nums[i] - nums[i - 1] == 1 for i in range(1, len(nums)))\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        a, b = 1, 2\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/347", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * j <= m * n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < r:\n        return 0\n    if n == r:\n        return 1\n    if (n, r) in memo:\n        return memo[(n, r)]\n    res = 0\n    for i in range(1, n + 1):\n        res += bin_coff(n - i, r - 1)\n    memo[(n, r)] = res\n    return res\n"}
{"task_id": "MBPP/349", "completion": "\n    return string == bin(int(string, 2))[2:]\n"}
{"task_id": "MBPP/350", "completion": "\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n"}
{"task_id": "MBPP/351", "completion": "\n    for i in range(n):\n        if arr[i] == k:\n            return i\n    return -1\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [item[:n] + item[n+1:] for item in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    return 4 * radius ** 2\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - a - b\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = test_list[0]\n    for i in test_list:\n        if i > max_val:\n            max_val = i\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is positive\n    if d > 0:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n):\n        carol = carol + i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the maximum count\n    max_count = max(count_dict.values())\n\n    # Find the item with the maximum count\n    max_item = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_item, max_count\n"}
{"task_id": "MBPP/363", "completion": "\n    new_list = []\n    for i in range(K):\n        new_list.append((test_list[i % len(test_list)], i))\n    return new_list\n"}
{"task_id": "MBPP/364", "completion": "\n    # Convert the string to a list of characters\n    ch = list(ch)\n    \n    # Initialize the count of flips\n    flips = 0\n    \n    # Iterate over the list of characters\n    for i in range(len(ch)):\n        # If the character at the current index is not equal to the character at the next index\n        if ch[i] != ch[i+1]:\n            # Increment the count of flips\n            flips += 1\n    \n    # Return the count of flips\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        if list_nums[i] * list_nums[i + 1] > max_product:\n            max_product = list_nums[i] * list_nums[i + 1]\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    return (abs(left_height - right_height) <= 1 and\n            is_tree_balanced(root.left) and\n            is_tree_balanced(root.right))\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))\n"}
{"task_id": "MBPP/371", "completion": "\n    A.sort()\n    for i in range(len(A)):\n        if A[i] != i + left_element:\n            return i + left_element\n    return len(A) + left_element\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 1:\n        return [test_list[-1]] + test_list[:-1]\n    else:\n        return test_list\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    low = 0\n    high = n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if A[mid] > A[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', toggle it to '0' and vice versa\n        if bit == '1':\n            result += '0'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # Create a dictionary to store the frequency of each element in the array\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the smallest value in the array\n    smallest = min(arr)\n\n    # Return the frequency of the smallest value\n    return freq_dict.get(smallest, 0)\n\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    i = 0\n    while 2 ** i <= n:\n        i += 1\n    return 2 ** (i - 1)\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create a dictionary with keys from l1 and values from l2\n    dict1 = dict(zip(l1, l2))\n    # Create a dictionary with keys from l1 and values from l3\n    dict2 = dict(zip(l1, l3))\n    # Create a dictionary with keys from l1 and values from dict1 and dict2\n    dict3 = {key: {k: v for k, v in zip(dict1.keys(), dict2.values())} for key in l1}\n    return dict3\n"}
{"task_id": "MBPP/392", "completion": "\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    elif n == 3:\n        return 2\n    elif n == 4:\n        return 4\n    else:\n        return max(get_max_sum(n//2) + (n//4) + (n//5), get_max_sum(n//3) + (n//4) + (n//5))\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(len(i) for i in input_list)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if len(string) == 1:\n        return True\n    if string[0] == string[-1]:\n        return True\n    return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return sum(int(digit) for num in nums for digit in str(num))  # <--- changed here\n\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Check if the element is a tuple\n        if isinstance(test_tup1[i], tuple):\n            # If the element is a tuple, add the corresponding element from the second tuple\n            result.append((test_tup1[i][0] + test_tup2[i][0], test_tup1[i][1] + test_tup2[i][1]))\n        else:\n            # If the element is not a tuple, add it to the result as is\n            result.append(test_tup1[i])\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/402", "completion": "\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if r == 1:\n        return n\n    pwr = [1] * (n + 1)\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pwr[i] = (pwr[i - 1] * p) % p\n        fact[i] = (fact[i - 1] * i) % p\n        inv[i] = pow(fact[i], p - 2, p)\n    ans = 1\n    for i in range(r):\n        ans = (ans * (n - i)) % p\n        ans = (ans * inv[i + 1]) % p\n    return ans\n"}
{"task_id": "MBPP/403", "completion": "\n    try:\n        result = urlparse(str)\n        return all([result.scheme, result.netloc])\n    except ValueError:\n        return False\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    for i in range(len(n) - 2, -1, -1):\n        if n[i] < n[i + 1]:\n            break\n    else:\n        return -1\n    for j in range(len(n) - 1, i, -1):\n        if n[j] > n[i]:\n            break\n    else:\n        return -1\n    n = list(n)\n    n[i], n[j] = n[j], n[i]\n    n[i + 1:] = sorted(n[i + 1:])\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    \n    # Push the first pair into the heap\n    heapq.heappush(min_heap, (nums1[0] + nums2[0], 0, 0))\n    \n    # Initialize the result list\n    result = []\n    \n    # Loop k times to find the k smallest pairs\n    for _ in range(k):\n        # Get the smallest pair from the heap\n        _, i, j = heapq.heappop(min_heap)\n        \n        # Add the pair to the result list\n        result.append((nums1[i], nums2[j]))\n        \n        # If the current pair is not the last pair in the first array, push the next pair into the heap\n        if i + 1 < len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        # If the current pair is not the last pair in the second array, push the next pair into the heap\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize minimum product with first element of list\n    min_product = list1[0][0] * list1[0][1]\n    # Iterate over list to find minimum product\n    for pair in list1:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'_([a-z])', lambda x: x.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1][0]  # Return the first element of the nth tuple\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n    max1 = max2 = float('-inf')\n    for num in arr:\n        if num > max1:\n            max1, max2 = num, max1\n        elif num > max2:\n            max2 = num\n    return max1 * max2\n"}
{"task_id": "MBPP/416", "completion": "\n    if n < 0:\n        return -MAX\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n       "}
{"task_id": "MBPP/417", "completion": "\n    return [list(g) for k, g in groupby(sorted(Input), key=lambda x: x[0])]\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n    return max_len\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(list1))\n    return total_sum * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/421", "completion": "\n    return ''.join(str(i) for i in test_tup)\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_cubes = 0\n    # Loop through first n natural numbers\n    for i in range(1, n + 1):\n        # Add cube of current number to sum\n        sum_cubes += i ** 3\n    # Calculate average of cubes\n    average_cubes = sum_cubes / n\n    return average_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # fill the dp array in a bottom-up manner\n    for i in range(1, m):\n        for j in range(1, n):\n            # for each cell, consider the maximum gold that can be collected from the top, left, and top-left cells\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # the maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return [string[-1] for string in test_tuple]\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    return dt.strftime('%d-%m-%Y')\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(test_tup1)):\n        # Append a tuple containing the elements at the current index from both tuples\n        result.append((test_tup1[i], test_tup2[i]))\n    \n    # Return the list of tuples\n    return result\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    # Calculate the directrix\n    directrix = -focal_length\n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    return area\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > element for element in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    return [i for i in list1 if i < 0]\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return sum(L)\n"}
{"task_id": "MBPP/440", "completion": "\n    # Regular expression to find adverbs\n    adverb_pattern = r'\\b(quickly|slowly|well|badly|happily|sadly|wisely|carefully|loudly|silently|quietly|loud|soft|fast|slow|hard|easy|well|bad|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderly|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|ugly|nice|good|great|excellent|wonderful|beautiful|"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    return sum(1 for num in nums if num > 0)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    return max(list1)\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i:i+K]) for i in range(0, len(test_list), K)]\n\n"}
{"task_id": "MBPP/445", "completion": "\n    return tuple(a * b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Count the occurrence of each element in the tuple\n    count_tup = Counter(tup)\n    # Return the count of each element in the list and tuple\n    return count, count_tup\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return [num ** 3 for num in nums]\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    else:\n        a, b = 2, 5\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Check if the points are collinear\n    if (x1 - x3) * (y2 - y3) == (x2 - x3) * (y1 - y3):\n        return False\n    else:\n        return True\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s for s in str if len(s) == l]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    return re.search(r'\\b\\w*z\\b', text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub(r'[A-Z]+', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return all(value == n for value in dict.values())\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return arr[low]\n    # If only one element is left, it is the peak\n    if high == low + 1:\n        if arr[low] > arr[high]:\n            return arr[low]\n        else:\n            return arr[high]\n\n    # Find the middle point\n    mid = (low + high) // 2\n\n    # If middle element is greater than its neighbors, it is the peak\n    if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == n - 1 or arr[mid] >= arr[mid + 1]):\n        return arr[mid]\n\n    # If middle element is smaller than the previous element, the peak must be in the left half\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    # If middle element is smaller than the next element, the peak must be in the right half\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product ending at the first position\n    max_product[0] = arr[0]\n    # Initialize the minimum product ending at the first position\n    min_product[0] = arr[0]\n    # Iterate over the array starting from the second position\n    for i in range(1, n):\n        # If the current element is greater than 0, update the maximum product ending at the current position\n        if arr[i] > 0:\n            max_product[i] = max(arr[i], max_product[i-1] * arr[i])\n            min_product[i] = min(arr[i], min_product[i-1] * arr[i])\n        # If the current element is less than 0, update the minimum product ending at the current position\n        elif arr[i] < 0:\n            max_product[i] = max(arr[i], min_product[i-1] * arr[i])\n            min_product[i] = min(arr[i], max_product[i-1] * arr[i])\n        # If the current element is equal to 0, reset the maximum and minimum product ending at the current position\n        else:\n            max_product[i] = 0\n            min_product[i] = 0\n    # Return the maximum product ending at the last position\n    return max(max_product)\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, b - a) for a, b in zip(price, price[1:]))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next index\n            for j in range(i + 1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # calculate the remainder of each element in the array divided by n\n    remainders = [x % n for x in arr]\n    return remainders\n"}
{"task_id": "MBPP/472", "completion": "\n    return len(l) == len(set(l)) and all(l[i] + 1 == l[i+1] for i in range(len(l)-1))\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower() == string\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    for char in str1:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Find the character with the maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if n == 0:\n        return sum == 0\n    if sum == 0:\n        return True\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r\"[A-Z][a-z]+\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/483", "completion": "\n    i = 1\n    while True:\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        if factorial % x == 0:\n            return factorial\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [t for t in test_list1 if t not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    return str(n) == str(n)[::-1]\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r to avoid duplicate calculations\n        r = n - r\n    C = [0] * (r + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            C[j] += C[j - 1]\n    return C[r]\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Find the largest number in the array\n    largest = max(arr)\n    \n    # Count the frequency of the largest number\n    frequency = arr.count(largest)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the center of the hexagon\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the distance between the start and end points\n    distance = math.sqrt((endx - startx) ** 2 + (endy - starty) ** 2)\n\n    # Calculate the angle between the start and end points\n    angle = math.atan2(endy - starty, endx - startx)\n\n    # Calculate the radius of the hexagon\n    hex_radius = radius\n\n    # Calculate the coordinates of the hexagon\n    hex_coords = []\n    for i in range(6):\n        # Calculate the angle of the current point\n        point_angle = angle + (i * math.pi / 3)\n\n        # Calculate the x and y coordinates of the current point\n        point_x = center_x + math.cos(point_angle) * hex_radius\n        point_y = center_y + math.sin(point_angle) * hex_radius\n\n        # Add the point to the list of coordinates\n        hex_coords.append((point_x, point_y))\n\n    return hex_coords\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert binary string to integer\n    integer = int(''.join(test_tup), 2)\n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(n)]\n\n"}
{"task_id": "MBPP/497", "completion": "\n    return math.pi * r * (r + math.sqrt(h ** 2 + r ** 2))\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    if x > y:\n        greater = x\n    else:\n        greater = y\n    for i in range(greater, 0, -1):\n        if ((x % i == 0) and (y % i == 0)):\n            return i\n    return 1\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return [sum(nums[i:i+2]) for i in range(len(nums)-1)]\n\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    removewords_set = set(removewords)\n    \n    # Use a list comprehension to create a new list that excludes the words to remove\n    new_list = [word for word in list1 if word not in removewords_set]\n    \n    return new_list\n"}
{"task_id": "MBPP/508", "completion": "\n    return list(l1) == list(l2)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product < k:\n            count += 1\n    return count\n"}
