{"task_id": "EvoEval/0", "completion": "\n    base_cost = 50\n    total_cost = 0\n    string_item = False\n\n    location_factors = {\n        \"Local\": 1,\n        \"National\": 1.5,\n        \"International\": 25\n    }\n\n    location_factor = location_factors.get(location, 1)\n\n    for item in items:\n        if isinstance(item, str):\n            total_cost += base_cost * 15\n            string_item = True\n            weight = 1\n        else:\n            weight = item\n            cost = base_cost\n            if weight > 5:\n                cost += 10\n            total_cost += cost\n\n    if string_item:\n        total_cost *= 15\n\n    total_cost *= location_factor\n    return f\"{total_cost:.2f}\"\n"}
{"task_id": "EvoEval/1", "completion": "\n    base_cost = 50\n    total_cost = 0\n\n    # Determine the location factor\n    if location == \"Local\":\n        location_factor = 1\n    elif location == \"National\":\n        location_factor = 1.5\n    elif location == \"International\":\n        location_factor = 25\n    else:\n        location_factor = 1\n\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0  # String item considered as 1kg\n        else:\n            weight = float(item)\n\n        item_cost = base_cost\n        if weight > 5:\n            item_cost += 10  # Additional charge for items over 5kg\n\n        total_cost += item_cost\n\n    total_cost *= location_factor\n    return round(total_cost, 2)\n"}
{"task_id": "EvoEval/2", "completion": "\n    if isinstance(key, str):\n        key = sum(ord(char) for char in key)\n\n    encrypted_words = []\n    \n    for word in words:\n        encrypted_word = []\n        for char in word:\n            if char.isalpha():\n                shift = (ord(char.lower()) - ord('a') + key) % 26\n                new_char = chr(shift + ord('a'))\n                encrypted_word.append(new_char if char.islower() else new_char.upper())\n            else:\n                encrypted_word.append(char)\n        encrypted_words.append(''.join(encrypted_word))\n    \n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    def backtrack(index: int, path: str):\n        if index == len(input_string):\n            combinations.append(path)\n            return\n        \n        # Single digit decoding\n        if index < len(input_string):\n            single_digit = int(input_string[index])\n            if 1 <= single_digit <= 26:\n                backtrack(index + 1, path + chr(single_digit + 96))\n        \n        # Double digit decoding\n        if index + 1 < len(input_string):\n            double_digit = int(input_string[index:index + 2])\n            if 10 <= double_digit <= 26:\n                backtrack(index + 2, path + chr(double_digit + 96))\n\n    combinations = []\n    backtrack(0, \"\")\n    return combinations\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n\n    count = 1  # The first candle is always lit\n    max_height = candles[0]\n\n    for height in candles[1:]:\n        if height > max_height:\n            count += 1\n            max_height = height\n\n    return count\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    rows, cols = len(matrix), len(matrix[0])\n\n    for r in range(rows):\n        if r % 2 == 0:\n            # Traverse from left to right\n            for c in range(cols):\n                result.append(matrix[r][c])\n        else:\n            # Traverse from right to left\n            for c in range(cols - 1, -1, -1):\n                result.append(matrix[r][c])\n\n    return result\n"}
{"task_id": "EvoEval/6", "completion": "\n    x, y = position\n\n    # Check if the position is out of bounds\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n        return grid\n\n    # Check if the clicked cell is a mine\n    if grid[x][y] == 1:\n        return grid\n\n    # Check if the clicked cell is already revealed\n    if grid[x][y] == 0:\n        return grid\n\n    # If the clicked cell is empty, reveal adjacent cells\n    def reveal_adjacent_cells(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return\n        if grid[i][j] == 1 or grid[i][j] == 0:\n            return\n        grid[i][j] = 0\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                if di != 0 or dj != 0:\n                    reveal_adjacent_cells(i + di, j + dj)\n\n    reveal_adjacent_cells(x, y)\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    x, y = 0, 0\n    for direction in code_sequence:\n        if direction == 0:  # North\n            y += 1\n        elif direction == 1:  # East\n            x += 1\n        elif direction == 2:  # South\n            y -= 1\n        elif direction == 3:  # West\n            x -= 1\n\n    if (x, y) == (0, 0) and len(code_sequence) > 0:\n        return 'Shang found'\n    else:\n        return 'Shangri not found'\n"}
{"task_id": "EvoEval/8", "completion": "\n    if canvas.count('P') != 1:\n        return 'Invalid canvas' if canvas.count('P') > 1 else canvas\n\n    painter_index = canvas.index('P')\n    left_index = painter_index\n    right_index = painter_index\n\n    # Move left\n    while left_index > 0 and canvas[left_index - 1] == '-':\n        left_index -= 1\n\n    # Move right\n    while right_index < len(canvas) - 1 and canvas[right_index + 1] == '-':\n        right_index += 1\n\n    painted_spaces = right_index - left_index + 1\n    total_empty_spaces = canvas.count('-')\n\n    if total_empty_spaces % painted_spaces == 0:\n        return 'Invalid canvas'\n\n    # Create the transformed canvas\n    transformed_canvas = (\n        canvas[:left_index] +\n        'P' +\n        '*' * (right_index - left_index - 1) +\n        canvas[right_index + 1:]\n    )\n\n    return transformed_canvas\n"}
{"task_id": "EvoEval/9", "completion": "\n    import string as str_lib\n\n    # Normalize the string by converting to lowercase and removing punctuation\n    normalized_string = string.lower().translate(str.maketrans('', '', str_lib.punctuation))\n    \n    # Split the string into words\n    words = normalized_string.split()\n    \n    # Calculate frequency of each word\n    frequency = {}\n    for word in words:\n        frequency[word] = frequency.get(word, 0) + 1\n    \n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_count = {'C': 0, 'D': 0, 'B': 0}\n    sounds = animal_string.split()\n    result = []\n    total_animals = 0\n\n    for sound in sounds:\n        if total_animals >= 5:\n            break\n        \n        animal = sound[0]\n        sound_count = sound.count('|')\n\n        if animal in animal_count and animal_count[animal] < 2:\n            animal_count[animal] += 1\n            result.append(sound_count)\n            total_animals += 1\n\n    return result\n"}
{"task_id": "EvoEval/11", "completion": "\n    if not fruits:\n        return \"\"\n\n    if len(fruits) == 1:\n        return f\"Oh are those {fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"Oh are those {', '.join(fruits[:-1])}, and {fruits[-1]} from {location}? Marvelous!\"\n"}
{"task_id": "EvoEval/12", "completion": "\n    from collections import Counter\n\n    # Count the occurrences of each element\n    count = Counter(flux_values)\n    \n    # Find the element with maximum occurrence (and the smallest one in case of a tie)\n    most_common_value = min((num for num, freq in count.items() if freq == max(count.values())))\n    \n    # Calculate the sum of all elements in the array\n    total_sum = sum(flux_values)\n    \n    # Calculate the unique energy signature\n    unique_energy_signature = total_sum * most_common_value\n    \n    return unique_energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n\n    frequency = {}\n    for elem in elems:\n        frequency[elem] = frequency.get(elem, 0) + 1\n\n    rarest_element = None\n    min_count = float('inf')\n\n    for elem in elems:\n        if frequency[elem] < min_count:\n            min_count = frequency[elem]\n            rarest_element = elem\n\n    return rarest_element\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = []\n\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Replace vowel\n                new_char = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            elif char.lower() in consonants:\n                # Replace consonant\n                new_char = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            else:\n                new_char = char\n            # Maintain original case\n            if char.isupper():\n                new_char = new_char.upper()\n            alias.append(new_char)\n        else:\n            alias.append(char)\n\n    return ''.join(alias)\n"}
{"task_id": "EvoEval/15", "completion": "\n    value_map = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n    counts = {}\n    \n    for card in hand:\n        value = card[:-1]  # Get the value part of the card\n        counts[value] = counts.get(value, 0) + 1\n    \n    score = 0\n    for value, count in counts.items():\n        if count == 2:  # Pair\n            score += value_map[value]\n        elif count == 3:  # Three of a kind\n            score += 2 * value_map[value]\n        elif count == 4:  # Four of a kind\n            score += 3 * value_map[value]\n        elif count == 5:  # Five of a kind\n            score += 4 * value_map[value]\n    \n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    a, b = 0, 1\n    total_sum = a + b\n\n    for _ in range(2, n):\n        a, b = b, a + b\n        total_sum += b\n\n    return total_sum\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard, power in wizards:\n        dragon_hp -= power\n        if dragon_hp <= 0:\n            return wizard\n    return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    count = 0\n    current = 7\n    while count < n:\n        if current % 7 == 0 and digit_sum(current) == 7:\n            count += 1\n        if count < n:\n            current += 7\n    return current\n"}
{"task_id": "EvoEval/19", "completion": "\n    humans_in_danger = 0\n    rows_with_vampires = set()\n    cols_with_vampires = set()\n\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 2:\n                rows_with_vampires.add(i)\n                cols_with_vampires.add(j)\n\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 1:\n                if i in rows_with_vampires or j in cols_with_vampires:\n                    humans_in_danger += 1\n\n    return humans_in_danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    \n    pattern = []\n    for i in range(1, n + 1):\n        ascending = ','.join(str(x) for x in range(1, i + 1))\n        descending = ','.join(str(x) for x in range(i, 0, -1))\n        pattern.append(ascending + ',' + descending)\n    \n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    def search_word(word, grid):\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # right, down, left, up\n                    if all(grid[(i + k * di) % n][(j + k * dj) % n] == word[k] for k in range(len(word))):\n                        return True\n        return False\n\n    for word in words:\n        if not search_word(word, grid):\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    light_year_km = 9.461e12\n    distance_km = t * v\n    distance_light_years = distance_km / light_year_km\n    return distance_light_years\n"}
{"task_id": "EvoEval/23", "completion": "\n    def nth_prime(n):\n        \"\"\"Return the n-th prime number.\"\"\"\n        count = 0\n        num = 1\n        while count < n:\n            num += 1\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    break\n            else:\n                count += 1\n        return num\n\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            index = ord(char) - ord('a') + 1\n            result.append(str(nth_prime(index)))\n        else:\n            result.append(char)\n\n    return ''.join(result)\n"}
{"task_id": "EvoEval/24", "completion": "\n    translation_map = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', \n        'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', \n        'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', \n        'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'\n    }\n    \n    translated_word = ''.join(translation_map.get(char, char) for char in english_word)\n    return translated_word\n"}
{"task_id": "EvoEval/25", "completion": "\n    import re\n\n    # Normalize the text and split into sentences\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    word = word.lower()\n    frequency = 0\n    max_sentence = \"\"\n\n    for sentence in sentences:\n        # Count occurrences of the word in the current sentence\n        count = len(re.findall(r'\\b' + re.escape(word) + r'\\b', sentence.lower()))\n        frequency += count\n        \n        # Update max_sentence if the current count is greater\n        if count > (len(re.findall(r'\\b' + re.escape(word) + r'\\b', max_sentence.lower())) if max_sentence else 0):\n            max_sentence = sentence\n\n    return (frequency, max_sentence)\n"}
{"task_id": "EvoEval/26", "completion": "\n    if start == end:\n        return []\n\n    directions = []\n    rows, cols = len(maze), len(maze[0])\n    visited = set()\n    queue = [(start, [])]\n\n    while queue:\n        (current_row, current_col), path = queue.pop(0)\n\n        if (current_row, current_col) == end:\n            return path\n\n        if (current_row, current_col) in visited:\n            continue\n\n        visited.add((current_row, current_col))\n\n        for d_row, d_col, direction in [(-1, 0, \"up\"), (1, 0, \"down\"), (0, -1, \"left\"), (0, 1, \"right\")]:\n            new_row, new_col = current_row + d_row, current_col + d_col\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] == 0:\n                queue.append(((new_row, new_col), path + [direction]))\n\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Calculate taxable income after deductions\n    if deductions <= 1000:\n        taxable_income = income - deductions\n    elif deductions <= 3000:\n        taxable_income = income - (1000 + (deductions - 1000) * 0.5)\n    else:\n        taxable_income = income - (1000 + 2000 * 0.5 + (deductions - 3000) * 0.33)\n\n    # Initialize tax variable\n    tax = 0.0\n\n    # Calculate tax based on progressive rates\n    if taxable_income <= 10000:\n        tax = 0.0\n    elif taxable_income <= 10025:\n        tax = (taxable_income - 10000) * 0.15\n    elif taxable_income <= 10070:\n        tax = (25 * 0.15) + (taxable_income - 10025) * 0.25\n    else:\n        tax = (25 * 0.15) + (45 * 0.25) + (taxable_income - 10070) * 0.30\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    def is_palindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    unique_palindromes = set()\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                unique_palindromes.add(substring)\n\n    return sorted(unique_palindromes)\n"}
{"task_id": "EvoEval/30", "completion": "\n    from collections import deque\n\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    parent = {start: None}\n\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = parent[current]\n            return path[::-1]\n\n        for direction in directions:\n            neighbor = (current[0] + direction[0], current[1] + direction[1])\n            if (0 <= neighbor[0] < rows and\n                0 <= neighbor[1] < cols and\n                maze[neighbor[0]][neighbor[1]] == 1 and\n                neighbor not in visited):\n                visited.add(neighbor)\n                parent[neighbor] = current\n                queue.append(neighbor)\n\n    return []\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[1] * n for _ in range(m)]\n    \n    # Fill the array\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    # The bottom-right cell contains the number of unique paths\n    return dp[m - 1][n - 1]\n"}
{"task_id": "EvoEval/32", "completion": "\n    if not playlist or seed % 2 == 0:\n        return playlist\n\n    playlist_length = len(playlist)\n    shuffled_playlist = sorted(playlist)\n\n    for i in range(playlist_length):\n        if \"Rock\" in shuffled_playlist[i]:\n            continue\n        \n        swap_index = seed % playlist_length\n        if \"Rock\" in shuffled_playlist[swap_index]:\n            continue\n        \n        # Swap the elements\n        shuffled_playlist[i], shuffled_playlist[swap_index] = shuffled_playlist[swap_index], shuffled_playlist[i]\n        \n        # Update the seed\n        seed = (seed * 16807) % 2147483647\n\n    return shuffled_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n\n    ways = [0] * (n + 1)\n    ways[0] = 1  # There's one way to stay at the ground (do nothing)\n\n    for step in range(1, n + 1):\n        for stone in magic_stones:\n            if step - stone >= 0:\n                ways[step] += ways[step - stone]\n\n    return ways[n]\n"}
{"task_id": "EvoEval/34", "completion": "\n    percentages = []\n    current_percentage = 0\n\n    for day in range(1, n + 1):\n        if day == m:\n            current_percentage = min(current_percentage * 2, 100)\n        elif day < m:\n            current_percentage = min(current_percentage + 10, 100)\n        else:\n            current_percentage = max(current_percentage - 10, 0)\n\n        percentages.append(current_percentage)\n\n    return percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if email.count('@') != 1 or email.startswith('@') or email.endswith('@'):\n        return False\n    \n    local_part, domain_part = email.split('@')\n    \n    if '.' not in domain_part or domain_part.startswith('.') or domain_part.endswith('.'):\n        return False\n    \n    return True\n"}
{"task_id": "EvoEval/36", "completion": "\n    n = len(xs)\n    integral_coeffs = [0]  # Start with the constant of integration set to zero\n\n    for i in range(n):\n        integral_coeffs.append(xs[i] / (i + 1))\n\n    return integral_coeffs\n"}
{"task_id": "EvoEval/37", "completion": "\n    def string_transform(s):\n    vowels = \"aeiou\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    transformed = []\n\n    for char in s:\n        if char.lower() in vowels:\n            # Find the next vowel\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed.append(next_vowel.upper() if char.isupper() else next_vowel)\n        elif char.lower() in consonants:\n            # Find the next consonant\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            transformed.append(next_consonant.upper() if char.isupper() else next_consonant)\n        else:\n            # Keep punctuation, spaces, and digits unchanged\n            transformed.append(char)\n\n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticon_dict = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \"\ud83d\ude04\",\n        \";)\": \"\ud83d\ude09\"\n    }\n    \n    for text_emoticon, unicode_emoticon in emoticon_dict.items():\n        sentence = sentence.replace(text_emoticon, unicode_emoticon)\n    \n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Calculate the width and height of the ASCII art\n    width = len(s) * n + 2\n    height = n + 2\n\n    # Create the top border\n    art = ['*' * width]\n\n    # Create the middle rows\n    for i in range(n):\n        row = '*' + s * n + '*'\n        art.append(row)\n\n    # Create the bottom border\n    art.append('*' * width)\n\n    return '\\n'.join(art)\n"}
{"task_id": "EvoEval/40", "completion": "\n    from itertools import combinations\n\n    def parse_potion(potion):\n        name, power = potion.rsplit(' ', 1)\n        return name, int(power)\n\n    potions = [parse_potion(p) for p in potions]\n    potions.sort(key=lambda x: (x[1], x[0]))  # Sort by power, then by name\n\n    best_combination = None\n\n    for r in range(1, len(potions) + 1):\n        for combo in combinations(potions, r):\n            total_power = sum(p[1] for p in combo)\n            if total_power == target:\n                combo_names = sorted(p[0] for p in combo)\n                if (best_combination is None or\n                        len(combo) < len(best_combination) or\n                        (len(combo) == len(best_combination) and combo_names < best_combination)):\n                    best_combination = combo_names\n\n    return best_combination if best_combination else []\n"}
{"task_id": "EvoEval/41", "completion": "\n    from collections import deque\n\n    def min_energy_path(arr):\n        rows, cols = len(arr), len(arr[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        energy = [[float('inf')] * cols for _ in range(rows)]\n        energy[0][0] = arr[0][0]\n        queue = deque([(0, 0)])\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols:\n                    new_energy = energy[x][y] + arr[nx][ny]\n                    if new_energy < energy[nx][ny]:\n                        energy[nx][ny] = new_energy\n                        queue.append((nx, ny))\n\n        # Find the minimum energy to reach the safe cell (0)\n        min_energy = float('inf')\n        for i in range(rows):\n            for j in range(cols):\n                if arr[i][j] == 0:\n                    min_energy = min(min_energy, energy[i][j])\n\n        return min_energy\n\n    return min_energy_path(arr)\n"}
{"task_id": "EvoEval/42", "completion": "\n    def find_legendary_item(player_input):\n    unique_items = set(player_input)\n    \n    if 5 in unique_items:\n        unique_items.remove(5)\n        if unique_items:\n            return True, max(unique_items)\n        else:\n            return True, -1\n    else:\n        return False, None\n"}
{"task_id": "EvoEval/43", "completion": "\n    duration_trip = distance / speed\n    fuel_consumption = spaceship_weight * planet_gravity * 0.1 * duration_trip\n\n    if fuel < duration_trip:\n        return 'Insufficient fuel'\n    \n    remaining_fuel = fuel - fuel_consumption\n    return round(remaining_fuel, 2)\n"}
{"task_id": "EvoEval/44", "completion": "\n    def fairy_tale_transport(q, w, e):\n    total_weight = sum(q)\n    unicorn_capacity = w\n    dragon_griffin_capacity = e\n\n    # Assuming we have an unlimited number of unicorns and dragons/griffins\n    if total_weight <= unicorn_capacity + dragon_griffin_capacity:\n        return True\n    return False\n"}
{"task_id": "EvoEval/45", "completion": "\n    max_view = 0\n\n    for i in range(len(arr)):\n        current_height = arr[i]\n        view_count = 0\n\n        # Check to the left\n        for j in range(i - 1, -1, -1):\n            if arr[j] <= current_height:\n                view_count += 1\n            if arr[j] > current_height:\n                break\n\n        # Check to the right\n        for j in range(i + 1, len(arr)):\n            if arr[j] <= current_height:\n                view_count += 1\n            if arr[j] > current_height:\n                break\n\n        max_view = max(max_view, view_count)\n\n    return max_view\n"}
{"task_id": "EvoEval/46", "completion": "\n    def hidden_message(test_cases):\n    secret_message = []\n    for case in test_cases:\n        message = ''.join(word[0].lower() for word in case if word and word[0].isalpha())\n        if message in ''.join(case).lower():\n            secret_message.append(message)\n        else:\n            secret_message.append(\"Take the cannoli.\")\n    return secret_message\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if available.get(ingredient, 0) < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    def wizard_inventory(inventory_logs):\n    inventory = {}\n    \n    for log in inventory_logs:\n        item = log['item']\n        quant = log['quant']\n        \n        if item in inventory:\n            inventory[item] += quant\n        else:\n            inventory[item] = quant\n    \n    # Remove items with zero or negative quantity\n    final_inventory = {item: quant for item, quant in inventory.items() if quant > 0}\n    \n    return final_inventory\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code_dict = {\n        '01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F',\n        '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L',\n        '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '1000': 'R',\n        '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X',\n        '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3',\n        '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8',\n        '11110': '9', '11111': '0'\n    }\n\n    words = msg.split('/')\n    decoded_message = []\n\n    for word in words:\n        characters = word.split()\n        decoded_word = ''.join(morse_code_dict[char] for char in characters)\n        decoded_message.append(decoded_word)\n\n    return ' '.join(decoded_message)\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', \n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', \n        '8': '---..', '9': '----.', ' ': ' '\n    }\n    \n    text = text.upper()\n    morse_code = []\n    \n    for char in text:\n        if char in morse_code_dict:\n            morse_code.append(morse_code_dict[char])\n    \n    return ' '.join(morse_code).replace('  ', '   ')\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not list_of_alphabets:\n        return string\n    \n    encoded_string = []\n    for i, char in enumerate(string):\n        encoded_char = list_of_alphabets[i % len(list_of_alphabets)]\n        encoded_string.append(encoded_char)\n    \n    return ''.join(encoded_string)\n"}
{"task_id": "EvoEval/52", "completion": "\n    fulfilled_orders = 0\n    for order in orders:\n        if order <= n and fulfilled_orders < m:\n            fulfilled_orders += 1\n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = \"aeiouAEIOU\"\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    transformed = []\n\n    for index, char in enumerate(s):\n        if char in vowels:\n            if char.islower():\n                transformed.append(chr((ord(char) - ord('a') + 1) % 5 + ord('a')))\n            else:\n                transformed.append(chr((ord(char) - ord('A') + 1) % 5 + ord('A')))\n        elif char in consonants:\n            if char.islower():\n                transformed.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a')))\n            else:\n                transformed.append(chr((ord(char) - ord('A') + 1) % 26 + ord('A')))\n        elif char == '?':\n            if index % 2 == 0:\n                transformed.append('!')\n            else:\n                transformed.append('?')\n        else:\n            transformed.append(char)\n\n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/54", "completion": "\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == star:\n                coordinates.append((i, j))\n    return coordinates\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = []\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift_amount = shift + i + 1\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {\n        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', \n        'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', \n        'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', \n        's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', \n        'y': '-.--', 'z': '--..', ' ': '/'\n    }\n    \n    morse_code = []\n    \n    for word in s.split(' '):\n        morse_word = ' '.join(morse_code_dict[char] for char in word)\n        morse_code.append(morse_word)\n    \n    return ' / '.join(morse_code)\n"}
{"task_id": "EvoEval/57", "completion": "\n    transformed_menu = {}\n    spell_length = len(magic_spell)\n\n    for dish, price in menu.items():\n        transformed_dish = ''.join(magic_spell[i % spell_length] for i in range(len(dish)))\n        transformed_menu[transformed_dish] = price\n\n    return transformed_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_words = []\n\n    for word in earth_phrase.split():\n        if not word:\n            continue\n        \n        translated_word = []\n        first_letter = word[0]\n        is_first_vowel = first_letter in vowels\n        \n        for char in word:\n            if char in vowels:\n                next_vowel = vowels[(vowels.index(char) + 1) % len(vowels)]\n                translated_word.append(next_vowel)\n            elif char in consonants:\n                next_consonant = consonants[(consonants.index(char) + 1) % len(consonants)]\n                translated_word.append(next_consonant)\n            elif char == ' ':\n                translated_word.append('@')\n            else:\n                translated_word.append(char)\n\n        translated_word = ''.join(translated_word)\n        if is_first_vowel:\n            translated_word += 'xy'\n        else:\n            translated_word += 'yz'\n        \n        translated_word = translated_word.capitalize()\n        translated_words.append(translated_word)\n\n    return ' '.join(translated_words)\n"}
{"task_id": "EvoEval/59", "completion": "\n    if not ingredient_dict:\n        return []\n\n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_ingredients\n"}
{"task_id": "EvoEval/60", "completion": "\n    sugar_set = set(sugar_locations)\n    happy_ants_count = 0\n\n    for position, direction in ant_positions:\n        if direction == \"right\":\n            for pos in range(position, path_length):\n                if pos in sugar_set:\n                    happy_ants_count += 1\n                    sugar_set.remove(pos)\n                    break\n        elif direction == \"left\":\n            for pos in range(position, -1, -1):\n                if pos in sugar_set:\n                    happy_ants_count += 1\n                    sugar_set.remove(pos)\n                    break\n\n    return happy_ants_count\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiou'\n    transformed = []\n    \n    for i, char in enumerate(s):\n        if char.isalpha():\n            if i % 2 == 1:  # Odd index\n                char = char.swapcase()\n            \n            if char.lower() in vowels:\n                next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n                char = next_vowel if char.islower() else next_vowel.upper()\n            else:\n                if char.lower() == 'z':\n                    char = 'y'\n                elif char.lower() == 'b':\n                    char = 'z'\n                elif char.isalpha():\n                    char = chr(ord(char) - 1)\n            \n            transformed.append(char)\n        else:\n            transformed.append(char)\n    \n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/62", "completion": "\n    def recipe_converter(reci, conversion_factor):\n    return {ingredient: quantity * conversion_factor for ingredient, quantity in reci.items()}\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\n    while p > 0:\n        pyramid.append(p)\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n    return pyramid\n"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    if not order:\n        return menu\n\n    final_order = {}\n    \n    for food, ingredients in menu.items():\n        if food in order:\n            customized_ingredients = ingredients.copy()\n            if \"remove\" in order[food]:\n                for ingredient in order[food][\"remove\"]:\n                    if ingredient in customized_ingredients:\n                        customized_ingredients.remove(ingredient)\n            if \"add\" in order[food]:\n                customized_ingredients.extend(order[food][\"add\"])\n            final_order[food] = customized_ingredients\n        else:\n            final_order[food] = ingredients\n\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def are_anagrams(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    primes = [i for i in range(2, n) if is_prime(i)]\n    prime_pairs = []\n\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if are_anagrams(primes[i], primes[j]):\n                prime_pairs.append((primes[i], primes[j]))\n\n    return sorted(prime_pairs)\n"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum(meal['calories'] for meal in meals[customer])\n            result[customer] = total_calories\n        else:\n            result[customer] = 0\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    if not arr:\n        return True\n\n    sorted_arr = sorted(arr)\n    n = len(arr)\n\n    for i in range(n):\n        # Rotate the array\n        rotated_arr = arr[i:] + arr[:i]\n        if rotated_arr == sorted_arr:\n            return True\n        \n        # Check if we can sort by one swap\n        for j in range(n):\n            for k in range(j + 1, n):\n                swapped_arr = rotated_arr[:]\n                swapped_arr[j], swapped_arr[k] = swapped_arr[k], swapped_arr[j]\n                if swapped_arr == sorted_arr:\n                    return True\n\n    return False\n"}
{"task_id": "EvoEval/69", "completion": "\n    card_indices = {}\n    \n    for i, card in enumerate(cards):\n        if card != 0 and magicNumber % card == 0:\n            complement = magicNumber // card\n            if complement in card_indices:\n                return (card_indices[complement], i)\n            card_indices[card] = i\n            \n    return \"No magic today\"\n"}
{"task_id": "EvoEval/70", "completion": "\n    if not planets or not path:\n        return False\n    \n    for i in range(len(path) - 1):\n        if path[i] not in planets or path[i + 1] not in planets:\n            return False\n        if path[i + 1] not in planets[path[i]]:\n            return False\n            \n    return True\n"}
{"task_id": "EvoEval/71", "completion": "\n    def shift_char(c, n):\n        if c.isalpha():\n            start = ord('a') if c.islower() else ord('A')\n            return chr((ord(c) - start + n) % 26 + start)\n        return c\n\n    encrypted_string = ''.join(shift_char(c, n) for c in s)\n    vow_count = sum(1 for c in encrypted_string.lower() if c in 'aeiou')\n    \n    return (encrypted_string, vow_count)\n"}
{"task_id": "EvoEval/72", "completion": "\n    result = []\n    for item in lst:\n        name = item\n        tale_count = sum(c.isdigit() for c in item)\n        story = f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{name}' who was known for telling {tale_count} tales a day\"\n        result.append(story)\n    return result\n"}
{"task_id": "EvoEval/73", "completion": "\n    total_treasures = sum(sum(row) for row in grid)\n    trips = math.ceil(total_treasures / bag_capacity) * 2\n    return trips\n"}
{"task_id": "EvoEval/74", "completion": "\n    if not s:\n        return \"\"\n    \n    return ''.join(cipher.get(char, char) for char in s)\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = []\n\n    for index, char in enumerate(input_str):\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed.append(next_vowel.upper() if char.isupper() else next_vowel)\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            transformed.append(next_consonant.upper() if char.isupper() else next_consonant)\n        elif char.isdigit():\n            transformed.append(str((int(char) + 1) % 10))\n        elif char == '?':\n            transformed.append('!' if index % 2 == 0 else '?')\n        else:\n            transformed.append(char)\n\n    return ''.join(transformed)\n"}
{"task_id": "EvoEval/76", "completion": "\n    def create_pyramid(lst):\n    if not lst:\n        return []\n    \n    pyramid = []\n    max_width = sum(lst)  # Total number of '#' characters in the bottom level\n\n    for i in range(len(lst)):\n        level_width = lst[i]  # Number of '#' characters for the current level\n        level_string = '#' * level_width  # Create the level string\n        # Center the level string based on the max width\n        centered_level = level_string.center(max_width)\n        pyramid.append(centered_level)\n\n    return pyramid[::-1]  # Reverse to have the bottom level first\n"}
{"task_id": "EvoEval/77", "completion": "\n    def points(n, k):\n        count = 0\n        while n > 1:\n            n //= k\n            count += 1\n        return count\n\n    points_list = [(num, points(num, k)) for num in sequence]\n    points_list.sort(key=lambda x: x[1], reverse=True)\n    \n    return [num for num, _ in points_list]\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    if n % 2 == 0:\n        raise ValueError(\"Matrix must have an odd dimension.\")\n    \n    result = []\n    \n    for i in range(n):\n        result.append(mat[i][i])  # From top-left to bottom-right\n        result.append(mat[i][n - 1 - i])  # From top-right to bottom-left\n    \n    # Remove duplicates while maintaining order\n    return list(dict.fromkeys(result))\n"}
{"task_id": "EvoEval/79", "completion": "\n    max_profit = 0\n    min_price = float('inf')\n\n    for i in range(days):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        elif prices[i] - min_price > max_profit:\n            max_profit = prices[i] - min_price\n\n    return max_profit\n"}
{"task_id": "EvoEval/80", "completion": "\n    def adventure_game(map, instructions):\n    # Find the starting position\n    start_row, start_col = next((r, c) for r in range(len(map)) for c in range(len(map[0])) if map[r][c] == 'S')\n    path = [(start_row, start_col)]\n    current_row, current_col = start_row, start_col\n\n    # Define movement directions\n    directions = {\n        'up': (-1, 0),\n        'down': (1, 0),\n        'left': (0, -1),\n        'right': (0, 1)\n    }\n\n    for instruction in instructions:\n        if instruction in directions:\n            new_row = current_row + directions[instruction][0]\n            new_col = current_col + directions[instruction][1]\n\n            # Check boundaries and walls\n            if 0 <= new_row < len(map) and 0 <= new_col < len(map[0]) and map[new_row][new_col] != 'X':\n                current_row, current_col = new_row, new_col\n\n            # Check for end condition\n            if map[current_row][current_col] == 'E':\n                path.append((current_row, current_col))\n                break\n\n        path.append((current_row, current_col))\n\n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n\n    # Create a mapping of each character to its index in the alien dictionary\n    alien_order = {char: index for index, char in enumerate(alien_dictionary)}\n\n    # Function to convert a word to its corresponding order based on the alien dictionary\n    def convert_word(word):\n        return [alien_order[char] for char in word]\n\n    # Convert all words to their corresponding order\n    converted_words = [convert_word(word) for word in word_list]\n\n    # Check if the list of converted words is sorted\n    for i in range(1, len(converted_words)):\n        if converted_words[i] < converted_words[i - 1]:\n            return \"INCOR\"\n\n    return \"CORRECT\"\n"}
{"task_id": "EvoEval/82", "completion": "\n    if not birthdays:\n        return None\n\n    zodiac_dates = {\n        \"Aries\": (\"03-21\", \"04-19\", \"Fire\"),\n        \"Taurus\": (\"04-20\", \"05-20\", \"Earth\"),\n        \"Gemini\": (\"05-21\", \"06-20\", \"Air\"),\n        \"Cancer\": (\"06-21\", \"07-22\", \"Water\"),\n        \"Leo\": (\"07-23\", \"08-22\", \"Fire\"),\n        \"Virgo\": (\"08-23\", \"09-22\", \"Earth\"),\n        \"Libra\": (\"09-23\", \"10-22\", \"Air\"),\n        \"Scorpio\": (\"10-23\", \"11-21\", \"Water\"),\n        \"Sagittarius\": (\"11-22\", \"12-21\", \"Fire\"),\n        \"Capricorn\": (\"12-22\", \"01-19\", \"Earth\"),\n        \"Aquarius\": (\"01-20\", \"02-18\", \"Air\"),\n        \"Pisces\": (\"02-19\", \"03-20\", \"Water\"),\n    }\n\n    element_count = {\n        \"Fire\": 0,\n        \"Earth\": 0,\n        \"Air\": 0,\n        \"Water\": 0,\n    }\n\n    for birthday in birthdays:\n        year = birthday[:4]\n        month_day = birthday[5:10]\n        \n        for sign, (start, end, element) in zodiac_dates.items():\n            if (start <= month_day <= end) or (start <= month_day <= end and (start[0:2] == \"12\" and month_day[0:2] == \"01\")):\n                element_count[element] += 1\n                break\n\n    return {element: count for element, count in element_count.items() if count > 0}\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s_list[left] not in vowels:\n            left += 1\n        elif s_list[right] not in vowels:\n            right -= 1\n        else:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n\n    return ''.join(s_list)\n"}
{"task_id": "EvoEval/84", "completion": "\n    def tree_traversal(tree):\n    def dfs(node, path, paths):\n        if not node:\n            return\n        path.append(node)\n        if not tree[node]:  # If there are no children\n            paths.append(path.copy())\n        else:\n            for child in tree[node]:\n                dfs(child, path, paths)\n        path.pop()  # Backtrack\n\n    paths = []\n    root = next(iter(tree))  # Get the root node\n    dfs(root, [], paths)\n    return paths\n"}
{"task_id": "EvoEval/85", "completion": "\n    from collections import deque\n\n    rows, cols = len(grid), len(grid[0])\n    target_row, target_col = coord\n\n    if grid[0][0] == 1 or grid[target_row][target_col] == 1:\n        return -1\n\n    queue = deque([(0, 0, 0)])  # (row, col, moves)\n    visited = set((0, 0))\n\n    while queue:\n        row, col, moves = queue.popleft()\n\n        if (row, col) == (target_row, target_col):\n            return moves\n\n        for dr, dc in [(1, 0), (0, 1)]:  # down, right\n            new_row, new_col = row + dr, col + dc\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0:\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, moves + 1))\n\n    return -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    def sort_movies_by_ratings_and_release_date(m_dict):\n    sorted_movies = sorted(m_dict.items(), key=lambda item: (-item[1][0], -item[1][1]))\n    return [movie[0] for movie in sorted_movies]\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr or not arr[0]:\n        return \"\"\n    \n    result = []\n    top, bottom, left, right = 0, len(arr) - 1, 0, len(arr[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result.append(arr[top][i])\n        top += 1\n        \n        # Traverse from top to bottom\n        for i in range(top, bottom + 1):\n            result.append(arr[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse from right to left\n            for i in range(right, left - 1, -1):\n                result.append(arr[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse from bottom to top\n            for i in range(bottom, top - 1, -1):\n                result.append(arr[i][left])\n            left += 1\n\n    return ''.join(result)\n"}
{"task_id": "EvoEval/88", "completion": "\n    def planet_population(dict_of_planets):\n    density_dict = {}\n    \n    for planet, features in dict_of_planets.items():\n        if len(features) == 2:\n            population, size = features\n            if isinstance(population, int) and isinstance(size, (int, float)) and size > 0:\n                density = round(population / size, 2)\n                density_dict[planet] = density\n    \n    return density_dict\n"}
{"task_id": "EvoEval/89", "completion": "\n    remaining_aliens = []\n    for alien in aliens:\n        if alien < ray - 1 or alien > ray + 1 or alien % 2 != 0:\n            remaining_aliens.append(alien)\n    return remaining_aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    def digit_combinations(digits1, digits2):\n        from itertools import product\n        return {sum(pair) for pair in product(digits1, digits2)}\n\n    digits1 = [int(d) for d in s1]\n    digits2 = [int(d) for d in s2]\n\n    unique_sums = digit_combinations(digits1, digits2)\n    return sum(unique_sums)\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n\n    for action, distance in spaceship_data:\n        if action == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Move':\n            if status == 'In Space':\n                continue  # Moving in space is always valid\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status == 'In Space' and distance < 0:\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    result = []\n    for i in range(n):\n        layer = []\n        for j in range(n):\n            if j < i:\n                layer.append(chr(65 + (i - j) % 26))\n            else:\n                layer.append(chr(65 + (j - i) % 26))\n        result.append(''.join(layer).center(2 * n - 1))\n    return '\\n'.join(result)\n"}
{"task_id": "EvoEval/93", "completion": "\n    encoded_message = []\n    n_length = len(n_values)\n\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift = n_values[i % n_length]\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n\n    return ''.join(encoded_message)\n"}
{"task_id": "EvoEval/94", "completion": "\n    sorted_spells = []\n    for spell in strings:\n        words = spell.split()\n        sorted_words = sorted(words, key=len)\n        sorted_spells.append(' '.join(sorted_words))\n    return sorted_spells\n"}
{"task_id": "EvoEval/95", "completion": "\n    if not all(len(row) == len(m) for row in m):\n        return 'Invalid Matrix'\n    \n    n = len(m)\n    primary_diagonal_sum = sum(m[i][i] for i in range(n))\n    secondary_diagonal_sum = sum(m[i][n - i - 1] for i in range(n))\n    \n    return abs(primary_diagonal_sum - secondary_diagonal_sum)\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    \n    for index, value in enumerate(lst):\n        if value % index == 0 and index != 0:  # Check if value is a multiple of index\n            product_of_digits = 1\n            for digit in str(abs(value)):  # Calculate product of digits\n                product_of_digits *= int(digit)\n            if product_of_digits == index:  # Check if product of digits equals index\n                magic_indices.append(index)\n    \n    return sorted(magic_indices)\n"}
{"task_id": "EvoEval/97", "completion": "\n    def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n\n    encounter_order = [\"Asia\", \"Africa\", \"Europe\", \"North\", \"South\"]\n    encountered_humans = []\n\n    for continent in encounter_order:\n        for human, location in humans.items():\n            if location == continent:\n                encountered_humans.append(human)\n\n    return encountered_humans\n"}
{"task_id": "EvoEval/98", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sequence = [a, b]\n    for i in range(1, n - 2):\n        next_value = sequence[-1] + sequence[-2] + (i + 1)\n        sequence.append(next_value)\n\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    current_position = 0\n\n    for round_time in rounds:\n        current_position = (current_position + (round_time * music)) % len(players)\n        players.pop(current_position)\n        if current_position == len(players):  # Adjust if we removed the last player\n            current_position = 0\n\n    return players\n"}
