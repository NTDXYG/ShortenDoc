{"task_id": "EvoEval/0", "completion": "\n    total_cost = 0\n    for item in items:\n        if isinstance(item, str):\n            item = 1.0\n        base_cost = 5.0\n        if location == \"Local\":\n            factor = 1.0\n        elif location == \"National\":\n            factor = 1.5\n        else:\n            factor = 2.5\n        total_cost += base_cost * factor\n        if item > 5.0:\n            total_cost += 10.0\n        total_cost *= 15.0\n    return \"{:.2f}\".format(total_cost)  # format the result to two decimal places\n"}
{"task_id": "EvoEval/1", "completion": "\n    total_cost = 0.0\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0\n        else:\n            weight = item\n        total_cost += 5.0 + (10.0 if weight > 5.0 else 0.0)\n    if location == \"Local\":\n        return round(total_cost, 2)\n    elif location == \"International\":\n        return round(total_cost * 2, 2)\n    else:\n        return round(total_cost, 2)  # no factor for other locations"}
{"task_id": "EvoEval/2", "completion": "\n    if isinstance(key, str):\n        key = sum(ord(c) for c in key)\n    result = []\n    for word in words:\n        encrypted_word = \"\"\n        for char in word:\n            if char.isalpha():\n                ascii_offset = 97 if char.islower() else 65\n                encrypted_word += chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n            else:\n                encrypted_word += char\n        result.append(encrypted_word)\n    return result\n"}
{"task_id": "EvoEval/3", "completion": "\n    if not input_string:\n        return []\n\n    result = []\n    def backtrack(start, path):\n        if start == len(input_string):\n            result.append(''.join(path))\n            return\n        for i in range(int(input_string[start])):\n            path.append(chr(96 + i))\n            backtrack(start + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return result\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    max_height = candles[0]\n    count = 1\n    for i in range(1, len(candles)):\n        if candles[i] > max_height:\n            max_height = candles[i]\n            count += 1\n    return count\n    pass\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    up, down = 0, len(matrix) - 1\n    while left <= right and up <= down:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result.append(matrix[up][i])\n        up += 1\n        # Traverse from up to down\n        for i in range(up, down + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        # Traverse from right to left\n        if up <= down:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[down][i])\n            down -= 1\n        # Traverse from down to up\n        if left <= right:\n            for i in range(down, up - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # Check if the position is within the grid\n    if position[0] < 0 or position[0] >= rows or position[1] < 0 or position[1] >= cols:\n        return grid\n\n    # Get the value of the cell at the clicked position\n    cell_value = grid[position[0]][position[1]]\n\n    # If the cell is a mine, return the grid as it is\n    if cell_value == 1:\n        return grid\n\n    # If the cell is already revealed, return the grid as it is\n    if cell_value == 0:\n        return grid\n\n    # Mark the cell as revealed\n    grid[position[0]][position[1]] = 0\n\n    # Get the adjacent cells (horizontally, vertically, and diagonally)\n    adjacent_cells = get_adjacent_cells(position, rows, cols)\n\n    # Convert all adjacent cells to 't' (if they are not mines)\n    for cell in adjacent_cells:\n        if grid[cell[0]][cell[1]] != 1:\n            grid[cell[0]][cell[1]] = 't'\n\n    return grid\n\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize the current position as 0,0\r\n    current_position = [0, 0]\r\n    # Iterate over each move in the sequence\r\n    for move in code_sequence:\r\n        # Update the current position based on the move\r\n        if move == 0:\r\n            current_position[0] += 1\r\n        elif move == 1:\r\n            current_position[1] += 1\r\n        elif move == 2:\r\n            current_position[0] -= 1\r\n        elif move == 3:\r\n            current_position[1] -= 1\r\n    # Check if the current position is the same as the starting point\r\n    if current_position == [0, 0]:\r\n        return 'Shangri-La found'\r\n    else:\r\n        return 'Shangri-La not found'\r\n"}
{"task_id": "EvoEval/8", "completion": "\n    # Check if there is more than one 'P' or the 'P' is at the edge of the canvas\n    if canvas.count('P') > 1 or canvas[0] == 'P' or canvas[-1] == 'P':\n        return 'Invalid canvas'\n\n    # Find the position of the 'P'\n    p_pos = canvas.find('P')\n\n    # Initialize a stack to keep track of the positions to visit\n    stack = [p_pos]\n\n    # Initialize a set to keep track of the visited positions\n    visited = set()\n\n    # Initialize the result canvas\n    result = list(canvas)\n\n    # While there are still positions to visit\n    while stack:\n        # Get the current position\n        pos = stack.pop()\n\n        # If the position has not been visited yet\n        if pos not in visited:\n            # Mark the position as visited\n            visited.add(pos)\n\n            # If the position is not a wall\n            if result[pos] != '#':\n                # Paint the position\n                result[pos] = 'P'\n\n                # Add the adjacent positions to the stack\n                for i in range(-1, 2):\n                    new_pos = pos + i\n                    if 0 <= new_pos < len(result) and result[new_pos] != '#':\n                        stack.append(new_pos)\n\n    # Join the result list into a string\n    result = ''.join(result)\n\n    # Return the result\n    return result\n\n"}
{"task_id": "EvoEval/9", "completion": "\n    # Remove punctuation and convert to lower case\n    string = ''.join(e for e in string if e.isalnum() or e.isspace()).lower()\n    # Split the string into words\n    words = string.split()\n    # Create a dictionary to store the frequency of each word\n    frequency = {}\n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word is already in the dictionary, increment its count\n        if word in frequency:\n            frequency[word] += 1\n        # If the word is not in the dictionary, add it with a count of 1\n        else:\n            frequency[word] = 1\n    # Return the dictionary of word frequencies\n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_dict = {}\r\n    animal_string = animal_string.split(' ')\r\n    for animal in animal_string:\r\n        if animal in animal_dict:\r\n            if animal_dict[animal] < 2:\r\n                animal_dict[animal] += 1\r\n        else:\r\n            animal_dict[animal] = 1\r\n    animal_list = []\r\n    for animal in animal_dict:\r\n        animal_list.append(animal_dict[animal])\r\n    return animal_list\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    if len(fruits) == 1:\n        return f\"Oh, are those {fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"Oh, are those {fruits[0]} and {fruits[-1]} from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Count the occurrence of each element in the list\n    count_dict = {}\n    for num in flux_values:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the element with maximum occurrence\n    max_count = max(count_dict.values())\n    most_occurred = min([num for num, count in count_dict.items() if count == max_count])\n\n    # Calculate the sum of all elements\n    total_sum = sum(flux_values)\n\n    # Multiply the sum of all elements by the most occurred element\n    energy_signature = total_sum * most_occurred\n\n    return energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n    count_dict = {}\n    for elem in elems:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    min_count = min(count_dict.values())\n    rarest_elements = [elem for elem, count in count_dict.items() if count == min_count]\n    return min(rarest_elements)  # return the lexicographically smallest rarest element\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                if char.isupper():\n                    alias += 'A' if alias[-1].lower() == 'a' else 'E' if alias[-1].lower() == 'e' else 'I' if alias[-1].lower() == 'i' else 'U' if alias[-1].lower() == 'u' else 'A'\n                else:\n                    alias += 'a' if alias[-1].lower() == 'a' else 'e' if alias[-1].lower() == 'e' else 'i' if alias[-1].lower() == 'i' else 'u' if alias[-1].lower() == 'u' else 'a'\n            else:\n                if char.isupper():\n                    alias += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n                else:\n                    alias += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].lower()\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Create a dictionary to store the count of each card value\n    card_counts = {}\n    for card in hand:\n        # Extract the card value (first character of the string)\n        value = card[0]\n        # Increment the count for this value\n        card_counts[value] = card_counts.get(value, 0) + 1\n\n    # Initialize the score to 0\n    score = 0\n\n    # Check for pairs, triples, fours, and fives\n    for value, count in card_counts.items():\n        # If there's a pair, add the value of the card to the score\n        if count == 2:\n            score += int(value)\n        # If there's a triple, add double the value of the card to the score\n        elif count == 3:\n            score += 2 * int(value)\n        # If there's a four, add triple the value of the card to the score\n        elif count == 4:\n            score += 3 * int(value)\n        # If there's a five, add quadruple the value of the card to the score\n        elif count == 5:\n            score += 4 * int(value)\n\n    # Return the total score\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return \"Input should be a positive integer\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        while len(fib_sequence) < n:\n            fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n        return sum(fib_sequence)\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard in wizards:\n        name, magic = wizard\n        dragon_hp -= magic\n        if dragon_hp <= 0:\n            return name\n    return 'The dragon won'  # If none of the wizards can defeat the dragon\n"}
{"task_id": "EvoEval/18", "completion": "\n    i = 1\n    while True:\n        num = i\n        digits = [int(d) for d in str(num)]\n        if len(digits) > 7 or any(d > 7 for d in digits):\n            i += 1\n            continue\n        if all(d % 7 == 0 for d in digits):\n            return num\n        i += 1\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize a variable to store the count of humans in danger\n    humans_in_danger = 0\n\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a human (1) and there is a vampire in the same row or column\n            if cell == 1 and (any(cell == 2 for cell in row) or any(m[row.index(cell)].count(2) > 0 for row in m)):\n                # Increment the count of humans in danger\n                humans_in_danger += 1\n\n    # Return the count of humans in danger\n    return humans_in_danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(str(i))\n    for i in range(n - 1, 0, -1):\n        pattern.append(str(i))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    def find_word(word, row, col, direction):\n        if direction == 'right':\n            for i in range(len(word)):\n                if col + i >= len(grid[0]) or grid[row][col + i] != word[i]:\n                    return False\n            return True\n        elif direction == 'left':\n            for i in range(len(word)):\n                if col - i < 0 or grid[row][col - i] != word[i]:\n                    return False\n            return True\n        elif direction == 'down':\n            for i in range(len(word)):\n                if row + i >= len(grid) or grid[row + i][col] != word[i]:\n                    return False\n            return True\n        elif direction == 'up':\n            for i in range(len(word)):\n                if row - i < 0 or grid[row - i][col] != word[i]:\n                    return False\n            return True\n\n    for word in words:\n        found = False\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == word[0]:\n                    if find_word(word, row, col, 'right'):\n                        found = True\n                        break\n                    if find_word(word, row, col, 'left'):\n                        found = True\n                        break\n                    if find_word(word, row, col, 'down'):\n                        found = True\n                        break\n                    if find_word(word, row, col, 'up'):\n                        found = True\n                        break\n            if found:\n                break\n        if not found:\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    return t * v / 299792.458\n"}
{"task_id": "EvoEval/23", "completion": "\n    primes = []\n    num = 2\n    while len(primes) < 26:\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n        num += 1\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += str(primes[ord(char) - 97])\n            else:\n                result += str(primes[ord(char) - 65])\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_dict = {\n        'a': '+', 'b': '', 'c': '*', 'd': '', 'e': '%', 'f': '', 'g': '#', 'h': '$',\n        'i': '^', 'j': '&', 'k': '(', 'l': ')', 'm': '', 'n': '?', 'o': ':', 'p': ';',\n        'q': '`', 'r': '~', 's': '>', 't': '<', 'u': '{', 'v': '}', 'w': '[', 'x': ']',\n        'y': '|', 'z': '='\n    }\n    return ''.join(alien_dict.get(char, '') for char in english_word.lower())  # convert to lower case to handle case sensitivity\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\n    sentences = text.split(\". \")\n    # Initialize a dictionary to store the frequency of each word in each sentence\n    frequency = {}\n    for sentence in sentences:\n        words = sentence.split()\n        frequency[sentence] = words.count(word)\n    # Find the sentence with the highest frequency of the word\n    max_frequency = max(frequency.values())\n    if max_frequency == 0:\n        return (0, \"\")\n    max_sentence = [sentence for sentence, freq in frequency.items() if freq == max_frequency][0]\n    return (max_frequency, max_sentence)  # Return the frequency and the sentence with the highest frequency of the word\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    # Define the possible directions\n    directions = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n    \n    # Define the queue for BFS\n    queue = [(start, [start])]\n    \n    # Define the set to keep track of visited cells\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the next cell\n        (x, y), path = queue.pop(0)\n        \n        # If this is the destination cell, return the path\n        if (x, y) == end:\n            return path\n        \n        # Check all possible directions\n        for dx, dy, direction in directions:\n            nx, ny = x + dx, y + dy\n            \n            # If the new cell is within the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and maze[nx][ny] == 0 and (nx, ny) not in visited:\n                # Mark the new cell as visited\n                visited.add((nx, ny))\n                \n                # Add the new cell to the queue\n                queue.append(((nx, ny), path + [direction]))\n    \n    # If there is no path to the destination\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # First, calculate the taxable income by subtracting the deductions from the income\n    taxable_income = income - deductions\n\n    # If the taxable income is less than 0, return 0\n    if taxable_income < 0:\n        return 0\n\n    # Calculate the tax for the first $10,000\n    tax = min(taxable_income, 10000) * 0.1\n\n    # Calculate the tax for the next $25,000\n    tax += min(max(taxable_income - 10000, 0), 25000) * 0.15\n\n    # Calculate the tax for the next $45,000\n    tax += min(max(taxable_income - 10000 - 25000, 0), 45000) * 0.20\n\n    # Calculate the tax for any income over $130,000\n    tax += max(taxable_income - 10000 - 25000 - 45000, 0) * 0.30\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                substrings.add(substring)\n    return sorted(list(substrings))\n\n\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Create a queue for BFS, contains cells in the form (x, y, path)\n    queue = [(start[0], start[1], [start])]\n\n    # Create a set to store visited cells\n    visited = set((start[0], start[1]))\n\n    while queue:\n        # Dequeue the next cell\n        x, y, path = queue.pop(0)\n\n        # If this is the destination cell, return the path\n        if (x, y) == end:\n            return path\n\n        # For each possible movement\n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n\n            # If the new cell is inside the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new cell as visited\n                visited.add((nx, ny))\n\n                # Enqueue the new cell\n                queue.append((nx, ny, path + [(nx, ny)]))\n\n    # If there is no path to the destination\n    return []  # Return an empty list\n"}
{"task_id": "EvoEval/31", "completion": "\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m][n]\n"}
{"task_id": "EvoEval/32", "completion": "\n    # Create a copy of the original playlist to avoid modifying it\n    shuffled_playlist = playlist.copy()\n\n    # Iterate over the indices of the playlist\n    for i in range(len(shuffled_playlist)):\n        # Calculate the seed for the current index\n        seed_i = (seed * 807147483647) % 2147483647\n\n        # Calculate the index to swap with\n        swap_index = (seed_i % len(shuffled_playlist)) if not \"Rock\" in shuffled_playlist[i] else i\n\n        # Swap the elements at the current index and the swap index\n        shuffled_playlist[i], shuffled_playlist[swap_index] = shuffled_playlist[swap_index], shuffled_playlist[i]\n\n    return shuffled_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\n    ways = [0] * (n + 1)\r\n    # There is one way to reach the first step (by not jumping at all)\r\n    ways[0] = 1\r\n    # For each step from 1 to n\r\n    for i in range(1, n + 1):\r\n        # For each magic stone\r\n        for stone in magic_stones:\r\n            # If the stone's power is less than or equal to the current step\r\n            if stone <= i:\r\n                # Add the number of ways to reach the step minus the stone's power to the current number of ways\r\n                ways[i] += ways[i - stone]\r\n    # Return the number of ways to reach the top of the staircase\r\n    return ways[n]\r\n\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize an empty list to store the transformation percentages\n    transformation_percentages = []\n    # Calculate the percentage for the m-th day\n    mth_day_percentage = 100\n    # Calculate the percentage for the day before the m-th day\n    previous_day_percentage = 0\n    # Iterate over the cycle\n    for i in range(n):\n        # If it's the m-th day, double the previous day's percentage\n        if i == m - 1:\n            transformation_percentages.append(mth_day_percentage)\n            # Update the previous day's percentage\n            previous_day_percentage = mth_day_percentage\n        # If it's the day before the m-th day, increase the previous day's percentage by 10\n        elif i == m - 2:\n            transformation_percentages.append(previous_day_percentage + 10)\n            # Update the previous day's percentage\n            previous_day_percentage = previous_day_percentage + 10\n        # If it's not the m-th or the day before the m-th day, decrease the previous day's percentage by 10\n        else:\n            transformation_percentages.append(previous_day_percentage - 10)\n            # Update the previous day's percentage\n            previous_day_percentage = previous_day_percentage - 10\n        # Ensure the percentage is within the range of 0 and 100\n        transformation_percentages[-1] = max(0, min(transformation_percentages[-1], 100))\n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email:\r\n        return False\r\n    at_index = email.index(\"@\")\r\n    if at_index == 0 or at_index == len(email) - 1:\r\n        return False\r\n    return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    coefficients = []\n    for i in range(1, len(xs)):\n        coefficients.append(xs[i] / (i + 1))\n    return coefficients\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for char in s:\n        if char in vowels:\n            index = vowels.index(char)\n            if char.isupper():\n                result += vowels[(index + 1) % 5].upper()\n            else:\n                result += vowels[(index + 1) % 5]\n        elif char in consonants:\n            index = consonants.index(char)\n            if char.isupper():\n                result += consonants[(index + 1) % 21].upper()\n            else:\n                result += consonants[(index + 1) % 21]\n        elif char in '0123456789':\n            result += char\n        elif char in ' !,.\"\\'?;:-_':\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ud83d\ude0a\",\n        \":D\": \"\ud83d\ude01\",\n        \":(\": \"\u2639\ufe0f\",\n        \"(\": \"\ufffd\",\n        \")\": \"\ud83d\ude09\"\n    }\n    for emoticon, emoji in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Create the top and bottom border of the art\n    top_bottom = \"*\" * (n + 2)\n    # Create the middle part of the art\n    middle = \"\"\n    for i in range(n):\n        # Add the top border\n        middle += \"*\"\n        # Add the row of the art\n        middle += s * (n // len(s) + 1)\n        # Add the bottom border\n        middle += \"*\\n\"\n    # Create the bottom border\n    bottom = \"*\" * (n + 2)\n    # Return the art\n    return top_bottom + \"\\n\" + middle + bottom\n"}
{"task_id": "EvoEval/40", "completion": "\n    potions = [potion.split() for potion in potions]\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    potions.sort(key=lambda x: (len(x), x))\n    for potion in potions:\n        for i in range(target, int(potion[1]) - 1, -1):\n            dp[i] = min(dp[i], dp[i - int(potion[1])] + 1)\n    if dp[target] == float('inf'):\n        return []\n    result = []\n    i = target\n    while i > 0:\n        for potion in potions:\n            if int(potion[1]) <= i and dp[i] == dp[i - int(potion[1])] + 1:\n                result.append(' '.join(potion))\n                i -= int(potion[1])\n                break\n    return result[::-1]  # return in ascending order\n"}
{"task_id": "EvoEval/41", "completion": "\n    rows = len(arr)\n    cols = len(arr[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = arr[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + arr[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + arr[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j]\n    return dp[-1][-1]\n"}
{"task_id": "EvoEval/42", "completion": "\n    def find_legendary_item(player_input):\r\n        # Check if the player has acquired a legendary item\r\n        if 5 in player_input:\r\n            # If the player has acquired a legendary item, find the second most valuable item\r\n            # If the player has only acquired the legendary item, return -1\r\n            if len(player_input) == 1:\r\n                return True, -1\r\n            else:\r\n                # Remove the legendary item from the list\r\n                player_input.remove(5)\r\n                # Sort the list in descending order\r\n                player_input.sort(reverse=True)\r\n                # Return True and the second most valuable item\r\n                return True, player_input[1]\r\n        else:\r\n            # If the player has not acquired a legendary item, return False and None\r\n            return False, None\r\n\r"}
{"task_id": "EvoEval/43", "completion": "\n    trip_duration = distance / speed\n    fuel_consumption = spaceship_weight * planet_gravity * trip_duration\n    if fuel_consumption > fuel:\n        return 'Insufficient fuel'\n    else:\n        remaining_fuel = fuel - fuel_consumption\n        return str(int(remaining_fuel))\n"}
{"task_id": "EvoEval/44", "completion": "\n\n    def fairy_tale_transport(weights, unicorn_weight, dragon_griffin_weight):\r\n    # Sort the weights in descending order\r\n    weights.sort(reverse=True)\r\n    \r\n    # Initialize the total weight carried by unicorns, dragons, and griffins\r\n    unicorn_weight_carried = 0\r\n    dragon_griffin_weight_carried = 0\r\n    \r\n    # Iterate over the weights\r\n    for weight in weights:\r\n        # If the weight can be carried by a unicorn, add it to the unicorn's weight\r\n        if weight <= unicorn_weight:\r\n            unicorn_weight_carried += weight\r\n            unicorn_weight -= weight\r\n        # If the weight can be carried by a dragon or a griffin, add it to the dragon's weight\r\n        elif weight <= dragon_griffin_weight:\r\n            dragon_griffin_weight_carried += weight\r\n            dragon_griffin_weight -= weight\r\n        # If the weight cannot be carried by either a unicorn or a dragon/griffin, return False\r\n        else:\r\n            return False\r\n    \r\n    # If all weights can be carried, return True\r\n    return True\n    \"\"\"\n    def fairy_tale_transport(weights, unicorn_weight, dragon_griffin_weight):\r\n    # Sort the weights in descending order\r\n    weights.sort(reverse=True)\r\n    \r\n    # Initialize the total weight carried by unicorns, dragons, and griffins\r\n    unicorn_weight_carried = 0\r\n    dragon_griffin_weight_carried = 0\r\n    \r\n"}
{"task_id": "EvoEval/45", "completion": "\n    n = len(arr)\n    res = []\n    for i in range(n):\n        count = 0\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                count += 1\n            else:\n                break\n        for j in range(i - 1, -1, -1):\n            if arr[j] > arr[i]:\n                count += 1\n            else:\n                break\n        res.append(count)\n    return res\n"}
{"task_id": "EvoEval/46", "completion": "\n    def hidden_message(test_cases):\n        secret_messages = []\n        for case in test_cases:\n            secret_message = ''.join(word[0] for word in case)\n            secret_messages.append(secret_message)\n        return secret_messages\n\n    print(hidden_message([['Hello, world!', 'okay?'], ['Every', 'good', 'does', 'fine']]))\n    print(hidden_message([['apple'], ',rape ', 'kiwi', 'melon']))\n    print(hidden_message([['This', 'is', '? ', 'test??'], ['']]))  # Output: ['This', 'is', '? ', 'test??']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cannoli.']  # Output: ['the cann"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}  # Filter out items with quantity 0 or less\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code = {\n        'A': '01', 'B': '1101', 'C': '1010', 'D': '1100', 'E': '0',\n        'F': '0010', 'G': '110', 'H': '0000', 'I': '', 'J': '11',\n        'K': '0100', 'L': '0011', 'M': '11', 'N': '10', 'O': '11',\n        'P': '0011', 'Q': '1101', 'R': '010', 'S': '00', 'T': '1',\n        'U': '01', 'V': '0001', 'W': '0111', 'X': '1001', 'Y': '101',\n        'Z': '1100', '1': '01', '2': '00111', '3': '00011', '4': '0',\n        '5': '00000', '6': '10000', '7': '11000', '8': '11100', '9': '11110', '0': '11111'\n    }\n    msg = msg.split('/')\n    decoded_msg = ''\n    for char in msg:\n        for key, value in morse_code.items():\n            if char == value:\n                decoded_msg += key\n    return decoded_msg\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': ' '}\n    morse_code = ''\n    for char in text.upper():\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n        else:\n            morse_code += ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not list_of_alphabets:\n        return string\n    result = ''\n    for i, char in enumerate(string):\n        if char.isalpha():\n            result += list_of_alphabets[i % len(list_of_alphabets)]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    orders = sorted(orders, reverse=True)\n    batches = 0\n    total_cookies = 0\n    for order in orders:\n        if total_cookies + order > n:\n            continue\n        batches += 1\n        total_cookies += order\n        if batches == m:\n            break\n    return batches\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for char in s:\n        if char.isalpha():\n            if char.lower() in vowels:\n                if char.isupper():\n                    result += vowels[(vowels.index(char.lower()) + 1) % 5].upper()\n                else:\n                    result += vowels[(vowels.index(char.lower()) + 1) % 5]\n            elif char.lower() in consonants:\n                if char.isupper():\n                    result += consonants[(consonants.index(char.lower()) + 1) % 21].upper()\n                else:\n                    result += consonants[(consonants.index(char.lower()) + 1) % 21]\n            else:\n                result += char\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                result.append((j, i))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = \"\"\n    for i in range(len(message)):\n        if message[i].isalpha():\n            shift = shift + i\n            if message[i].isupper():\n                result += chr((ord(message[i]) - 65 + shift) % 26 + 65)\n            else:\n                result += chr((ord(message[i]) - 97 + shift) % 26 + 97)\n        else:\n            result += message[i]\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {\n        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', \n        'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', \n        'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', \n        's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', \n        'y': '-.--', 'z': '--..', ' ': '/'\n    }\n    morse_code = ''\n    for char in s:\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        transformed_dish = ''\n        for i, letter in enumerate(dish):\n            if i < len(magic_spell):\n                transformed_dish += magic_spell[i]\n            else:\n                transformed_dish += letter\n        new_menu[transformed_dish] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for char in earth_phrase:\n        if char in vowels:\n            if char == 'a':\n                result += 'i'\n            elif char == 'e':\n                result += 'o'\n            elif char == 'i':\n                result += 'u'\n            elif char == 'o':\n                result += 'u'\n            elif char == 'u':\n                result += 'u'\n        elif char in consonants:\n            if char == 'z':\n                result += 'b'\n            else:\n                result += chr(ord(char) + 1)\n        elif char == ' ':\n            result += '@'\n        else:\n            result += char\n    result = result.capitalize()\n    words = result.split('@')\n    for i in range(len(words)):\n        if words[i][0] == 'a':\n            words[i] = words[i] + 'xy'\n        else:\n            words[i] = words[i] + 't'\n    result = '@'.join(words)\n    return result\n"}
{"task_id": "EvoEval/59", "completion": "\n    if not ingredient_dict:\n        return []\n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    return [(ingredient, recipe) for ingredient, recipe in sorted_ingredients]\n"}
{"task_id": "EvoEval/60", "completion": "\n    # Initialize a set to store the positions of sugar locations\n    sugar_positions = set(sugar_locations)\n    \n    # Initialize a set to store the positions of ants\n    ant_positions_set = set(ant_positions)\n    \n    # Initialize a counter for happy ants\n    happy_ants_count = 0\n    \n    # Iterate over the path length\n    for i in range(path_length):\n        # Check if there are ants at the current position\n        if i in ant_positions_set:\n            # Get the ant's position and direction\n            ant_position, direction = next((position, ant_direction) for position, ant_direction in ant_positions if position == i)\n            \n            # Check if the ant is at a sugar location\n            if i in sugar_positions:\n                # Remove the sugar location from the set\n                sugar_positions.remove(i)\n                \n                # Add the ant's position to the set of sugar locations\n                sugar_positions.add(ant_position)\n            \n            # Check if the ant is moving to a sugar location\n            if (ant_position + 1) in sugar_positions and direction == \"right\":\n                # Remove the sugar location from the set\n                sugar_positions.remove(ant_position + 1)\n                \n                # Add the ant's position to the set of sugar locations\n                sugar_positions.add(ant_position)\n            \n            # Check if the ant is moving to a sugar location\n            if (ant_position - 1) in sugar_positions and direction == \"left\":\n                # Remove the sugar location from the set\n                sugar_positions.remove(ant_position - 1)\n                \n                # Add the ant's position to the set of sugar locations\n                sugar_positions.add(ant_position)\n        \n        # Increment the happy ants count\n        happy_ants_count += len(sugar_positions)\n    \n    # Return the happy ants count\n    return happy_ants_count\n"}
{"task_id": "EvoEval/61", "completion": "\n    result = []\n    for i, c in enumerate(s):\n        if c.isalpha():\n            if i % 2 == 0:\n                if c.islower():\n                    result.append(c.upper())\n                else:\n                    result.append(c.lower())\n            else:\n                if c in 'aeiou':\n                    if c == 'a':\n                        result.append('e')\n                    elif c == 'e':\n                        result.append('i')\n                    elif c == 'i':\n                        result.append('o')\n                    elif c == 'o':\n                        result.append('u')\n                    else:\n                        result.append('a')\n                else:\n                    if c == 'z':\n                        result.append('y')\n                    elif c == 'y':\n                        result.append('x')\n                    else:\n                        result.append(chr(ord(c) + 1))\n        else:\n            result.append(c)\n    return ''.join(result)  # return the result as a string\n"}
{"task_id": "EvoEval/62", "completion": "\n    return {key: value * factor for key, value in recipe.items()}\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\r\n    while p > 0:\r\n        pyramid.append(p)\r\n        if p % 2 == 0:\r\n            p = p - 2\r\n        else:\r\n            p = p - 1\r\n    return pyramid[::-1]  # return the list in reverse order\r\n\r"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    final_order = {}\n    for food, ingredients in menu.items():\n        if food in order:\n            final_order[food] = ingredients + order[food].get(\"add\", [])\n        else:\n            final_order[food] = ingredients\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    prime_nums = [num for num in range(1, n + 1) if is_prime(num)]\n    prime_pairs = []\n    for i in range(len(prime_nums)):\n        for j in range(i + 1, len(prime_nums)):\n            if is_anagram(prime_nums[i], prime_nums[j]):\n                prime_pairs.append((prime_nums[i], prime_nums[j]))\n    return sorted(prime_pairs, key=lambda x: (x[0], x[1]))\n\n"}
{"task_id": "EvoEval/67", "completion": "\n    total_calories = {}\n    for customer in customers:\n        total_calories[customer] = 0\n        if customer in meals:\n            for meal in meals[customer]:\n                total_calories[customer] += meal['calories']\n    return total_calories\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n    if arr == sorted(arr):\n        return True\n    if len(arr) == 1:\n        return True\n    if arr[0] > arr[1]:\n        return False\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n"}
{"task_id": "EvoEval/69", "completion": "\n    # Create a dictionary to store the indices of the cards\n    card_indices = {card: i for i, card in enumerate(cards)}\n    \n    # Iterate over the cards\n    for i, card in enumerate(cards):\n        # Calculate the complement of the current card\n        complement = magicNumber // card\n        \n        # Check if the complement is in the dictionary and it's not the same card\n        if complement in card_indices and card_indices[complement] != i:\n            # Return the indices of the current card and its complement\n            return (min(i, card_indices[complement]), max(i, card_indices[complement]))\n    \n    # If no pair of cards is found, return \"No magic today\"\n    return \"No magic today\"  # Return the result as a string\n"}
{"task_id": "EvoEval/70", "completion": "\n    if planet not in planets:\r\n        return False\r\n    if path[0] not in planets[planet]:\r\n        return False\r\n    if len(path) == 1:\r\n        return True\r\n    return planet_path(planets, path[1:])\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    # Convert the string to lowercase to simplify the problem\n    s = s.lower()\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Initialize a counter for the number of vowels\n    vowel_count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            # Calculate the new position of the character in the alphabet\n            new_position = (ord(char) - ord('a') + n) % 26\n            # Convert the new position back to a character and add it to the result\n            result += chr(new_position + ord('a'))\n        else:\n            # If the character is not a letter, add it to the result as is\n            result += char\n        # Check if the character is a vowel\n        if char in 'aeiou':\n            # If the character is a vowel, increment the vowel count\n            vowel_count += 1\n    # Return the result and the vowel count\n    return result, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    return [f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{i}' who was known for telling {j} tales a day\" for i, j in zip(lst, map(len, lst))]  # <--- changed here\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Initialize variables to keep track of the number of trips and the current bag capacity\r\n    trips = 0\r\n    current_bag_capacity = 0\r\n\r\n    # Iterate over each row in the grid\r\n    for row in grid:\r\n        # Iterate over each chamber in the row\r\n        for chamber in row:\r\n            # If the chamber is not empty\r\n            if chamber != 0:\r\n                # Add the number of chests in the chamber to the current bag capacity\r\n                current_bag_capacity += chamber\r\n                # If the current bag capacity exceeds the bag capacity, increment the number of trips and reset the current bag capacity\r\n                if current_bag_capacity > bag_capacity:\r\n                    trips += 1\r\n                    current_bag_capacity = 0\r\n    # Increment the number of trips by 1 to account for the final trip out of the pyramid\r\n    trips += 1\r\n    return trips\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    # Create a dictionary from the cipher string\n    cipher_dict = {}\n    for pair in cipher[1:-1].split(','):\n        key, value = pair.split(':')\n        cipher_dict[key] = value\n\n    # Use a list comprehension to replace each character in the string\n    # with its corresponding value in the cipher dictionary\n    return ''.join(cipher_dict.get(char, char) for char in s)\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\n    result = []\n    for i, char in enumerate(input_str):\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = vowels.index(char.lower())\n                result.append(vowels[(index + 1) % len(vowels)])\n            else:\n                index = consonants.index(char.lower())\n                result.append(consonants[(index + 1) % len(consonants)].upper() if char.isupper() else consonants[(index + 1) % len(consonants)])\n        elif char.isdigit():\n            result.append(str((int(char) + 1) % 10))\n        elif char in punctuation:\n            if char == '?' and i % 2 == 0:\n                result.append('!')\n            elif char == '!' and i % 2 != 0:\n                result.append('?')\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n    return ''.join(result)  # Join the list of characters into a string\n"}
{"task_id": "EvoEval/76", "completion": "\n    if not lst:\n        return []\n    max_len = max(len(str(x)) for x in lst)\n    pyramid = []\n    for i in range(len(lst), 0, -1):\n        level = ''\n        for j in range(i):\n            level += '#' * lst[j]\n        pyramid.append(level.ljust(max_len))\n    return pyramid\n"}
{"task_id": "EvoEval/77", "completion": "\n    return sorted([sum(1 for i in range(1, n + 1) if n % i == 0) for n in sequence], reverse=True)  # [0, 0, 2, 3, 2, 1]  # [2, 3, 2, 1]  # [3, 2, 1]  # [2, 1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1]  # [1"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    pattern = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                pattern.append(mat[i][j])\n    return pattern\n"}
{"task_id": "EvoEval/79", "completion": "\n    if days == 1:\r\n        return 0\r\n\r\n    max_profit = 0\r\n    for i in range(days - 1):\r\n        min_price = prices[i]\r\n        for j in range(i + 1, days):\r\n            max_price = prices[j]\r\n            if max_price > min_price:\r\n                max_profit += max_price - min_price\r\n\r\n    return max_profit\r\n\r"}
{"task_id": "EvoEval/80", "completion": "\n\n    You are building text-based adventure game. game map is a 2D list, where '' represents the start 'E' end, \n    '.' represents a and 'X' represents a wall. A player can four: up down, left,.\n\n   Given a game of instructions, the path the player takes. If the player moves into a wall or the \n   map, they should stay in current position. player finds the end 'E', the is won and further instructions \n   are processed. If the of instructions before player 'E the player's path.    player's be as a list ofples, each tuple represents the player's position ("}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n    for i in range(len(word_list) - 1):\n        if not is_sorted(word_list[i], word_list[i + 1], alien_dictionary):\n            return \"INCORRECT\"\n    return \"CORRECT\"\n\n"}
{"task_id": "EvoEval/82", "completion": "\n    zodiac_elements = {\n        'Aries': 'Fire',\n        'Taurus': 'Earth',\n        'Gemini': 'Air',\n        'Cancer': 'Water',\n        'Leo': 'Fire',\n        'Virgo': 'Earth',\n        'Libra': 'Air',\n        'Scorpio': 'Water',\n        'Sagittarius': 'Fire',\n        'Capricorn': 'Earth',\n        'Aquarius': 'Air',\n        'Pisces': 'Water'\n    }\n    zodiac_dates = {\n        'Aries': (3, 21, 4, 19),\n        'Taurus': (4, 20, 5, 20),\n        'Gemini': (5, 21, 6, 20),\n        'Cancer': (6, 21, 7, 22),\n        'Leo': (7, 23, 8, 22),\n        'Virgo': (8, 23, 9, 22),\n        'Libra': (9, 23, 10, 22),\n        'Scorpio': (10, 23, 11, 21),\n        'Sagittarius': (11, 22, 12, 21),\n        'Capricorn': (12, 22, 1, 19),\n        'Aquarius': (1, 20, 2, 18),\n        'Pisces': (2, 19, 3, 20)\n    }\n    result = {}\n    for birthday in birthdays:\n        birthday = datetime.strptime(birthday, '%Y-%m-%d')\n        for zodiac, dates in zodiac_dates.items():\n            if (dates[0] <= birthday.month <= dates[1] and\n                    dates[2] <= birthday.day <= dates[3]):\n                element = zodiac_elements[zodiac]\n                if element in result:\n                    result[element] += 1\n                else:\n                    result[element] = 1\n    return result if result else None\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n    return ''.join(s)\n"}
{"task_id": "EvoEval/84", "completion": "\n    def tree_traversal(tree):\n        paths = []\n        def dfs(node, path):\n            if not node:\n                return\n            path.append(node)\n            if not node:\n                paths.append(path[:])\n            else:\n                dfs(node, path)\n                dfs(node, path)\n            path.pop()\n        dfs(tree, [])\n        return paths\n    return tree_traversal(tree)"}
{"task_id": "EvoEval/85", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a 2D list to store the minimum number of steps to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Initialize the first cell as 0 since we are starting from there\n    dp[0][0] = 0\n    \n    # Fill the first row\n    for j in range(1, cols):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1] + 1\n        else:\n            dp[0][j] = float('inf')\n    \n    # Fill the first column\n    for i in range(1, rows):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0] + 1\n        else:\n            dp[i][0] = float('inf')\n    \n    # Fill the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n            else:\n                dp[i][j] = float('inf')\n    \n    # Check if it's possible to reach the princess\n    if dp[coord[0]][coord[1]] == float('inf'):\n        return -1\n    else:\n        return dp[coord[0]][coord[1]]\n\n"}
{"task_id": "EvoEval/86", "completion": "\n    def sort_movies_by_ratings_and_date(movies_dict):\n        # Sort the dictionary items by rating in descending order and then by release year in ascending order\n        sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n        # Extract the movie names from the sorted list of tuples\n        sorted_movie_names = [movie[0] for movie in sorted_movies]\n        return sorted_movie_names\n\n    movies_dict = {\"Toy Story\": [8.8, 2019], \"Toy Story 2\": [7.9, 1999], \"Toy Story 3\": [8.3, 2010], \"Toy Story 4\": [8.8, 2019]}\n    print(sort_movies_by_ratings_and_date(movies_dict))  # \u279e [\"Toy Story 4\", \"Toy Story\", \"Toy Story 2\", \"Toy Story 3\"]\n    print(sort_movies_by_ratings_and_date({\"Inception\": [8.8, 2010], \"The Dark Knight\": [9, 2008], \"Interstellar\": [8.6, 2014], \"The Dark Knight Rises\": [8.1, 2012]}))  # \u279e [\"The Dark Knight\", \"Inception\", \"Interstellar\", \"The Dark Knight Rises\"]\n    print(sort_movies_by_ratings_and_date({\"Toy Story\": [8, 1995], \"Toy Story 2\": [7.9, 1999], \"Toy Story 3\": [8.3, 2010], \"Toy Story 4\": [8.8, 2019]}))  # \u279e [\"Toy Story 4\", \"Toy Story\", \"Toy Story 2\", \"Toy Story 3\"]  # No error for this test case\n    print(sort_movies_by_ratings_and_date({\"Toy Story\": [8.8, 2019], \"Toy Story 2\": [7.9, 1999], \"Toy Story 3\": [8.3, 2010], \"Toy Story 4\": [8.8, 2019]}))  # \u279e [\"Toy Story 4\", \"Toy Story\", \"Toy Story 2\", \"Toy Story 3\"]  # No error for this test case\n    print(sort_movies_by_ratings_and_date({\"Toy Story\": [8.8, 2019], \"Toy Story 2\": [7"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr:\n        return ''\n    result = ''\n    top = 0\n    bottom = len(arr) - 1\n    left = 0\n    right = len(arr[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result += arr[top][i]\n        top += 1\n        for i in range(top, bottom + 1):\n            result += arr[i][right]\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result += arr[bottom][i]\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result += arr[i][left]\n            left += 1\n    return result\n"}
{"task_id": "EvoEval/88", "completion": "\n\n    \n    # Initialize an empty dictionary to store the population densities\n    population_density = {}\n    \n    # Check if the dictionary is empty\n    if not dict_of_planets:\n        return population_density\n    \n    # Iterate over each planet in the dictionary\n    for planet, data in dict_of_planets.items():\n        # Check if the planet has complete data (i.e., both population and size are not None)\n        if data[0] is not None and data[1] is not None:\n            # Calculate the population density by dividing the population by the size and rounding to two decimal places\n            population_density[planet] = round(data[0] / data[1], 2)\n    \n    # Return the dictionary of population densities\n    return population_density\n"}
{"task_id": "EvoEval/89", "completion": "\n    aliens = sorted(aliens)\n    aliens = [alien for alien in aliens if alien != ray]\n    aliens = [alien for alien in aliens if abs(alien - ray) > 1]\n    return aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    # Convert the input strings to lists of integers\n    s1 = [int(d) for d in s1]\n    s2 = [int(d) for d in s2]\n\n    # Generate all possible combinations of digits\n    combinations = []\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            combination = s1[:i] + s1[i+1:] + s2[:j] + s2[j+1:]\n            combinations.append(combination)\n\n    # Calculate the sum of all combinations\n    total = 0\n    for combination in combinations:\n        total += sum(combination)\n\n    return total\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceship_data:\n        if status == 'On Ground':\n            if action == 'Launch':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif status == 'In Space':\n            if action == 'Land':\n                status = 'On Ground'\n            elif action == 'Move':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            if action == 'Land':\n                status = 'On Ground'\n            elif action == 'Move':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Calculate the width of the fountain\n    width = 2 * n - 1\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Loop through each layer of the fountain\n    for i in range(1, n + 1):\n        # Calculate the number of spaces needed for the current layer\n        spaces = (width - (2 * i - 1)) // 2\n        \n        # Calculate the number of letters needed for the current layer\n        letters = 2 * i - 1\n        \n        # Add the spaces and letters to the result string\n        result += ' ' * spaces + ''.join(chr(64 + j) for j in range(1, letters + 1)) + '\\n'\n    \n    # Loop through each layer of the fountain in reverse order\n    for i in range(n - 1, 0, -1):\n        # Calculate the number of spaces needed for the current layer\n        spaces = (width - (2 * i - 1)) // 2\n        \n        # Calculate the number of letters needed for the current layer\n        letters = 2 * i - 1\n        \n        # Add the spaces and letters to the result string\n        result += ' ' * spaces + ''.join(chr(64 + j) for j in range(1, letters + 1)) + '\\n'\n    \n    # Return the result string\n    return result\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i in range(len(message)):\n        if message[i].isalpha():\n            n = n_values[i % len(n_values)]\n            if message[i].isupper():\n                result += chr((ord(message[i]) - 65 + n) % 26 + 65)\n            else:\n                result += chr((ord(message[i]) - 97 + n) % 26 + 97)\n        else:\n            result += message[i]\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    spells = []\n    for spell in strings:\n        spell = spell.split()\n        spell.sort(key=len)\n        spells.append(' '.join(spell))\n    return spells\n"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n\n    diagonal1 = [m[i][i] for i in range(len(m))]\n    diagonal2 = [m[i][len(m) - i - 1] for i in range(len(m))]\n\n    return abs(sum(diagonal1) - sum(diagonal2))  # return the absolute difference between the sums of the diagonals"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] % (i + 1) == 0:\n            product = 1\n            for digit in str(abs(lst[i])):\n                product *= int(digit)\n            if product == i + 1:\n                magic_indices.append(i)\n    return sorted(magic_indices) if magic_indices else [-1]  # Return [-1] if no magic indices found\n"}
{"task_id": "EvoEval/97", "completion": "\n    def alien_invasion(alien, humans):\n        # Check if the alien name and humans dictionary are valid\n        if not isinstance(alien, str) or not isinstance(humans, dict):\n            return []\n        \n        # Check if the alien name is valid\n        if not alien.isalpha():\n            return []\n        \n        # Check if the humans dictionary is valid\n        for human, continent in humans.items():\n            if not isinstance(human, str) or not isinstance(continent, str):\n                return []\n        \n        # Define the order of the continents\n        continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n        \n        # Initialize an empty list to store the human names\n        human_names = []\n        \n        # Iterate over the humans dictionary\n        for human, continent in humans.items():\n            # Check if the continent is valid\n            if continent in continents:\n                # Add the human name to the list\n                human_names.append(human)\n        \n        # Sort the human names based on the order of the continents\n        human_names.sort(key=lambda x: continents.index(humans[x]))\n        \n        # Return the sorted list of human names\n        return human_names\n"}
{"task_id": "EvoEval/98", "completion": "\n    sequence = [a, b]\n    for i in range(2, n):\n        next_number = sequence[i-1] + sequence[i-2]\n        if next_number > 1:\n            for j in range(2, int(next_number ** 0.5) + 1):\n                if next_number % j == 0:\n                    sequence.append('prime')\n                    break\n            else:\n                sequence.append(next_number)\n        else:\n            sequence.append('prime')\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    for i in range(rounds):\n        for j in range(music[i]):\n            if players[j] != 0:\n                players[j] = 0\n        players = players[1:] + players[:1]\n    return [player for player in players if player != 0]  # return players left after rounds are finished\n"}
