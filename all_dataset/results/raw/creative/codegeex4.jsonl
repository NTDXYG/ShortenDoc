{"task_id": "EvoEval/0", "completion": "\n    total_cost = 0.0\n    location_factor = 1.0\n    string_item_multiplier = 1.0\n    \n    if location == \"National\":\n        location_factor = 1.5\n    elif location == \"International\":\n        location_factor = 2.5\n    \n    for item in items:\n        if isinstance(item, str):\n            string_item_multiplier = 1.5\n            item = 1.0\n        else:\n            string_item_multiplier = 1.0\n        \n        base_cost = 5.0\n        if item > 5.0:\n            base_cost += 10.0\n        \n        total_cost += base_cost * string_item_multiplier\n    \n    total_cost *= location_factor\n    \n    return f\"{total_cost:.2f}\"\n"}
{"task_id": "EvoEval/1", "completion": "\n    total_cost = 0.0\n    for item in items:\n        weight = float(item) if isinstance(item, str) else item\n        base_cost = 5.0\n        if weight > 5.0:\n            base_cost += 10.0\n        total_cost += base_cost\n    location_factor = 1.5 if location == 'National' else 2.5 if location == 'International' else 1.0\n    total_cost *= location_factor\n    return round(total_cost, 2)\n"}
{"task_id": "EvoEval/2", "completion": "\n    if not words:\n        return []\n    \n    key_value = sum(ord(char) for char in key) if isinstance(key, str) else key\n    \n    encrypted_words = []\n    for word in words:\n        encrypted_word = \"\"\n        for char in word:\n            if char.isalpha():\n                ascii_offset = ord('a') if char.islower() else ord('A')\n                encrypted_char = chr((ord(char) - ascii_offset + key_value) % 26 + ascii_offset)\n                encrypted_word += encrypted_char\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    \n    return encrypted_words\n\nThe function `encrypt_message` is designed to encrypt a list of words using a Caesar cipher. The Caesar cipher is a type of substitution cipher in which each letter in the plaintext is shifted a certain number of places down or up the alphabet. \n\nThe function takes two arguments: `words`, which is a list of words to be encrypted, and `key`, which is either a string or an integer. If the key is a string, it is converted to an integer by summing the ASCII values of its characters. If the key is an integer, it is used as-is.\n\nThe function then iterates over each word in the list and encrypts it using the Caesar cipher. For each character in the word, if it is an alphabetical character, it is shifted by the value of the key. If the shifted character exceeds 'z', it wraps around to the start of the alphabet. If the character is not alphabetical, it is left as-is.\n\nThe encrypted words are then returned as a list.\n\nThe function has been tested with a few examples to ensure it works as expected. The first example tests the function with an empty list of words, which should return an empty list. The second example tests the function with a list of words and an integer key, which should return the encrypted words. The third example tests the function with a list of words and a string key, which should return the encrypted words.\n"}
{"task_id": "EvoEval/3", "completion": "\n    # TODO: Implement this function\n    pass\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n\n    tallest = candles[0]\n    count = 1\n\n    for i in range(1, len(candles)):\n        if candles[i] > tallest:\n            tallest = candles[i]\n            count = 1\n        elif candles[i] == tallest:\n            count += 1\n\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix or not matrix[0]:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    result = []\n    direction = 1  # 1 for rightwards, -1 for downwards\n    \n    for i in range(rows):\n        for j in range(cols):\n            result.append(matrix[i][j])\n            if (i + j) % 2 == 0:\n                if j == cols - 1:\n                    direction = -1\n                    i += 1\n                elif i == 0:\n                    direction = 1\n                    j += 1\n            else:\n                if i == rows - 1:\n                    direction = 1\n                    j += 1\n                elif j == 0:\n                    direction = -1\n                    i += 1\n    \n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    x, y = position\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n        return grid\n    if grid[x][y] == 1:\n        return grid\n    if grid[x][y] == 0:\n        return grid\n    if grid[x][y] == -1:\n        grid[x][y] = 0\n        for i in range(max(0, x-1), min(len(grid), x+2)):\n            for j in range(max(0, y-1), min(len(grid[0]), y+2)):\n                if grid[i][j] == 1:\n                    continue\n                if grid[i][j] == -1:\n                    grid[i][j] = 0\n        return grid\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\ncode_sequence = [0, 1, 2, 3]\nx, y = 0, 0\nfor code in code_sequence:\n    if code == 0:\n        y += 1\n    elif code == 1:\n        x += 1\n    elif code == 2:\n        y -= 1\n    elif code == 3:\n        x -= 1"}
{"task_id": "EvoEval/8", "completion": "\n    # Check if the canvas contains more than one 'P' or the number of painted space divides the empty spaces evenly\n    if canvas.count('P') > 1 or canvas.count('*') % canvas.count('-') == 0:\n        return 'Invalid canvas'\n    \n    # Find the index of the painter 'P'\n    painter_index = canvas.index('P')\n    \n    # Initialize the left and right pointers\n    left = painter_index\n    right = painter_index\n    \n    # Move the left pointer to the left until it hits a wall or the start of the canvas\n    while left > 0 and canvas[left-1] != '#':\n        left -= 1\n    \n    # Move the right pointer to the right until it hits a wall or the end of the canvas\n    while right < len(canvas)-1 and canvas[right+1] != '#':\n        right += 1\n    \n    # Paint all the accessible spaces between the left and right pointers\n    canvas = canvas[:left] + '*'*(right-left+1) + canvas[right+1:]\n    \n    return canvas\n"}
{"task_id": "EvoEval/9", "completion": "\n    # TODO: Implement this function\n    pass\n"}
{"task_id": "EvoEval/10", "completion": "\n###PATH:./python-projects-master/README.md"}
{"task_id": "EvoEval/11", "completion": "\n    if len(fruits) == 1:\n        return f\"Oh, are those {fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"Oh, are those {', '.join(fruits[:-1])} and {fruits[-1]} from {location}? Marvelous!\"\n"}
{"task_id": "EvoEval/12", "completion": "\n    from collections import Counter\n    counter = Counter(flux_values)\n    max_occurrence = max(counter.values())\n    most_occurred_number = min([k for k, v in counter.items() if v == max_occurrence])\n    return sum(flux_values) * most_occurred_number\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for elem in elems:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n\n    # Find the element with the minimum count\n    min_count = min(count_dict.values())\n    rarest_elem = None\n    for elem, count in count_dict.items():\n        if count == min_count:\n            if rarest_elem is None or elems.index(elem) < elems.index(rarest_elem):\n                rarest_elem = elem\n\n    return rarest_elem\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = vowels.index(char.lower())\n                if char.isupper():\n                    alias += vowels[index+1].upper()\n                else:\n                    alias += vowels[index+1]\n            elif char.lower() in consonants:\n                index = consonants.index(char.lower())\n                if char.isupper():\n                    alias += consonants[index+1].upper()\n                else:\n                    alias += consonants[index+1]\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Create a dictionary to store the count of each card value\n    card_counts = {}\n    for card in hand:\n        value = int(card[:-1])\n        if value in card_counts:\n            card_counts[value] += 1\n        else:\n            card_counts[value] = 1\n\n    # Initialize the score to 0\n    score = 0\n\n    # Check for pairs, triples, and fours\n    for value, count in card_counts.items():\n        if count == 2:\n            score += value\n        elif count == 3:\n            score += 2 * value\n        elif count == 4:\n            score += 3 * value\n        elif count == 5:\n            score += 4 * value\n\n    return score\n\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, n):\n            fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])\n        return sum(fib_sequence)"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard in wizards:\n        if wizard[1] >= dragon_hp:\n            return wizard[0]\n    return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    if n == 1:\n        return 7\n    else:\n        return magical_seven(n-1) + 7 * 10 ** (len(str(magical_seven(n-1))) - 1)"}
{"task_id": "EvoEval/19", "completion": "\n    danger = 0\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 1:\n                if i > 0 and m[i-1][j] == 2:\n                    danger += 1\n                if i < len(m)-1 and m[i+1][j] == 2:\n                    danger += 1\n                if j > 0 and m[i][j-1] == 2:\n                    danger += 1\n                if j < len(m[i])-1 and m[i][j+1] == 2:\n                    danger += 1\n    return danger"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n+1):\n        pattern.append(str(i))\n    for i in range(n-1, 0, -1):\n        pattern.append(str(i))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    # TODO: implement this function\n    pass\n\n"}
{"task_id": "EvoEval/22", "completion": "\n    return t * v / 9.461e12\n"}
{"task_id": "EvoEval/23", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_prime(k):\n        count = 0\n        num = 2\n        while count < k:\n            if is_prime(num):\n                count += 1\n            num += 1\n        return num\n\n    result = \"\"\n    for char in s:\n        if char.islower():\n            prime = get_prime(ord(char) - ord('a') + 1)\n            result += str(prime)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    return ''.join(alien_dict[i] for i in english_word.lower())\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\n    sentences = text.split(\".\")\n    \n    # Initialize variables\n    max_frequency = 0\n    max_sentence = \"\"\n    \n    # Iterate through each sentence\n    for sentence in sentences:\n        # Count the frequency of the word in the sentence\n        frequency = sentence.count(word)\n        \n        # Update the max frequency and sentence if necessary\n        if frequency > max_frequency:\n            max_frequency = frequency\n            max_sentence = sentence.strip()\n    \n    # Return the result\n    return (max_frequency, max_sentence)\n\n"}
{"task_id": "EvoEval/26", "completion": "\n    # Check if start and end are the same\n    if start == end:\n        return []\n    \n    # Check if start or end is out of bounds\n    if start[0] < 0 or start[0] >= len(maze) or start[1] < 0 or start[1] >= len(maze[0]) or end[0] < 0 or end[0] >= len(maze) or end[1] < 0 or end[1] >= len(maze[0]):\n        return []\n    \n    # Check if start or end is a wall\n    if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:\n        return []\n    \n    # Initialize the queue and the visited set\n    queue = [(start, [])]\n    visited = set()\n    \n    # Perform breadth-first search\n    while queue:\n        (current, path) = queue.pop(0)\n        visited.add(current)\n        \n        # Check if we have reached the end\n        if current == end:\n            return path\n        \n        # Add the neighboring cells to the queue\n        for direction in [\"up\", \"down\", \"left\", \"right\"]:\n            next_cell = get_next_cell(maze, current, direction)\n            if next_cell and next_cell not in visited:\n                queue.append((next_cell, path + [direction]))\n    \n    # If we have not reached the end, return an empty list\n    return []"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n"}
{"task_id": "EvoEval/28", "completion": "\n    taxable_income = income - deductions\n    tax = 0\n\n    if taxable_income <= 10000:\n        tax = 0\n    elif taxable_income <= 35000:\n        tax = (taxable_income - 10000) * 0.15\n    elif taxable_income <= 80000:\n        tax = 2500 + (taxable_income - 35000) * 0.25\n    else:\n        tax = 2500 + 15000 + (taxable_income - 80000) * 0.30\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                palindromes.add(substring)\n    return sorted(list(palindromes))\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Create a queue to store the points to be visited\n    queue = [start]\n    # Create a set to store the points that have been visited\n    visited = set()\n    # Create a dictionary to store the parent of each point\n    parent = {}\n\n    # While the queue is not empty\n    while queue:\n        # Get the current point\n        current = queue.pop(0)\n        # If the current point is the end point, return the path\n        if current == end:\n            path = []\n            while current in parent:\n                path.append(current)\n                current = parent[current]\n            path.append(start)\n            return path[::-1]\n        # If the current point has not been visited\n        if current not in visited:\n            # Add the current point to the visited set\n            visited.add(current)\n            # Get the neighbors of the current point\n            neighbors = get_neighbors(maze, current)\n            # For each neighbor\n            for neighbor in neighbors:\n                # Add the neighbor to the queue\n                queue.append(neighbor)\n                # Set the parent of the neighbor to the current point\n                parent[neighbor] = current\n\n    # If no path is found, return an empty list\n    return []\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    paths = [[0] * n for _ in range(m)]\n\n    # Initialize the first row and column to 1, since there is only one way to reach them\n    for i in range(m):\n        paths[i][0] = 1\n    for j in range(n):\n        paths[0][j] = 1\n\n    # Calculate the number of unique paths to each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\n\n    # Return the number of unique paths to the bottom-right corner\n    return paths[m - 1][n - 1]\n\n"}
{"task_id": "EvoEval/32", "completion": "\n    # TODO: implement this function\n    pass\n\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\n    ways = [0] * (n + 1)\n    # There is 1 way to reach the 0th step (starting point)\n    ways[0] = 1\n\n    # Iterate through each step\n    for i in range(1, n + 1):\n        # For each step, iterate through each magic stone\n        for stone in magic_stones:\n            # If the stone's power is less than or equal to the current step, add the number of ways to reach the previous step\n            if stone <= i:\n                ways[i] += ways[i - stone]\n\n    # Return the number of ways to reach the nth step\n    return ways[n]\n"}
{"task_id": "EvoEval/34", "completion": "\n    transformation = [0]\n    for i in range(1, n+1):\n        if i < m:\n            transformation.append(min(100, transformation[-1] + 10))\n        elif i == m:\n            transformation.append(min(100, transformation[-1] * 2))\n        else:\n            transformation.append(max(0, transformation[-1] - 10))\n    return transformation\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email or email[0] == \"@\" or email[-1] == \"@\" or \".\" not in email[email.index(\"@\"):]:\r\n        return False\r\n    else:\r\n        return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coefficients = [0]\n    for i in range(len(xs)):\n        integral_coefficients.append(xs[i] / (i + 1))\n    return integral_coefficients\n\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for char in s:\n        if char.lower() in vowels:\n            if char.isupper():\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)].upper()\n            else:\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            if char.isupper():\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].upper()\n            else:\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        else:\n            transformed += char\n    return transformed\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \"\ud83d\ude00\",\n        \";)\": \"\ud83d\ude09\"\n    }\n    for emoticon, emoji in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Create a list to store the rows of the ASCII art\n    rows = []\n\n    # Create the top row of the ASCII art\n    top_row = \"*\" * (len(s) * n + 2)\n    rows.append(top_row)\n\n    # Create the middle rows of the ASCII art\n    for _ in range(n):\n        middle_row = \"*\" + s * n + \"*\"\n        rows.append(middle_row)\n\n    # Create the bottom row of the ASCII art\n    bottom_row = \"*\" * (len(s) * n + 2)\n    rows.append(bottom_row)\n\n    # Join the rows with newline characters to create the final ASCII art\n    ascii_art = \"\\n\".join(rows)\n\n    return ascii_art\n"}
{"task_id": "EvoEval/40", "completion": "\n    potions = sorted(potions)\n    target = int(target)\n    result = []\n    for potion in potions:\n        name, power = potion.split()\n        power = int(power)\n        if power <= target:\n            result.append(potion)\n            target -= power\n        if target == 0:\n            break\n    if target != 0:\n        return []\n    return result\n"}
{"task_id": "EvoEval/41", "completion": "\n    # Initialize the minimum energy required to infinity\n    min_energy = float('inf')\n    \n    # Define the directions in which the spider can move\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Define the function to check if a cell is within the bounds of the array\n    def is_valid_cell(x, y):\n        return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n    \n    # Define the function to perform a depth-first search to find the minimum energy required\n    def dfs(x, y, energy):\n        nonlocal min_energy\n        \n        # If the current cell is the safe cell, update the minimum energy required\n        if arr[x][y] == 0:\n            min_energy = min(min_energy, energy)\n            return\n        \n        # Mark the current cell as visited\n        arr[x][y] = -1\n        \n        # Explore all possible directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # If the neighboring cell is within the bounds and not visited, move to that cell\n            if is_valid_cell(nx, ny) and arr[nx][ny] != -1:\n                dfs(nx, ny, energy + arr[nx][ny])\n        \n        # Unmark the current cell as visited\n        arr[x][y] = arr[x][y] if arr[x][y] != 0 else -1\n    \n    # Start the depth-first search from the top-left cell\n    dfs(0, 0, 0)\n    \n    return min_energy\n"}
{"task_id": "EvoEval/42", "completion": "\n\r\n    # Check if the player has acquired a legendary item\r\n    if 5 in player_input:\r\n        # Find the rarity of the second most valuable item\r\n        sorted_input = sorted(player_input, reverse=True)\r\n        if len(sorted_input) > 1:\r\n            return (True, sorted_input[1])\r\n        else:\r\n            return (True, -1)\r\n    else:\r\n        return (False, None)\n"}
{"task_id": "EvoEval/43", "completion": "\n    if distance / speed > fuel:\n        return 'Insufficient fuel'\n    else:\n        return round(fuel - (distance / speed) * spaceship_weight * planet_gravity * 0.1, 2)\n"}
{"task_id": "EvoEval/44", "completion": "\ndef fairy_tale_transport(q,w,e):\r\n    return sum(q) <= w + e\n"}
{"task_id": "EvoEval/45", "completion": "\n    # Initialize variables\n    max_view = 0\n    current_view = 0\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        # Check if the current hill is taller than the previous hill\n        if i == 0 or arr[i] > arr[i-1]:\n            # Increment the current view\n            current_view += 1\n        else:\n            # Reset the current view\n            current_view = 1\n\n        # Update the maximum view\n        max_view = max(max_view, current_view)\n\n    return max_view\n"}
{"task_id": "EvoEval/46", "completion": "\n    pass\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code = {\n        '01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0'\n    }\n    msg = msg.replace('/', ' / ')\n    words = msg.split(' ')\n    decoded_words = []\n    for word in words:\n        if word == '':\n            continue\n        decoded_word = ''\n        for char in word.split(' '):\n            decoded_word += morse_code[char]\n        decoded_words.append(decoded_word)\n    return ' '.join(decoded_words)\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n    'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n    'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n    'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n    'Y': '-.--', 'Z': '--..', ' ': '  '}\n    result = \"\"\n    for char in text:\n        if char.upper() in morse_code:\n            result += morse_code[char.upper()] + \" \"\n        else:\n            result += char + \" \"\n    return result.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not string:\n        return ''\n    if not list_of_alphabets:\n        return string\n    result = ''\n    for char in string:\n        result += list_of_alphabets[(ord(char) - ord('a')) % len(list_of_alphabets)]\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # Sort the orders in descending order\n    orders.sort(reverse=True)\n\n    # Initialize the number of orders fulfilled\n    fulfilled_orders = 0\n\n    # Iterate through the orders\n    for order in orders:\n        # If the order can be fulfilled in a single batch\n        if order <= n:\n            # Increment the number of orders fulfilled\n            fulfilled_orders += 1\n            # Decrement the number of batches remaining\n            m -= 1\n            # If there are no more batches remaining, break the loop\n            if m == 0:\n                break\n\n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            if char.isupper():\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)].upper()\n            else:\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            if char.isupper():\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].upper()\n            else:\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        elif char == '?':\n            if i % 2 == 0:\n                transformed += '!'\n            else:\n                transformed += '?'\n        else:\n            transformed += char\n    return transformed\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = \"\"\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift_amount = (i + shift) % 26\n            if char.islower():\n                result += chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', \n    'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', \n    'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', \n    'y': '-.--', 'z': '--..'}\n    morse_code = \"\"\n    for char in s:\n        if char == \" \":\n            morse_code += \" \"\n        else:\n            morse_code += morse_code_dict[char] + \" \"\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        new_name = ''\n        for letter in dish:\n            new_name += magic_spell[(magic_spell.index(letter) + len(magic_spell)) % len(magic_spell)]\n        new_menu[new_name] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for char in earth_phrase:\n        if char in vowels:\n            translated_phrase += vowels[(vowels.index(char) + 1) % len(vowels)]\n        elif char in consonants:\n            translated_phrase += consonants[(consonants.index(char) + 1) % len(consonants)]\n        elif char == ' ':\n            translated_phrase += '@'\n    translated_words = translated_phrase.split('@')\n    translated_words = [word.capitalize() for word in translated_words]\n    for i in range(len(translated_words)):\n        if translated_words[i][0] in vowels:\n            translated_words[i] += 'xy'\n        else:\n            translated_words[i] += 'yz'\n    return '@'.join(translated_words)\n"}
{"task_id": "EvoEval/59", "completion": "\n    # Sort the dictionary by value in descending order and then by key in ascending order\n    sorted_dict = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Convert the sorted dictionary to a list of tuples\n    result = [(k, v) for k, v in sorted_dict]\n    \n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    pass\n\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n    for i, char in enumerate(s):\n        if char == ' ':\n            result.append(' ')\n        elif i % 2 == 0:\n            if char.lower() in vowels:\n                result.append(vowels[(vowels.index(char.lower()) + 1) % len(vowels)])\n            elif char.lower() in consonants:\n                result.append(consonants[(consonants.index(char.lower()) - 1) % len(consonants)])\n        else:\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n    return ''.join(result)\n"}
{"task_id": "EvoEval/62", "completion": "\n    new_recipe = {}\n    for ingredient, quantity in recipe.items():\n        new_recipe[ingredient] = quantity * conversion_factor\n    return new_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = [p]\r\n    while p > 0:\r\n        if p % 2 == 0:\r\n            p -= 2\r\n        else:\r\n            p -= 3\r\n        if p > 0:\r\n            pyramid.append(p)\r\n    return pyramid\n"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [x for x in range(start, end + 1) if x % divisor == 0 and is_prime(x)]\n\n"}
{"task_id": "EvoEval/65", "completion": "\n    if not order:\n        return menu\n\n    final_order = {}\n\n    for food, modifications in order.items():\n        if food in menu:\n            base_ingredients = menu[food]\n            if \"remove\" in modifications:\n                base_ingredients = [ingredient for ingredient in base_ingredients if ingredient not in modifications[\"remove\"]]\n            if \"add\" in modifications:\n                base_ingredients.extend(modifications[\"add\"])\n            final_order[food] = base_ingredients\n\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    primes = [i for i in range(2, n+1) if is_prime(i)]\n    anagram_pairs = []\n\n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            if is_anagram(primes[i], primes[j]):\n                anagram_pairs.append((primes[i], primes[j]))\n\n    return sorted(anagram_pairs)\n"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum([meal['calories'] for meal in meals[customer]])\n        else:\n            total_calories = 0\n        result[customer] = total_calories\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n\n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n\n    # Check if the array can be sorted by rotating\n    rotated_arr = arr[1:] + arr[:1]\n    if rotated_arr == sorted(rotated_arr):\n        return True\n\n    # Check if the array can be sorted by swapping\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:]\n            swapped_arr[i], swapped_arr[j] = swapped_arr[j], swapped_arr[i]\n            if swapped_arr == sorted(swapped_arr):\n                return True\n\n    return False\n\n"}
{"task_id": "EvoEval/69", "completion": "\n    for i in range(len(cards)):\n        for j in range(i+1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return \"No magic today\"\n"}
{"task_id": "EvoEval/70", "completion": "\n    if not planets or not path:\r\n        return False\r\n    for i in range(len(path)-1):\r\n        if path[i] not in planets or path[i+1] not in planets[path[i]]:\r\n            return False\r\n    return True\n"}
{"task_id": "EvoEval/71", "completion": "\n    def shift_letter(letter, n):\n        if letter.isalpha():\n            base = ord('a') if letter.islower() else ord('A')\n            return chr((ord(letter) - base + n) % 26 + base)\n        return letter\n\n    encrypted_string = ''.join(shift_letter(char, n) for char in s)\n    vowel_count = sum(1 for char in encrypted_string if char.lower() in 'aeiou')\n    return encrypted_string, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    fairy_tales = []\n    for string in lst:\n        name = string\n        tales = sum(c.isdigit() for c in string)\n        fairy_tales.append(f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{name}' who was known for telling {tales} tales a day\")\n    return fairy_tales\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n    # Your code goes here\n   "}
{"task_id": "EvoEval/74", "completion": "\n    new_string = \"\"\n    for char in s:\n        if char in cipher:\n            new_string += cipher[char]\n        else:\n            new_string += char\n    return new_string\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed_str = ''\n    for i, char in enumerate(input_str):\n        if char.lower() in vowels:\n            transformed_str += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            transformed_str += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        elif char.isdigit():\n            transformed_str += str((int(char) + 1) % 10)\n        elif char == '?':\n            if i % 2 == 0:\n                transformed_str += '!'\n            else:\n                transformed_str += '?'\n        else:\n            transformed_str += char\n    return transformed_str\n"}
{"task_id": "EvoEval/76", "completion": "\n    pyramid = []\n    level = 0\n    for num in lst:\n        level += num\n        pyramid.append('#' * level)\n    return pyramid[::-1]\n"}
{"task_id": "EvoEval/77", "completion": "\n    def count_divisions(n, k):\n        count = 0\n        while n % k == 0:\n            n //= k\n            count += 1\n        return count\n\n    points = [count_divisions(num, k) for num in sequence]\n    sorted_sequence = sorted(zip(sequence, points), key=lambda x: x[1], reverse=True)\n    return [x[0] for x in sorted_sequence]\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        result.append(mat[i][i])\n        result.append(mat[i][n-i-1])\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n\r\n    max_profit = 0\r\n    for i in range(len(prices)):\r\n        for j in range(i + 1, min(i + days, len(prices))):\r\n            profit = prices[j] - prices[i]\r\n            if profit > max_profit:\r\n                max_profit = profit\r\n    return max_profit\n"}
{"task_id": "EvoEval/80", "completion": "\n    # Initialize the player's position to the start 'S'\n    player_position = (0, 0)\n    for i, row in enumerate(map):\n        if 'S' in row:\n            player_position = (i, row.index('S'))\n            break\n\n    # Initialize the player's path to the start 'S'\n    path = [(player_position[0], player_position[1])]\n\n    # Process each instruction\n    for instruction in instructions:\n        # Determine the player's new position based on the instruction\n        if instruction == 'up':\n            new_position = (player_position[0] - 1, player_position[1])\n        elif instruction == 'down':\n            new_position = (player_position[0] + 1, player_position[1])\n        elif instruction == 'left':\n            new_position = (player_position[0], player_position[1] - 1)\n        elif instruction == 'right':\n            new_position = (player_position[0], player_position[1] + 1)\n\n        # Check if the new position is valid\n        if new_position[0] < 0 or new_position[0] >= len(map) or new_position[1] < 0 or new_position[1] >= len(map[0]):\n            # The new position is outside the map, so the player stays in their current position\n            path.append((player_position[0], player_position[1]))\n        elif map[new_position[0]][new_position[1]] == 'X':\n            # The new position is a wall, so the player stays in their current position\n            path.append((player_position[0], player_position[1]))\n        elif map[new_position[0]][new_position[1]] == 'E':\n            # The new position is the end 'E', so the game is won\n            path.append((new_position[0], new_position[1]))\n            break\n        else:\n            # The new position is a valid path, so the player moves to it\n            player_position = new_position\n            path.append((player_position[0], player_position[1]))\n\n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n    alien_order = {char: i for i, char in enumerate(alien_dictionary)}\n    for i in range(len(word_list) - 1):\n        word1, word2 = word_list[i], word_list[i + 1]\n        min_length = min(len(word1), len(word2))\n        for j in range(min_length):\n            if word1[j] != word2[j]:\n                if alien_order[word1[j]] > alien_order[word2[j]]:\n                    return \"INCORRECT\"\n                break\n        else:\n            if len(word1) > len(word2):\n                return \"INCORRECT\"\n    return \"CORRECT\"\n"}
{"task_id": "EvoEval/82", "completion": "\n    if not birthdays:\n        return None\n\n    zodiac_signs = {\n        \"Aries\": (\"March 21\", \"April 19\"),\n        \"Taurus\": (\"April 20\", \"May 20\"),\n        \"Gemini\": (\"May 21\", \"June 20\"),\n        \"Cancer\": (\"June 21\", \"July 22\"),\n        \"Leo\": (\"July 23\", \"August 22\"),\n        \"Virgo\": (\"August 23\", \"September 22\"),\n        \"Libra\": (\"September 23\", \"October 22\"),\n        \"Scorpio\": (\"October 23\", \"November 21\"),\n        \"Sagittarius\": (\"November 22\", \"December 21\"),\n        \"Capricorn\": (\"December 22\", \"January 19\"),\n        \"Aquarius\": (\"January 20\", \"February 18\"),\n        \"Pisces\": (\"February 19\", \"March 20\")\n    }\n\n    elements = {\n        \"Fire\": [\"Aries\", \"Leo\", \"Sagittarius\"],\n        \"Water\": [\"Cancer\", \"Scorpio\", \"Pisces\"],\n        \"Air\": [\"Gemini\", \"Libra\", \"Aquarius\"],\n        \"Earth\": [\"Taurus\", \"Virgo\", \"Capricorn\"]\n    }\n\n    result = {}\n\n    for birthday in birthdays:\n        month, day = map(int, birthday.split(\"-\")[1:])\n        for sign, (start, end) in zodiac_signs.items():\n            start_month, start_day = map(int, start.split())\n            end_month, end_day = map(int, end.split())\n            if (month == start_month and day >= start_day) or (month == end_month and day <= end_day) or (month > start_month and month < end_month):\n                for element, signs in elements.items():\n                    if sign in signs:\n                        result[element] = result.get(element, 0) + 1\n                        break\n\n    return result\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] not in vowels:\n            i += 1\n        elif s[j] not in vowels:\n            j -= 1\n        else:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n    return ''.join(s)\n"}
{"task_id": "EvoEval/84", "completion": "\n    def dfs(node, path):\n        if not node:\n            return\n        path.append(node)\n        if not node.get('left') and not node.get('right'):\n            paths.append(path.copy())\n        else:\n            dfs(node.get('left'), path)\n            dfs(node.get('right'), path)\n        path.pop()\n\n    paths = []\n    dfs(tree, [])\n    return paths\n"}
{"task_id": "EvoEval/85", "completion": "\n    # Check if the starting point or the princess's coordinate is a monster\n    if grid[0][0] == 1 or grid[coord[0]][coord[1]] == 1:\n        return -1\n    \n    # Initialize the number of moves to 0\n    moves = 0\n    \n    # Initialize the current position to the starting point\n    current_position = (0, 0)\n    \n    # While the current position is not the princess's coordinate\n    while current_position != coord:\n        # Check if the current position is a monster\n        if grid[current_position[0]][current_position[1]] == 1:\n            return -1\n        \n        # Check if the princess's coordinate is reachable from the current position\n        if current_position[0] == coord[0] and current_position[1] < coord[1]:\n            # Move right\n            current_position = (current_position[0], current_position[1] + 1)\n        elif current_position[0] < coord[0] and current_position[1] == coord[1]:\n            # Move down\n            current_position = (current_position[0] + 1, current_position[1])\n        elif current_position[0] < coord[0] and current_position[1] < coord[1]:\n            # Check if the cell to the right is open\n            if grid[current_position[0]][current_position[1] + 1] == 0:\n                # Move right\n                current_position = (current_position[0], current_position[1] + 1)\n            else:\n                # Move down\n                current_position = (current_position[0] + 1, current_position[1])\n        else:\n            return -1\n        \n        # Increment the number of moves\n        moves += 1\n    \n    return moves\n"}
{"task_id": "EvoEval/86", "completion": "\n    # Sort the dictionary by ratings and release year\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], -x[1][1]))\n\n    # Extract the movie names from the sorted dictionary\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n\n    return sorted_movie_names\n"}
{"task_id": "EvoEval/87", "completion": "\n    # Your code here\n    if not arr:\n        return ''\n    result = ''\n    rows, cols = len(arr), len(arr[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result += arr[top][i]\n        top += 1\n        for i in range(top, bottom + 1):\n            result += arr[i][right]\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result += arr[bottom][i]\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result += arr[i][left]\n            left += 1\n    return result\n"}
{"task_id": "EvoEval/88", "completion": "\n    result = {}\n    for planet, data in dict_of_planets.items():\n        if data[0] is not None and data[1] is not None:\n            result[planet] = round(data[0] / data[1], 2)\n    return result\n"}
{"task_id": "EvoEval/89", "completion": "\n    # Create a new list to store the remaining aliens' positions\n    remaining_aliens = []\n\n    # Iterate through the list of aliens\n    for alien in aliens:\n        # Check if the alien's position is not adjacent to the ray gun's position\n        if not (alien == ray - 1 or alien == ray + 1):\n            # If the alien's position is not adjacent, add it to the list of remaining aliens\n            remaining_aliens.append(alien)\n\n    # Return the list of remaining aliens' positions\n    return remaining_aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    def get_combinations(s1, s2):\n        combinations = []\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                combinations.append(int(s1[i]) * int(s2[j]))\n        return combinations\n\n    def get_unique_combinations(combinations):\n        unique_combinations = []\n        for combination in combinations:\n            if combination not in unique_combinations:\n                unique_combinations.append(combination)\n        return unique_combinations\n\n    def get_sum_of_combinations(unique_combinations):\n        sum_of_combinations = 0\n        for combination in unique_combinations:\n            sum_of_combinations += combination\n        return sum_of_combinations\n\n    combinations = get_combinations(s1, s2)\n    unique_combinations = get_unique_combinations(combinations)\n    sum_of_combinations = get_sum_of_combinations(unique_combinations)\n    return sum_of_combinations\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceship_data:\n        if status == 'On Ground' and action == 'Launch':\n            status = 'In Space'\n        elif status == 'In Space' and action == 'Move':\n            continue\n        elif status == 'In Space' and action == 'Land':\n            status = 'On Ground'\n        else:\n            return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Create a list to store the layers of the fountain\n    layers = []\n    \n    # Loop through the number of layers\n    for i in range(1, n+1):\n        # Calculate the width of the current layer\n        width = 2*i-1\n        \n        # Calculate the number of letters to use for the current layer\n        letters = i\n        \n        # Create a string to store the current layer\n        layer = ''\n        \n        # Loop through the number of letters\n        for j in range(letters):\n            # Calculate the letter to use for the current position\n            letter = chr(ord('A') + (j % 26))\n            \n            # Add the letter to the current layer\n            layer += letter\n            \n            # Add spaces to the current layer\n            layer += ' ' * (width - 2*letters)\n            \n            # Add the letter in reverse order to the current layer\n            layer += letter[::-1]\n        \n        # Add the current layer to the list of layers\n        layers.append(layer)\n    \n    # Join the layers with newlines and return the result\n    return '\\n'.join(layers)\n"}
{"task_id": "EvoEval/93", "completion": "\n    encoded_message = \"\"\n    for i, char in enumerate(message):\n        if char.isalpha():\n            n = n_values[i % len(n_values)]\n            if char.isupper():\n                encoded_char = chr((ord(char) - ord('A') + n) % 26 + ord('A'))\n            else:\n                encoded_char = chr((ord(char) - ord('a') + n) % 26 + ord('a'))\n            encoded_message += encoded_char\n        else:\n            encoded_message += char\n    return encoded_message\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [ ' '.join(sorted(spell.split(), key=len)) for spell in strings]\n"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    else:\n        sum1 = 0\n        sum2 = 0\n        for i in range(len(m)):\n            sum1 += m[i][i]\n            sum2 += m[i][len(m)-i-1]\n        return abs(sum1 - sum2)\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        value = lst[i]\n        if value % i == 0 and product_of_digits(value) == i:\n            magic_indices.append(i)\n    return magic_indices\n"}
{"task_id": "EvoEval/97", "completion": "\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    else:\n        continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n        encounter_order = []\n        for continent in continents:\n            for human, location in humans.items():\n                if location == continent:\n                    encounter_order.append(human)\n        return encounter_order\n"}
{"task_id": "EvoEval/98", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    sequence = [a, b]\n    for i in range(2, n):\n        next_num = sequence[i-1] + sequence[i-2] + i\n        if is_prime(next_num):\n            sequence.append('prime')\n        else:\n            sequence.append(next_num)\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    position = 0\n    for round in rounds:\n        time = 0\n        while time < round:\n            position = (position + music) % len(players)\n            time += 1\n        players.pop(position)\n        position = position % len(players)\n    return players\n"}
