{"task_id": "EvoEval/0", "completion": "\n    # Initialize the total cost and the additional charge flag\n    total_cost = 0.0\n    additional_charge = False\n    \n    # Check if there are any string items\n    string_items = [item for item in items if isinstance(item, str)]\n    \n    # If there are string items, multiply the total cost by 1.5\n    if string_items:\n        total_cost *= 1.5\n    \n    # Iterate over each item\n    for item in items:\n        # If the item is a string, consider its weight as 1kg\n        if isinstance(item, str):\n            weight = 1.0\n        else:\n            weight = item\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 5.0\n        \n        # If the item's weight is more than 5kg, add an additional charge\n        if weight > 5.0:\n            total_cost += 10.0\n            additional_charge = True\n    \n    # Apply the location factor\n    if location == \"National\":\n        total_cost *= 1.5\n    elif location == \"International\":\n        total_cost *= 2.5\n    \n    # If there were any string items, multiply the total cost by 1.5\n    if string_items:\n        total_cost *= 1.5\n    \n    # If there was an additional charge, multiply the total cost by 1.5\n    if additional_charge:\n        total_cost *= 1.5\n    \n    # Return the total shipping cost rounded to two decimal places as a string\n    return \"{:.2f}\".format(total_cost)  # Use string formatting to round the cost to two decimal places\n"}
{"task_id": "EvoEval/1", "completion": "\n    # Initialize the total cost to 0\n    total_cost = 0.0\n    \n    # Define the location factors\n    location_factors = {\n        \"Local\": 1.0,\n        \"National\": 1.5,\n        \"International\": 2.5\n    }\n    \n    # Iterate over each item in the list\n    for item in items:\n        # If the item is a string, consider its weight as 1kg\n        if isinstance(item, str):\n            weight = 1.0\n        # If the item is a float, use its value as the weight\n        elif isinstance(item, float):\n            weight = item\n        # If the item is neither a string nor a float, raise a ValueError\n        else:\n            raise ValueError(\"Invalid item type\")\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 5.0\n        \n        # If the item's weight is more than 5kg, add an additional charge\n        if weight > 5.0:\n            total_cost += 10.0\n        \n        # Multiply the total cost by the location factor\n        total_cost *= location_factors.get(location, 1.0)\n    \n    # Return the total shipping cost rounded to two decimal places\n    return round(total_cost, 2)  # Changed from 1 to 2 to match the problem's requirements\n"}
{"task_id": "EvoEval/2", "completion": "\n    # Convert the key to an integer if it's a string\n    if isinstance(key, str):\n        key = sum(ord(char) for char in key)\n    \n    # Initialize an empty list to store the encrypted words\n    encrypted_words = []\n    \n    # Iterate over each word in the input list\n    for word in words:\n        # Initialize an empty string to store the encrypted word\n        encrypted_word = \"\"\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Find the ASCII value of 'a' or 'A' depending on the case of the character\n                ascii_offset = ord('a') if char.islower() else ord('A')\n                \n                # Calculate the new character by shifting the current character by the key\n                new_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n                \n                # Add the new character to the encrypted word\n                encrypted_word += new_char\n            else:\n                # If the character is not a letter, add it to the encrypted word as-is\n                encrypted_word += char\n        \n        # Add the encrypted word to the list of encrypted words\n        encrypted_words.append(encrypted_word)\n    \n    # Return the list of encrypted words\n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    if not input_string:\n        return []\n\n    def backtrack(start, path, res):\n        if start == len(input_string):\n            res.append(''.join(path))\n            return\n        for i in range(int(input_string[start]), 27):\n            path.append(chr(i + 96))\n            backtrack(start + 1, path, res)\n            path.pop()\n\n    res = []\n    backtrack(0, [], res)\n    return res\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    max_height = candles[0]\n    count = 1\n    for height in candles[1:]:\n        if height > max_height:\n            max_height = height\n            count += 1\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    for row in matrix:\n        if left > right:\n            break\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result.append(row[i])\n        # Traverse from right to left\n        for i in range(right, left - 1, -1):\n            result.append(row[i])\n        left += 1\n        right -= 1\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n\n    # Check if the position is out of the grid\n    if position[0] < 0 or position[0] >= rows or position[1] < 0 or position[1] >= cols:\n        return grid\n\n    # Get the value of the cell at the clicked position\n    cell_value = grid[position[0]][position[1]]\n\n    # If the cell is already revealed or is a mine, return the initial grid\n    if cell_value == 0 or cell_value == 1:\n        return grid\n\n    # If the cell is empty, convert all the adjacent cells to 0\n    if cell_value == -1:\n        # Define the adjacent positions\n        adjacent_positions = [\n            (position[0] - 1, position[1] - 1),\n            (position[0] - 1, position[1]),\n            (position[0] - 1, position[1] + 1),\n            (position[0], position[1] - 1),\n            (position[0], position[1] + 1),\n            (position[0] + 1, position[1] - 1),\n            (position[0] + 1, position[1]),\n            (position[0] + 1, position[1] + 1),\n        ]\n\n        # Check if each adjacent position is within the grid\n        for pos in adjacent_positions:\n            if 0 <= pos[0] < rows and 0 <= pos[1] < cols:\n                # Convert the adjacent cell to 0\n                grid[pos[0]][pos[1]] = 0\n\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize the current position at (0,0)\r\n    current_position = [0, 0]\r\n    \r\n    # Iterate over each direction in the code sequence\r\n    for direction in code_sequence:\r\n        # Move in the specified direction\r\n        if direction == 0:\r\n            current_position[1] += 1\r\n        elif direction == 1:\r\n            current_position[0] += 1\r\n        elif direction == 2:\r\n            current_position[1] -= 1\r\n        elif direction == 3:\r\n            current_position[0] -= 1\r\n        \r\n        # If the current position is back at the starting point, return 'Shangri-La found'\r\n        if current_position == [0, 0]:\r\n            return 'Shangri-La found'\r\n    \r\n    # If the sequence does not lead back to the starting point, return 'Shangri-La not found'\r\n    return 'Shangri-La not found'\r\n\r\n\r"}
{"task_id": "EvoEval/8", "completion": "\n    # Split the canvas into a list of characters\n    canvas = list(canvas)\n    \n    # Find the position of the painter\n    painter_pos = [i for i, char in enumerate(canvas) if char == 'P']\n    \n    # If there is no painter or more than one painter, return 'Invalid canvas'\n    if len(painter_pos) != 1:\n        return 'Invalid canvas'\n    \n    # Get the position of the painter\n    painter = painter_pos[0]\n    \n    # Initialize a set to keep track of visited positions\n    visited = set()\n    \n    # Define the directions for DFS\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Perform DFS from the painter's position\n    stack = [(painter, 0)]\n    while stack:\n        pos, dist = stack.pop()\n        \n        # If the position is not visited and is not a wall, mark it as visited and paint it\n        if pos not in visited and canvas[pos] != '#':\n            visited.add(pos)\n            canvas[pos] = '*'\n            \n            # Add the neighboring positions to the stack\n            for direction in directions:\n                new_pos = pos + direction[0] * dist + direction[1]\n                if 0 <= new_pos < len(canvas) and canvas[new_pos] != '#':\n                    stack.append((new_pos, dist + 1))\n    \n    # Count the number of painted spaces and empty spaces\n    painted = sum(1 for char in canvas if char == '*')\n    empty = sum(1 for char in canvas if char == '-')\n    \n    # If the number of painted spaces divides the empty spaces evenly, return 'Invalid canvas'\n    if painted % empty == 0:\n        return 'Invalid canvas'\n    \n    # Return the updated canvas\n    return ''.join(canvas)  # <--- Changed here\n"}
{"task_id": "EvoEval/9", "completion": "\n    # Convert the string to lower case to ignore case sensitivity\n    string = string.lower()\n    \n    # Remove punctuation from the string\n    string = ''.join(e for e in string if e.isalnum() or e.isspace())\n    \n    # Split the string into words\n    words = string.split()\n    \n    # Create a dictionary to store the frequency of each word\n    frequency = {}\n    \n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word is already in the dictionary, increment its frequency by 1\n        if word in frequency:\n            frequency[word] += 1\n        # If the word is not in the dictionary, add it with a frequency of 1\n        else:\n            frequency[word] = 1\n    \n    # Return the dictionary of word frequencies\n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_sounds = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\r\n    animal_count = {}\r\n    result = []\r\n    animal_string = animal_string.split()\r\n    for animal in animal_string:\r\n        if len(animal) > 1:\r\n            if animal[0] in animal_sounds:\r\n                if animal[0] not in animal_count or animal_count[animal[0]] < 2:\r\n                    animal_count[animal[0]] = animal.count('|')\r\n                    result.append(animal_count[animal[0]])\r\n                    if len(result) == 5:\r\n                        break\r\n    return result\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    # Check if the list of fruits has only one element\n    if len(fruits) == 1:\n        # If it does, return the message with the singular fruit\n        return f\"Oh, are those {fruits[0]} from {location}? Marvelous!\"\n    # Check if the list of fruits has two elements\n    elif len(fruits) == 2:\n        # If it does, return the message with the two fruits\n        return f\"Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    # If the list of fruits has more than two elements\n    else:\n        # Return the message with the first two fruits and the rest as a comma-separated list\n        return f\"Oh, are those {', '.join(fruits[:2])} and {len(fruits) - 2} more from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Create a dictionary to store the frequency of each number in the list\n    frequency = {}\n    for num in flux_values:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Find the number with the maximum frequency. If there are multiple, select the smallest one\n    max_frequency = max(frequency.values())\n    most_occurred_number = min([num for num, freq in frequency.items() if freq == max_frequency])\n\n    # Calculate the sum of all elements in the list\n    total_sum = sum(flux_values)\n\n    # Multiply the sum of all elements with the most occurred number\n    energy_signature = total_sum * most_occurred_number\n\n    return energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    # If the list is empty, return None\n    if not elems:\n        return None\n\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for elem in elems:\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        else:\n            freq_dict[elem] = 1\n\n    # Find the element with the minimum frequency\n    min_freq = min(freq_dict.values())\n    rarest_elems = [elem for elem, freq in freq_dict.items() if freq == min_freq]\n\n    # Return the rarest element that appears first\n    return rarest_elems[0]  # Return the first element in the list of rarest elements\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = (vowels.index(char.lower()) + 1) % len(vowels)\n                alias += vowels[index] if char.islower() else vowels[index].upper()\n            else:\n                index = (consonants.index(char.lower()) + 1) % len(consonants)\n                alias += consonants[index] if char.islower() else consonants[index].upper()\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Create a dictionary to map card values to their scores\n    card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 1}\n\n    # Create a dictionary to store the count of each card value\n    value_counts = {}\n\n    # Iterate over each card in the hand\n    for card in hand:\n        # Get the value of the card\n        value = card[0]\n\n        # Increment the count of the card value\n        if value in value_counts:\n            value_counts[value] += 1\n        else:\n            value_counts[value] = 1\n\n    # Initialize the score to 0\n    score = 0\n\n    # Check for pairs, triples, fours and fives\n    for value, count in value_counts.items():\n        # If the count is 2, it's a pair\n        if count == 2:\n            score += card_values[value]\n        # If the count is 3, it's a triple\n        elif count == 3:\n            score += 2 * card_values[value]\n        # If the count is 4, it's a four of a kind\n        elif count == 4:\n            score += 3 * card_values[value]\n        # If the count is 5, it's a five of a kind\n        elif count == 5:\n            score += 4 * card_values[value]\n\n    # Return the score\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        total = 1\n        for _ in range(2, n):\n            a, b = b, a + b\n            total += b\n        return total\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard_name, magic_power in wizards:\n        dragon_hp -= magic_power\n        if dragon_hp <= 0:\n            return wizard_name\n    return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # noqa: E501\n"}
{"task_id": "EvoEval/18", "completion": "\n    i = 1\n    while True:\n        if sum(int(digit) for digit in str(i)) == 7 and i % 7 == 0:\n            return i\n        i += 1\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize a variable to store the number of humans in danger\n    humans_in_danger = 0\n\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a human (1)\n            if cell == 1:\n                # Check if there is a vampire in the same row\n                if 2 in row:\n                    # If there is, increment the humans_in_danger counter\n                    humans_in_danger += 1\n                # Check if there is a vampire in the same column\n                elif any(m[i][j] == 2 for i in range(len(m)) for j in range(len(m[0])) if i != len(m) - 1 and j != len(m[0]) - 1):\n                    # If there is, increment the humans_in_danger counter\n                    humans_in_danger += 1\n\n    # Return the total number of humans in danger\n    return humans_in_danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join(map(str, range(1, i + 1))))\n    for i in range(n - 1, 0, -1):\n        pattern.append(','.join(map(str, range(i, 0, -1))))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Check if the grid is a square\n    if len(grid) != len(grid[0]):\n        return False\n\n    # Check if all words are in the grid\n    for word in words:\n        found = False\n        # Check horizontally\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == word[0]:\n                    k = 1\n                    while k < len(word) and j + k < len(grid[0]) and grid[i][j + k] == word[k]:\n                        k += 1\n                    if k == len(word):\n                        found = True\n                        break\n            if found:\n                break\n        if not found:\n            # Check vertically\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == word[0]:\n                        k = 1\n                        while k < len(word) and i + k < len(grid) and grid[i + k][j] == word[k]:\n                            k += 1\n                        if k == len(word):\n                            found = True\n                            break\n                if found:\n                    break\n        if not found:\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Convert the velocity from km/s to light years/year\n    v_lyr = v / (9.461 * 10**12)\n    # Calculate the distance traveled\n    distance = t * v_lyr\n    return distance\n"}
{"task_id": "EvoEval/23", "completion": "\n\n        Helper function to check if a number is prime.\n        \"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def nth_prime(n: int) -> int:\n        \"\"\"\n        Helper function to find the nth prime number.\n        \"\"\"\n        count = 0\n        num = 2\n        while True:\n            if is_prime(num):\n                count += 1\n                if count == n:\n                    return num\n            num += 1\n\n    prime_dict = {chr(i): nth_prime(i - 96) for i in range(97, 123)}\n    return ''.join(prime_dict.get(c, c) for c in s)  # Use get() to handle non-alphabetic characters\n\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_language = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^',\n        'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>',\n        'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'\n    }\n    return ''.join(alien_language.get(char, char) for char in english_word.lower())  # Convert to lowercase to handle case-insensitive input\n\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\r\n    sentences = text.split(\".\")\r\n\r\n    # Initialize a dictionary to store the frequency of the word in each sentence\r\n    frequency = {}\r\n\r\n    # Initialize the maximum frequency and the sentence with the maximum frequency\r\n    max_frequency = 0\r\n    max_sentence = \"\"\r\n\r\n    # Iterate over each sentence\r\n    for sentence in sentences:\r\n        # Split the sentence into words\r\n        words = sentence.split()\r\n\r\n        # Count the frequency of the word in the sentence\r\n        frequency[sentence] = words.count(word)\r\n\r\n        # Update the maximum frequency and the sentence with the maximum frequency\r\n        if frequency[sentence] > max_frequency:\r\n            max_frequency = frequency[sentence]\r\n            max_sentence = sentence\r\n\r\n    # Return the frequency of the word and the sentence with the maximum frequency\r\n    return (max_frequency, max_sentence) if max_frequency > 0 else (0, \"\")\r\n\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    \n    # Check if the start and end are the same\n    if start == end:\n        return []\n    \n    # Get the number of rows and columns in the maze\n    rows, cols = len(maze), len(maze[0])\n    \n    # Create a visited set to keep track of visited cells\n    visited = set()\n    \n    # Create a stack to store the path\n    stack = [(start, [])]\n    \n    # While the stack is not empty\n    while stack:\n        # Get the current cell and path\n        (x, y), path = stack.pop()\n        \n        # If the current cell is the end, return the path\n        if (x, y) == end:\n            return path\n        \n        # If the current cell has been visited, skip it\n        if (x, y) in visited:\n            continue\n        \n        # Mark the current cell as visited\n        visited.add((x, y))\n        \n        # Get the possible directions\n        directions = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n        \n        # For each direction\n        for dx, dy, direction in directions:\n            # Calculate the new cell\n            nx, ny = x + dx, y + dy\n            \n            # If the new cell is within the maze and is not a wall and has not been visited\n            if (0 <= nx < rows) and (0 <= ny < cols) and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                # Add the new cell and the direction to the stack\n                stack.append(((nx, ny), path + [direction]))\n    \n    # If the path does not exist, return an empty list\n    return []\n\n\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Calculate the taxable income by subtracting the deductions\n    taxable_income = income - deductions\n\n    # Apply the tax reductions due to deductions\n    if deductions <= 1000:\n        taxable_income -= deductions\n    elif deductions <= 3000:\n        taxable_income -= (1000 + (deductions - 1000) * 2 / 3)\n    else:\n        taxable_income -= (1000 + 2000 + (deductions - 3000) * 3 / 3)\n\n    # Apply the progressive tax rates\n    if taxable_income <= 10000:\n        tax = 0\n    elif taxable_income <= 25000:\n        tax = (taxable_income - 10000) * 0.15\n    elif taxable_income <= 50000:\n        tax = (10000 * 0.15) + ((taxable_income - 25000) * 0.25)\n    elif taxable_income <= 130000:\n        tax = (10000 * 0.15) + (25000 * 0.25) + ((taxable_income - 50000) * 0.25)\n    else:\n        tax = (10000 * 0.15) + (25000 * 0.25) + (50000 * 0.25) + ((taxable_income - 130000) * 0.30)\n\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    # Initialize an empty set to store unique palindrome substrings\n    palindrome_substrings = set()\n\n    # Iterate over the string with two nested loops to generate all substrings\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            # Extract the substring\n            substring = s[i:j]\n\n            # Check if the substring is a palindrome\n            if substring == substring[::-1]:\n                # Add the palindrome substring to the set\n                palindrome_substrings.add(substring)\n\n    # Convert the set to a list and sort it in ascending order\n    palindrome_substrings = sorted(list(palindrome_substrings))\n\n    return palindrome_substrings\n\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements in the maze (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Create a queue for BFS, containing the start point\n    queue = [(start, [start])]\n\n    # Create a set to store the visited points\n    visited = set([start])\n\n    while queue:\n        # Dequeue the next point and its path\n        (x, y), path = queue.pop(0)\n\n        # If this is the end point, return the path\n        if (x, y) == end:\n            return path\n\n        # For each possible movement\n        for dx, dy in movements:\n            # Calculate the new point\n            nx, ny = x + dx, y + dy\n\n            # If the new point is within the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new point as visited\n                visited.add((nx, ny))\n\n                # Enqueue the new point and its path\n                queue.append(((nx, ny), path + [(nx, ny)]))\n\n    # If no path is found, return an empty list\n    return []  # pragma: no cover\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[0] * n for _ in range(m)]\n    \n    # There is only one way to reach each cell in the first row and first column\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n    \n    # For each cell, the number of unique paths to it is the sum of the number of unique paths to the cell above it and the cell to its left\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    # The number of unique paths to the bottom-right cell is the total number of unique paths\n    return dp[m-1][n-1]  # return the value at the bottom-right cell\n"}
{"task_id": "EvoEval/32", "completion": "\n    # Create a copy of the original playlist to avoid modifying it\n    playlist_copy = playlist.copy()\n    \n    # Initialize the seed and the length of the playlist\n    seed = seed\n    playlist_length = len(playlist_copy)\n    \n    # Iterate over the indices of the playlist\n    for i in range(playlist_length):\n        # If the current song title contains the word \"Rock\", skip the swap operation\n        if \"Rock\" in playlist_copy[i]:\n            continue\n        \n        # Calculate the index to swap with\n        swap_index = (seed % playlist_length)\n        \n        # Swap the current song title with the one at the calculated index\n        playlist_copy[i], playlist_copy[swap_index] = playlist_copy[swap_index], playlist_copy[i]\n        \n        # Update the seed for the next iteration\n        seed = (seed * 16807) % 2147483647\n    \n    # Return the shuffled playlist\n    return playlist_copy\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\r\n    ways = [0] * (n + 1)\r\n    # There's only one way to reach the first step (by not jumping at all)\r\n    ways[0] = 1\r\n    # For each step from 1 to n\r\n    for i in range(1, n + 1):\r\n        # For each magic stone\r\n        for stone in magic_stones:\r\n            # If the stone's power is less than or equal to the current step\r\n            if stone <= i:\r\n                # Add the number of ways to reach the step before the stone's power to the current step\r\n                ways[i] += ways[i - stone]\r\n    # Return the number of ways to reach the top of the staircase\r\n    return ways[n]\r\n\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize the list to store the transformation percentages\n    transformation_percentages = [0]\n    \n    # Initialize the current transformation percentage\n    current_transformation = 0\n    \n    # Iterate over the days in the cycle\n    for day in range(1, n):\n        # If the current day is the most intense day, double the transformation percentage\n        if day == m:\n            current_transformation = min(100, current_transformation * 2)\n        # If the current day is after the most intense day, decrease the transformation percentage by 10%\n        elif day > m:\n            current_transformation = max(0, current_transformation - 10)\n        # If the current day is before the most intense day, increase the transformation percentage by 10%\n        else:\n            current_transformation = min(100, current_transformation + 10)\n        \n        # Append the current transformation percentage to the list\n        transformation_percentages.append(current_transformation)\n    \n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if email.count('@') != 1:\r\n        return False\r\n    if email[0] == '@' or email[-1] == '@':\r\n        return False\r\n    if email.find('@') == len(email) - 1:\r\n        return False\r\n    if email.find('.') == -1 or email.find('.') < email.find('@'):\r\n        return False\r\n    return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coefficients = [0]\n    for i in range(len(xs)):\n        integral_coefficients.append(xs[i] / (i + 1))\n    return integral_coefficients\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for char in s:\n        if char in vowels:\n            idx = vowels.index(char)\n            result += vowels[(idx + 1) % len(vowels)]\n        elif char in consonants:\n            idx = consonants.index(char)\n            result += consonants[(idx + 1) % len(consonants)]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \"\ud83d\ude00\",\n        \";)\": \"\ud83d\ude09\",\n        # Add more emoticons as needed\n    }\n    for emoticon, emoji in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # First, we create a string of '*' characters that will be used to frame the ASCII art\n    frame = '*' * (n * len(s) + 3)\n\n    # Then, we create a string that will be repeated n times to create each row of the ASCII art\n    row = '*' + s * n + '*'\n\n    # Next, we create the ASCII art by repeating the row string n times\n    ascii_art = row * n\n\n    # Finally, we add the frame to the top and bottom of the ASCII art\n    ascii_art = frame + '\\n' + ascii_art + '\\n' + frame\n\n    return ascii_art\n"}
{"task_id": "EvoEval/40", "completion": "\n    # Split each potion into name and power level, and store them in a list of tuples\n    potions = [tuple(potion.split(' ', 1)) for potion in potions]\n    \n    # Sort the potions by power level in ascending order\n    potions.sort(key=lambda x: int(x[1]))\n    \n    # Initialize a list to store the result\n    result = []\n    \n    # Initialize a variable to store the current power level\n    current_power = 0\n    \n    # Iterate over the sorted potions\n    for potion in potions:\n        # If the current power level is less than the target power level\n        if current_power < target:\n            # If adding the current potion's power level would exceed the target power level\n            if current_power + int(potion[1]) > target:\n                # Skip this potion\n                continue\n            # Otherwise, add the potion to the result and update the current power level\n            result.append(potion)\n            current_power += int(potion[1])\n    \n    # If the current power level is not equal to the target power level, return an empty list\n    if current_power != target:\n        return []\n    \n    # Otherwise, return the result\n    return result\n"}
{"task_id": "EvoEval/41", "completion": "\n    # Get the dimensions of the web\n    rows, cols = len(arr), len(arr[0])\n    \n    # Initialize a 2D array to store the minimum energy required to reach each cell\n    energy = [[float('inf')] * cols for _ in range(rows)]\n    \n    # The spider starts at the top-left cell, so the energy required to reach it is 0\n    energy[0][0] = 0\n    \n    # Iterate over each cell in the web\n    for i in range(rows):\n        for j in range(cols):\n            # If the current cell is the safe cell, we're done\n            if arr[i][j] == 0:\n                return energy[i][j]\n            \n            # If the current cell is not the safe cell, calculate the minimum energy required to reach it\n            if i > 0:\n                energy[i][j] = min(energy[i][j], energy[i-1][j] + arr[i][j])\n            if j > 0:\n                energy[i][j] = min(energy[i][j], energy[i][j-1] + arr[i][j])\n    \n    # If the safe cell is not reachable, return -1\n    return -1\n"}
{"task_id": "EvoEval/42", "completion": "\n    # Check if the player has acquired a legendary item\r\n    if 5 in player_input:\r\n        # If the player has acquired a legendary item, remove it from the list\r\n        player_input.remove(5)\r\n        # Sort the list in descending order to find the second most valuable item\r\n        player_input.sort(reverse=True)\r\n        # If the player has only acquired the legendary item, return -1\r\n        if len(player_input) == 0:\r\n            return (True, -1)\r\n        # Otherwise, return the rarity of the second most valuable item\r\n        else:\r\n            return (True, player_input[1])\r\n    # If the player has not acquired a legendary item, return False and None\r\n    else:\r\n        return (False, None)"}
{"task_id": "EvoEval/43", "completion": "\n    # Calculate the duration of the trip\n    trip_duration = distance / speed\n    \n    # Check if the spaceship can reach the planet\n    if trip_duration <= fuel:\n        # Calculate the fuel consumption of the trip\n        fuel_consumption = trip_duration * spaceship_weight * planet_gravity * 0.1\n        \n        # Calculate the remaining fuel\n        remaining_fuel = fuel - fuel_consumption\n        \n        # Return the remaining fuel rounded to 2 decimal points\n        return round(remaining_fuel, 2)\n    else:\n        # Return 'Insufficient fuel' if the spaceship cannot reach the planet\n        return 'Insufficient fuel'  # Changed this line to return a string instead of None\n\n"}
{"task_id": "EvoEval/44", "completion": "\n    # Calculate the total weight of all items\r\n    total_weight = sum(q)\r\n    \r\n    # If the total weight is greater than the combined strength of unicorns and dragons/griffins, return False\r\n    if total_weight > w + e:\r\n        return False\r\n    # If the total weight is less than or equal to the combined strength of unicorns and dragons/griffins, return True\r\n    else:\r\n        return True\r\n\r"}
{"task_id": "EvoEval/45", "completion": "\n    if not arr:\n        return 0\n\n    max_view = 0\n    left_view = 0\n    right_view = 0\n    left_taller = False\n    right_taller = False\n\n    for i in range(len(arr)):\n        if i > 0:\n            if arr[i] > arr[i-1]:\n                left_taller = True\n            else:\n                left_taller = False\n\n        if i < len(arr) - 1:\n            if arr[i] > arr[i+1]:\n                right_taller = True\n            else:\n                right_taller = False\n\n        if not left_taller:\n            left_view += 1\n        if not right_taller:\n            right_view += 1\n\n        if left_view + right_view + 1 > max_view:\n            max_view = left_view + right_view + 1\n\n    return max_view\n"}
{"task_id": "EvoEval/46", "completion": "\n    secret_messages = []\n    for test_case in test_cases:\n        secret_message = ''\n        for word in test_case:\n            # Remove any non-alphabetic characters from the word\n            cleaned_word = ''.join(char for char in word if char.isalpha())\n            # Add the first letter of the cleaned word to the secret message\n            secret_message += cleaned_word[0].lower() if cleaned_word else ''\n        # Check if the secret message is in the original strings\n        if secret_message in ''.join(test_case).lower():\n            secret_message = 'Take the cannoli.'\n        secret_messages.append(secret_message)\n    return secret_messages\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    # Initialize an empty dictionary to store the inventory\n    inventory = {}\n\n    # Iterate over each log in the inventory logs\n    for log in inventory_logs:\n        # Get the item and quantity from the log\n        item = log['item']\n        quantity = log['quantity']\n\n        # If the item is already in the inventory, add the quantity to its current value\n        if item in inventory:\n            inventory[item] += quantity\n        # If the item is not in the inventory, add it with its quantity\n        else:\n            inventory[item] = quantity\n\n        # If the quantity of an item is zero or less, remove it from the inventory\n        if inventory[item] <= 0:\n            del inventory[item]\n\n    # Return the final inventory\n    return inventory\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code_map = {\n        'A': '01', 'B': '1000', 'C': '1010', 'D': '100', 'E': '0', 'F': '0010',\n        'G': '110', 'H': '0000', 'I': '00', 'J': '0111', 'K': '101', 'L': '0100',\n        'M': '11', 'N': '10', 'O': '111', 'P': '0110', 'Q': '1101', 'R': '010',\n        'S': '000', 'T': '1', 'U': '001', 'V': '0001', 'W': '011', 'X': '1001',\n        'Y': '1011', 'Z': '1100', '1': '01111', '2': '00111', '3': '00011',\n        '4': '00001', '5': '00000', '6': '10000', '7': '11000', '8': '11100',\n        '9': '11110', '0': '11111'\n    }\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        decoded_word = ''\n        for char in word.split():\n            if char in morse_code_map:\n                decoded_word += morse_code_map[char]\n        for key, value in morse_code_map.items():\n            if value in decoded_word:\n                decoded_word = decoded_word.replace(value, key)\n        decoded_words.append(decoded_word)\n    return ''.join(decoded_words)  # Return the decoded words as a single string\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n                        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n                        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n                        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n                        'Y': '-.--', 'Z': '--..', ' ': '  '}\n    morse_code = ''\n    for char in text.upper():\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()  # remove trailing space\n"}
{"task_id": "EvoEval/51", "completion": "\n    \n    if not list_of_alphabets:\n        return string\n    \n    result = ''\n    for i, char in enumerate(string):\n        result += list_of_alphabets[i % len(list_of_alphabets)]\n    \n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # First, sort the orders in descending order\n    orders.sort(reverse=True)\n    \n    # Initialize a variable to keep track of the number of orders fulfilled\n    fulfilled_orders = 0\n    \n    # Initialize a variable to keep track of the remaining capacity in the current batch\n    remaining_capacity = n\n    \n    # Iterate over each order\n    for order in orders:\n        # If the order can be fulfilled with the remaining capacity, increment the fulfilled orders and reset the remaining capacity\n        if order <= remaining_capacity:\n            fulfilled_orders += 1\n            remaining_capacity = n\n        # If the order cannot be fulfilled with the remaining capacity, increment the fulfilled orders and reset the remaining capacity\n        else:\n            fulfilled_orders += 1\n            remaining_capacity = n - order % n\n            # If the remaining capacity is 0, break the loop\n            if remaining_capacity == 0:\n                break\n    \n    # Return the maximum number of orders that can be fulfilled in a day\n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    \n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for i, char in enumerate(s):\n        if char in vowels:\n            index = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[index]\n        elif char in consonants:\n            index = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[index]\n        elif char == '?':\n            if i % 2 == 0:\n                result += '!'\n            else:\n                result += '?'\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    \n    result = ''\n    shift_counter = shift\n    \n    for char in message:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + shift_counter) % 26 + ascii_offset)\n            shift_counter += 1\n        else:\n            result += char\n    \n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', \n                       'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', \n                       'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', \n                       'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    morse_code = \"\"\n    words = s.split()\n    for word in words:\n        letters = word.split()\n        for letter in letters:\n            morse_code += morse_code_dict.get(letter, \"\") + \" \"\n        morse_code += \"/ \"\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    \n    # Initialize an empty dictionary to store the transformed menu\n    transformed_menu = {}\n    \n    # Iterate over each dish in the menu\n    for dish, price in menu.items():\n        # Initialize an empty string to store the transformed dish name\n        transformed_dish = ''\n        \n        # Iterate over each character in the dish name\n        for i, char in enumerate(dish):\n            # Append the corresponding character from the spell to the transformed dish name\n            # The index of the character in the spell is the position of the character in the dish name modulo the length of the spell\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        \n        # Store the transformed dish name and its price in the transformed menu\n        transformed_menu[transformed_dish] = price\n    \n    # Return the transformed menu\n    return transformed_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for char in earth_phrase:\n        if char in vowels:\n            if char == 'u':\n                translated_phrase += 'a'\n            else:\n                translated_phrase += chr(ord(char) + 1)\n        elif char in consonants:\n            if char == 'z':\n                translated_phrase += 'b'\n            else:\n                translated_phrase += chr(ord(char) + 1)\n        elif char == ' ':\n            translated_phrase += '@'\n    translated_phrase = translated_phrase.title()\n    words = translated_phrase.split('@')\n    for i, word in enumerate(words):\n        if word[0] in vowels:\n            words[i] += 'xy'\n        else:\n            words[i] += 'yz'\n    translated_phrase = '@'.join(words)\n    return translated_phrase\n"}
{"task_id": "EvoEval/59", "completion": "\n    \n    # First, we sort the dictionary items based on the number of recipes in descending order and then by the ingredient name in ascending order\n    sorted_items = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Then, we convert the sorted items into a list of tuples\n    result = list(sorted_items)\n    \n    # Finally, we return the result\n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    # Initialize a list to keep track of sugar locations\n    sugar_locations = sugar_locations.copy()\n    \n    # Initialize a list to keep track of happy ants\n    happy_ants = [False] * len(ant_positions)\n    \n    # Iterate over each ant\n    for i, (position, direction) in enumerate(ant_positions):\n        # If the ant is moving to the right\n        if direction == \"right\":\n            # While the ant is still on the path\n            while position < path_length - 1:\n                # If the ant encounters a sugar location\n                if position in sugar_locations:\n                    # Mark the ant as happy\n                    happy_ants[i] = True\n                    # Remove the sugar location\n                    sugar_locations.remove(position)\n                # Move the ant to the right\n                position += 1\n        # If the ant is moving to the left\n        else:\n            # While the ant is still on the path\n            while position > 0:\n                # If the ant encounters a sugar location\n                if position in sugar_locations:\n                    # Mark the ant as happy\n                    happy_ants[i] = True\n                    # Remove the sugar location\n                    sugar_locations.remove(position)\n                # Move the ant to the left\n                position -= 1\n    \n    # Return the number of happy ants\n    return happy_ants.count(True)  # Count the number of True values in the list\n"}
{"task_id": "EvoEval/61", "completion": "\n    \n    # Initialize an empty list to store the transformed characters\n    transformed_chars = []\n    \n    # Iterate over the input string with index\n    for i, char in enumerate(s):\n        # Check if the character is alphabetic\n        if char.isalpha():\n            # Check if the index is odd\n            if i % 2 != 0:\n                # Swap the case of the character\n                transformed_chars.append(char.swapcase())\n            else:\n                # Perform the case swap\n                transformed_chars.append(char)\n        else:\n            # If the character is not alphabetic, just append it as is\n            transformed_chars.append(char)\n    \n    # Initialize a dictionary to map vowels to the next vowel in the sequence\n    vowel_map = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a'}\n    \n    # Initialize a dictionary to map consonants to the preceding consonant\n    consonant_map = {chr(i): chr((i - ord('a') - 1) % 26 + ord('a')) for i in range(ord('a'), ord('z') + 1)}\n    \n    # Initialize a string of vowels\n    vowels = 'aeiou'\n    \n    # Initialize a string of consonants\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    \n    # Initialize an empty list to store the final transformed characters\n    final_transformed_chars = []\n    \n    # Iterate over the transformed characters\n    for char in transformed_chars:\n        # Check if the character is a vowel\n        if char.lower() in vowels:\n            # Replace the vowel with the next vowel in the sequence\n            final_transformed_chars.append(vowel_map[char.lower()])\n        # Check if the character is a consonant\n        elif char.lower() in consonants:\n            # Replace the consonant with the preceding consonant\n            final_transformed_chars.append(consonant_map[char.lower()])\n        else:\n            # If the character is neither a vowel nor a consonant, just append it as is\n            final_transformed_chars.append(char)\n    \n    # Join the final transformed characters into a string\n    result = ''.join(final_transformed_chars)\n    \n    # Return the final transformed string\n    return result\n"}
{"task_id": "EvoEval/62", "completion": "\n    # Initialize an empty dictionary to store the result\n    result = {}\n    \n    # Iterate over each ingredient and its quantity in the recipe\n    for ingredient, quantity in recipe.items():\n        # Multiply the quantity by the conversion factor and store it in the result dictionary\n        result[ingredient] = quantity * conversion_factor\n    \n    # Return the result dictionary\n    return result\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\r\n    current_layer = p\r\n    while current_layer > 0:\r\n        pyramid.append(current_layer)\r\n        if current_layer % 2 == 0:\r\n            current_layer -= 2\r\n        else:\r\n            current_layer -= 3\r\n    return pyramid[::-1]  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the pyramid in the correct order (from bottom to top)  # Return the"}
{"task_id": "EvoEval/64", "completion": "\nThis function checks if a number 'n' is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Then, we generate a list of all numbers in the range [start, end] inclusive\n    numbers = list(range(start, end + 1))\n\n    # Next, we filter the list to include only numbers that are divisible by 'divisor' and are prime\n    result = [n for n in numbers if n % divisor == 0 and is_prime(n)]\n\n    # Finally, we return the result\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    final_order = menu.copy()  # Create a copy of the original menu\n    for food, custom in order.items():\n        if \"remove\" in custom:\n            final_order[food] = [i for i in final_order[food] if i not in custom[\"remove\"]]\n        if \"add\" in custom:\n            final_order[food].extend(custom[\"add\"])\n    return final_order\n\n"}
{"task_id": "EvoEval/66", "completion": "\nCheck if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        \"\"\"Check if two numbers are anagrams of each other.\"\"\"\n        return sorted(str(num1)) == sorted(str(num2))\n\n    prime_nums = [i for i in range(2, n) if is_prime(i)]\n    prime_anagrams = []\n\n    for i in range(len(prime_nums)):\n        for j in range(i + 1, len(prime_nums)):\n            if is_anagram(prime_nums[i], prime_nums[j]):\n                prime_anagrams.append((prime_nums[i], prime_nums[j]))\n\n    # Sort the list of anagram pairs\n    prime_anagrams.sort(key=lambda x: (x[0], x[1]))\n\n    return prime_anagrams\n\n"}
{"task_id": "EvoEval/67", "completion": "\n    # Initialize an empty dictionary to store the total calories for each customer\n    total_calories = {}\n    \n    # Iterate over each customer in the customers list\n    for customer in customers:\n        # Initialize the total calories for the current customer to 0\n        total_calories[customer] = 0\n        \n        # Check if the customer exists in the meals dictionary\n        if customer in meals:\n            # If the customer exists, iterate over each meal consumed by the customer\n            for meal in meals[customer]:\n                # Add the calories of the current meal to the total calories of the customer\n                total_calories[customer] += meal['calories']\n    \n    # Return the dictionary containing the total calories for each customer\n    return total_calories\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n\n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n\n    # Check if the array can be sorted by rotating it\n    for i in range(len(arr)):\n        # Rotate the array\n        arr = arr[-1:] + arr[:-1]\n        # Check if the rotated array is sorted\n        if arr == sorted(arr):\n            return True\n\n    # If the array cannot be sorted by rotating it, check if it can be sorted by swapping two elements\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Swap two elements\n            arr[i], arr[j] = arr[j], arr[i]\n            # Check if the swapped array is sorted\n            if arr == sorted(arr):\n                return True\n            # Swap the elements back\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # If the array cannot be sorted by rotating or swapping, return False\n    return False\n"}
{"task_id": "EvoEval/69", "completion": "\n    \n    # Create a dictionary to store the indices of the cards\n    card_indices = {card: i for i, card in enumerate(cards)}\n    \n    # Iterate over the cards\n    for i in range(len(cards)):\n        # For each card, iterate over the remaining cards\n        for j in range(i + 1, len(cards)):\n            # Check if the product of the two cards equals the magic number\n            if cards[i] * cards[j] == magicNumber:\n                # If it does, return the indices of the two cards\n                return (i, j)\n    \n    # If no pair of cards is found, return \"No magic today\"\n    return \"No magic today\"  # This line will never be reached\n\n"}
{"task_id": "EvoEval/70", "completion": "\n    # Check if the path list is empty or the planet does not exist in the dictionary\r\n    if not path or path[0] not in planets:\r\n        return False\r\n\r\n    # Iterate over the path list\r\n    for i in range(len(path) - 1):\r\n        # Check if the current planet connects directly to the next planet\r\n        if path[i] not in planets or path[i + 1] not in planets[path[i]]:\r\n            return False\r\n\r\n    # If the function has not returned False, the path is valid\r\n    return True\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    vowels = 'aeiou'\n    result = ''\n    vowel_count = 0\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            if char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return result, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    return [f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{s}' who was known for telling {sum(int(digit) for digit in s if digit.isdigit())} tales a day\" for s in lst]  # count the digits in each string and create the fairy tale story\n\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Calculate the total number of treasures in the pyramid\r\n    total_treasures = sum(sum(row) for row in grid)\r\n    \r\n    # Calculate the number of trips needed to collect all treasures\r\n    # The number of trips is equal to the total number of treasures divided by the bag capacity, rounded up to the nearest integer\r\n    # We use the math.ceil function to round up to the nearest integer\r\n    trips = math.ceil(total_treasures / bag_capacity)\r\n    \r\n    return trips\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the string 's'\n    for char in s:\n        # Check if the character exists in the 'cipher' dictionary\n        if char in cipher:\n            # If it exists, append its corresponding value to the result string\n            result += cipher[char]\n        else:\n            # If it does not exist, append the character as it is to the result string\n            result += char\n    \n    # Return the result string\n    return result\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    digits = '0123456789'\n    result = ''\n    for i, char in enumerate(input_str):\n        if char in vowels:\n            next_vowel_index = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[next_vowel_index]\n        elif char in consonants:\n            next_consonant_index = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[next_consonant_index]\n        elif char in digits:\n            result += str((int(char) + 1) % 10)\n        elif char in \"!?\":\n            if i % 2 == 0:\n                if char == \"!\":\n                    result += \"?\"\n                else:\n                    result += \"!\"\n            else:\n                if char == \"?\":\n                    result += \"!\"\n                else:\n                    result += \"?\"\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/76", "completion": "\n    pyramid = []\n    for i, num in enumerate(lst):\n        level = '#' * num\n        pyramid.append(level)\n    return pyramid[::-1]  # Reverse the list to get the correct order of the pyramid\n"}
{"task_id": "EvoEval/77", "completion": "\n    return sorted([sum(1 for _ in range(0, int(n) + 1, k)) for n in sequence], reverse=True)  # noqa: E501\n\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        result.append(mat[i][i])  # top left to bottom right\n        result.append(mat[i][n - i - 1])  # top right to bottom left\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n    # Initialize the maximum profit to 0\r\n    max_profit = 0\r\n\r\n    # Iterate over each day from the first day to the day before the vendor leaves the market\r\n    for i in range(days):\r\n        # Initialize the minimum price to the price on the current day\r\n        min_price = prices[i]\r\n\r\n        # Iterate over each day from the current day to the day before the vendor leaves the market\r\n        for j in range(i + 1, days + 1):\r\n            # Update the minimum price if the price on the current day is lower\r\n            min_price = min(min_price, prices[j - 1])\r\n\r\n            # Update the maximum profit if the difference between the price on the current day and the minimum price is higher\r\n            max_profit = max(max_profit, prices[j - 1] - min_price)\r\n\r\n    # Return the maximum profit\r\n    return max_profit\r\n\r"}
{"task_id": "EvoEval/80", "completion": "\n    \n    # Initialize the player's position and path\n    player_row, player_col = 0, 0\n    path = [(0, 0)]\n    \n    # Iterate over each instruction\n    for instruction in instructions:\n        # Get the current player position\n        current_row, current_col = player_row, player_col\n        \n        # Move the player according to the instruction\n        if instruction == 'up' and current_row > 0 and map[current_row - 1][current_col] != 'X':\n            player_row -= 1\n        elif instruction == 'down' and current_row < len(map) - 1 and map[current_row + 1][current_col] != 'X':\n            player_row += 1\n        elif instruction == 'left' and current_col > 0 and map[current_row][current_col - 1] != 'X':\n            player_col -= 1\n        elif instruction == 'right' and current_col < len(map[0]) - 1 and map[current_row][current_col + 1] != 'X':\n            player_col += 1\n        \n        # Add the new player position to the path\n        path.append((player_row, player_col))\n        \n        # Check if the player has reached the end\n        if map[player_row][player_col] == 'E':\n            break\n    \n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    # Create a dictionary to store the order of the alien alphabet\n    alien_alphabet = {}\n    for i, char in enumerate(alien_dictionary):\n        alien_alphabet[char] = i\n\n    # Iterate over the list of words\n    for i in range(len(word_list) - 1):\n        # If the current word is longer than the next word, the list is sorted correctly\n        if len(word_list[i]) > len(word_list[i + 1]):\n            continue\n        # If the current word is shorter than the next word, the list is not sorted correctly\n        elif len(word_list[i]) < len(word_list[i + 1]):\n            return \"INCORRECT\"\n        # If the current word and the next word are of the same length, compare them character by character\n        else:\n            for j in range(len(word_list[i])):\n                # If the current character in the current word is smaller than the current character in the next word, the list is sorted correctly\n                if alien_alphabet[word_list[i][j]] < alien_alphabet[word_list[i + 1][j]]:\n                    break\n                # If the current character in the current word is larger than the current character in the next word, the list is not sorted correctly\n                elif alien_alphabet[word_list[i][j]] > alien_alphabet[word_list[i + 1][j]]:\n                    return \"INCORRECT\"\n            # If all characters in the current word and the next word are compared and no difference is found, the list is sorted correctly\n            else:\n                continue\n\n    # If the function has not returned \"INCORRECT\" after iterating over the list of words, the list is sorted correctly\n    return \"CORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted correctly, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if"}
{"task_id": "EvoEval/82", "completion": "\n    zodiac_signs = {\n        \"Aries\": \"Fire\",\n        \"Taurus\": \"Earth\",\n        \"Gemini\": \"Air\",\n        \"Cancer\": \"Water\",\n        \"Leo\": \"Fire\",\n        \"Virgo\": \"Earth\",\n        \"Libra\": \"Air\",\n        \"Scorpio\": \"Water\",\n        \"Sagittarius\": \"Fire\",\n        \"Capricorn\": \"Earth\",\n        \"Aquarius\": \"Air\",\n        \"Pisces\": \"Water\"\n    }\n\n    elements = {\"Fire\": 0, \"Water\": 0, \"Air\": 0, \"Earth\": 0}\n\n    for birthday in birthdays:\n        month, day = birthday.split(\"-\")\n        month = int(month)\n        day = int(day)\n        if (month == 3 and 21 <= day <= 31) or (month == 4 and 1 <= day <= 19):\n            elements[\"Fire\"] += 1\n        elif (month == 4 and 20 <= day <= 30) or (month == 5 and 1 <= day <= 20):\n            elements[\"Earth\"] += 1\n        elif (month == 5 and 21 <= day <= 31) or (month == 6 and 1 <= day <= 20):\n            elements[\"Air\"] += 1\n        elif (month == 6 and 21 <= day <= 30) or (month == 7 and 1 <= day <= 22):\n            elements[\"Water\"] += 1\n        elif (month == 7 and 23 <= day <= 31) or (month == 8 and 1 <= day <= 22):\n            elements[\"Fire\"] += 1\n        elif (month == 8 and 23 <= day <= 31) or (month == 9 and 1 <= day <= 22):\n            elements[\"Earth\"] += 1\n        elif (month == 9 and 23 <= day <= 30) or (month == 10 and 1 <= day <= 22):\n            elements[\"Air\"] += 1\n        elif (month == 10 and 23 <= day <= 31) or (month == 11 and 1 <= day <= 21):\n            elements[\"Water\"] += 1\n        elif (month == 11 and 22 <= day <= 30) or (month == 12 and 1 <= day <= "}
{"task_id": "EvoEval/83", "completion": "\n    # Convert the string to a list of characters for easier manipulation\n    s = list(s)\n    \n    # Define the vowels\n    vowels = 'aeiouAEIOU'\n    \n    # Initialize two pointers, one at the start and one at the end of the string\n    left = 0\n    right = len(s) - 1\n    \n    # Loop until the two pointers meet\n    while left < right:\n        # If the character at the left pointer is not a vowel, move the pointer to the right\n        if s[left] not in vowels:\n            left += 1\n        # If the character at the right pointer is not a vowel, move the pointer to the left\n        elif s[right] not in vowels:\n            right -= 1\n        # If both characters are vowels, swap them and move both pointers\n        else:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n    \n    # Join the list of characters back into a string and return it\n    return ''.join(s)  # Removed the unnecessary 'return' keyword\n"}
{"task_id": "EvoEval/84", "completion": "\n    def dfs(node, path):\n        if not node:\n            return []\n        if not node:\n            return [path]\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return []\n        if not node:\n            return"}
{"task_id": "EvoEval/85", "completion": "\n    \n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a 2D list to store the minimum number of moves to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Initialize the minimum number of moves to reach the top-left cell as 0\n    dp[0][0] = 0\n    \n    # Fill in the minimum number of moves to reach each cell in the first row\n    for col in range(1, cols):\n        if grid[0][col] == 0:\n            dp[0][col] = dp[0][col-1] + 1\n    \n    # Fill in the minimum number of moves to reach each cell in the first column\n    for row in range(1, rows):\n        if grid[row][0] == 0:\n            dp[row][0] = dp[row-1][0] + 1\n    \n    # Fill in the minimum number of moves to reach each cell in the rest of the grid\n    for row in range(1, rows):\n        for col in range(1, cols):\n            if grid[row][col] == 0:\n                dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + 1\n    \n    # If the princess is at a cell that has a monster, return -1\n    if grid[coord[0]][coord[1]] == 1:\n        return -1\n    \n    # Return the minimum number of moves to reach the princess\n    return dp[coord[0]][coord[1]] if dp[coord[0]][coord[1]] != float('inf') else -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    # First, we sort the movies based on their ratings in descending order and release year in ascending order\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n    \n    # Then, we extract the movie names from the sorted list of tuples\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n    \n    # Finally, we return the sorted list of movie names\n    return sorted_movie_names\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr:\n        return ''\n\n    result = ''\n    top, bottom, left, right = 0, len(arr) - 1, 0, len(arr[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result += arr[top][i]\n        top += 1\n\n        # Traverse from top to bottom\n        for i in range(top, bottom + 1):\n            result += arr[i][right]\n        right -= 1\n\n        # Traverse from right to left\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result += arr[bottom][i]\n            bottom -= 1\n\n        # Traverse from bottom to top\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result += arr[i][left]\n            left += 1\n\n    return result  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string."}
{"task_id": "EvoEval/88", "completion": "\n    result = {}\n    for planet, features in dict_of_planets.items():\n        if features[0] is not None and features[1] is not None:\n            population = features[0]\n            size = features[1]\n            if population > 0 and size > 0:\n                population_density = round(population / size, 2)\n                result[planet] = population_density\n    return result\n"}
{"task_id": "EvoEval/89", "completion": "\n    aliens = [alien for alien in aliens if alien % 2 != 0 or alien == ray]\n    aliens = [alien for alien in aliens if alien != ray - 1 and alien != ray + 1]\n    return aliens  # This is a placeholder for the actual implementation\n"}
{"task_id": "EvoEval/90", "completion": "\n    # Convert the input strings to lists of integers\n    s1 = [int(digit) for digit in s1]\n    s2 = [int(digit) for digit in s2]\n\n    # Initialize a set to store unique sums\n    unique_sums = set()\n\n    # Generate all possible combinations of digits\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            # Calculate the sum of the current combination\n            combination_sum = s1[i] + s2[j]\n            # Add the sum to the set\n            unique_sums.add(combination_sum)\n\n    # Return the sum of all unique sums\n    return sum(unique_sums)  # Changed from return sum(unique_sums) to return sum(unique_sums) to fix the bug\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceships_data:\n        if status == 'On Ground':\n            if action == 'Launch':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif status == 'In Space':\n            if action == 'Move':\n                pass\n            elif action == 'Land':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Calculate the number of letters in the alphabet\n    num_letters = 26\n    \n    # Calculate the number of layers that will be painted with the same letter\n    layers_per_letter = num_letters // n\n    \n    # Calculate the number of layers that will be painted with the last letter\n    last_layers = num_letters % n\n    \n    # Initialize the letter counter\n    letter = 0\n    \n    # Loop over each layer\n    for i in range(1, n + 1):\n        # Calculate the width of the current layer\n        width = 2 * i - 1\n        \n        # Calculate the number of layers that will be painted with the current letter\n        layers = layers_per_letter + (1 if i <= last_layers else 0)\n        \n        # Loop over each layer that will be painted with the current letter\n        for _ in range(layers):\n            # Calculate the number of spaces before the first character\n            spaces_before = (width - 1) // 2\n            \n            # Calculate the number of spaces after the last character\n            spaces_after = width - 1 - spaces_before\n            \n            # Loop over each character in the current layer\n            for j in range(width):\n                # Calculate the column number\n                col = j - spaces_before\n                \n                # If the column is within the layer, add the character to the result\n                if 0 <= col < width:\n                    # Add the character to the result\n                    result += chr(ord('A') + letter)\n                    \n                    # Increment the letter counter\n                    letter = (letter + 1) % num_letters\n                    \n            # Add a newline character to the result\n            result += '\\n'\n    \n    # Return the result\n    return result.strip()  # Remove the trailing newline character\n\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i, char in enumerate(message):\n        n = n_values[i % len(n_values)]\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(word.split(), key=len)) if ' ' in spell else spell for spell in strings]  # <--- your code here\n"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n\n    diagonal1 = 0\n    diagonal2 = 0\n    for i in range(len(m)):\n        diagonal1 += m[i][i]\n        diagonal2 += m[i][len(m)-i-1]\n\n    return abs(diagonal1 - diagonal2)  # return the absolute difference between the two diagonals\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        # Check if the value at the current index is a multiple of the index\n        if lst[i] % (i + 1) == 0:\n            # Convert the value to a string to calculate the product of its digits\n            value_str = str(abs(lst[i]))\n            # Calculate the product of the digits\n            product = 1\n            for digit in value_str:\n                product *= int(digit)\n            # Check if the product of the digits equals the index\n            if product == i + 1:\n                # If both conditions are met, add the index to the list of magic indices\n                magic_indices.append(i)\n    # Return the list of magic indices, sorted in ascending order\n    return sorted(magic_indices)  # Changed to sorted(magic_indices) to sort the list of indices\n\n"}
{"task_id": "EvoEval/97", "completion": "\n    # Check if the alien name is valid\n    if not isinstance(alien, str) or len(alien) == 0:\n        return []\n    \n    # Check if the humans dictionary is valid\n    if not isinstance(humans, dict):\n        return []\n    \n    # Define the order of the continents\n    continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n    \n    # Initialize an empty list to store the humans that will encounter the alien\n    humans_encountered = []\n    \n    # Iterate over the continents in the order they are invaded\n    for continent in continents:\n        # Check if the alien is in the current continent\n        if continent == \"Asia\":\n            # If the alien is in Asia, add all humans in Asia to the list\n            humans_encountered.extend([human for human, location in humans.items() if location == continent])\n        else:\n            # If the alien is not in Asia, add all humans in the current continent to the list\n            humans_encountered.extend([human for human, location in humans.items() if location == continent])\n    \n    # Return the list of humans that will encounter the alien, sorted by the order of their encounter\n    return sorted(humans_encountered)  # Use sorted() instead of sorted()[:] to avoid creating a new list\n"}
{"task_id": "EvoEval/98", "completion": "\n    \n    # Initialize the sequence with the first two numbers\n    sequence = [a, b]\n    \n    # Generate the rest of the sequence\n    for i in range(2, n):\n        # Calculate the next number in the sequence\n        next_number = sequence[i-1] + sequence[i-2] + (i+1)\n        \n        # Add the next number to the sequence\n        sequence.append(next_number)\n    \n    # Check if the generated sequence has any prime numbers\n    def is_prime(num):\n        if num < 2:\n            return False\n        for j in range(2, int(num**0.5) + 1):\n            if num % j == 0:\n                return False\n        return True\n    \n    # Replace prime numbers with 'prime'\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n    \n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))  # Initialize the list of players\n    position = 0  # Initialize the position\n\n    for round in rounds:\n        for _ in range(round):\n            position = (position + music) % n  # Advance the position\n            players.pop(position - 1)  # Eliminate the player at the current position\n\n    return players  # Return the players left after all rounds\n\n"}
