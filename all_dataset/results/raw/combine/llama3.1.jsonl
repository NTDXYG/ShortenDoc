{"task_id": "EvoEval/0", "completion": "\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i+1] == s[i+2]:\n                return False\n        return True\n\n    if not is_happy(a) and not is_happy(b):\n        return None\n    if is_happy(a) and not is_happy(b):\n        return a\n    if not is_happy(a) and is_happy(b):\n        return b\n    if is_happy(a) and is_happy(b):\n        a = a.replace(',', '.')\n        b = b.replace(',', '.')\n        a = float(a)\n        b = float(b)\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n"}
{"task_id": "EvoEval/1", "completion": "\n    # Split the input string into number and string parts\n    number, string = value.split('.')\n\n    # Convert the number part to a float\n    number = float(number)\n\n    # Round the number away from zero\n    rounded_number = round(number + 0.5 if number % 1 >= 0.5 else number - 0.5)\n\n    # Flip the case of the string part\n    flipped_string = string.swapcase()\n\n    # Return the rounded number and the flipped string with a space in between\n    return f'{int(rounded_number)} {flipped_string}'  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  # Removed the unnecessary conversion to str()  #"}
{"task_id": "EvoEval/2", "completion": "\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append((2 ** n) % p)\n    return result\n"}
{"task_id": "EvoEval/3", "completion": "\n    # First, we need to extract the numbers from the strings and sort them\n    numbers = sorted([int(s.replace('(', '').replace(')', '')) for s in lst])\n    \n    # Then, we need to check if it is possible to concatenate the strings in this order so that the resulting string will be good\n    # We can do this by checking if the number of open parentheses is greater than or equal to the number of close parentheses\n    # at each position in the sorted list\n    for i, num in enumerate(numbers):\n        # We need to get the string from the original list that corresponds to the current number\n        s = lst[numbers.index(num)]\n        \n        # We need to count the number of open and close parentheses in the string\n        open_parentheses = s.count('(')\n        close_parentheses = s.count(')')\n        \n        # If the number of open parentheses is less than the number of close parentheses, we return 'No'\n        if open_parentheses < close_parentheses:\n            return 'No'\n    \n    # If we have checked all the strings and haven't returned 'No', we return 'Yes'\n    return 'Yes'  # This line will never be reached, but it's required by the linter\n"}
{"task_id": "EvoEval/4", "completion": "\nCheck if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def largest_prime_divisor(n: int) -> int:\n        \"\"\"Find the largest prime divisor of a number.\"\"\"\n        for i in range(n - 1, 1, -1):\n            if n % i == 0 and is_prime(i):\n                return i\n        return n\n\n    def sum_of_digits(n: int) -> int:\n        \"\"\"Calculate the sum of digits of a number.\"\"\"\n        return sum(int(digit) for digit in str(n))\n\n    max_sum = 0\n    for num in lst:\n        prime_divisor = largest_prime_divisor(num)\n        max_sum = max(max_sum, sum_of_digits(prime_divisor))\n    return max_sum\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    # Check if any two numbers in the array are closer to each other than the given threshold\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # Sort the array according to the given rules\n                if round(numbers[0] + numbers[-1]) % 2 == 0:\n                    numbers.sort(reverse=True)\n                else:\n                    numbers.sort()\n                return numbers\n    # If no two numbers are closer than the threshold, return the array as it is\n    return numbers\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Initialize an empty list to store the number of stones in each level\n    stones = []\n    # Initialize a variable to keep track of the current number of stones\n    current_stones = n\n    # Loop through each level\n    for _ in range(n):\n        # Add the current number of stones to the list\n        stones.append(current_stones)\n        # If the current number of stones is odd, add 1 to make it even\n        if current_stones % 2 != 0:\n            current_stones += 1\n        # If the current number of stones is even, add 2 to make it odd\n        else:\n            current_stones += 2\n    # Sort the list of stones in ascending order\n    stones.sort()\n    # If the number of levels is odd, return the middle number\n    if n % 2 != 0:\n        return stones[n // 2]\n    # If the number of levels is even, return the average of the two middle numbers\n    else:\n        return (stones[n // 2 - 1] + stones[n // 2]) / 2\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize an empty list to store the results\n    result = []\n    # Loop through the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if the index is a multiple of 3\n        if i % 3 == 0:\n            # If it is, square the number and append it to the result list\n            result.append(i ** 2)\n        # Check if the index is a multiple of 4 but not 3\n        elif i % 4 == 0 and i % 3 != 0:\n            # If it is, cube the number and append it to the result list\n            result.append(i ** 3)\n        else:\n            # If it's neither, just append the number as it is\n            result.append(i)\n    # Return the sum of all entries in the result list\n    return sum(result)  # Changed from sum(result) to sum(result) to make it more explicit that we're summing the list\n\n"}
{"task_id": "EvoEval/8", "completion": "\n    # Initialize a counter for the specific bracket\n    bracket_count = 0\n    \n    # Initialize a flag to track if the brackets are correctly paired\n    is_correct = True\n    \n    # Iterate over the string\n    for char in string:\n        # If the character is the specific bracket, increment the counter\n        if char == bracket:\n            bracket_count += 1\n        # If the character is the opposite bracket, decrement the counter\n        elif char == '>' if bracket == '<' else '<':\n            bracket_count -= 1\n            # If the counter is negative, it means there's an extra closing bracket, so set the flag to False\n            if bracket_count < 0:\n                is_correct = False\n                break\n    \n    # Return the flag and the counter\n    return is_correct, bracket_count\n"}
{"task_id": "EvoEval/9", "completion": "\n    planets = {\n        \"mercury\": 1,\n        \"venus\": 2,\n        \"earth\": 3,\n        \"mars\": 4,\n        \"jupiter\": 5,\n        \"saturn\": 6,\n        \"uranus\": 7,\n        \"neptune\": 8\n    }\n    \n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    \n    planet1_index = planets[planet1]\n    planet2_index = planets[planet2]\n    \n    if planet1_index >= planet2_index:\n        return {}\n    \n    result = {}\n    for planet, index in planets.items():\n        if planet1_index < index < planet2_index:\n            result[planet] = roman_numerals[index]\n    \n    return result\n\nroman_numerals = {\n    1: 'i',\n    2: 'ii',\n    3: 'iii',\n    4: 'iv',\n    5: 'v',\n    6: 'vi',\n    7: 'vii',\n    8: 'viii'\n}  # This dictionary is used to convert integer to roman numeral string\n"}
{"task_id": "EvoEval/10", "completion": "\n    # Define the grading table\n    grading_table = {\n        (4.0,): 'A+',\n        (3.7, 4.0): 'A',\n        (3.3, 3.7): 'A-',\n        (3.0, 3.3): 'B+',\n        (2.7, 3.0): 'B',\n        (2.3, 2.7): 'B-',\n        (2.0, 2.3): 'C+',\n        (1.7, 2.0): 'C',\n        (1.3, 1.7): 'C-',\n        (1.0, 1.3): 'D+',\n        (0.7, 1.0): 'D',\n        (0.0, 0.7): 'D-',\n        (0.0,): 'E'\n    }\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over each student in the input list\n    for name, gpa in name_grade_list:\n        # Convert the name to proper case\n        proper_name = name.title()\n\n        # Find the corresponding letter grade\n        for gpa_range, letter_grade in grading_table.items():\n            if gpa in gpa_range:\n                result.append((proper_name, letter_grade))\n                break\n\n    return result\n"}
{"task_id": "EvoEval/11", "completion": "\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    vowels = \"aeiouy\"\n    planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet_vowel_counts = [0, 2, 2, 1, 3, 2, 3, 3]\n    planet_index = {planet: i for i, planet in enumerate(planet_names)}\n    if planet1 not in planet_index or planet2 not in planet_index:\n        return 0\n    planet1_index = planet_index[planet1]\n    planet2_index = planet_index[planet2]\n    if planet1_index > planet2_index:\n        planet1_index, planet2_index = planet2_index, planet1_index\n    return sum(planet_vowel_counts[i] for i in range(planet1_index + 1, planet2_index))  # <--- changed this line\n"}
{"task_id": "EvoEval/12", "completion": "\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n    for student in student_info:\n        name = student['name']\n        gpa = student['GPA']\n        consonant_count = sum(1 for char in name.lower() if char in consonants)\n        if consonant_count == n:\n            if gpa > 3.7:\n                grade = 'A'\n            elif gpa > 3.3:\n                grade = 'A-'\n            elif gpa > 3.0:\n                grade = 'B+'\n            elif gpa > 2.7:\n                grade = 'B'\n            elif gpa > 2.3:\n                grade = 'B-'\n            elif gpa > 2.0:\n                grade = 'C+'\n            elif gpa > 1.7:\n                grade = 'C'\n            elif gpa > 1.3:\n                grade = 'C-'\n            elif gpa > 1.0:\n                grade = 'D+'\n            elif gpa > 0.7:\n                grade = 'D'\n            elif gpa > 0.0:\n                grade = 'D-'\n            else:\n                grade = 'E'\n        else:\n            if gpa > 3.7:\n                grade = 'A+'\n            elif gpa > 3.3:\n                grade = 'A'\n            elif gpa > 3.0:\n                grade = 'A-'\n            elif gpa > 2.7:\n                grade = 'B+'\n            elif gpa > 2.3:\n                grade = 'B'\n            elif gpa > 2.0:\n                grade = 'B-'\n            elif gpa > 1.7:\n                grade = 'C+'\n            elif gpa > 1.3:\n                grade = 'C'\n            elif gpa > 1.0:\n                grade = 'C-'\n            elif gpa > 0.7:\n                grade = 'D+'\n            elif gpa > 0.0:\n                grade = 'D'\n            else:\n                grade = 'E'\n        result.append({'name': student['name'], 'grade': grade})\n    return result\n"}
{"task_id": "EvoEval/13", "completion": "\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    # Filter the array to keep only the numbers which have a sum of digits > 0\n    filtered_arr = [num for num in arr if sum_of_digits(num) > 0]\n\n    # Determine whether it is possible to perform an exchange of elements between the filtered array and lst1\n    # to make lst1 a list of only even numbers\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    elif any(num % 2 == 0 for num in filtered_arr):\n        return \"YES\"\n    else:\n        return \"NO\"  # If neither lst1 nor filtered_arr contains even numbers, return \"NO\"  # noqa: E501\n\n"}
{"task_id": "EvoEval/14", "completion": "\n    \n    # Check if n is greater than m, return -1 if true\n    if n > m:\n        return -1\n    \n    # Initialize an empty list to store prime numbers\n    primes = []\n    \n    # Iterate over the range from n to m (inclusive)\n    for possiblePrime in range(n, m + 1):\n        \n        # Assume number is prime until shown it is not. \n        isPrime = True\n        \n        # Iterate from 2 to the square root of the number\n        for num in range(2, int(possiblePrime ** 0.5) + 1):\n            \n            # If the number is divisible by any of these values, it's not prime\n            if possiblePrime % num == 0:\n                isPrime = False\n                break\n        \n        # If the number is prime, add it to the list\n        if isPrime:\n            primes.append(possiblePrime)\n    \n    # If there are no prime numbers in the range, return -1\n    if len(primes) == 0:\n        return -1\n    \n    # Calculate the average of the prime numbers\n    avg = sum(primes) / len(primes)\n    \n    # Round the average to the nearest integer\n    avg = round(avg)\n    \n    # Convert the average to binary and remove the '0b' prefix\n    binary_avg = bin(avg)[2:]\n    \n    # Return the binary representation of the average\n    return binary_avg\n"}
{"task_id": "EvoEval/15", "completion": "\n    balance = 0\n    seen = set()\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return False\n        if balance == 0:\n            seen.add(balance)\n        if len(seen) >= 3:\n            return True\n    return False\n"}
{"task_id": "EvoEval/16", "completion": "\n    # Find the index of the last vowel in the word\n    last_vowel_index = -1\n    for i in range(len(word) - 1, -1, -1):\n        if word[i] in 'aeiou':\n            last_vowel_index = i\n            break\n\n    # If no vowel is found, return an empty list\n    if last_vowel_index == -1:\n        return []\n\n    # Find the index of the first consonant to the right of the last vowel\n    for i in range(last_vowel_index + 1, len(word)):\n        if word[i] not in 'aeiou':\n            first_consonant_index = i\n            break\n\n    # If no consonant is found, return an empty list\n    if first_consonant_index == len(word):\n        return []\n\n    # Get the corresponding music notes up to the last vowel\n    music_notes = music_string[:last_vowel_index + 1]\n\n    # Initialize the result list\n    result = []\n\n    # Process each music note\n    for note in music_notes.split():\n        # Handle whole note\n        if note == 'o':\n            result.append(4)\n        # Handle half note\n        elif note == 'o|':\n            result.append(2)\n        # Handle quarter note\n        elif note == '.|':\n            result.append(1)\n\n    return result\n"}
{"task_id": "EvoEval/17", "completion": "\n    \n    # Base cases for the FibFib sequence\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize the first three elements of the FibFib sequence\n    a, b, c = 0, 0, 1\n    \n    # Compute the n-th element of the FibFib sequence\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    # Initialize a dictionary to store the frequency of each integer in the list\n    freq_dict = {}\n    \n    # Count the frequency of each integer in the list\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    # Find the greatest integer in the list that is greater than zero, and has a frequency equal to or greater than the value of the calculated n-th FibFib element\n    max_num = -1\n    for num in sorted(freq_dict.keys(), reverse=True):\n        if num > 0 and freq_dict[num] >= c:\n            max_num = num\n            break\n    \n    return max_num\n"}
{"task_id": "EvoEval/18", "completion": "\n    if len(nums) < 3:\n        return 0\n\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        for j in range(i + 1, len(nums) - 1):\n            for k in range(j + 1, len(nums)):\n                triplet_sum = nums[i] + nums[j] + nums[k]\n                min_sum = min(min_sum, triplet_sum)\n\n    return min_sum if min_sum != float('inf') else 0\n\n"}
{"task_id": "EvoEval/19", "completion": "\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    below_zero = False\n\n    for operation in operations:\n        balance += operation\n        if operation < 0:\n            largest_withdrawal = max(largest_withdrawal, operation) if largest_withdrawal is not None else operation\n        elif operation > 0:\n            smallest_deposit = min(smallest_deposit, operation) if smallest_deposit is not None else operation\n        if balance < 0:\n            below_zero = True\n\n    return largest_withdrawal, smallest_deposit, below_zero\n"}
{"task_id": "EvoEval/20", "completion": "\n    result = []\n    for i in range(len(s)):\n        name = s[i]\n        gpa = grades[i]\n        # Reverse the case of the name\n        reversed_name = name.swapcase()\n        # Determine the letter grade based on the GPA\n        if gpa >= 4.0:\n            letter_grade = 'A+'\n        elif gpa > 3.7:\n            letter_grade = 'A'\n        elif gpa > 3.3:\n            letter_grade = 'A-'\n        elif gpa > 3.0:\n            letter_grade = 'B+'\n        elif gpa > 2.7:\n            letter_grade = 'B'\n        elif gpa > 2.3:\n            letter_grade = 'B-'\n        elif gpa > 2.0:\n            letter_grade = 'C+'\n        elif gpa > 1.7:\n            letter_grade = 'C'\n        elif gpa > 1.3:\n            letter_grade = 'C-'\n        elif gpa > 1.0:\n            letter_grade = 'D+'\n        elif gpa > 0.7:\n            letter_grade = 'D'\n        elif gpa > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        # Append the reversed name and letter grade to the result list\n        result.append((reversed_name, letter_grade))\n    return result\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Convert the number to the new base\n    new_base = convert_base(x, base)\n    \n    # Initialize an empty list to store the prefixes\n    prefixes = []\n    \n    # Iterate over the new base representation of x\n    for i in range(1, len(new_base)):\n        # Append the prefix to the list\n        prefixes.append(new_base[:i])\n    \n    # Return the list of prefixes\n    return prefixes\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Define the order of the planets in our solar system\r\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\r\n    \r\n    # Check if the input planets are valid\r\n    if planet1 not in planets or planet2 not in planets:\r\n        return \"\"\r\n    \r\n    # Find the indices of the input planets in the list of planets\r\n    index1 = planets.index(planet1)\r\n    index2 = planets.index(planet2)\r\n    \r\n    # Find the planets whose orbits are located between the orbit of planet1 and the orbit of planet2\r\n    between_planets = [planet for i, planet in enumerate(planets) if index1 < i < index2]\r\n    \r\n    # Sort the planets by their proximity to the Sun\r\n    between_planets.sort()\r\n    \r\n    # Convert the number of planets to binary format\r\n    binary = bin(len(between_planets))[2:]\r\n    \r\n    # Add the extra characters 'bd' at the beginning and at the end of the string\r\n    binary = \"bd\" + binary + \"bd\"\r\n    \r\n    return binary\r\n\r"}
{"task_id": "EvoEval/23", "completion": "\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            num_stones = i + 2\n        else:\n            num_stones = i + 1\n        factorial = 1\n        for j in range(1, num_stones + 1):\n            factorial *= j\n        result.append(factorial)\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    \n    # Define a dictionary to map the string representation of numbers to their integer values\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    \n    # Split the input string into a list of numbers\n    numbers = numbers.split()\n    \n    # Check if the string is happy\n    if len(numbers) > 1:\n        for i in range(len(numbers) - 2):\n            if numbers[i] == numbers[i + 1] == numbers[i + 2]:\n                return 'Not a happy string'\n    \n    # Sort the list of numbers\n    numbers.sort(key=lambda x: num_dict[x])\n    \n    # Join the sorted list into a string and return it\n    return ' '.join(numbers)\n"}
{"task_id": "EvoEval/25", "completion": "\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_ = 0\n    product = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    sum_ += a[i]\n                    product *= a[i]\n    return sum_, product\n"}
{"task_id": "EvoEval/26", "completion": "\n    # Split each string into a list of numerals, sort them, and store them in a list\n    sorted_numerals = [sorted(value.split(), key=lambda x: int(x)) for value in values]\n    \n    # Initialize variables to store the smallest even numeral and its index\n    smallest_even = None\n    smallest_even_index = None\n    \n    # Iterate over the sorted numerals\n    for i, numerals in enumerate(sorted_numerals):\n        # Iterate over the numerals in the current string\n        for j, numeral in enumerate(numerals):\n            # Convert the numeral to an integer\n            num = int(numeral)\n            # Check if the numeral is even\n            if num % 2 == 0:\n                # If this is the first even numeral, store it and its index\n                if smallest_even is None:\n                    smallest_even = numeral\n                    smallest_even_index = (i, j)\n                # If this even numeral is smaller than the current smallest even numeral, update the smallest even numeral and its index\n                elif num < int(smallest_even):\n                    smallest_even = numeral\n                    smallest_even_index = (i, j)\n    \n    # If no even numerals were found, return an empty tuple\n    if smallest_even is None:\n        return ()\n    # Otherwise, return the smallest even numeral and its index\n    else:\n        return (smallest_even, smallest_even_index[1])  # Return the index of the numeral in its original string, not in the sorted list\n"}
{"task_id": "EvoEval/27", "completion": "\n    \n    # First, we define a helper function to check if a number is prime\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Then, we create a set of prime numbers from lst2\n    prime_set = set(num for num in lst2 if is_prime(num))\n\n    # We initialize a variable to store the result\n    result = x\n\n    # We iterate over the elements of lst1\n    for num in lst1:\n        # If the number is not prime, we try to find a prime number in lst2 that can replace it\n        if not is_prime(num):\n            # If we find a prime number in lst2 that can replace the current number, we add the difference to the result\n            if prime_set:\n                result += num - min(prime_set)\n                prime_set.remove(min(prime_set))\n        # If the number is prime, we add it to the result\n        else:\n            result += num\n\n    # Finally, we return the result\n    return result\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Define the grading system\n    grading_system = {\n        'A+': 4.0, 'A': 3.7, 'A-': 3.3, 'B+': 3.0, 'B': 2.7, 'B-': 2.3, 'C+': 2.0, 'C': 1.7, 'C-': 1.3, 'D+': 1.0, 'D': 0.7, 'D-': 0.0, 'E': 0.0\n    }\n    # Initialize an empty list to store the grades\n    grades_list = []\n    # Iterate over the GPAs\n    for g in grades:\n        # Check if the name and course title have the same characters\n        if set(s0) == set(s1):\n            # Find the grade corresponding to the GPA\n            for grade, gpa in grading_system.items():\n                if gpa > g:\n                    # Add the grade to the list\n                    grades_list.append(grade)\n                    # Break the loop to avoid duplicates\n                    break\n    # Return the list of grades\n    return grades_list\n"}
{"task_id": "EvoEval/29", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        for i in range(2, n):\n            if n % i == 0 and is_prime(i):\n                return i\n        return n  # if no factors are found, return the number itself\n"}
{"task_id": "EvoEval/30", "completion": "\n    \n    # Split the music string into individual notes\n    notes = music_string.split()\n    \n    # Initialize the list to store the results\n    result = []\n    \n    # Define the beats for each note\n    beats = {'o': 4, 'o|': 2, '.|': 1}\n    \n    # Split the fraction into numerator and denominator\n    numerator, denominator = map(int, x.split('/'))\n    \n    # Iterate over each note\n    for note in notes:\n        # Get the beats for the current note\n        note_beats = beats[note]\n        \n        # Check if the product of the numerator and the beats is divisible by the denominator\n        if (numerator * note_beats) % denominator == 0:\n            # If it is, add True to the result list\n            result.append(True)\n        else:\n            # If it's not, add False to the result list\n            result.append(False)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "EvoEval/31", "completion": "\n    \n    # First, we need to find all the prime factors of 'n' and their counts\n    factors = prime_factors(n)\n    \n    # Then, we calculate the factorial of each prime factor as many times as it appears in the factorization\n    special_factorial = 1\n    for factor, count in factors.items():\n        special_factorial *= factorial(factor) ** count\n    \n    return special_factorial\n\n"}
{"task_id": "EvoEval/32", "completion": "\n \n        Calculate the deepest level of nesting of parentheses in a string.\n        \n        Args:\n        s (str): A string of nested parentheses.\n        \n        Returns:\n        int: The deepest level of nesting of parentheses.\n        \"\"\"\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif c == ')':\n                depth -= 1\n        return max_depth\n\n    # Calculate the deepest level of nesting of parentheses for each group\n    depths = [calculate_depth(s) for s in input]\n    \n    # Concatenate the list of nesting depths as a single number\n    num = int(''.join(map(str, depths)))\n    \n    # Apply a circular shift on that number\n    shift = shift % len(str(num))\n    num = int(str(num)[-shift:] + str(num)[:-shift])\n    \n    # Return the result as a list of individual digits after the circular shift\n    return [int(d) for d in str(num)]\n\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Define the mapping of Roman numerals to integers\n    roman_map = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    \n    # Check if the length of the string is at least 3\n    if len(s) < 3:\n        return False\n    \n    # Initialize the total value to 0\n    total = 0\n    \n    # Iterate over the string from left to right\n    for i in range(len(s)):\n        # If the current numeral is less than the next one, subtract its value\n        if i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i + 1]]:\n            total -= roman_map[s[i]]\n        # Otherwise, add its value\n        else:\n            total += roman_map[s[i]]\n    \n    # Check if the total value is less than or equal to 1000\n    if total > 1000:\n        return False\n    \n    # Check if every 3 consecutive letters are distinct\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n    \n    # If all conditions are met, return the total value\n    return total\n"}
{"task_id": "EvoEval/34", "completion": "\n    if not paren_string:\n        return []\n\n    deepest_levels = []\n    groups = paren_string.split()\n    for group in groups:\n        stack = []\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                stack.append(char)\n                max_depth = max(max_depth, len(stack))\n            elif char == ')':\n                if stack:\n                    stack.pop()\n        if stack:\n            deepest_levels.append('None')\n        else:\n            deepest_levels.append(str(max_depth))\n\n    return [hashlib.md5(deepest_level.encode()).hexdigest() for deepest_level in deepest_levels]  # type: ignore\n"}
{"task_id": "EvoEval/35", "completion": "\n    if not dict:\n        return False\n    for key in dict:\n        if not (isinstance(key, str) and (key.islower() or key.isupper())):\n            return False\n        if len(key) < 3:\n            return False\n        for i in range(len(key) - 2):\n            if len(set(key[i:i+3])) < 3:\n                return False\n    return True\n"}
{"task_id": "EvoEval/36", "completion": "\n    # Check if the array is empty\n    if not arr:\n        return True\n\n    # Sort the array in non-decreasing order\n    sorted_arr = sorted(arr)\n\n    # Initialize the count of right shift operations\n    shift_count = 0\n\n    # Iterate over the array from right to left\n    for i in range(len(arr) - 1, -1, -1):\n        # If the current element is not equal to the corresponding element in the sorted array\n        if arr[i] != sorted_arr[i]:\n            # Increment the shift count\n            shift_count += 1\n            # If the shift count exceeds the limit, return False\n            if shift_count > (2 ** n) % p:\n                return False\n\n    # If the array is sorted, return True\n    return True\n"}
{"task_id": "EvoEval/37", "completion": "\n    min_sum = float('inf')\n    even_count = 0\n    odd_count = 0\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            if current_sum % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n            if current_sum < min_sum:\n                min_sum = current_sum\n    return (even_count, odd_count)\n"}
{"task_id": "EvoEval/38", "completion": "\n    # Calculate the number of even and odd integer palindromes within the range (1, n)\n    even_palindromes = sum(1 for i in range(1, n+1) if str(i) == str(i)[::-1] and i % 2 == 0)\n    odd_palindromes = sum(1 for i in range(1, n+1) if str(i) == str(i)[::-1] and i % 2 != 0)\n    \n    # Create a set of the list elements for efficient lookups\n    num_set = set(l)\n    \n    # Check if there are two distinct elements in the list that sum to the number of even palindromes\n    even_sum = any(i in num_set and n - i in num_set for i in num_set)\n    \n    # Check if there are two distinct elements in the list that sum to the number of odd palindromes\n    odd_sum = any(i in num_set and n - i in num_set for i in num_set)\n    \n    # Return a tuple of the two booleans\n    return (even_sum, odd_sum)  # Return a tuple of two booleans\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Initialize a 2D array to store the minimum changes for subarrays\r\n    dp = [[0] * len(arr) for _ in range(len(arr))]\r\n\r\n    # Fill the diagonal of the 2D array with 0, since a single element is always a palindrome\r\n    for i in range(len(arr)):\r\n        dp[i][i] = 0\r\n\r\n    # Fill the 2D array in a bottom-up manner\r\n    for length in range(2, len(arr) + 1):\r\n        for i in range(len(arr) - length + 1):\r\n            j = i + length - 1\r\n            # If the first and last elements are the same, no change is needed\r\n            if arr[i] == arr[j]:\r\n                dp[i][j] = dp[i + 1][j - 1]\r\n            # Otherwise, try all possible changes and take the minimum\r\n            else:\r\n                dp[i][j] = 1 + dp[i + 1][j - 1]\r\n                for k in range(i + 1, j):\r\n                    dp[i][j] = min(dp[i][j], 1 + dp[i + 1][k - 1] + dp[k + 1][j - 1])\r\n\r\n    # Add the value of x and y to the minimum changes\r\n    return dp[0][len(arr) - 1] + x + y\r\n\r"}
{"task_id": "EvoEval/40", "completion": "\nCheck if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def largest_prime_factor(n):\n        \"\"\"Find the largest prime factor of a number.\"\"\"\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n        return n\n\n    def is_odd_ends(n):\n        \"\"\"Check if a number has both first and last digits odd.\"\"\"\n        return n > 10 and n % 10 % 2 != 0 and n // 10 % 10 % 2 != 0\n\n    prime_factors = []\n    for num in nums:\n        if is_odd_ends(num):\n            prime_factors.append(largest_prime_factor(num))\n    if prime_factors:\n        return max([f for f in prime_factors if is_prime(f)])\n    else:\n        return None\n"}
{"task_id": "EvoEval/41", "completion": "\n    # Reverse the string if shift is greater than the length of the string\n    if shift > len(s):\n        s = s[::-1]\n        shift = shift % len(s)\n    \n    # Perform the circular shift on the ASCII values of the characters in the string\n    shifted_s = ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a')) if c.isalpha() else c for c in s)\n    \n    # Count the uppercase vowels in even indices after the shift\n    count = 0\n    for i in range(len(shifted_s)):\n        if i % 2 == 0 and shifted_s[i].upper() in 'AEIOU':\n            count += 1\n    \n    return count\n"}
{"task_id": "EvoEval/42", "completion": "\n    # Initialize a stack to keep track of opening brackets\n    stack = []\n    # Initialize a list to store the fractions\n    fractions = []\n    # Initialize a string to build the current fraction\n    current_fraction = \"\"\n    # Initialize a flag to indicate if we are currently processing a fraction\n    processing_fraction = False\n    # Iterate over each character in the string\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char == \"<\":\n            stack.append(char)\n        # If the character is a closing bracket, pop the corresponding opening bracket from the stack\n        elif char == \">\":\n            if not stack:\n                return False\n            stack.pop()\n        # If the character is a comma and we are currently processing a fraction, add the current fraction to the list and reset the current fraction\n        elif char == \",\" and processing_fraction:\n            fractions.append(current_fraction)\n            current_fraction = \"\"\n        # If the character is a comma and we are not currently processing a fraction, return False\n        elif char == \",\" and not processing_fraction:\n            return False\n        # If the character is a digit, add it to the current fraction\n        elif char.isdigit():\n            current_fraction += char\n            processing_fraction = True\n        # If the character is a slash, add it to the current fraction\n        elif char == \"/\":\n            current_fraction += char\n            processing_fraction = True\n        # If the character is not a digit, slash, or comma, return False\n        else:\n            return False\n    # If we are currently processing a fraction, add it to the list\n    if processing_fraction:\n        fractions.append(current_fraction)\n    # If there are any opening brackets left in the stack, return False\n    if stack:\n        return False\n    # Initialize a variable to store the product of the fractions\n    product = 1\n    # Iterate over each fraction in the list\n    for fraction in fractions:\n        # Split the fraction into numerator and denominator\n        numerator, denominator = map(int, fraction.split(\"/\"))\n        # Multiply the product by the fraction\n        product *= numerator / denominator\n    # Return True if the product is a whole number, False otherwise\n    return product.is_integer() and product > 0\n"}
{"task_id": "EvoEval/43", "completion": "\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 0]\n    elif n == 3:\n        return [0, 0, 2]\n    elif n == 4:\n        return [0, 0, 2, 2]\n    else:\n        fib4_sequence = [0, 0, 2, 2]\n        while len(fib4_sequence) < n:\n            fib4_sequence.append(fib4_sequence[-1] + fib4_sequence[-2] + fib4_sequence[-3] + fib4_sequence[-4])\n        if (fib4_sequence[0] + fib4_sequence[-1]) % 2 == 0:\n            return sorted(fib4_sequence)\n        else:\n            return sorted(fib4_sequence, reverse=True)  # sort in descending order if the sum is even\n"}
{"task_id": "EvoEval/44", "completion": "\n    # Define a dictionary to map integers to their roman numeral equivalents\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n\n    # Convert the number to its roman numeral equivalent\n    roman_numeral = ''\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            roman_numeral += roman_numerals[value]\n            number -= value\n\n    # Initialize an empty list to store the prefixes\n    prefixes = []\n\n    # Iterate over the length of the roman numeral\n    for i in range(1, len(roman_numeral) + 1):\n        # Append the prefix of the current length to the list\n        prefixes.append(roman_numeral[:i])\n\n    # Return the list of prefixes\n    return prefixes\n"}
{"task_id": "EvoEval/45", "completion": "\n Helper function to check if a number is prime. \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    prime_product = 1\n    for num in numbers:\n        if is_prime(num):\n            prime_sum += num\n            prime_product *= num\n    return prime_sum, prime_product\n"}
{"task_id": "EvoEval/46", "completion": "\n    \n    # First, we filter out the negative numbers from the list\n    positive_numbers = [num for num in l if num > 0]\n    \n    # Then, we filter out the odd numbers from the list of positive numbers\n    even_numbers = [num for num in positive_numbers if num % 2 == 0]\n    \n    # If there are no even numbers, we return -1\n    if not even_numbers:\n        return -1\n    \n    # Otherwise, we return the maximum even number\n    return max(even_numbers)  # Changed this line to use the max function\n\n"}
{"task_id": "EvoEval/47", "completion": "\n    n = sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in 'AEIOU')\n    return [f\"In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {sum(1 for c in s if int(c) % 2 != 0)}.\" for _ in lst]  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits in 's' instead of each string in 'lst'  # count odd digits"}
{"task_id": "EvoEval/48", "completion": "\n\n        Helper function to check if a number is prime.\n        \n        Args:\n        n (int): The number to check.\n        \n        Returns:\n        bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def get_length(s: str) -> int:\n        \"\"\"\n        Helper function to get the length of a string.\n        \n        Args:\n        s (str): The string to get the length of.\n        \n        Returns:\n        int: The length of the string.\n        \"\"\"\n        return len(s)\n\n    # Filter the list of strings based on the given prefix and prime length\n    return [s for s in strings if s.startswith(prefix) and is_prime(get_length(s))]  # noqa: E501\n"}
{"task_id": "EvoEval/49", "completion": "\n    # Calculate 2^n modulo p\n    result = pow(2, n, p)\n    \n    # Initialize a counter for numbers with sum of digits > result\n    count = 0\n    \n    # Iterate over each number in the array\n    for num in arr:\n        # Convert the number to a string to easily calculate the sum of its digits\n        str_num = str(abs(num))\n        \n        # Initialize a variable to store the sum of the digits\n        digit_sum = 0\n        \n        # Iterate over each character in the string\n        for char in str_num:\n            # Add the integer value of the character to the sum\n            digit_sum += int(char)\n        \n        # If the sum of the digits is greater than the result, increment the counter\n        if digit_sum > result:\n            count += 1\n    \n    # Return the count\n    return count\n"}
{"task_id": "EvoEval/50", "completion": "\n    vowels = 'AEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i].isupper():\n            if i % 2 == 0 and (i - 1 > 0 and word[i - 1].isalpha() and word[i - 1].lower() not in vowels or i + 1 < len(word) and word[i + 1].isalpha() and word[i + 1].lower() not in vowels):\n                return word[i]\n    return \"\"  # no vowel found\n\n"}
{"task_id": "EvoEval/51", "completion": "\n    \n    # Check if 'a' is a string\n    if isinstance(a, str):\n        # Check if 'a' contains alphabets\n        if any(char.isalpha() for char in a):\n            # Convert 'a' to lower case if it is upper case, and vice versa\n            a = a.swapcase()\n        else:\n            # Reverse 'a' if it contains no alphabets\n            a = a[::-1]\n    \n    # Check if 'b' is a string\n    if isinstance(b, str):\n        # Check if 'b' contains alphabets\n        if any(char.isalpha() for char in b):\n            # Convert 'b' to lower case if it is upper case, and vice versa\n            b = b.swapcase()\n        else:\n            # Reverse 'b' if it contains no alphabets\n            b = b[::-1]\n    \n    # Check if 'a' and 'b' represent real numbers\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        # Compare 'a' and 'b'\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    else:\n        # Return 'b' if at least one of 'a' and 'b' does not represent a real number\n        return b\n"}
{"task_id": "EvoEval/52", "completion": "\n    if not arr:\n        return [], None\n\n    # Find the smallest even value in the array\n    smallest_even = min([x for x in arr if x % 2 == 0])\n\n    # Find the index of the smallest even value\n    smallest_even_index = [i for i, x in enumerate(arr) if x == smallest_even][0]\n\n    # Pluck the node with the smallest even value\n    plucked_node = [smallest_even, smallest_even_index]\n    arr.pop(smallest_even_index)\n\n    # Compute the sum of the remaining nodes\n    remaining_sum = sum(abs(x) for x in arr)\n\n    # Compute the product of the signs of the remaining nodes\n    sign_product = 1\n    for x in arr:\n        if x < 0:\n            sign_product *= -1\n\n    # Return the result\n    return plucked_node, remaining_sum if sign_product != 0 else None\n\n"}
{"task_id": "EvoEval/53", "completion": "\n    prime_grades = ['D', 'B', '7', '5', '3']\n    count = 0\n    for grade in grades:\n        if grade >= 4.0:\n            grade = 'F'\n        elif grade >= 3.7:\n            grade = 'E'\n        elif grade >= 3.3:\n            grade = 'D'\n        elif grade >= 3.0:\n            grade = 'C'\n        elif grade >= 2.7:\n            grade = 'B'\n        elif grade >= 2.3:\n            grade = 'A'\n        elif grade >= 2.0:\n            grade = '9'\n        elif grade >= 1.7:\n            grade = '8'\n        elif grade >= 1.3:\n            grade = '7'\n        elif grade >= 1.0:\n            grade = '6'\n        elif grade >= 0.7:\n            grade = '5'\n        elif grade >= 0.0:\n            grade = '4'\n        if grade in prime_grades:\n            count += 1\n    return count\n"}
{"task_id": "EvoEval/54", "completion": "\n\n        Helper function to check if a number is prime\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum\n"}
{"task_id": "EvoEval/55", "completion": "\n    if number <= 0:\r\n        return None\r\n\r\n    roman_numerals = {\r\n        1000: 'm',\r\n        900: 'cm',\r\n        500: 'd',\r\n        400: 'cd',\r\n        100: 'c',\r\n        90: 'xc',\r\n        50: 'l',\r\n        40: 'xl',\r\n        10: 'x',\r\n        9: 'ix',\r\n        5: 'v',\r\n        4: 'iv',\r\n        1: 'i'\r\n    }\r\n\r\n    roman_numeral = ''\r\n    for value, numeral in roman_numerals.items():\r\n        while number >= value:\r\n            roman_numeral += numeral\r\n            number -= value\r\n\r\n    return hashlib.md5(roman_numeral.encode()).hexdigest()  # Convert to lowercase before hashing\r\n"}
{"task_id": "EvoEval/56", "completion": "\n    # Initialize an empty list to store odd prime factors\n    odd_prime_factors = []\n    \n    # Iterate from 3 to sqrt(n) with a step of 2 (since we're only interested in odd numbers)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # If i is a factor, check if it's prime\n            if is_prime(i):\n                # If i is prime, add it to the list of odd prime factors\n                odd_prime_factors.append(i)\n            # Divide n by i to remove the factor\n            n //= i\n    \n    # If n is a prime number greater than 2, it's an odd prime factor\n    if n > 2 and is_prime(n):\n        odd_prime_factors.append(n)\n    \n    # If the list of odd prime factors is empty, return 0\n    if not odd_prime_factors:\n        return 0\n    # Otherwise, return the product of the odd prime factors\n    else:\n        return math.prod(odd_prime_factors)\n\n"}
{"task_id": "EvoEval/57", "completion": "\n    # Convert the array to a string to easily check if it's a palindrome\r\n    str_arr = ''.join(map(str, arr))\r\n    \r\n    # Initialize a counter for the number of elements that need to be changed\r\n    changes = 0\r\n    \r\n    # Iterate over the array\r\n    for i in range(len(arr)):\r\n        # If the current element is not a palindrome, increment the changes counter\r\n        if str_arr[i] != str_arr[-i - 1]:\r\n            changes += 1\r\n        # If the current element is not an odd digit, increment the changes counter\r\n        if arr[i] % 2 == 0:\r\n            changes += 1\r\n    \r\n    # Return the minimum number of elements that need to be changed\r\n    return changes\r\n\r"}
{"task_id": "EvoEval/58", "completion": "\n    # Create a dictionary to store the frequency of each number in the list\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Initialize max_freq to -1\n    max_freq = -1\n\n    # Iterate over the dictionary to find the greatest integer with frequency greater than or equal to the integer itself\n    for num, freq in freq_dict.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n\n    # Check if either a or b is equal to the sum of max_freq and the other integer\n    if a == max_freq + b or b == max_freq + a:\n        return (max_freq, True)\n    else:\n        return (max_freq, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of (False, False)  # Changed this line to return (max_freq, False) instead of ("}
{"task_id": "EvoEval/59", "completion": "\n    result = []\n    for string in lst:\n        odd_count = 0\n        for digit in string:\n            # Convert the digit to the given base and count the odd digits\n            base_digit = int(digit, 10) % base\n            if base_digit % 2 != 0:\n                odd_count += 1\n        # Replace the odd count with the string representation of the odd count\n        result.append(string.replace(str(odd_count), \"the number of odd elements \" + str(odd_count) + \"n the str\" + str(odd_count) + \"ng \" + str(odd_count) + \" of the \" + str(odd_count) + \"nput.\"))\n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triple = []\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if not triple or a[i] < triple[0]:\n                        triple = [a[i], a[j], a[k]]\n    if triple:\n        arr.append(triple[0])\n        even = [x for x in arr if x % 2 == 0]\n        if even:\n            return [min(even), arr.index(min(even))]\n    return []  # Return an empty list if no even value is found or the array is empty.  # noqa: E501\n\n"}
{"task_id": "EvoEval/61", "completion": "\n    \n    # Define the correct planet names\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if planet1 and planet2 are correct planet names\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    \n    # Initialize the longest chain\n    longest_chain = None\n    \n    # Iterate over each chain\n    for chain in chains:\n        # Check if the chain starts with planet1 and ends with planet2\n        if chain[0] == planet1 and chain[-1] == planet2:\n            # If the chain is longer than the current longest chain, update the longest chain\n            if longest_chain is None or len(chain) > len(longest_chain):\n                longest_chain = chain\n    \n    # Return the longest chain\n    return longest_chain\n"}
{"task_id": "EvoEval/62", "completion": "\n    # Split the text into words and replace multiple spaces with a single space\n    words = text.replace(\"  \", \" \").replace(\"   \", \"-\").replace(\"  \", \"-\").split()\n    \n    # If the list of words is empty, return an empty string\n    if not words:\n        return \"\"\n    \n    # Sort the list of words in a strange order\n    sorted_words = []\n    while words:\n        # Find the minimum word\n        min_word = min(words, key=lambda x: x.lower())\n        sorted_words.append(min_word)\n        # Remove the minimum word from the list\n        words.remove(min_word)\n        # If there are still words in the list, find the maximum word\n        if words:\n            max_word = max(words, key=lambda x: x.lower())\n            sorted_words.append(max_word)\n            # Remove the maximum word from the list\n            words.remove(max_word)\n    \n    # Join the sorted words with an underscore\n    return \"_\".join(sorted_words)  # Changed here\n"}
{"task_id": "EvoEval/63", "completion": "\n    \n    # Define the planets and their corresponding numbers\n    planets = {\n        'zero': 'Mercury', 'one': 'Venus', 'two': 'Earth', 'three': 'Mars', \n        'four': 'Jupiter', 'five': 'Saturn', 'six': 'Uranus', 'seven': 'Neptune'\n    }\n    \n    # Check if planet1 and planet2 are valid planet names\n    if planet1 not in planets.values() or planet2 not in planets.values():\n        return 'Invalid'\n    \n    # Get the numbers corresponding to planet1 and planet2\n    num1 = list(planets.keys())[list(planets.values()).index(planet1)]\n    num2 = list(planets.keys())[list(planets.values()).index(planet2)]\n    \n    # Check if the order string contains numbers outside the range 'zero' to 'seven' or contains duplicates\n    order_nums = [int(num) for num in order.split()]\n    if len(order_nums) != len(set(order_nums)) or not all(0 <= num <= 7 for num in order_nums):\n        return 'Invalid'\n    \n    # Get the numbers in the order string\n    order_nums = sorted([int(num) for num in order.split()])\n    \n    # Get the planets in the order string\n    order_planets = [planets[str(num)] for num in order_nums]\n    \n    # Get the planets between planet1 and planet2\n    between_planets = [planet for planet in order_planets if num1 < list(planets.keys()).index(planets[planet]) < num2]\n    \n    # Sort the planets by proximity to the sun according to the given order\n    sorted_planets = [planets[str(num)] for num in order_nums if num1 < num < num2]\n    \n    # Return the sorted planets as a string\n    return ' '.join(sorted_planets) if sorted_planets else 'Invalid'  # Return 'Invalid' if there are no planets between planet1 and planet2\n\n"}
{"task_id": "EvoEval/64", "completion": "\n    # Calculate 2^n modulo p\n    mod_result = pow(2, n, p)\n    \n    # Initialize an empty list to store prime numbers\n    prime_numbers = []\n    \n    # Iterate over the range from 2 to the calculated modulo result\n    for i in range(2, mod_result):\n        # Assume the number is prime\n        is_prime = True\n        \n        # Check if the number is divisible by any number up to its square root\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                # If the number is divisible, it's not prime\n                is_prime = False\n                break\n        \n        # If the number is prime, add it to the list\n        if is_prime:\n            prime_numbers.append(i)\n    \n    # Return the list of prime numbers\n    return prime_numbers\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Calculate 2^n modulo p\n    mod_n = pow(2, n, p)\n    \n    # Initialize the largest divisor\n    largest_divisor = 1\n    \n    # Iterate from 2 to p-1\n    for i in range(2, p):\n        # Check if i is a divisor of mod_n\n        if mod_n % i == 0:\n            # Update the largest divisor\n            largest_divisor = i\n    \n    # Return the largest divisor\n    return largest_divisor\n"}
{"task_id": "EvoEval/66", "completion": "\n    \n    # Find the largest even integer in the range [x, y] inclusive\n    max_even = max(i for i in range(x, y+1) if i % 2 == 0)\n    \n    # If no even integer is found, return -1\n    if max_even == 0:\n        return -1\n    \n    # Create an integer array a of length n\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    \n    # Initialize the maximum sum\n    max_sum = -1\n    \n    # Iterate over all possible triples (a[i], a[j], a[k]) where i < j < k\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # Check if the sum of the triple is a multiple of 3\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    # Update the maximum sum\n                    max_sum = max(max_sum, a[i] + a[j] + a[k])\n    \n    # If the maximum sum is still -1, return -1\n    if max_sum == -1:\n        return -1\n    \n    # Add the largest even integer to the maximum sum\n    max_sum += max_even\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "EvoEval/67", "completion": "\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Iterate over the list of numbers\n    for i in range(len(numbers)):\n        # Iterate over the remaining numbers in the list\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            diff = abs(numbers[i] - numbers[j])\n            # If the difference is less than the threshold and greater than the current maximum difference, update the maximum difference\n            if diff < threshold and diff > max_diff:\n                max_diff = diff\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "EvoEval/68", "completion": "\n    min_product = float('inf')\n    for i in range(len(nums)):\n        product = 1\n        for j in range(i, len(nums)):\n            num = nums[j]\n            odd_digits_product = 1\n            while num > 0:\n                digit = num % 10\n                if digit % 2 != 0:\n                    odd_digits_product *= digit\n                num //= 10\n            product *= odd_digits_product\n            min_product = min(min_product, product)\n    return min_product\n"}
{"task_id": "EvoEval/69", "completion": "\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if len(set(s[i:i+3])) != 3:\n                return False\n        return True\n\n    happy_strings = [s for s in lst if is_happy(s) and len(s) % 2 == 0]\n    return sorted(happy_strings, key=lambda x: (len(x), x))  # sorted by length and then alphabetically\n\n"}
{"task_id": "EvoEval/70", "completion": "\n    \n    # Initialize the minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()  # Initialize with an empty tuple\n\n    # Iterate over all pairs of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate the special factorials of the current pair of numbers\n            special_factorial_i = math.factorial(numbers[i])\n            special_factorial_j = math.factorial(numbers[j])\n\n            # Calculate the difference between the special factorials of the current pair of numbers\n            diff = abs(special_factorial_i - special_factorial_j)\n\n            # If the difference is smaller than the current minimum difference, update the minimum difference and the closest pair\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    # Return the pair of numbers with the minimum difference\n    return closest_pair\n\n"}
{"task_id": "EvoEval/71", "completion": "\n    # Calculate the Brazilian factorial\n    brazilian_factorial = math.factorial(n)\n    for i in range(n-1, 0, -1):\n        brazilian_factorial *= math.factorial(i)\n    \n    # Check if the load is balanced\n    if w != w[::-1]:\n        return False\n    \n    # Check if the sum of the weights is less than or equal to the maximum possible weight\n    if sum(w) <= brazilian_factorial:\n        return True\n    else:\n        return False\n"}
{"task_id": "EvoEval/72", "completion": "\n \n        Calculate the special factorial of a number n.\n        \"\"\"\n        return factorial(n)\n\n    # Generate all special factorials for numbers in the list\n    factorials = [special_factorial(n) for n in numbers]\n\n    # Check all pairs of factorials\n    for i in range(len(factorials)):\n        for j in range(i + 1, len(factorials)):\n            # If the difference between two factorials is less than the threshold, return True\n            if abs(factorials[i] - factorials[j]) < threshold:\n                return True\n\n    # If no pair of factorials is closer than the threshold, return False\n    return False\n"}
{"task_id": "EvoEval/73", "completion": "\n Helper function to simplify a fraction. \"\"\"\n        return Fraction(frac)\n\n    def multiply_and_simplify(frac1: Fraction, frac2: Fraction) -> bool:\n        \"\"\" Helper function to multiply two fractions and check if the result is a whole number. \"\"\"\n        return frac1 * frac2 == 1\n\n    # Convert the input list of fractions to a list of Fraction objects\n    fractions = [simplify_fraction(frac) for frac in fractions]\n    \n    # Convert the input string n to a Fraction object\n    n = simplify_fraction(n)\n    \n    # Use list comprehension to filter the list of fractions\n    return [multiply_and_simplify(frac, n) for frac in fractions]  # Return a list of boolean values\n"}
{"task_id": "EvoEval/74", "completion": "\n    # First, we check if all elements in lst1 are even\r\n    if all(num % 2 == 0 for num in lst1):\r\n        return \"YES\"\r\n    # If not, we check if all elements in lst2 are even\r\n    elif all(num % 2 == 0 for num in lst2):\r\n        return \"YES\"\r\n    # If neither of the above conditions are met, we check if we can make all elements in lst1 even by exchanging elements with lst2\r\n    else:\r\n        # We create a list of all elements in lst1 and lst2\r\n        combined_list = lst1 + lst2\r\n        # We count the number of odd elements in lst1\r\n        odd_count = sum(1 for num in lst1 if num % 2 != 0)\r\n        # We count the number of odd elements in lst2\r\n        odd_count_lst2 = sum(1 for num in lst2 if num % 2 != 0)\r\n        # If the number of odd elements in lst1 is greater than or equal to the number of odd elements in lst2, we return \"NO\"\r\n        if odd_count >= odd_count_lst2:\r\n            return \"NO\"\r\n        # Otherwise, we return \"YES\"\r\n        else:\r\n            return \"YES\"\r\n\r\n    # Now, we check if one of the integers x, y, z is equal to the sum of the other two\r\n    if x == y + z or y == x + z or z == x + y:\r\n        return \"SUM\"\r\n    else:\r\n        return \"NO_SUM\"\r\n\r\n\r"}
{"task_id": "EvoEval/75", "completion": "\n    # Check if the dictionary is empty or if keys are not all strings or if keys are not all in upper case or all in lower case\r\n    if not input_dict or not all(isinstance(key, str) for key in input_dict) or not all(key.isupper() or key.islower() for key in input_dict):\r\n        return {}\r\n    \r\n    # Initialize an empty dictionary to store the results\r\n    result = {}\r\n    \r\n    # Iterate over each key-value pair in the input dictionary\r\n    for key, value in input_dict.items():\r\n        # Try to convert the value string to a float\r\n        try:\r\n            num = float(value)\r\n            # Round the number to the nearest integer, rounding away from zero if necessary\r\n            result[key] = round(num + 0.5 if num % 1 != 0 else num)\r\n        # If the value string cannot be converted to a float, skip this key-value pair\r\n        except ValueError:\r\n            pass\r\n    \r\n    # Return the resulting dictionary\r\n    return result\r\n\r"}
{"task_id": "EvoEval/76", "completion": "\n    def is_prime(n):\r\n        if n < 2:\r\n            return False\r\n        for i in range(2, int(n**0.5) + 1):\r\n            if n % i == 0:\r\n                return False\r\n        return True\r\n\r\n    def sum_of_digits(n):\r\n        return sum(int(digit) for digit in str(n))\r\n\r\n    lst_copy = lst.copy()\r\n    for i in range(len(lst_copy)):\r\n        if is_prime(lst_copy[i]):\r\n            lst_copy[i] = sum_of_digits(lst_copy[i])\r\n\r\n    if (lst_copy[0] + lst_copy[-1]) % 2 == 0:\r\n        return sorted(lst_copy, reverse=True)\r\n    else:\r\n        return sorted(lst_copy)\r\n"}
{"task_id": "EvoEval/77", "completion": "\n    total_sum = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 != 0:\n            num_str = str(abs(arr[i]))\n            if sum(int(digit) for digit in num_str) > 0:\n                total_sum += arr[i]\n    return total_sum\n"}
{"task_id": "EvoEval/78", "completion": "\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Initialize a counter for uppercase vowels in even indices\n    count = 0\n    \n    # Iterate over the string\n    for i in range(len(s)):\n        # If the character is a letter, reverse its case\n        if s[i].isalpha():\n            result += s[i].swapcase()\n        # If the character is not a letter, keep it as it is\n        else:\n            result += s[i]\n        \n        # If the character is an uppercase vowel and the index is even\n        if s[i].isupper() and s[i] in 'AEIOU' and i % 2 == 0:\n            # Increment the counter\n            count += 1\n    \n    # If the string contains no letters, reverse the string\n    if not any(c.isalpha() for c in s):\n        result = result[::-1]\n    \n    # Return the result and the count\n    return result, count\n"}
{"task_id": "EvoEval/79", "completion": "\n    \n    # Check if the string is happy\n    if len(s) < 3:\n        return s[::-1]\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] == s[i+2]:\n            return s[::-1]\n    \n    # If the string is happy, reverse the case for each letter in the string\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    \n    return result\n"}
{"task_id": "EvoEval/80", "completion": "\n    # First, we encode the string s by cycling groups of three characters\r\n    encoded_s = cyclic_encode(s)\r\n    \r\n    # Then, we delete all the characters in the encoded string that are equal to any character in c\r\n    encoded_s = ''.join([char for char in encoded_s if char not in c])\r\n    \r\n    # If the result string is a palindrome, it keeps the result string\r\n    if encoded_s == encoded_s[::-1]:\r\n        return encoded_s, True\r\n    # If it is not a palindrome, it decodes the result string back to the original form\r\n    else:\r\n        return cyclic_decode(encoded_s), False\r\n\r"}
{"task_id": "EvoEval/81", "completion": "\n    # Initialize the first three elements of the FibFib sequence\n    fibfib_sequence = [0, 0, 1]\n    \n    # Generate the rest of the sequence up to n elements\n    for i in range(3, n):\n        # Calculate the next element as the sum of the previous three elements\n        next_element = fibfib_sequence[i-1] + fibfib_sequence[i-2] + fibfib_sequence[i-3]\n        # Append the new element to the sequence\n        fibfib_sequence.append(next_element)\n    \n    # Calculate the mean of the sequence\n    mean = sum(fibfib_sequence) / len(fibfib_sequence)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in fibfib_sequence]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad\n"}
{"task_id": "EvoEval/82", "completion": "\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n        if c % 2 == 0:\n            c = int(''.join(str(d) for d in str(c) if d % 2 != 0)) or 0\n    return c\n"}
{"task_id": "EvoEval/83", "completion": "\n    \n    # Replace all spaces in the text with underscores\n    text = text.replace(\" \", \"_\")\n    \n    # If a string has more than 2 consecutive spaces, \n    # then replace all consecutive spaces with a single underscore\n    text = re.sub(r'_+', '_', text)\n    \n    # Check if the length of the new string is a prime number\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return is_prime(len(text))  # Return True if the length is a prime number, False otherwise\n\n"}
{"task_id": "EvoEval/84", "completion": "\n    \n    # Initialize an empty dictionary to store the prefixes and their histograms\n    result = {}\n    \n    # Iterate over the string to generate all prefixes\n    for i in range(len(string) + 1):\n        prefix = string[:i]\n        \n        # Initialize an empty dictionary to store the histogram of the current prefix\n        histogram = {}\n        \n        # Count the occurrence of each letter in the prefix\n        for letter in set(prefix):\n            count = prefix.count(letter)\n            if count > 0:\n                histogram[letter] = count\n        \n        # If the prefix is not empty, add it to the result dictionary\n        if prefix:\n            result[prefix] = histogram\n    \n    return result\n"}
{"task_id": "EvoEval/85", "completion": "\n    if not lst:\n        return None\n\n    # Count the number of ones in the binary representation of each number\n    ones_count = [bin(num).count('1') for num in lst]\n\n    # Combine the original list with the count of ones\n    combined = list(zip(lst, ones_count))\n\n    # Sort the combined list based on the count of ones and the original value\n    combined.sort(key=lambda x: (x[1], x[0]))\n\n    # Get the 2nd smallest element\n    second_smallest = combined[1][0]\n\n    return second_smallest\n\n"}
{"task_id": "EvoEval/86", "completion": "\n    # Find the common operands between all operand_lists\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands &= set(operand_list)\n    \n    # If there are no common operands, return None\n    if not common_operands:\n        return None\n\n    # Sort the common operands in ascending order\n    common_operands = sorted(list(common_operands))\n\n    # Evaluate the algebraic expression built using the common operands with the given operators\n    result = common_operands[0]\n    for i in range(len(operators)):\n        if operators[i] == '+':\n            result += common_operands[i + 1]\n        elif operators[i] == '-':\n            result -= common_operands[i + 1]\n        elif operators[i] == '*':\n            result *= common_operands[i + 1]\n        elif operators[i] == '//':\n            result //= common_operands[i + 1]\n        elif operators[i] == '**':\n            result **= common_operands[i + 1]\n\n    return result\n"}
{"task_id": "EvoEval/87", "completion": "\n    # Initialize a stack to keep track of the opening parentheses\n    stack = []\n    # Initialize a list to store the indices of the vowels\n    vowels = []\n    \n    # Iterate over the string\n    for i, char in enumerate(text):\n        # If the character is an opening parenthesis, push it to the stack\n        if char == '(':\n            stack.append(i)\n        # If the character is a closing parenthesis, check if the stack is empty\n        elif char == ')':\n            # If the stack is empty, it means there's no corresponding opening parenthesis, so remove the vowels from the string\n            if not stack:\n                vowels.append(i)\n            # If the stack is not empty, pop the opening parenthesis from the stack\n            else:\n                stack.pop()\n    \n    # If the stack is not empty, it means there are unbalanced opening parentheses, so remove the vowels from the string\n    if stack:\n        vowels.extend(stack)\n    \n    # Remove the vowels from the string\n    vowels = sorted(vowels, reverse=True)\n    for vowel in vowels:\n        text = text[:vowel] + text[vowel+1:]\n    \n    return text\n"}
{"task_id": "EvoEval/88", "completion": "\n    # First, we need to split the string into words. We can use the split() function with a comma and a space as separators.\n    words = s.replace(\",\", \" \").split()\n    \n    # Then, we need to filter out the words with odd lengths. We can use a list comprehension for this.\n    # The if condition checks if the length of the word is even.\n    even_length_words = [word for word in words if len(word) % 2 == 0]\n    \n    # Finally, we need to sort the list of words. We can use the sorted() function with a custom sorting key.\n    # The key is a tuple where the first element is the length of the word and the second element is the word itself.\n    # This way, the list will be sorted by the length of the words in ascending order, and then alphabetically.\n    sorted_words = sorted(even_length_words, key=lambda word: (len(word), word))\n    \n    return sorted_words\n"}
{"task_id": "EvoEval/89", "completion": "\n    if not strings:\n        return None\n    return [s for s in strings if hash_substring in md5(s).hexdigest()]  # type: ignore\n"}
{"task_id": "EvoEval/90", "completion": "\n    \n    # Check if the input dictionary is empty\n    if not dict:\n        return {}\n    \n    # Check if all keys are strings\n    if not all(isinstance(key, str) for key in dict.keys()):\n        return {}\n    \n    # Check if all keys are in lower case or upper case\n    if not all(key.islower() or key.isupper() for key in dict.keys()):\n        return {}\n    \n    # Initialize an empty dictionary to store the count of vowels in each key\n    vowels_count = {}\n    \n    # Iterate over each key in the input dictionary\n    for key in dict.keys():\n        # Initialize a counter for vowels in the current key\n        count = 0\n        \n        # Check if the key is in lower case\n        if key.islower():\n            # Iterate over each character in the key\n            for char in key:\n                # Check if the character is a vowel\n                if char in 'aeiou':\n                    # Increment the vowel counter\n                    count += 1\n        # Check if the key is in upper case\n        elif key.isupper():\n            # Iterate over each character in the key\n            for char in key:\n                # Check if the character is a vowel\n                if char in 'AEIOU':\n                    # Increment the vowel counter\n                    count += 1\n        \n        # Store the count of vowels in the current key in the vowels_count dictionary\n        vowels_count[key] = count\n    \n    # Return the vowels_count dictionary\n    return vowels_count\n"}
{"task_id": "EvoEval/91", "completion": "\nThis function checks if a number n is prime.\"\"\"\n            if n < 2:\n                return False\n            for j in range(2, int(n**0.5) + 1):\n                if n % j == 0:\n                    return False\n            return True\n\n        # If the element is prime, we replace it with x. Otherwise, we replace it with y.\n        if is_prime(even[i]):\n            even[i] = x\n        else:\n            even[i] = y\n\n    # Finally, we combine the even and odd lists, and return the result\n    return [x if i % 2 == 0 else y for x, y in zip(even, odd)]\n\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Create the array 'a' of length n\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Find the common elements between the array 'a' and list 'l1'\n    common_elements = list(set(a) & set(l1))\n    \n    # Sort the common elements\n    common_elements.sort()\n    \n    # If there are no numbers that are multiples of 3 in the list of common elements, return 0\n    if not any(i % 3 == 0 for i in common_elements):\n        return common_elements, 0\n    \n    # Initialize a counter for the number of valid triples\n    count = 0\n    \n    # Iterate over the common elements\n    for i in range(len(common_elements)):\n        # Iterate over the common elements starting from the next element\n        for j in range(i + 1, len(common_elements)):\n            # Iterate over the common elements starting from the next element\n            for k in range(j + 1, len(common_elements)):\n                # Check if the sum of the current three elements is a multiple of 3\n                if (common_elements[i] + common_elements[j] + common_elements[k]) % 3 == 0:\n                    # Increment the counter\n                    count += 1\n    \n    # Return the common elements and the count of valid triples\n    return common_elements, count\n"}
{"task_id": "EvoEval/93", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not is_prime(len(string)):\n        return \"\"\n\n    vowels = 'aeiou'\n    for i in range(len(string) - 1, 1, -1):\n        if string[i] in vowels:\n            if string[i-1] not in vowels and string[i+1] not in vowels:\n                return string[i]\n    return \"\"  # if no vowel is found between two consonants, return an empty string\n\n"}
{"task_id": "EvoEval/94", "completion": "\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    count = sum(1 for num in arr if sum_of_digits(num) > 0)\n    sorted_arr = sorted(arr)\n    return sorted_arr if count % 2 == 0 else sorted_arr[::-1]  # return sorted_arr[::-1] for descending order\n\n"}
{"task_id": "EvoEval/95", "completion": "\n    \n    # First, filter the list to only include strings that contain the substring and have an even length\n    filtered_strings = [string for string in strings if substring in string and len(string) % 2 == 0]\n    \n    # Then, sort the filtered list first by the length of each string and then alphabetically\n    sorted_strings = sorted(filtered_strings, key=lambda string: (len(string), string))\n    \n    return sorted_strings\n"}
{"task_id": "EvoEval/96", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements between the two lists\n    common_elements = set1.intersection(set2)\n    \n    # Check if there are two distinct elements in the common elements that sum to zero\n    for element in common_elements:\n        if -element in common_elements and element != -element:\n            return True\n    \n    return False\n"}
{"task_id": "EvoEval/97", "completion": "\n    fib = [0, 0, 1]\n    for i in range(3, n+1):\n        fib.append(fib[i-1] + fib[i-2] + fib[i-3] + i*i - i + 1)\n    \n    count = 0\n    for i in range(len(fib)):\n        for j in range(i+1, len(fib)):\n            for k in range(j+1, len(fib)):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count\n"}
{"task_id": "EvoEval/98", "completion": "\n    # Check if the dictionary is empty\n    if not dict:\n        return False\n\n    # Check if all keys are in lower case or all keys are in upper case\n    if not all(key.islower() for key in dict.keys()) and not all(key.isupper() for key in dict.keys()):\n        return False\n\n    # Check if all values are strings of \"(\" and \")\" and have correct bracketing\n    for value in dict.values():\n        if not set(value).issubset({\"(\", \")\"}):\n            return False\n        stack = []\n        for bracket in value:\n            if bracket == \"(\":\n                stack.append(bracket)\n            elif bracket == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        if stack:\n            return False\n\n    return True\n"}
{"task_id": "EvoEval/99", "completion": "\n    # Convert the number to the desired base\n    converted_num = convert_base(x, base)\n    # Return the length of the string representation\n    return len(str(converted_num))\n"}
