{"task_id": "valid/0", "completion": "\n    categories = {\n        'sports': ['football', 'basketball', 'tennis', 'soccer', 'baseball'],\n        'politics': ['election', 'government', 'policy', 'vote', 'senate'],\n        'technology': ['computer', 'software', 'hardware', 'AI', 'internet'],\n        'health': ['doctor', 'medicine', 'healthcare', 'disease', 'treatment'],\n        'entertainment': ['movie', 'music', 'celebrity', 'show', 'theater']\n    }\n\n    text = text.lower()\n    for category, keywords in categories.items():\n        if any(keyword in text for keyword in keywords):\n            return category\n    return 'unknown'\n"}
{"task_id": "valid/1", "completion": "\n    return frozenset(s)\n"}
{"task_id": "valid/2", "completion": "\n    return num1 ^ num2\n"}
{"task_id": "valid/3", "completion": "\n    return sorted(instruments, reverse=True)\n"}
{"task_id": "valid/4", "completion": "\n    try:\n        return json.loads(json_string)\n    except json.JSONDecodeError:\n        raise ValueError(\"Invalid JSON string\")\n"}
{"task_id": "valid/5", "completion": "\n    if not isinstance(n, (int, float)) or n < 0:\n        return False\n    \n    if n % 5 != 0:\n        return False\n    \n    digit_sum = sum(int(digit) for digit in str(int(n)))\n    \n    return digit_sum % 3 == 0\n"}
{"task_id": "valid/6", "completion": "\n    if base <= 1 or n <= 0:\n        raise ValueError(\"Base must be greater than 1 and n must be positive.\")\n    \n    current = 1\n    for exponent in range(0, n):\n        current = (current * base) % n\n        if current == 1:\n            return exponent + 1  # Return the exponent in the range [1, n-1]\n    \n    return None  # If no discrete logarithm is found\n"}
{"task_id": "valid/7", "completion": "\n    try:\n        json_data = json.loads(json_str)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Invalid JSON string\") from e\n\n    pprint.pprint(json_data)\n"}
{"task_id": "valid/8", "completion": "\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    return False\n"}
{"task_id": "valid/9", "completion": "\n    for key, value in values.items():\n        placeholder = f\"{{{{ {key} }}}}\"\n        template = template.replace(placeholder, str(value))\n    return template\n"}
{"task_id": "valid/10", "completion": "\n    char_set = set()\n    for char in string:\n        if char in char_set:\n            return False\n        char_set.add(char)\n    return True\n"}
{"task_id": "valid/11", "completion": "\n    date_object = datetime.strptime(date_string, '%Y-%m-%d')\n    new_date = date_object + timedelta(days=days)\n    return new_date.strftime('%Y-%m-%d')\n"}
{"task_id": "valid/12", "completion": "\n    if len(text) > 10000:\n        raise ValueError(\"Text exceeds the maximum allowed length of 10,000 characters.\")\n    \n    # Strip leading and trailing whitespace\n    stripped_text = text.strip()\n    \n    # Replace multiple spaces between words with a single space\n    cleaned_text = ' '.join(stripped_text.split())\n    \n    return cleaned_text\n"}
{"task_id": "valid/13", "completion": "\n    # Convert to lowercase\n    text = text.lower()\n    \n    # Remove punctuation\n    text = text.translate(str.maketrans('', '', string.punctuation))\n    \n    # Remove extra whitespace\n    text = ' '.join(text.split())\n    \n    # Handle multilingual characters (if needed, you can add specific normalization for different languages)\n    \n    return text\n"}
{"task_id": "valid/14", "completion": "\n    pattern = r'\\b(' + re.escape(word1) + r'|' + re.escape(word2) + r')\\b'\n    return bool(re.search(pattern, text))\n"}
{"task_id": "valid/15", "completion": "\n    if not array or not array[0]:\n        return []\n\n    layers_sums = []\n    n, m = len(array), len(array[0])\n\n    for layer in range((min(n, m) + 1) // 2):\n        layer_sum = 0\n\n        # Top row\n        for j in range(layer, m - layer):\n            layer_sum += array[layer][j]\n\n        # Right column\n        for i in range(layer + 1, n - layer - 1):\n            layer_sum += array[i][m - layer - 1]\n\n        # Bottom row\n        if n - layer - 1 > layer:  # Check if there's a bottom row\n            for j in range(m - layer - 1, layer - 1, -1):\n                layer_sum += array[n - layer - 1][j]\n\n        # Left column\n        if layer < m - layer - 1:  # Check if there's a left column\n            for i in range(n - layer - 2, layer, -1):\n                layer_sum += array[i][layer]\n\n        layers_sums.append(layer_sum)\n\n    return layers_sums\n"}
{"task_id": "valid/16", "completion": "\n    settings = {}\n    lines = comment.splitlines()\n    \n    for line in lines:\n        line = line.strip()\n        if line.startswith(\"set\"):\n            parts = line.split()\n            for part in parts:\n                if '=' in part:\n                    key, value = part.split('=')\n                    key = key.replace('set', '').strip()\n                    settings[key] = int(value) if value.isdigit() else value.lower() == 'true'\n    \n    return settings\n"}
{"task_id": "valid/17", "completion": "\n    # Split the sentence into words using whitespace as the delimiter\n    words = sentence.split()\n    \n    # Create a list to hold the lexical items\n    lexical_items = []\n    \n    # Iterate through each word in the sentence\n    for word in words:\n        # Remove punctuation from the word and convert it to lowercase\n        clean_word = ''.join(char for char in word if char.isalnum()).lower()\n        if clean_word:  # Ensure the cleaned word is not empty\n            lexical_items.append(clean_word)\n    \n    return lexical_items\n"}
{"task_id": "valid/18", "completion": "\n    if num == 0:\n        return 1\n    elif num < 0:\n        num = -num  # Handle negative numbers\n    return 1 + find_digits_count(num // 10)\n"}
{"task_id": "valid/19", "completion": "\n    reversed_list1 = list1[::-1]\n    reversed_list2 = list2[::-1]\n    combined_list = reversed_list1 + reversed_list2\n    sorted_list = sorted(combined_list)\n    return sorted_list\n"}
{"task_id": "valid/20", "completion": "\n    return input_string.replace(old_word, new_word)\n"}
{"task_id": "valid/21", "completion": "\n    return z * z\n"}
{"task_id": "valid/22", "completion": "\n    return dictionary.get(\"name\", None)\n"}
{"task_id": "valid/23", "completion": "\n    if isinstance(struct, dict):\n        return {key: struct_to_dict(value) for key, value in struct.items()}\n    elif isinstance(struct, list):\n        return [struct_to_dict(item) for item in struct]\n    elif isinstance(struct, tuple):\n        return tuple(struct_to_dict(item) for item in struct)\n    else:\n        return struct\n"}
{"task_id": "valid/24", "completion": "\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    if num == \"1\":\n        return \"0\"\n    \n    candidates = set()\n    length = len(num)\n    prefix = int(num[:(length + 1) // 2])\n    \n    for p in [prefix - 1, prefix, prefix + 1]:\n        candidates.add(int(str(p) + str(p)[-2::-1]))  # Even length palindrome\n        candidates.add(int(str(p) + str(p)[-1::-1]))  # Odd length palindrome\n\n    candidates.add(10 ** length + 1)  # 100...001\n    candidates.add(10 ** (length - 1) - 1)  # 999...999\n\n    candidates.discard(int(num))  # Remove the original number if it's a palindrome\n\n    closest = None\n    min_diff = float('inf')\n\n    for candidate in candidates:\n        diff = abs(candidate - int(num))\n        if diff < min_diff or (diff == min_diff and candidate < closest):\n            min_diff = diff\n            closest = candidate\n\n    return str(closest)\n"}
{"task_id": "valid/25", "completion": "\n    if num < 0:\n        raise ValueError(\"Cannot calculate the square root of a negative number.\")\n    return num ** 0.5\n"}
{"task_id": "valid/26", "completion": "\n    rows = len(matrix)\n    cols = len(matrix[0]) if rows > 0 else 0\n    diagonal_sum = sum(matrix[i][i] for i in range(min(rows, cols)))\n    is_square = rows == cols\n    \n    return rows, cols, diagonal_sum, is_square\n"}
{"task_id": "valid/27", "completion": "\n    byte_string = string.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_string)\n    return base64_bytes.decode('utf-8')\n"}
{"task_id": "valid/28", "completion": "\n    return ''.join(char.lower() for char in s if char.isalpha())\n"}
{"task_id": "valid/29", "completion": "\n    if not lst:\n        return None\n    min_value = lst[0]\n    for num in lst:\n        if num < min_value:\n            min_value = num\n    return min_value\n"}
{"task_id": "valid/30", "completion": "\n    # If json_data is a string, parse it into a dictionary\n    if isinstance(json_data, str):\n        json_data = json.loads(json_data)\n\n    # Check if the key exists and if the value matches\n    if key in json_data and json_data[key] == value:\n        return False\n\n    return True\n"}
{"task_id": "valid/31", "completion": "\n    :param buttons: A list of tuples where each tuple contains the button label and the action to be performed when the button is clicked.\n    :param num_columns: An integer representing the number of columns in the button table.\n    :return: A string representation of the button table in HTML format.\n\n    Example:\n    buttons = [('Button 1', 'action1'), ('Button 2', 'action2')]\n    num_columns = 2\n    The function should return:\n    <table>\n        <tr>\n            <td><button onclick=\"action1()\">Button 1</button></td>\n            <td><button onclick=\"action2()\">Button 2</button></td>\n        </tr>\n    </table>\n    \"\"\"\n    html = '<table>\\n'\n    for i in range(0, len(buttons), num_columns):\n        html += '    <tr>\\n'\n        for j in range(num_columns):\n            if i + j < len(buttons):\n                label, action = buttons[i + j]\n                html += f'        <td><button onclick=\"{action}()\">{label}</button></td>\\n'\n        html += '    </tr>\\n'\n    html += '</table>'\n    return html\n"}
{"task_id": "valid/32", "completion": "\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    index = 0\n\n    for char in s:\n        if char == alphabet[index]:\n            index += 1\n            if index == len(alphabet):\n                return True\n\n    return False\n"}
{"task_id": "valid/33", "completion": "\n    return a if a > b else b\n"}
{"task_id": "valid/34", "completion": "\n    import re\n\n    # Find all numeric substrings using regular expression\n    numeric_substrings = re.findall(r'\\d+', ts)\n\n    # Convert the numeric substrings to integers and sum them up\n    total_sum = sum(int(num) for num in numeric_substrings)\n\n    return total_sum\n"}
{"task_id": "valid/35", "completion": "\n    return [word[:-1] + word[-1].upper() for word in words]\n"}
{"task_id": "valid/36", "completion": "\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    for element in arr:\n        if not isinstance(element, (int, float)):\n            raise ValueError(\"All elements in the array must be numerical values.\")\n    \n    return sum(arr)\n"}
{"task_id": "valid/37", "completion": "\n    neighborhoods = json.loads(json_data)\n    sorted_neighborhoods = sorted(neighborhood['name'] for neighborhood in neighborhoods)\n    return sorted_neighborhoods\n"}
{"task_id": "valid/38", "completion": "\n    # Initialize the minimum absolute sum to a large value\n    min_sum = float('inf')\n    pair = (0, 0)\n\n    # Iterate through all pairs of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            current_sum = abs(arr[i] + arr[j])\n            # Update the minimum sum and pair if a new minimum is found\n            if current_sum < min_sum:\n                min_sum = current_sum\n                pair = (arr[i], arr[j])\n\n    return pair, min_sum\n"}
{"task_id": "valid/39", "completion": "\n    stack = []\n    for char in p:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "valid/40", "completion": "\n    if not votes or sum(vote[1] for vote in votes) < 100:\n        raise ValueError(\"Total number of votes must be at least 100.\")\n\n    results = {}\n    total_votes = 0\n\n    for candidate_name, number_of_votes in votes:\n        if not isinstance(candidate_name, str) or not candidate_name.isupper() or len(candidate_name) > 10:\n            raise ValueError(\"Candidate name must be an uppercase string with a maximum length of 10 characters.\")\n        if not isinstance(number_of_votes, int) or number_of_votes <= 0 or number_of_votes > 1000:\n            raise ValueError(\"Number of votes must be a positive integer not exceeding 1000.\")\n\n        results[candidate_name] = results.get(candidate_name, 0) + number_of_votes\n        total_votes += number_of_votes\n\n    percentages = {candidate: round((votes / total_votes) * 100, 2) for candidate, votes in results.items()}\n\n    return {\n        \"results\": results,\n        \"percentages\": percentages\n    }\n"}
{"task_id": "valid/41", "completion": "\n    months = {\n        \"Jan\": 1, \"Feb\": 2, \"Mar\": 3, \"Apr\": 4, \"May\": 5,\n        \"Jun\": 6, \"Jul\": 7, \"Aug\": 8, \"Sep\": 9, \"Oct\": 10,\n        \"Nov\": 11, \"Dec\": 12\n    }\n\n    try:\n        if '-' in date_string and len(date_string.split('-')) == 3:\n            parts = date_string.split('-')\n            if len(parts[1]) == 3:  # DD-MMM-YYYY format\n                day = int(parts[0])\n                month = months[parts[1]]\n                year = int(parts[2])\n            else:  # DD-MM-YYYY format\n                day = int(parts[0])\n                month = int(parts[1])\n                year = int(parts[2])\n        else:\n            raise ValueError(\"Date format is incorrect. Use DD-MM-YYYY or DD-MMM-YYYY.\")\n\n        # Validate the date\n        new_date = datetime(year, month, day)\n\n        # Return the date in the standardized format\n        return new_date.strftime(\"%B %d, %Y\")\n\n    except ValueError as e:\n        raise ValueError(f\"Invalid date: {date_string}. Error: {e}\")\n"}
{"task_id": "valid/42", "completion": "\n    allowed_extensions = {\n        'text': ['.txt', '.md'],\n        'image': ['.jpg', '.jpeg', '.png', '.gif'],\n        'video': ['.mp4', '.mkv', '.avi'],\n        'audio': ['.mp3', '.wav', '.aac'],\n        'document': ['.pdf', '.doc', '.docx', '.xls', '.xlsx']\n    }\n\n    if allowed_type not in allowed_extensions:\n        raise ValueError(\"Invalid allowed type specified.\")\n\n    old_extension = oldname.split('.')[-1] if '.' in oldname else ''\n    new_extension = newname.split('.')[-1] if '.' in newname else ''\n\n    if new_extension not in allowed_extensions[allowed_type]:\n        return False\n\n    return True\n"}
{"task_id": "valid/43", "completion": "\n    def is_even(n):\n        return isinstance(n, (int, float)) and n % 2 == 0\n\n    def is_numeric_string(s):\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return remove_uneven(element)\n        elif isinstance(element, (int, float)) and is_even(element):\n            return element\n        elif isinstance(element, str) and is_numeric_string(element) and is_even(float(element)):\n            return element\n        return None\n\n    return tuple(filter(lambda x: x is not None, (process_element(el) for el in lst)))\n"}
{"task_id": "valid/44", "completion": "\n    return hours * 60\n"}
{"task_id": "valid/45", "completion": "\n    return string.count(specific_character)\n"}
{"task_id": "valid/46", "completion": "\n    # Uncomment the following line to add accuracy data to the histogram\n    histogram_data[generation] = accs\n    return histogram_data\n"}
{"task_id": "valid/47", "completion": "\n    return bool(re.fullmatch(r'^[a-zA-Z0-9]{5}$', string))\n"}
{"task_id": "valid/48", "completion": "\n    unique_languages = set()\n\n    for classifier in classifiers:\n        parts = classifier.split(\" :: \")\n        if len(parts) == 3:\n            language = parts[1].strip()\n            unique_languages.add(language)\n\n    return len(unique_languages)\n"}
{"task_id": "valid/49", "completion": "\n    from collections import Counter\n\n    # Flatten the 2D array into a 1D array\n    flat_list = [item for sublist in arr for item in sublist]\n    \n    # Count the instances of each number\n    count = Counter(flat_list)\n    \n    # Convert the count to a list of tuples (number, count)\n    result = [(num, cnt) for num, cnt in count.items()]\n    \n    return result\n"}
{"task_id": "valid/50", "completion": "\n    urlpatterns = [\n        re.compile(r'^videos/(?P<video_id>\\d+)/$'),  # Matches URLs like /videos/123/\n        re.compile(r'^videos/upload/$'),             # Matches the upload URL /videos/upload/\n    ]\n\n    def view_video(video_id):\n        # Logic to view a specific video by its ID\n        pass\n\n    def upload_video():\n        # Logic to handle video upload\n        pass\n\n    def match_url(url):\n        for pattern in urlpatterns:\n            match = pattern.match(url)\n            if match:\n                if 'video_id' in match.groupdict():\n                    return view_video(match.group('video_id'))\n                else:\n                    return upload_video()\n        return None  # No match found\n"}
{"task_id": "valid/51", "completion": "\n    if position < 0 or position > len(list):\n        raise IndexError(\"Position out of bounds\")\n    list.insert(position, item)\n    return list\n"}
{"task_id": "valid/52", "completion": "\n    base_string = \"Hello\"\n    sentence = \"world! Welcome to Python programming.\"\n    concatenated_string = f\"{base_string}, {sentence}\"\n    return concatenated_string\n"}
{"task_id": "valid/53", "completion": "\n    substrings = set()\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substrings.add(s[i:j])\n    \n    return substrings\n"}
{"task_id": "valid/54", "completion": "\n    total_sum = 0\n    for dictionary in list_of_dicts:\n        for key, value in dictionary.items():\n            if key.startswith(\"price\") and isinstance(value, (int, float)):\n                total_sum += value\n    return total_sum\n"}
{"task_id": "valid/55", "completion": "\n    intersection = list(set(list1) & set(list2))\n    list2[:] = [item for item in list2 if item not in intersection]\n    return intersection\n"}
{"task_id": "valid/56", "completion": "\n    if request_method == 'GET':\n        return api_advisor_view\n    elif request_method == 'POST':\n        return api_advisor_view_post\n    else:\n        raise ValueError(\"Unsupported request method\")\n"}
{"task_id": "valid/57", "completion": "\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both numbers must be positive integers.\")\n    if b == 0:\n        return a\n    return gcd_recursive(b, a % b)\n"}
{"task_id": "valid/58", "completion": "\n    categorized_files = {\n        'system': [],\n        'application': [],\n        'user': [],\n        'other': []\n    }\n\n    for file_path in file_paths:\n        if 'etc' in file_path:\n            categorized_files['system'].append(file_path)\n        elif 'app' in file_path:\n            categorized_files['application'].append(file_path)\n        elif 'home' in file_path:\n            categorized_files['user'].append(file_path)\n        else:\n            categorized_files['other'].append(file_path)\n\n    return categorized_files\n"}
{"task_id": "valid/59", "completion": "\n    numbers = [a, b, c, d, e]\n    numbers.sort()\n    return numbers[2]\n"}
{"task_id": "valid/60", "completion": "\n    return len(my_list) == len(set(my_list))\n"}
{"task_id": "valid/61", "completion": "\n    if timeEnd < timeStart:\n        raise ValueError(\"timeEnd must be greater than or equal to timeStart\")\n    \n    return timeEnd - timeStart\n"}
{"task_id": "valid/62", "completion": "\n    if start > end:\n        return -1  # Target not found\n\n    mid = (start + end) // 2\n\n    if array[mid] == target:\n        return mid  # Target found\n    elif array[mid] > target:\n        return binary_search_recursive(array, target, start, mid - 1)  # Search in the left half\n    else:\n        return binary_search_recursive(array, target, mid + 1, end)  # Search in the right half\n"}
{"task_id": "valid/63", "completion": "\n    color_sequence = [\"WHITE\", \"RED\", \"GREEN\", \"BLUE\"]\n    if color in color_sequence:\n        current_index = color_sequence.index(color)\n        next_index = (current_index + 1) % len(color_sequence)\n        return color_sequence[next_index]\n    else:\n        raise ValueError(\"Invalid color input. Please choose from WHITE, RED, GREEN, or BLUE.\")\n"}
{"task_id": "valid/64", "completion": "\n    def increment_list_values(lst):\n    return [x + 1 for x in lst]\n"}
{"task_id": "valid/65", "completion": "\n    for num in range(start, end + 1):\n        if (num**0.5).is_integer():\n            return True\n    return False\n"}
{"task_id": "valid/66", "completion": "\n    for word in words:\n        if target in word:\n            return word\n    return None\n"}
{"task_id": "valid/67", "completion": "\n    return sentence.split()\n"}
{"task_id": "valid/68", "completion": "\n    print(\"The keys in the given dictionary are:\")\n    for key in dict.keys():\n        print(key)\n"}
{"task_id": "valid/69", "completion": "\n    phrase = \"world\"\n    concatenated_string = f\"Hello, {phrase}!\"\n    return concatenated_string\n"}
{"task_id": "valid/70", "completion": "\n    def is_special_character_present(s):\n        return bool(re.search(r'[^a-zA-Z0-9\\s]', s)\n\n    def process_strings(strings):\n        result = []\n        for s in strings:\n            if not is_special_character_present(s):\n                result.append(s.capitalize())\n        return result\n\n    return process_strings\n"}
{"task_id": "valid/71", "completion": "\n    positions = [index for index, c in enumerate(string) if c == char]\n    return positions\n"}
{"task_id": "valid/72", "completion": "\n    bold_texts = []\n    start_tag = '<b>'\n    end_tag = '</b>'\n    start_tag_length = len(start_tag)\n    end_tag_length = len(end_tag)\n\n    start_index = 0\n    while True:\n        start_index = html_code.find(start_tag, start_index)\n        if start_index == -1:\n            break\n        end_index = html_code.find(end_tag, start_index + start_tag_length)\n        if end_index == -1:\n            break\n        bold_text = html_code[start_index + start_tag_length:end_index]\n        bold_texts.append(bold_text)\n        start_index = end_index + end_tag_length\n\n    return bold_texts\n"}
{"task_id": "valid/73", "completion": "\n    # Define the items and their prices\n    items = {\n        \"chips\": 1.50,\n        \"soda\": 1.00,\n        \"candy\": 0.75\n    }\n    \n    # Define the stock for each item\n    stock = {\n        \"chips\": 5,\n        \"soda\": 5,\n        \"candy\": 5\n    }\n    \n    # Check if the item exists in the vending machine\n    if item not in items:\n        return \"Item not available.\"\n    \n    # Check if there is enough stock\n    if stock[item] <= 0:\n        return \"Item out of stock.\"\n    \n    # Check if the money inserted is sufficient\n    price = items[item]\n    if money_inserted < price:\n        return \"Insufficient funds. Please insert more money.\"\n    \n    # Calculate change\n    change = money_inserted - price\n    \n    # Update stock\n    stock[item] -= 1\n    \n    return f\"Dispensing {item}. Change returned: ${change:.2f}. Thank you!\"\n"}
{"task_id": "valid/74", "completion": "\n    merged_list = list1 + list2\n    return list(set(merged_list))\n"}
{"task_id": "valid/75", "completion": "\n    return list.count(target)\n"}
{"task_id": "valid/76", "completion": "\n    byte_string = string.encode('utf-8')\n    base64_bytes = base64.b64encode(byte_string)\n    base64_string = base64_bytes.decode('utf-8')\n    return base64_string\n"}
{"task_id": "valid/77", "completion": "\n    return [index for index, value in enumerate(vector) if value != 0]\n"}
{"task_id": "valid/78", "completion": "\n    value = 10  # Assign a specific value\n    if value < 0:\n        raise ValueError(\"Value must be non-negative.\")\n    return value\n"}
{"task_id": "valid/79", "completion": "\n    word_list = list(word)\n    random.shuffle(word_list)\n    return ''.join(word_list)\n"}
{"task_id": "valid/80", "completion": "\n    if isinstance(element, int):\n        return \"Integer\"\n    elif isinstance(element, float):\n        return \"Float\"\n    elif isinstance(element, str):\n        return \"String\"\n    elif isinstance(element, list):\n        return \"List\"\n    elif isinstance(element, dict):\n        return \"Dictionary\"\n    elif isinstance(element, bool):\n        return \"Boolean\"\n    else:\n        return \"Unknown type\"\n"}
{"task_id": "valid/81", "completion": "\n    if not arr:\n        return []\n\n    merged = [arr[0]]\n\n    for i in range(1, len(arr)):\n        if arr[i] != arr[i - 1]:\n            merged.append(arr[i])\n\n    return merged\n"}
{"task_id": "valid/82", "completion": "\n    # Define a regular expression pattern for tokenization\n    pattern = r'\\w+|[^\\w\\s]'\n    \n    # Use re.findall to extract tokens based on the pattern\n    tokens = re.findall(pattern, text)\n    \n    return tokens\n"}
{"task_id": "valid/83", "completion": "\n    divisible_numbers = [num for num in numbers if num % 3 == 0 and num % 7 == 0]\n    \n    if not divisible_numbers:\n        print(\"No numbers are divisible by both 3 and 7.\")\n        return\n\n    average = sum(divisible_numbers) / len(divisible_numbers)\n    maximum = max(divisible_numbers)\n    minimum = min(divisible_numbers)\n    \n    occurrences = {num: divisible_numbers.count(num) for num in set(divisible_numbers)}\n    \n    print(f\"Average: {average}\")\n    print(f\"Maximum: {maximum}\")\n    print(f\"Minimum: {minimum}\")\n    print(\"Occurrences:\", occurrences)\n"}
{"task_id": "valid/84", "completion": "\n    from collections import Counter\n\n    # Normalize the sentence by converting it to lowercase and splitting into words\n    words = sentence.lower().split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Find the word with the highest frequency\n    highest_frequency_word = max(word_counts, key=word_counts.get)\n    \n    return highest_frequency_word\n"}
{"task_id": "valid/85", "completion": "\n    euler_number = sum(1 / math.factorial(i) for i in range(100))  # Calculate e using the series expansion\n    return round(euler_number, decimal_places)\n"}
{"task_id": "valid/86", "completion": "\n    total_sum = sum(numbers)\n    average = total_sum / len(numbers) if numbers else 0\n    return average, total_sum\n"}
{"task_id": "valid/87", "completion": "\n    if not time_series:\n        raise ValueError(\"The time series is empty.\")\n    \n    min_value = float('inf')\n    max_value = float('-inf')\n    \n    for value in time_series:\n        if not isinstance(value, (int, float)):\n            raise ValueError(\"The time series contains non-numerical values.\")\n        if value < min_value:\n            min_value = value\n        if value > max_value:\n            max_value = value\n            \n    return (min_value, max_value)\n"}
{"task_id": "valid/88", "completion": "\n    # Assuming encyclopedia is a dictionary where keys are article titles\n    # and values are lists of related article titles.\n    \n    related_counts = {}\n    \n    for article, related in encyclopedia.items():\n        related_counts[article] = len(related)\n    \n    return related_counts\n"}
{"task_id": "valid/89", "completion": "\n    if not lst:\n        return None  # Return None if the list is empty\n\n    largest_index = 0  # Start with the first index\n    for i in range(1, len(lst)):\n        if lst[i] > lst[largest_index]:\n            largest_index = i  # Update the index if a larger number is found\n\n    return largest_index\n"}
{"task_id": "valid/90", "completion": "\n    return any(elem in list1 for elem in list2)\n"}
{"task_id": "valid/91", "completion": "\n    def build_xml_element(key, value):\n        element = Element(key)\n        element.text = str(value)\n        return element\n\n    data_element = Element('data')\n    for key, value in dictionary.items():\n        child_element = build_xml_element(key, value)\n        data_element.append(child_element)\n\n    return tostring(data_element, encoding='unicode')\n"}
{"task_id": "valid/92", "completion": "\n    # 1. Each row of the matrix is sorted in ascending order.\n    # 2. The first integer of each row is greater than the last integer of the previous row.\n\n    m = len(matrix)\n    if m == 0:\n        return False\n    n = len(matrix[0])\n\n    left, right = 0, m * n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        mid_value = matrix[mid // n][mid % n]\n\n        if mid_value == target:\n            return True\n        elif mid_value < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n"}
{"task_id": "valid/93", "completion": "\n    total_sum = 0\n    count = 0\n\n    for number in lst:\n        if (number - 1) % 2 == 0:  # Check if the number is odd without using modulus operator\n            total_sum += number\n            count += 1\n\n    if count == 0:\n        return 0, 0  # Avoid division by zero if there are no odd elements\n\n    average = total_sum / count\n    return total_sum, average\n"}
{"task_id": "valid/94", "completion": "\n    if n < 1 or n > len(lst):\n        return None\n    unique_elements = list(set(lst))\n    unique_elements.sort(reverse=True)\n    return unique_elements[n - 1]\n"}
{"task_id": "valid/95", "completion": "\n    return sum(lst)\n\n"}
{"task_id": "valid/96", "completion": "\n    return set_a.symmetric_difference(set_b)\n"}
{"task_id": "valid/97", "completion": "\n    description = \"\"\"\n    Bot Name: MusicMasterBot\n\n    Features:\n    1. Play Music: The bot can play music from various sources including YouTube, Spotify, and SoundCloud.\n    2. Manage Playlists: Users can create, edit, and delete personal playlists through a web app interface.\n    3. Server Settings: Admins can configure server-specific settings such as default volume, allowed music sources, and command prefixes.\n    4. Command Categorization: Commands are organized into categories such as Music Control, Playlist Management, and Server Settings.\n    5. Help Command: A comprehensive help command that provides detailed information about each command and its usage.\n\n    Command Categories:\n    - Music Control:\n        - !play [song/link]: Play a song from a specified source.\n        - !pause: Pause the currently playing music.\n        - !resume: Resume paused music.\n        - !stop: Stop the music and clear the queue.\n        - !skip: Skip to the next song in the queue.\n    \n    - Playlist Management:\n        - !create_playlist [name]: Create a new personal playlist.\n        - !add_to_playlist [playlist_name] [song/link]: Add a song to a specified playlist.\n        - !remove_from_playlist [playlist_name] [song/link]: Remove a song from a specified playlist.\n        - !list_playlists: List all personal playlists.\n    \n    - Server Settings:\n        - !set_volume [level]: Set the volume for the bot (0-100).\n        - !set_source [source]: Set the default music source for the server.\n        - !set_prefix [prefix]: Change the command prefix for the server.\n\n    Help Command:\n    - !help: Display a list of all commands and their descriptions.\n    - !help [command]: Provide detailed information about a specific command.\n\n    This bot aims to enhance the music experience on Discord servers by providing easy-to-use commands and a user-friendly web interface for managing music and playlists.\n    \"\"\"\n    return description\n"}
{"task_id": "valid/98", "completion": "\n    if n == 0:\n        return '0'\n    \n    n = abs(n)\n    ternary = ''\n    \n    while n > 0:\n        ternary = str(n % 3) + ternary\n        n //= 3\n    \n    return ternary\n"}
{"task_id": "valid/99", "completion": "\n    return tuple(name.split('.')[-1] for name in file_names if '.' in name)\n"}
{"task_id": "valid/100", "completion": "\n    if age < 0:\n        return \"Invalid age\"\n    elif age <= 12:\n        return \"Child\"\n    elif age <= 19:\n        return \"Teenager\"\n    elif age <= 64:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n"}
{"task_id": "valid/101", "completion": "\n    letter_grade = (\n        'A' if numerical_grade >= 90 else\n        'B' if numerical_grade >= 80 else\n        'C' if numerical_grade >= 70 else\n        'D' if numerical_grade >= 60 else\n        'F'\n    )\n\n    gpa = (\n        4.0 if numerical_grade >= 90 else\n        3.0 if numerical_grade >= 80 else\n        2.0 if numerical_grade >= 70 else\n        1.0 if numerical_grade >= 60 else\n        0.0\n    )\n\n    return letter_grade, gpa\n"}
{"task_id": "valid/102", "completion": "\n    total = 0\n    for item in listing:\n        total += item['price'] * item['quantity']\n    return total\n"}
{"task_id": "valid/103", "completion": "\n    vowel_count = {}\n    vowels = 'aeiou'\n\n    for palindrome in palindrome_tuples:\n        count = sum(1 for char in palindrome.lower() if char in vowels)\n        vowel_count[palindrome] = count\n\n    return vowel_count\n"}
{"task_id": "valid/104", "completion": "\n    # Rule 1: Convert the string to lowercase\n    s = s.lower()\n    \n    # Rule 2: Remove all vowels from the string\n    vowels = 'aeiou'\n    s = ''.join([char for char in s if char not in vowels])\n    \n    # Rule 3: Reverse the string\n    s = s[::-1]\n    \n    return s\n"}
{"task_id": "valid/105", "completion": "\n    seen = set()\n    for num in arr:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n"}
{"task_id": "valid/106", "completion": "\n    latest_versions = {}\n\n    for package, version in dependencies:\n        if package not in latest_versions:\n            latest_versions[package] = version\n        else:\n            current_version = latest_versions[package]\n            if version > current_version:\n                latest_versions[package] = version\n\n    return list(latest_versions.items())\n"}
{"task_id": "valid/107", "completion": "\n    categories = {}\n\n    for cause in causes:\n        action, result = cause.split(\" \", 1)\n        if action not in categories:\n            categories[action] = []\n        categories[action].append(result)\n\n    return categories\n"}
{"task_id": "valid/108", "completion": "\n    return name.replace(\" \", \"-\").lower()\n"}
{"task_id": "valid/109", "completion": "\n    return any(ord(char) > 127 for char in text)\n"}
{"task_id": "valid/110", "completion": "\n    import string as str_lib\n\n    return ''.join(char for char in string if char not in str_lib.punctuation)\n"}
{"task_id": "valid/111", "completion": "\n    def raise_power(num_list, exp):\n    \"\"\"\n    Raises each element in num_list to the power of exp.\n    \n    Parameters:\n    num_list (list): A list of numbers.\n    exp (int or float): The exponent to raise each number to.\n    \n    Returns:\n    list: A list of numbers raised to the given exponent.\n    \"\"\"\n    result = []\n    for num in num_list:\n        try:\n            result.append(num ** exp)\n        except TypeError:\n            print(f\"Error: {num} is not a number and cannot be raised to a power.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n    return result\n"}
{"task_id": "valid/112", "completion": "\n    for row in grid:\n        if row:  # Check if the row is not empty\n            print(min(row))\n"}
{"task_id": "valid/113", "completion": "\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    if current_num < n:\n        print(\"Thank you\")\n        return print_thank_you(n, current_num + 1)\n"}
{"task_id": "valid/114", "completion": "\n    count = 0\n    max_count = 0\n\n    for item in lst:\n        if item == element:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n\n    return max_count\n"}
{"task_id": "valid/115", "completion": "\n    if num < 0:\n        return False\n\n    digits = []\n    while num > 0:\n        digits.append(num % base)\n        num //= base\n\n    return all(d == digits[0] for d in digits)\n"}
{"task_id": "valid/116", "completion": "\n    if not s:\n        return \"\"\n    \n    first_char = s[0]\n    rest_of_string = remove_vowels_recursive(s[1:])\n    \n    if first_char.lower() in 'aeiou':\n        return rest_of_string\n    else:\n        return first_char + rest_of_string\n"}
{"task_id": "valid/117", "completion": "\n    help_message = \"Usage: myapp [OPTIONS]\\n\\nOptions:\\n\"\n    \n    for option, description in options:\n        help_message += f\"  --{option}: {description}\\n\"\n    \n    return help_message.strip()\n"}
{"task_id": "valid/118", "completion": "\n    if input_string:\n        return input_string[0]\n    return None\n"}
{"task_id": "valid/119", "completion": "\n    from collections import Counter\n\n    def generate_count_table(array, value):\n        count = Counter(array)\n        return {val: count[val] for val in count if val == value}\n\n    return generate_count_table\n"}
{"task_id": "valid/120", "completion": "\n    return ~sample_bitset\n"}
{"task_id": "valid/121", "completion": "\n    return all(char in 'aeiouAEIOU' for char in s)\n"}
{"task_id": "valid/122", "completion": "\n    seq_len = len(sequence)\n    sub_len = len(subsequence)\n    \n    if sub_len == 0:\n        return 1  # An empty subsequence is a subsequence of any sequence\n    \n    if seq_len < sub_len:\n        return 0  # If the sequence is shorter than the subsequence, return 0\n    \n    # Create a 2D array to store the counts\n    dp = [[0] * (sub_len + 1) for _ in range(seq_len + 1)]\n    \n    # Initialize the first column\n    for i in range(seq_len + 1):\n        dp[i][0] = 1  # An empty subsequence can be formed in one way\n    \n    # Fill the dp array\n    for i in range(1, seq_len + 1):\n        for j in range(1, sub_len + 1):\n            if sequence[i - 1] == subsequence[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[seq_len][sub_len]\n"}
{"task_id": "valid/123", "completion": "\n    if t == 0:\n        raise ValueError(\"Cannot divide by zero.\")\n    \n    negative_result = (h < 0) ^ (t < 0)  # Determine if the result should be negative\n    h, t = abs(h), abs(t)  # Work with absolute values\n\n    quotient = 0\n    while h >= t:\n        h -= t\n        quotient += 1\n\n    return -quotient if negative_result else quotient\n"}
{"task_id": "valid/124", "completion": "\n    return sum(x for x in input_list if x % 2 != 0)\n"}
{"task_id": "valid/125", "completion": "\n    vowels = \"aeiouAEIOU\"\n    consonant_count = 0\n\n    for char in string:\n        if char.isalpha() and char not in vowels:\n            consonant_count += 1\n\n    return consonant_count\n"}
{"task_id": "valid/126", "completion": "\n    # Calculate the number of electrons based on energy values\n    num_electrons = sum(1 for energy in grid_energies if energy < 0)\n\n    # Adjust the number of electrons based on doping levels\n    if dope > 0:\n        num_electrons += dope * dos_grid_size\n    elif dope < 0:\n        num_electrons += dope * dos_grid_size // 2  # Assuming a different scaling for negative doping\n\n    # Apply the ados factor to the number of electrons\n    num_electrons *= ados\n\n    return num_electrons\n"}
{"task_id": "valid/127", "completion": "\n    return tuple(dict.fromkeys(tuple_to_process))\n"}
{"task_id": "valid/128", "completion": "\n    if not arr:\n        return []\n\n    arr.sort()\n    result = []\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        if left == right:\n            result.append(arr[left])\n        else:\n            result.append(arr[right])\n            result.append(arr[left])\n        left += 1\n        right -= 1\n\n    return result\n"}
{"task_id": "valid/129", "completion": "\n    color_dict = {}\n    for color in color_list:\n        name, value = color\n        color_dict[name] = value\n    return color_dict\n"}
{"task_id": "valid/130", "completion": "\n    stack = []\n    parentheses = {')': '(', '}': '{', ']': '['}\n\n    for char in string:\n        if char in parentheses.values():\n            stack.append(char)\n        elif char in parentheses.keys():\n            if not stack or stack.pop() != parentheses[char]:\n                return False\n\n    return len(stack) == 0\n"}
{"task_id": "valid/131", "completion": "\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n        if len(unique_elements) == 3:\n            break\n    return unique_elements\n"}
{"task_id": "valid/132", "completion": "\n    # Sort the fruit list in lexicographical order\n    sorted_list = sorted(fruit_list)\n    \n    # Join the sorted list into a single string with commas\n    result = ', '.join(sorted_list)\n    \n    return result\n"}
{"task_id": "valid/133", "completion": "\n    sublists = []\n    for i in range(len(lst) + 1):\n        for j in range(i):\n            sublists.append(lst[j:i])\n    return sublists\n"}
{"task_id": "valid/134", "completion": "\n    pattern = r'\\d+\\.\\d+'\n    return bool(re.search(pattern, string))\n"}
{"task_id": "valid/135", "completion": "\n    from django.db import migrations, models\n\n    class Migration(migrations.Migration):\n\n        dependencies = [\n            ('history', 'previous_migration_name'),  # Replace with the actual previous migration name\n        ]\n\n        operations = [\n            migrations.AlterField(\n                model_name=model_name,\n                name=field_name,\n                field=models.CharField(max_length=255),  # Adjust field type and parameters as needed\n            ),\n        ]\n"}
{"task_id": "valid/136", "completion": "\n    common_elements = set(list1) & set(list2)\n    return sum(common_elements)\n"}
{"task_id": "valid/137", "completion": "\n    length = len(df)\n    forecast_period = math.ceil(length * 0.01)\n    return forecast_period\n"}
{"task_id": "valid/138", "completion": "\n    return sorted(array, key=lambda x: x.get(attr, None))\n"}
{"task_id": "valid/139", "completion": "\n    if items_per_page <= 0:\n        raise ValueError(\"items_per_page must be greater than 0\")\n    \n    if page_number < 1:\n        raise ValueError(\"page_number must be 1 or greater\")\n    \n    start_index = (page_number - 1) * items_per_page\n    end_index = start_index + items_per_page\n    \n    return items[start_index:end_index]\n"}
{"task_id": "valid/140", "completion": "\n    # Initialize variables\n    result = []\n    carry = 0\n\n    # Reverse the string to process from least significant digit to most\n    n_str = n_str[::-1]\n\n    for digit in n_str:\n        # Convert character to integer\n        num = int(digit)\n        # Double the digit and add carry\n        doubled = num * 2 + carry\n        # Calculate new digit and carry\n        result_digit = doubled % 10\n        carry = doubled // 10\n        # Append the result digit to the result list\n        result.append(str(result_digit))\n\n    # If there's any carry left, add it to the result\n    if carry > 0:\n        result.append(str(carry))\n\n    # Reverse the result to get the final doubled number\n    return ''.join(result[::-1])\n"}
{"task_id": "valid/141", "completion": "\n    presets = {\n        \"home\": (0.0, 0.0, 0.0),\n        \"position1\": (1.0, 0.5, 0.2),\n        \"position2\": (0.5, 1.0, 0.3),\n        \"position3\": (0.0, 1.5, 0.4),\n    }\n\n    return presets.get(preset_name, \"Preset not found\")\n"}
{"task_id": "valid/142", "completion": "\n    common_elements = set(list1) & set(list2)\n    product = 1\n    for element in common_elements:\n        product *= element\n    return product if common_elements else 0\n"}
{"task_id": "valid/143", "completion": "\n    # Configuration for allowing multiple answers\n    if allow_multiple_answer:\n        print(\"Multiple answers are allowed for this quiz.\")\n    else:\n        print(\"Only one answer is allowed for this quiz.\")\n\n    # Configuration for zoom level\n    if zoom_level < 1:\n        print(\"Zoom level is too low. Setting to minimum zoom level of 1.\")\n        zoom_level = 1\n    elif zoom_level > 5:\n        print(\"Zoom level is too high. Setting to maximum zoom level of 5.\")\n        zoom_level = 5\n    print(f\"Current zoom level is set to {zoom_level}.\")\n"}
{"task_id": "valid/144", "completion": "\n    return math.floor(num)\n"}
{"task_id": "valid/145", "completion": "\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in sentence if char not in vowels)\n"}
{"task_id": "valid/146", "completion": "\n    merged = {}\n\n    def is_alpha(key):\n        return all(char.isalpha() for char in key)\n\n    def merge_dicts(dict1, dict2):\n        for key in dict1:\n            if is_alpha(key):\n                if key in dict2:\n                    merged[key] = dict2[key]\n                else:\n                    merged[key] = dict1[key]\n        for key in dict2:\n            if is_alpha(key) and key not in merged:\n                merged[key] = dict2[key]\n\n    def recursive_merge(dict1, dict2):\n        for key in dict1:\n            if is_alpha(key):\n                if isinstance(dict1[key], dict) and key in dict2 and isinstance(dict2[key], dict):\n                    recursive_merge(dict1[key], dict2[key])\n                else:\n                    merged[key] = dict1[key]\n        for key in dict2:\n            if is_alpha(key):\n                if key in merged:\n                    merged[key] = dict2[key]\n                else:\n                    merged[key] = dict2[key]\n\n    recursive_merge(a, b)\n\n    sorted_merged = {}\n    for key in sorted(merged.keys()):\n        sorted_merged[key] = merged[key]\n\n    return sorted_merged\n"}
{"task_id": "valid/147", "completion": "\n    try:\n        max_value = float('-inf')\n        for key, value in d.items():\n            if isinstance(value, dict):\n                nested_max = find_max_in_dict(value)\n                if nested_max > max_value:\n                    max_value = nested_max\n            elif isinstance(value, (int, float)):\n                if value > max_value:\n                    max_value = value\n            else:\n                raise ValueError(f\"Unsupported value type: {type(value)} for key: {key}\")\n        return max_value if max_value != float('-inf') else None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n"}
{"task_id": "valid/148", "completion": "\n    if key in dict:\n        values = dict[key]\n        return sum(values) / len(values)\n    else:\n        return None\n\naverage = calculate_avg_from_dict(grades_dict, values_key)"}
{"task_id": "valid/149", "completion": "\n    if string is None or string == \"\":\n        return None\n    return string.replace('e', '*')\n"}
{"task_id": "valid/150", "completion": "\n    if n <= 0:\n        return []\n    \n    return sorted(heapq.nsmallest(n, lst))\n"}
{"task_id": "valid/151", "completion": "\n    return x > 0 and sqrt(x).is_integer()\n\n"}
{"task_id": "valid/152", "completion": "\n    return date + datetime.timedelta(days=10)\n"}
