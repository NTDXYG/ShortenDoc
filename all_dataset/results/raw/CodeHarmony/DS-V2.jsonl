{"task_id": "valid/0", "completion": "\n    categories = {\n        \"sports\": [\"football\", \"basketball\", \"tennis\", \"soccer\"],\n        \"technology\": [\"computer\", \"software\", \"hardware\", \"internet\"],\n        \"finance\": [\"bank\", \"investment\", \"stock\", \"market\"],\n        \"health\": [\"medicine\", \"doctor\", \"hospital\", \"treatment\"],\n        \"politics\": [\"government\", \"election\", \"policy\", \"parliament\"]\n    }\n    \n    text_lower = text.lower()\n    \n    for category, keywords in categories.items():\n        for keyword in keywords:\n            if keyword in text_lower:\n                return category\n    \n    return \"unknown\"\n"}
{"task_id": "valid/1", "completion": "\n    return frozenset(s)\n"}
{"task_id": "valid/2", "completion": "\n    return num1 ^ num2\n"}
{"task_id": "valid/3", "completion": "\n    sorted_instruments = sorted(instruments, reverse=True)\n    return sorted_instruments\n"}
{"task_id": "valid/4", "completion": "\n    try:\n        data = json.loads(json_string)\n        if isinstance(data, list):\n            return data\n        else:\n            raise ValueError(\"The JSON string does not represent a list of dictionaries.\")\n    except json.JSONDecodeError:\n        raise ValueError(\"The input is not a valid JSON string.\")\n"}
{"task_id": "valid/5", "completion": "\n    if not isinstance(n, int) or n < 0:\n        return False\n    \n    digits_sum = sum(int(digit) for digit in str(n))\n    \n    return n % 5 == 0 and digits_sum % 3 == 0\n"}
{"task_id": "valid/6", "completion": "\n    result = 0\n    while n > 1:\n        n //= base\n        result += 1\n    return result\n"}
{"task_id": "valid/7", "completion": "    try:\n        parsed_json = json.loads(json_str)\n        pprint.pprint(parsed_json)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON string: {e}\")"}
{"task_id": "valid/8", "completion": "\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    return False\n"}
{"task_id": "valid/9", "completion": "\n    import re\n\n    def replace_placeholders(template, values):\n        def replace(match):\n            key = match.group(1)\n            return values.get(key, match.group(0))\n\n        pattern = r'\\{\\{(.*?)\\}\\}'\n        return re.sub(pattern, replace, template)\n"}
{"task_id": "valid/10", "completion": "\n    char_set = set()\n    for char in string:\n        if char in char_set:\n            return False\n        char_set.add(char)\n    return True\n"}
{"task_id": "valid/11", "completion": "\n    date_obj = datetime.strptime(date_string, '%Y-%m-%d')\n    new_date_obj = date_obj + timedelta(days=days)\n    return new_date_obj.strftime('%Y-%m-%d')\n"}
{"task_id": "valid/12", "completion": "\n    # First, strip any leading and trailing whitespace\n    text = text.strip()\n    \n    # Then, split the text by whitespace and join the words with a single space\n    words = text.split()\n    text = ' '.join(words)\n    \n    return text\n"}
{"task_id": "valid/13", "completion": "\n    # Convert text to lowercase\n    text = text.lower()\n    \n    # Remove punctuation\n    text = text.translate(str.maketrans('', '', string.punctuation))\n    \n    # Remove digits\n    text = ''.join([char for char in text if not char.isdigit()])\n    \n    # Remove extra whitespace\n    text = ' '.join(text.split())\n    \n    # Handle common linguistic variations and irregularities\n    # For example, handling common contractions in English\n    contractions = {\n        \"n't\": \" not\",\n        \"'re\": \" are\",\n        \"'s\": \" is\",\n        \"'d\": \" would\",\n        \"'ll\": \" will\",\n        \"'m\": \" am\",\n        \"'ve\": \" have\"\n    }\n    \n    for contraction, expansion in contractions.items():\n        text = text.replace(contraction, expansion)\n    \n    return text\n"}
{"task_id": "valid/14", "completion": "\n    pattern = rf'\\b({word1}|{word2})\\b'\n    return bool(re.search(pattern, text))\n"}
{"task_id": "valid/15", "completion": "\n    def layer_sum(array):\n        if not array or not array[0]:\n            return []\n\n        n = len(array)\n        m = len(array[0])\n        sums = []\n\n        for layer in range(min(n, m) // 2):\n            layer_sum = 0\n            # Top row\n            for j in range(layer, m - layer):\n                layer_sum += array[layer][j]\n            # Right column\n            for i in range(layer + 1, n - layer):\n                layer_sum += array[i][m - layer - 1]\n            # Bottom row\n            if layer < n - layer - 1:\n                for j in range(m - layer - 2, layer - 1, -1):\n                    layer_sum += array[n - layer - 1][j]\n            # Left column\n            if layer < m - layer - 1:\n                for i in range(n - layer - 2, layer, -1):\n                    layer_sum += array[i][layer]\n            sums.append(layer_sum)\n\n        return sums\n"}
{"task_id": "valid/16", "completion": "\n    settings = {}\n    lines = comment.strip().split('\\n')\n    \n    for line in lines:\n        line = line.strip()\n        if line.startswith('set'):\n            parts = line.split()\n            if len(parts) > 1:\n                key = parts[1]\n                value = parts[2] if len(parts) > 2 else 'on'\n                if key in ['tabstop', 'expandtab', 'shiftwidth', 'softtabstop']:\n                    settings[key] = value\n    \n    return settings\n"}
{"task_id": "valid/17", "completion": "\n    words = sentence.split()\n    return words\n"}
{"task_id": "valid/18", "completion": "\n    if num < 10:\n        return 1\n    else:\n        return 1 + find_digits_count(num // 10)\n"}
{"task_id": "valid/19", "completion": "\n    reversed_list1 = list1[::-1]\n    reversed_list2 = list2[::-1]\n    combined_list = reversed_list1 + reversed_list2\n    sorted_list = sorted(combined_list)\n    return sorted_list\n"}
{"task_id": "valid/20", "completion": "\n    words = input_string.split()\n    replaced_words = [new_word if word == old_word else word for word in words]\n    return ' '.join(replaced_words)\n"}
{"task_id": "valid/21", "completion": "\n    return z * z\n"}
{"task_id": "valid/22", "completion": "\n    try:\n        return dictionary['person']['name']\n    except KeyError:\n        return None\n"}
{"task_id": "valid/23", "completion": "\n    if isinstance(struct, dict):\n        return {key: struct_to_dict(value) for key, value in struct.items()}\n    elif isinstance(struct, list):\n        return [struct_to_dict(item) for item in struct]\n    elif isinstance(struct, tuple):\n        return tuple(struct_to_dict(item) for item in struct)\n    elif isinstance(struct, set):\n        return {struct_to_dict(item) for item in struct}\n    else:\n        return struct\n"}
{"task_id": "valid/24", "completion": "\n    def isPalindrome(n):\n        return str(n) == str(n)[::-1]\n\n    if isPalindrome(num):\n        return num\n\n    lower = num - 1\n    upper = num + 1\n\n    while True:\n        if isPalindrome(lower):\n            return lower\n        if isPalindrome(upper):\n            return upper\n        lower -= 1\n        upper += 1\n"}
{"task_id": "valid/25", "completion": "\n    if num < 0:\n        raise ValueError(\"Cannot calculate square root of a negative number\")\n    \n    guess = num / 2.0\n    tolerance = 0.0001\n    \n    while True:\n        better_guess = (guess + num / guess) / 2.0\n        if abs(guess - better_guess) < tolerance:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "valid/26", "completion": "\n    num_rows = len(matrix)\n    num_cols = len(matrix[0]) if num_rows > 0 else 0\n    \n    diagonal_sum = 0\n    is_square = num_rows == num_cols\n    \n    for i in range(min(num_rows, num_cols)):\n        diagonal_sum += matrix[i][i]\n    \n    return num_rows, num_cols, diagonal_sum, is_square\n"}
{"task_id": "valid/27", "completion": "    encoded_bytes = base64.b64encode(string.encode('utf-8'))\n    encoded_string = encoded_bytes.decode('utf-8')\n    return encoded_string"}
{"task_id": "valid/28", "completion": "\n    cleaned_string = ''.join(char for char in s if char.isalpha())\n    return cleaned_string.lower()\n"}
{"task_id": "valid/29", "completion": "\n    if not lst:\n        return None\n    min_element = lst[0]\n    for element in lst:\n        if element < min_element:\n            min_element = element\n    return min_element\n"}
{"task_id": "valid/30", "completion": "\n    if isinstance(json_data, str):\n        try:\n            json_data = json.loads(json_data)\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON string provided.\")\n\n    if not isinstance(json_data, dict):\n        raise ValueError(\"The provided JSON data must be a dictionary.\")\n\n    if key in json_data and json_data[key] == value:\n        return False\n    return True\n"}
{"task_id": "valid/31", "completion": "\n    button_table = []\n    row = []\n    for i, button in enumerate(buttons):\n        row.append(button)\n        if (i + 1) % num_columns == 0:\n            button_table.append(row)\n            row = []\n    if row:\n        button_table.append(row)\n    return button_table\n"}
{"task_id": "valid/32", "completion": "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    n = len(s)\n    m = len(alphabet)\n    \n    i, j = 0, 0\n    while i < n and j < m:\n        if s[i] == alphabet[j]:\n            j += 1\n        i += 1\n    \n    return j == m"}
{"task_id": "valid/33", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "valid/34", "completion": "\n    import re\n\n    # Find all numeric substrings in the input string\n    numeric_substrings = re.findall(r'\\d+', ts)\n    \n    # Convert the numeric substrings to integers and sum them up\n    total_sum = sum(int(num) for num in numeric_substrings)\n    \n    return total_sum\n"}
{"task_id": "valid/35", "completion": "\n    result = []\n    for word in words:\n        if word:\n            word = word[:-1] + word[-1].upper()\n        result.append(word)\n    return result\n"}
{"task_id": "valid/36", "completion": "\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"Array must contain only numerical values.\")\n    \n    return sum(arr)\n"}
{"task_id": "valid/37", "completion": "\n    neighborhoods = [entry['name'] for entry in json_data]\n    sorted_neighborhoods = sorted(neighborhoods)\n    return sorted_neighborhoods\n"}
{"task_id": "valid/38", "completion": "\n    # Variables to store the minimum sum and the pair\n    min_sum = float('inf')\n    min_l = 0\n    min_r = 1\n\n    # Iterate through the array to find the minimum sum pair\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            current_sum = abs(arr[i] + arr[j])\n            if current_sum < min_sum:\n                min_sum = current_sum\n                min_l = i\n                min_r = j\n\n    # Print the pair with the minimum absolute sum\n    print(f\"The pair with the minimum absolute sum is: ({arr[min_l]}, {arr[min_r]})\")\n"}
{"task_id": "valid/39", "completion": "\n    stack = []\n    for char in p:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "valid/40", "completion": "\n    results = {}\n    total_votes = 0\n\n    for candidate, votes in votes:\n        if candidate not in results:\n            results[candidate] = 0\n        results[candidate] += votes\n        total_votes += votes\n\n    for candidate in results:\n        percentage = (results[candidate] / total_votes) * 100\n        results[candidate] = (results[candidate], round(percentage, 2))\n\n    return results\n"}
{"task_id": "valid/41", "completion": "\n    try:\n        # Attempt to parse the date string with the first format\n        date_obj = datetime.strptime(date_string, \"%d-%m-%Y\")\n    except ValueError:\n        try:\n            # Attempt to parse the date string with the second format\n            date_obj = datetime.strptime(date_string, \"%d-%b-%Y\")\n        except ValueError:\n            raise ValueError(\"Invalid date format. Please use DD-MM-YYYY or DD-MMM-YYYY.\")\n    \n    # Check if the parsed date is valid\n    try:\n        # Create a date object from the parsed components\n        date_obj = datetime(date_obj.year, date_obj.month, date_obj.day)\n    except ValueError:\n        raise ValueError(\"Invalid date. The date does not exist.\")\n    \n    # Return the date in the standardized format\n    return date_obj.strftime(\"%B %d, %Y\")\n"}
{"task_id": "valid/42", "completion": "\n    # Split the new file name to get the file extension\n    _, ext = os.path.splitext(newname)\n    \n    # Remove the leading dot from the extension\n    ext = ext.lstrip('.')\n    \n    # Check if the extension is in the allowed types\n    if ext in allowed_type:\n        return True\n    else:\n        return False\n"}
{"task_id": "valid/43", "completion": "\n    def is_even(x):\n        if isinstance(x, str):\n            try:\n                return float(x) % 2 == 0\n            except ValueError:\n                return False\n        elif isinstance(x, (int, float)):\n            return x % 2 == 0\n        return False\n\n    def process_element(element):\n        if isinstance(element, tuple):\n            return tuple(filter(is_even, element))\n        elif isinstance(element, list):\n            return list(filter(is_even, element))\n        else:\n            return element if is_even(element) else None\n\n    def process_list(lst):\n        return [process_element(element) for element in lst if process_element(element) is not None]\n\n    return tuple(process_list(lst))\n"}
{"task_id": "valid/44", "completion": "\n    return hours * 60\n"}
{"task_id": "valid/45", "completion": "\n    count = 0\n    for char in string:\n        if char == specific_character:\n            count += 1\n    return count\n"}
{"task_id": "valid/46", "completion": "\n    # Ensure the histogram data is a dictionary\n    if not isinstance(histogram_data, dict):\n        raise ValueError(\"histogram_data must be a dictionary\")\n    \n    # Ensure the generation is an integer\n    if not isinstance(generation, int):\n        raise ValueError(\"generation must be an integer\")\n    \n    # Ensure the accuracies are a list\n    if not isinstance(accs, list):\n        raise ValueError(\"accs must be a list\")\n    \n    # Add the accuracy data to the histogram for the given generation\n    if generation not in histogram_data:\n        histogram_data[generation] = []\n    \n    histogram_data[generation].extend(accs)\n    \n    return histogram_data\n"}
{"task_id": "valid/47", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]{5}$')\n    return bool(pattern.match(string))\n"}
{"task_id": "valid/48", "completion": "\n    unique_languages = set()\n    \n    for classifier in classifiers:\n        parts = classifier.split(\" :: \")\n        if len(parts) == 3 and parts[0] == \"Programming Language\":\n            unique_languages.add(parts[1])\n    \n    return len(unique_languages)\n"}
{"task_id": "valid/49", "completion": "\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Iterate through each sub-array in the 2D array\n    for sub_array in arr:\n        # Iterate through each number in the sub-array\n        for num in sub_array:\n            # If the number is already in the dictionary, increment its count\n            if num in count_dict:\n                count_dict[num] += 1\n            # Otherwise, add the number to the dictionary with a count of 1\n            else:\n                count_dict[num] = 1\n    \n    # Extract the unique numbers from the dictionary keys\n    unique_numbers = list(count_dict.keys())\n    \n    # Sort the unique numbers to ensure the output is in a consistent order\n    unique_numbers.sort()\n    \n    # Create the result array with the count of each number\n    result = [count_dict[num] for num in unique_numbers]\n    \n    return result\n"}
{"task_id": "valid/50", "completion": "\n    urlpatterns = [\n        re.compile(r'^videos/(?P<video_id>\\d+)/$').match,\n        re.compile(r'^competitions/(?P<competition_id>\\d+)/$').match,\n    ]\n\n    for pattern in urlpatterns:\n        match = pattern(url)\n        if match:\n            return match.groupdict()\n\n    return None\n"}
{"task_id": "valid/51", "completion": "\n    if position < 0:\n        position = 0\n    elif position > len(list):\n        position = len(list)\n    \n    list.insert(position, item)\n    return list\n"}
{"task_id": "valid/52", "completion": "    string_to_concatenate = \"Hello, \"\n    sentence = \"world!\"\n    concatenated_string = string_to_concatenate + sentence\n    return concatenated_string"}
{"task_id": "valid/53", "completion": "\n    from collections import defaultdict\n\n    def find_substrings(s):\n        n = len(s)\n        substrings = defaultdict(list)\n\n        # Generate all substrings and store them in a dictionary\n        for length in range(1, n + 1):\n            for start in range(n - length + 1):\n                substring = s[start:start + length]\n                substrings[substring].append(start)\n\n        # Filter substrings that appear more than once\n        repeated_substrings = {sub: positions for sub, positions in substrings.items() if len(positions) > 1}\n\n        return repeated_substrings\n"}
{"task_id": "valid/54", "completion": "\n    total_sum = 0\n    for dictionary in list_of_dicts:\n        for key in dictionary:\n            if key.startswith(\"price\"):\n                try:\n                    price_value = float(dictionary[key])\n                    total_sum += price_value\n                except ValueError:\n                    # If the value is not a valid float, skip it\n                    continue\n    return total_sum\n"}
{"task_id": "valid/55", "completion": "\n    intersection = []\n    for item in list1:\n        if item in list2:\n            intersection.append(item)\n            list2.remove(item)\n    return intersection\n"}
{"task_id": "valid/56", "completion": "\n    if request_method == 'GET':\n        return api_advisor_view()\n    elif request_method == 'POST':\n        return api_advisor_view_post()\n    else:\n        return \"Unsupported request method\", 405\n"}
{"task_id": "valid/57", "completion": "\n    if not isinstance(a, int) or not isinstance(b, int) or a <= 0 or b <= 0:\n        raise ValueError(\"Both arguments must be positive integers.\")\n    \n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n"}
{"task_id": "valid/58", "completion": "\n    categorized_files = {}\n\n    for file_path in file_paths:\n        # Split the file path into its components\n        path_parts = file_path.split('/')\n        \n        # The category will be the first directory in the path\n        category = path_parts[0] if path_parts else 'uncategorized'\n        \n        # If the category is not already in the dictionary, add it\n        if category not in categorized_files:\n            categorized_files[category] = []\n        \n        # Append the file path to the appropriate category\n        categorized_files[category].append(file_path)\n    \n    return categorized_files\n"}
{"task_id": "valid/59", "completion": "\n    # Sort the five numbers using a series of comparisons\n    if a > b: a, b = b, a\n    if c > d: c, d = d, c\n    if a > c: a, c = c, a\n    if b > d: b, d = d, b\n    if b > c: b, c = c, b\n    if e > c: e, c = c, e\n    if e > d: e, d = d, e\n    if e > b: e, b = b, e\n\n    # The median is now the third largest number, which is 'b'\n    return b\n"}
{"task_id": "valid/60", "completion": "\n    unique_elements = set()\n    for item in my_list:\n        if item in unique_elements:\n            return False\n        unique_elements.add(item)\n    return True\n"}
{"task_id": "valid/61", "completion": "\n    if timeStart > timeEnd:\n        raise ValueError(\"timeStart cannot be greater than timeEnd\")\n    \n    return timeEnd - timeStart\n"}
{"task_id": "valid/62", "completion": "\n    if start > end:\n        return -1  # Target not found\n\n    mid = (start + end) // 2\n\n    if array[mid] == target:\n        return mid  # Target found at mid index\n    elif array[mid] > target:\n        return binary_search_recursive(array, target, start, mid - 1)  # Search in the left half\n    else:\n        return binary_search_recursive(array, target, mid + 1, end)  # Search in the right half\n"}
{"task_id": "valid/63", "completion": "\n    if color == \"WHITE\":\n        return \"RED\"\n    elif color == \"RED\":\n        return \"GREEN\"\n    elif color == \"GREEN\":\n        return \"BLUE\"\n    elif color == \"BLUE\":\n        return \"WHITE\"\n    else:\n        raise ValueError(\"Invalid color input\")\n"}
{"task_id": "valid/64", "completion": "\n    def increment_list_values(lst):\n    return [x + 1 for x in lst]\n"}
{"task_id": "valid/65", "completion": "\n    for num in range(start, end + 1):\n        if (num ** 0.5).is_integer():\n            return True\n    return False\n"}
{"task_id": "valid/66", "completion": "\n    for word in words:\n        if target in word:\n            return word.index(target)\n    return -1\n"}
{"task_id": "valid/67", "completion": "\n    words = sentence.split()\n    return words\n"}
{"task_id": "valid/68", "completion": "\n    print(\"The keys in the given dictionary are:\")\n    for key in dict.keys():\n        print(key)\n"}
{"task_id": "valid/69", "completion": "    original_string = \"Hello\"\n    phrase = \"world!\"\n    concatenated_string = f\"{original_string} {phrase}\"\n    return concatenated_string"}
{"task_id": "valid/70", "completion": "\n    result = []\n    for s in strings:\n        if re.match(r'^[a-zA-Z0-9\\s]+$', s):\n            result.append(s.capitalize())\n    return result\n"}
{"task_id": "valid/71", "completion": "\n    for index, c in enumerate(string):\n        if c == char:\n            return index\n    return -1  # Return -1 if the character is not found in the string\n"}
{"task_id": "valid/72", "completion": "\n    bold_texts = []\n    i = 0\n    while i < len(html_code):\n        start_tag = html_code.find('<b>', i)\n        if start_tag == -1:\n            break\n        end_tag = html_code.find('</b>', start_tag)\n        if end_tag == -1:\n            break\n        bold_text = html_code[start_tag + 3:end_tag]\n        bold_texts.append(bold_text)\n        i = end_tag + 4\n    return bold_texts\n"}
{"task_id": "valid/73", "completion": "\n    items = {\n        \"chips\": {\"price\": 1.50, \"stock\": 10},\n        \"soda\": {\"price\": 1.00, \"stock\": 15},\n        \"candy\": {\"price\": 0.75, \"stock\": 20},\n        \"water\": {\"price\": 0.50, \"stock\": 5}\n    }\n\n    if item not in items:\n        return \"Item not available\"\n\n    item_info = items[item]\n    price = item_info[\"price\"]\n    stock = item_info[\"stock\"]\n\n    if stock == 0:\n        return \"Item out of stock\"\n\n    if money_inserted < price:\n        return \"Insufficient funds\"\n\n    change = money_inserted - price\n    items[item][\"stock\"] -= 1\n\n    return f\"Dispensing {item}, change: ${change:.2f}\"\n"}
{"task_id": "valid/74", "completion": "\n    merged_list = list1 + list2\n    unique_list = []\n    for item in merged_list:\n        if item not in unique_list:\n            unique_list.append(item)\n    return unique_list\n"}
{"task_id": "valid/75", "completion": "\n    count = 0\n    for element in list:\n        if element == target:\n            count += 1\n    return count\n"}
{"task_id": "valid/76", "completion": "\n    encoded_bytes = base64.b64encode(string.encode('utf-8'))\n    encoded_string = encoded_bytes.decode('utf-8')\n    return encoded_string\n"}
{"task_id": "valid/77", "completion": "\n    non_zero_indices = [i for i, value in enumerate(vector) if value != 0]\n    return non_zero_indices\n"}
{"task_id": "valid/78", "completion": "\n    value = 42  # Assign a specific value to the variable\n    \n    # Validate the value\n    if value == 42:\n        print(\"Validation successful: The value is 42.\")\n    else:\n        print(\"Validation failed: The value is not 42.\")\n\nassign_and_validate()\n"}
{"task_id": "valid/79", "completion": "\n    # Convert the word into a list of characters\n    word_list = list(word)\n    \n    # Shuffle the list of characters\n    random.shuffle(word_list)\n    \n    # Join the shuffled list back into a string\n    rearranged_word = ''.join(word_list)\n    \n    return rearranged_word\n"}
{"task_id": "valid/80", "completion": "\n    if isinstance(element, int):\n        return \"Integer\"\n    elif isinstance(element, float):\n        return \"Float\"\n    elif isinstance(element, str):\n        return \"String\"\n    elif isinstance(element, list):\n        return \"List\"\n    elif isinstance(element, dict):\n        return \"Dictionary\"\n    elif isinstance(element, tuple):\n        return \"Tuple\"\n    elif isinstance(element, set):\n        return \"Set\"\n    elif isinstance(element, bool):\n        return \"Boolean\"\n    else:\n        return \"Unknown Type\"\n"}
{"task_id": "valid/81", "completion": "\n    merged_arr = []\n    i = 0\n    while i < len(arr):\n        current_element = arr[i]\n        count = 1\n        while i + 1 < len(arr) and arr[i + 1] == current_element:\n            count += 1\n            i += 1\n        merged_arr.append((current_element, count))\n        i += 1\n    return merged_arr\n"}
{"task_id": "valid/82", "completion": "    # Define the regular expression pattern for tokenization\n    pattern = r'\\b\\w+\\b'  # This pattern matches words\n\n    # Use re.findall to find all tokens in the text\n    tokens = re.findall(pattern, text)\n\n    return tokens"}
{"task_id": "valid/83", "completion": "\n    divisible_numbers = [num for num in numbers if num % 3 == 0 and num % 7 == 0]\n    \n    if not divisible_numbers:\n        print(\"No numbers are divisible by both 3 and 7.\")\n        return\n    \n    average = sum(divisible_numbers) / len(divisible_numbers)\n    max_value = max(divisible_numbers)\n    min_value = min(divisible_numbers)\n    \n    print(f\"Average of numbers divisible by both 3 and 7: {average}\")\n    print(f\"Maximum value: {max_value}\")\n    print(f\"Minimum value: {min_value}\")\n    \n    occurrences = {num: divisible_numbers.count(num) for num in set(divisible_numbers)}\n    print(\"Number of occurrences of each unique number divisible by both 3 and 7:\")\n    for num, count in occurrences.items():\n        print(f\"{num}: {count}\")\n"}
{"task_id": "valid/84", "completion": "\n    words = sentence.split()\n    frequency = {}\n    \n    for word in words:\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    \n    max_frequency = max(frequency.values())\n    highest_frequency_words = [word for word, freq in frequency.items() if freq == max_frequency]\n    \n    return highest_frequency_words[0] if highest_frequency_words else None\n"}
{"task_id": "valid/85", "completion": "\n    e = 0\n    factorial = 1\n    n = 0\n    while True:\n        if n > 0:\n            factorial *= n\n        term = 1 / factorial\n        e += term\n        if term < 10 ** (-decimal_places - 1):\n            break\n        n += 1\n    return round(e, decimal_places)\n"}
{"task_id": "valid/86", "completion": "\n    total_sum = sum(numbers)\n    average = total_sum / len(numbers)\n    return average, total_sum\n"}
{"task_id": "valid/87", "completion": "\n    if not time_series:\n        raise ValueError(\"The time series is empty.\")\n    \n    try:\n        min_value = min(time_series)\n        max_value = max(time_series)\n    except TypeError:\n        raise ValueError(\"The time series contains non-numerical values.\")\n    \n    return (min_value, max_value)\n"}
{"task_id": "valid/88", "completion": "\n    related_counts = {}\n    \n    for entry, related_entries in encyclopedia.items():\n        related_counts[entry] = len(related_entries)\n    \n    return related_counts\n"}
{"task_id": "valid/89", "completion": "\n    max_value = max(lst)\n    return lst.index(max_value)\n"}
{"task_id": "valid/90", "completion": "\n    set1 = set(list1)\n    set2 = set(list2)\n    return not set1.isdisjoint(set2)\n"}
{"task_id": "valid/91", "completion": "\n    root = Element('data')\n    for key, value in dictionary.items():\n        child = Element(key)\n        child.text = str(value)\n        root.append(child)\n    return tostring(root, encoding='unicode')\n"}
{"task_id": "valid/92", "completion": "\n    # 1. Integers in each row are sorted in ascending order from left to right.\n    # 2. Integers in each column are sorted in ascending order from top to bottom.\n    \n    # Given these properties, I need to determine if the target value exists in the matrix.\n    \n    # If the matrix is empty, return False immediately.\n    if not matrix or not matrix[0]:\n        return False\n    \n    # Start from the top-right corner of the matrix.\n    row, col = 0, len(matrix[0]) - 1\n    \n    # Use a while loop to traverse the matrix.\n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            # If the current element is greater than the target, move left.\n            col -= 1\n        else:\n            # If the current element is less than the target, move down.\n            row += 1\n    \n    # If the loop exits without finding the target, return False.\n    return False\n"}
{"task_id": "valid/93", "completion": "\n    total_sum = 0\n    count = 0\n    \n    for num in lst:\n        if num & 1:  # Bitwise check for odd number\n            total_sum += num\n            count += 1\n    \n    if count == 0:\n        return 0, 0  # Return 0 for both sum and average if no odd numbers are found\n    \n    average = total_sum // count  # Integer division for average\n    \n    return total_sum, average\n"}
{"task_id": "valid/94", "completion": "\n    if n < 1 or n > len(lst):\n        return None\n    \n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[n-1]\n"}
{"task_id": "valid/95", "completion": "\n    return sum(lst)\n"}
{"task_id": "valid/96", "completion": "\n    exclusive_elements = set_a.symmetric_difference(set_b)\n    return exclusive_elements\n"}
{"task_id": "valid/97", "completion": "\n    description = (\n        \"This Discord bot is designed to manage and play music in your server. \"\n        \"It offers a variety of features including:\\n\"\n        \"- **Music Playback**: Play, pause, skip, and control the volume of music.\\n\"\n        \"- **Playlist Management**: Create, edit, and delete personal playlists.\\n\"\n        \"- **Server Settings**: Customize bot settings for your server.\\n\"\n        \"- **Command Categorization**: Organize commands into categories for easy navigation.\\n\"\n        \"- **Help Information**: Detailed help for each command.\\n\"\n        \"- **Web App Integration**: Manage playlists and server settings via a web app.\\n\"\n        \"\\n\"\n        \"To get started, use the `!help` command to see a list of available commands and their descriptions.\"\n    )\n    \n    return description\n"}
{"task_id": "valid/98", "completion": "\n    if n == 0:\n        return '0'\n    \n    abs_n = abs(n)\n    ternary = []\n    \n    while abs_n:\n        ternary.append(str(abs_n % 3))\n        abs_n //= 3\n    \n    ternary_str = ''.join(ternary[::-1])\n    \n    if n < 0:\n        return '-' + ternary_str\n    else:\n        return ternary_str\n"}
{"task_id": "valid/99", "completion": "\n    extensions = []\n    for file_name in file_names:\n        if '.' in file_name:\n            extension = file_name.split('.')[-1]\n            extensions.append(extension)\n        else:\n            extensions.append(None)\n    return tuple(extensions)\n"}
{"task_id": "valid/100", "completion": "\n    if age < 0:\n        return \"Invalid age\"\n    elif age <= 1:\n        return \"Infant\"\n    elif age <= 12:\n        return \"Child\"\n    elif age <= 19:\n        return \"Teenager\"\n    elif age <= 64:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n"}
{"task_id": "valid/101", "completion": "\n    if numerical_grade < 0 or numerical_grade > 100:\n        return \"Invalid grade\"\n    \n    letter_grade = (\n        \"A\" if numerical_grade >= 90 else\n        \"B\" if numerical_grade >= 80 else\n        \"C\" if numerical_grade >= 70 else\n        \"D\" if numerical_grade >= 60 else\n        \"F\"\n    )\n    \n    gpa = (\n        4.0 if numerical_grade >= 90 else\n        3.0 if numerical_grade >= 80 else\n        2.0 if numerical_grade >= 70 else\n        1.0 if numerical_grade >= 60 else\n        0.0\n    )\n    \n    return letter_grade, gpa\n"}
{"task_id": "valid/102", "completion": "\n    total = 0\n    for item in listing:\n        total += item['price']\n    return total\n"}
{"task_id": "valid/103", "completion": "\n    vowels = set('aeiou')\n    vowel_count_dict = {}\n    \n    for palindrome in palindrome_tuples:\n        vowel_count = sum(1 for char in palindrome if char in vowels)\n        vowel_count_dict[palindrome] = vowel_count\n    \n    return vowel_count_dict\n"}
{"task_id": "valid/104", "completion": "\n    # Rule 1: If the string has more than 5 characters, reverse the string.\n    if len(s) > 5:\n        s = s[::-1]\n    \n    # Rule 2: If the string contains the letter 'a', replace all occurrences of 'a' with 'A'.\n    if 'a' in s:\n        s = s.replace('a', 'A')\n    \n    # Rule 3: If the string ends with a digit, append 'END' to the string.\n    if s[-1].isdigit():\n        s += 'END'\n    \n    # Rule 4: If the string starts with a vowel (a, e, i, o, u), convert the entire string to uppercase.\n    if s[0].lower() in 'aeiou':\n        s = s.upper()\n    \n    return s\n"}
{"task_id": "valid/105", "completion": "\n    seen = set()\n    for num in arr:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n"}
{"task_id": "valid/106", "completion": "\n    latest_versions = {}\n    \n    for package, version in dependencies:\n        version_id, timestamp = version.split('_auto_')\n        if package not in latest_versions:\n            latest_versions[package] = (version_id, timestamp)\n        else:\n            current_version_id, current_timestamp = latest_versions[package]\n            if timestamp > current_timestamp:\n                latest_versions[package] = (version_id, timestamp)\n    \n    return [(package, f\"{version_id}_auto_{timestamp}\") for package, (version_id, timestamp) in latest_versions.items()]\n"}
{"task_id": "valid/107", "completion": "\n    categorized_causes = {}\n\n    for cause in causes:\n        action, result = cause.split(\" \", 1)\n        if action in categorized_causes:\n            categorized_causes[action].append(result)\n        else:\n            categorized_causes[action] = [result]\n\n    return categorized_causes\n"}
{"task_id": "valid/108", "completion": "\n    code_name = name.replace(\" \", \"-\").lower()\n    return code_name\n"}
{"task_id": "valid/109", "completion": "\n    non_ascii_chars = [char for char in text if ord(char) > 127]\n    return non_ascii_chars\n"}
{"task_id": "valid/110", "completion": "\n    import string\n    return string.translate(str.maketrans('', '', string.punctuation))\n"}
{"task_id": "valid/111", "completion": "\n    try:\n        result = [x ** exp for x in num_list]\n    except TypeError as e:\n        print(f\"Error: {e}. Please ensure all elements in the list are numbers.\")\n        return None\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n        return None\n    else:\n        return result\n"}
{"task_id": "valid/112", "completion": "\n    for row in grid:\n        min_value = min(row)\n        print(min_value)\n"}
{"task_id": "valid/113", "completion": "\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    if current_num >= 2 * n:\n        return\n    \n    if current_num % 2 == 0:\n        print(\"Thank you\")\n    \n    print_thank_you(n, current_num + 1)\n"}
{"task_id": "valid/114", "completion": "\n    count = 0\n    max_count = 0\n    \n    for item in lst:\n        if item == element:\n            count += 1\n            if count > max_count:\n                max_count = count\n        else:\n            count = 0\n    \n    return max_count\n"}
{"task_id": "valid/115", "completion": "\n    # Convert the number to the specified base and check if all digits are the same\n    digits = [int(d) for d in str(num)] if base == 10 else [int(d, base) for d in str(num)]\n    return all(d == digits[0] for d in digits)\n"}
{"task_id": "valid/116", "completion": "\n    if not s:\n        return s\n    elif s[0] in 'aeiouAEIOU':\n        return remove_vowels_recursive(s[1:])\n    else:\n        return s[0] + remove_vowels_recursive(s[1:])\n"}
{"task_id": "valid/117", "completion": "\n    help_message = \"Usage: my_app [OPTIONS]\\n\\nOptions:\\n\"\n    for option, description in options:\n        help_message += f\"  --{option:<20} {description}\\n\"\n    return help_message\n"}
{"task_id": "valid/118", "completion": "\n    if input_string:\n        return input_string[0]\n    else:\n        return None\n"}
{"task_id": "valid/119", "completion": "\n    def count_val(Val):\n        \"\"\"\n        Write a function to generate a table of counts of a given value in an input array.\n        \"\"\"\n        counts = {}\n        for value in Val:\n            if value in counts:\n                counts[value] += 1\n            else:\n                counts[value] = 1\n        return counts\n"}
{"task_id": "valid/120", "completion": "\n    inverted_bitset = ~sample_bitset & 0xFF  # Assuming 8-bit bitset\n    return inverted_bitset\n"}
{"task_id": "valid/121", "completion": "\n    vowels = set('aeiouAEIOU')\n    return all(char in vowels for char in s)\n"}
{"task_id": "valid/122", "completion": "\n    count = 0\n    sub_len = len(subsequence)\n    seq_len = len(sequence)\n    \n    for i in range(seq_len - sub_len + 1):\n        if sequence[i:i + sub_len] == subsequence:\n            count += 1\n    \n    return count\n"}
{"task_id": "valid/123", "completion": "\n    if t == 0:\n        raise ValueError(\"The divisor cannot be zero.\")\n    \n    if h < 0:\n        h = -h\n        negative_result = True\n    else:\n        negative_result = False\n    \n    if t < 0:\n        t = -t\n        negative_result = not negative_result\n    \n    quotient = 0\n    while h >= t:\n        h -= t\n        quotient += 1\n    \n    if negative_result:\n        quotient = -quotient\n    \n    return quotient\n"}
{"task_id": "valid/124", "completion": "\n    total = 0\n    for num in input_list:\n        if num % 2 != 0:\n            total += num\n    return total\n"}
{"task_id": "valid/125", "completion": "\n    vowels = \"aeiouAEIOU\"\n    consonant_count = 0\n\n    for char in string:\n        if char.isalpha() and char not in vowels:\n            consonant_count += 1\n\n    return consonant_count\n"}
{"task_id": "valid/126", "completion": "\n    # Calculate the number of electrons based on the given energy values\n    num_electrons = np.sum(ados * grid_energies)\n    \n    # Adjust the number of electrons based on the doping levels\n    num_electrons += dope * dos_grid_size\n    \n    return num_electrons\n"}
{"task_id": "valid/127", "completion": "\n    return tuple(set(tuple_to_process))\n"}
{"task_id": "valid/128", "completion": "\n    n = len(arr)\n    if n <= 1:\n        return arr\n    \n    # Sort the array to easily pick the largest and smallest elements\n    arr.sort()\n    \n    # Initialize the result array\n    result = [0] * n\n    \n    # Use two pointers to place the largest and smallest elements alternately\n    left, right = 0, n - 1\n    for i in range(n):\n        if i % 2 == 0:\n            result[i] = arr[right]\n            right -= 1\n        else:\n            result[i] = arr[left]\n            left += 1\n    \n    return result\n"}
{"task_id": "valid/129", "completion": "\n    color_dict = {}\n    for color_name, color_value in color_list:\n        color_dict[color_name] = color_value\n    return color_dict\n"}
{"task_id": "valid/130", "completion": "\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in string:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if stack == [] or mapping[char] != stack.pop():\n                return False\n        else:\n            continue\n    \n    return stack == []\n"}
{"task_id": "valid/131", "completion": "\n    unique_elements = []\n    count = 0\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n            count += 1\n            if count == 3:\n                break\n    return unique_elements\n"}
{"task_id": "valid/132", "completion": "\n    sorted_list = sorted(fruit_list)\n    return ', '.join(sorted_list)\n"}
{"task_id": "valid/133", "completion": "\n    sublists = []\n    n = len(lst)\n    for i in range(2**n):\n        sublist = [lst[j] for j in range(n) if (i & (1 << j))]\n        sublists.append(sublist)\n    return sublists\n"}
{"task_id": "valid/134", "completion": "    pattern = r'\\d\\.\\d'\n    return bool(re.search(pattern, string))"}
{"task_id": "valid/135", "completion": "\n    from django.db import migrations, models\n\n    def alter_field(apps, schema_editor):\n        CommitteeMember = apps.get_model(app_name, model_name)\n        if schema_editor.connection.vendor.startswith('mysql'):\n            # MySQL-specific operations\n            schema_editor.execute(\"ALTER TABLE {table_name} MODIFY {field_name} {new_field_type};\".format(\n                table_name=CommitteeMember._meta.db_table,\n                field_name=field_name,\n                new_field_type='NEW_FIELD_TYPE'  # Replace with the desired new field type\n            ))\n        else:\n            # Generic operations for other databases\n            schema_editor.alter_field(CommitteeMember, CommitteeMember._meta.get_field(field_name), models.NEW_FIELD_TYPE())  # Replace with the desired new field type\n\n    class Migration(migrations.Migration):\n        dependencies = [\n            # List any dependencies here\n        ]\n\n        operations = [\n            migrations.RunPython(alter_field),\n        ]\n"}
{"task_id": "valid/136", "completion": "\n    # Convert both lists to sets to find common elements\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Calculate the sum of the common elements\n    common_elements_sum = sum(common_elements)\n    \n    return common_elements_sum\n"}
{"task_id": "valid/137", "completion": "\n    # Calculate the length of the dataset\n    dataset_length = len(df)\n    \n    # Calculate 1% of the dataset length\n    one_percent_length = dataset_length * 0.01\n    \n    # Round up to the nearest integer\n    forecast_period = math.ceil(one_percent_length)\n    \n    return forecast_period\n"}
{"task_id": "valid/138", "completion": "\n    return sorted(array, key=lambda x: x.get(attr))\n"}
{"task_id": "valid/139", "completion": "\n    start_index = (page_number - 1) * items_per_page\n    end_index = start_index + items_per_page\n    return items[start_index:end_index]\n"}
{"task_id": "valid/140", "completion": "\n    result = []\n    carry = 0\n    \n    for digit in reversed(n_str):\n        # Convert the current digit to an integer\n        current_digit = int(digit)\n        \n        # Double the current digit and add the carry\n        doubled_digit = current_digit * 2 + carry\n        \n        # Determine the new digit and the new carry\n        new_digit = doubled_digit % 10\n        carry = doubled_digit // 10\n        \n        # Append the new digit to the result\n        result.append(str(new_digit))\n    \n    # If there's a carry left after the last digit, add it\n    if carry:\n        result.append(str(carry))\n    \n    # The result is currently reversed, so reverse it back\n    result.reverse()\n    \n    # Join the list into a string and return it\n    return ''.join(result)\n"}
{"task_id": "valid/141", "completion": "\n    presets = {\n        \"home\": (0.0, 0.0, 0.0),\n        \"pick\": (1.0, 2.0, 0.5),\n        \"place\": (3.0, 4.0, 0.5),\n        \"avoid\": (-1.0, -2.0, -0.5)\n    }\n\n    if preset_name in presets:\n        return presets[preset_name]\n    else:\n        raise ValueError(f\"Preset '{preset_name}' not found.\")\n"}
{"task_id": "valid/142", "completion": "\n    common_elements = set(list1) & set(list2)\n    if not common_elements:\n        return 0\n    product = 1\n    for element in common_elements:\n        product *= element\n    return product\n"}
{"task_id": "valid/143", "completion": "\n    if allow_multiple_answer:\n        print(\"The quiz allows multiple answers per question.\")\n    else:\n        print(\"The quiz allows only one answer per question.\")\n\n    if zoom_level > 100:\n        print(\"The zoom level is set to a high value, which may cause the text to be too small to read.\")\n    elif zoom_level < 50:\n        print(\"The zoom level is set to a low value, which may cause the text to be too large to fit on the screen.\")\n    else:\n        print(\"The zoom level is set to a moderate value, which should be comfortable for most users.\")\n"}
{"task_id": "valid/144", "completion": "\n    return math.floor(num)\n"}
{"task_id": "valid/145", "completion": "\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in sentence if char not in vowels])\n"}
{"task_id": "valid/146", "completion": "\n    def is_alphabetic(key):\n        return all(c.isalpha() for c in key)\n\n    def merge_nested(a, b):\n        merged = {}\n        keys = set(a.keys()).union(b.keys())\n        for key in keys:\n            if is_alphabetic(key):\n                if isinstance(a.get(key), dict) and isinstance(b.get(key), dict):\n                    merged[key] = merge_nested(a[key], b[key])\n                else:\n                    merged[key] = b.get(key) if key in b else a.get(key)\n        return merged\n\n    merged = merge_nested(a, b)\n    sorted_keys = sorted(merged.keys())\n    sorted_merged = {key: merged[key] for key in sorted_keys}\n    return sorted_merged\n"}
{"task_id": "valid/147", "completion": "\n    try:\n        def _find_max_in_dict(d):\n            max_value = float('-inf')\n            for key, value in d.items():\n                if isinstance(value, dict):\n                    max_value = max(max_value, _find_max_in_dict(value))\n                else:\n                    max_value = max(max_value, value)\n            return max_value\n        \n        return _find_max_in_dict(d)\n    except (TypeError, ValueError, AttributeError) as e:\n        print(f\"An error occurred: {e}\")\n        return None\n"}
{"task_id": "valid/148", "completion": "\n    if key in dict:\n        values = dict[key]\n        avg = sum(values) / len(values)\n        return avg\n    else:\n        return None\n"}
{"task_id": "valid/149", "completion": "\n    if not string:\n        return None\n    return string.replace('e', '*')\n"}
{"task_id": "valid/150", "completion": "\n    if n <= 0:\n        return []\n    \n    # Use heapq.nsmallest to find the n smallest items\n    smallest_items = heapq.nsmallest(n, lst)\n    \n    return smallest_items\n"}
{"task_id": "valid/151", "completion": "\n    if x <= 0:\n        return False\n    root = int(sqrt(x))\n    return root * root == x\n"}
{"task_id": "valid/152", "completion": "\n    return date + datetime.timedelta(days=10)\n"}
