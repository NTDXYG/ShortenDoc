{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    if ch in s:\n        s.remove(ch)\n        s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum)\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the input string into words\n    words = words.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the most common word and its count\n    most_common_word = word_counts.most_common(1)[0]\n    \n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    # Calculate the volume of the triangular prism\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'[a-z]+', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.findall(r'[a-z]+_[a-z]+', text)\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string2]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # A Woodall number is a number n such that n = 2^(k-1) * (2^k - 1) for some k.\n    # We can check if a number is Woodall by checking if it can be expressed in this form.\n    # We can do this by iterating over all possible values of k and checking if the number\n    # can be expressed as 2^(k-1) * (2^k - 1).\n    k = 1\n    while True:\n        # Calculate the value of the Woodall number for the current k.\n        woodall_num = 2 ** (k - 1) * (2 ** k - 1)\n        # If the given number is equal to the Woodall number, return True.\n        if x == woodall_num:\n            return True\n        # If the given number is greater than the Woodall number, increment k and try again.\n        elif x > woodall_num:\n            k += 1\n        # If the given number is less than the Woodall number, the number is not Woodall, so return False.\n        else:\n            return False\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i for i in range(n, m*n+1, n)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(lst) for lst in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize product as 1\n    product = 1\n    # Iterate over the dictionary\n    for num, count in freq.items():\n        # If the count is 1, multiply the product by the number\n        if count == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # Taking advantage of symmetry\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element has odd frequency, return None\n    return None\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a heap to store the top k integers\n    heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(heap, (-count, num))\n\n        # If the heap size exceeds k, pop the smallest integer from the heap\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    # Return the top k integers\n    return [num for _, num in heap]\n\n"}
{"task_id": "MBPP/32", "completion": "\n    # Initialize the largest prime factor\n    max_prime_factor = 1\n\n    # Iterate from 2 to sqrt(n)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # Update the largest prime factor\n            max_prime_factor = i\n            # Divide n by i\n            n = n // i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        # Update the largest prime factor\n        max_prime_factor = n\n\n    return max_prime_factor\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    # Calculate the sum of the first N natural numbers\n    total_sum = N * (N + 1) // 2\n    \n    # Calculate the sum of the numbers in the array\n    array_sum = sum(ar)\n    \n    # The missing number is the difference between the total sum and the array sum\n    missing_num = total_sum - array_sum\n    \n    return missing_num\n"}
{"task_id": "MBPP/35", "completion": "\n    i = 1\n    while True:\n        rect_num = i * (i + 1) // 2\n        if rect_num == n:\n            return i\n        elif rect_num > n:\n            return None\n        i += 1\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a decimal\n    decimal = p / q\n    \n    # Convert the decimal to a string\n    decimal_str = str(decimal)\n    \n    # Remove the leading 0.\n    decimal_str = decimal_str[2:]\n    \n    # Find the nth digit\n    nth_digit = decimal_str[N-1]\n    \n    return nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Use the sorted function with a custom sorting key\n    # The key function returns a tuple for each element in the list\n    # The first element of the tuple is the element itself (for strings, this will be the string itself, and for integers, this will be the integer)\n    # The second element of the tuple is the type of the element (for strings, this will be a string, and for integers, this will be an integer)\n    # The sorted function will first sort by the first element of the tuple, and then by the second element\n    # This means that strings will come before integers, and integers will be sorted in ascending order\n    return sorted(mixed_list, key=lambda x: (x, type(x)))\n"}
{"task_id": "MBPP/38", "completion": "\n    even_count = 0\n    odd_count = 0\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if even_count > 0 and odd_count > 0:\n        even_num = list1[even_count - 1]\n        odd_num = list1[odd_count - 1]\n        return even_num / odd_num\n    elif even_count > 0:\n        return list1[even_count - 1]\n    elif odd_count > 0:\n        return list1[odd_count - 1]\n    else:\n        return \"List is empty or contains only one number\"\n"}
{"task_id": "MBPP/39", "completion": "\n    if len(S) <= 1:\n        return True\n    count = Counter(S)\n    max_heap = []\n    for char, freq in count.items():\n        heapq.heappush(max_heap, (-freq, char))\n    while len(max_heap) > 1:\n        freq1, char1 = heapq.heappop(max_heap)\n        freq2, char2 = heapq.heappop(max_heap)\n        if freq1 + 1 < 0:\n            heapq.heappush(max_heap, (freq1 + 1, char1))\n        if freq2 + 1 < 0:\n            heapq.heappush(max_heap, (freq2 + 1, char2))\n        if char1 == char2:\n            return False\n    return True\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = chain(*nums)\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"[a-z]+_[a-z]+\"\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    return re.match(pattern, text)\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in range(1, len(x)):\n        result = gcd(result, x[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(A) % 10 / factorial(B) % 10\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n & -n\n"}
{"task_id": "MBPP/49", "completion": "\n    result = []\n    for i in range(N):\n        if i == 0:\n            result.append(nums[i][0])\n        else:\n            result.append(nums[i][N-i])\n    return result\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)  # return the list with minimum length\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    # Check if the string is empty\n    if len(str) == 0:\n        return False\n    # Check if the first and last characters are equal\n    return str[0] == str[-1]  # str[-1] is used to get the last character of the string\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum element in the array\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrences of each element in the array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, len(count_array)):\n        count_array[i] += count_array[i - 1]\n    \n    # Create a sorted array\n    sorted_array = [0] * len(my_list)\n    \n    # Build the sorted array\n    for num in my_list:\n        sorted_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return sorted_array\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\nWrite a python function to check if a given number is one less than twice its reverse.\n    \"\"\"\n    return n == 2 * rev(n) - 1\n\n"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    max_num = 0\n    for i in range(n-1, -1, -1):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)  # This will return True if the signs are opposite and False otherwise\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 1) // 2\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    max_len = 1\n    curr_len = 1\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] == 1:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    return max(max_len, curr_len)  # Return the maximum length of the subsequence\n"}
{"task_id": "MBPP/61", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize the maximum difference\n    max_diff = 0\n    \n    # Iterate over the sorted list to find the maximum difference\n    for i in range(1, len(test_list)):\n        # Calculate the difference between the current and previous elements\n        diff = test_list[i] - test_list[i-1]\n        \n        # Update the maximum difference if the current difference is larger\n        max_diff = max(max_diff, diff)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n"}
{"task_id": "MBPP/65", "completion": "\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    # Initialize a list to store the bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    \n    # Calculate the bell numbers\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[i] += bell[j] * (i - j) ** (j + 1)\n    \n    # The number of ways to partition a set of bell numbers is the sum of the bell numbers\n    return sum(bell)\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n    for i in range(n-1):\n        if A[i] > A[i+1]:\n            increasing = False\n        if A[i] < A[i+1]:\n            decreasing = False\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    return all(len(i) == k for i in Input)\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if (n - i**2) >= 0 and (n - i**2) % i == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,\\s\\|\\-\\+]'\n    # Split the text using the delimiters\n    result = re.split(delimiters, text)\n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    # Convert the number to string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize sum of even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Iterate over each digit in the number\n    for digit in str_n:\n        # Convert the digit back to integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd\n        if int_digit % 2 == 0:\n            # If even, add to even sum\n            even_sum += int_digit\n        else:\n            # If odd, add to odd sum\n            odd_sum += int_digit\n    \n    # Return the difference between even and odd sums\n    return even_sum - odd_sum\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return ''.join(chr(ord(c) + 1) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1:\n        return 1\n    else:\n        return sequence(n-1) + sequence(n//2) if n%2 else sequence(n-1) + sequence(n//2 + 1)  # <--- changed this line\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)  # This is the formula for the nth centered hexagonal number\n\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max((n-1 for n in N if n > 0), default=None)  # or return None if no such number exists\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    return sub_str in str1\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a flag to track if the number is undulating\n    is_undulating = False\n    \n    # Iterate over the digits in the number\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is less than the next digit\n        if int(str_n[i]) < int(str_n[i + 1]):\n            # If it is, set the flag to True\n            is_undulating = True\n        # Check if the current digit is greater than the next digit\n        elif int(str_n[i]) > int(str_n[i + 1]):\n            # If it is, set the flag to False\n            is_undulating = False\n            # Break out of the loop since we've found a non-undulating pair\n            break\n    \n    # Return the flag\n    return is_undulating\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    # Use the min function with a custom key to find the index of the minimum value\n    min_index = min(enumerate(test_list), key=itemgetter(1))[0]\n    return min_index\n\n"}
{"task_id": "MBPP/95", "completion": "\n    return min(len(sublist) for sublist in lst)\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers) if numbers else 0\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n)[2:]\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    # Split the string into words by underscore\n    words = re.split('_+', word)\n    # Capitalize the first letter of each word except the first one\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n    # Join the words together\n    return ''.join(words)\n\n"}
{"task_id": "MBPP/103", "completion": "\n    # Initialize the result\n    result = 0\n    # Calculate the sum of the first m terms of the sequence\n    for i in range(1, m + 1):\n        # Calculate the ith term of the sequence\n        term = (i ** n) // (i - 1)\n        # Add the term to the result\n        result += term\n    # Return the result\n    return result\n"}
{"task_id": "MBPP/104", "completion": "\n    return [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)  # count() method returns the number of occurrences of a value in the list\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the list to a tuple\n    test_tup = list(test_tup) + test_list\n    # Convert the tuple back to a list\n    test_tup = tuple(test_tup)\n    return test_tup\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap to store the elements from the three sorted lists\n    min_heap = []\n    \n    # Push the first element from each list into the min heap along with the list index and element index\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 1, 0))\n    heapq.heappush(min_heap, (num3[0], 2, 0))\n    \n    # Initialize the result list\n    result = []\n    \n    # While the min heap is not empty\n    while min_heap:\n        # Pop the smallest element from the min heap\n        val, list_idx, elem_idx = heapq.heappop(min_heap)\n        \n        # Add the popped element to the result list\n        result.append(val)\n        \n        # If there are more elements in the list from which the element was popped\n        if elem_idx + 1 < len(num1) if list_idx == 0 else elem_idx + 1 < len(num2) if list_idx == 1 else elem_idx + 1 < len(num3):\n            # Push the next element from the list into the min heap\n            if list_idx == 0:\n                heapq.heappush(min_heap, (num1[elem_idx + 1], 0, elem_idx + 1))\n            elif list_idx == 1:\n                heapq.heappush(min_heap, (num2[elem_idx + 1], 1, elem_idx + 1))\n            else:\n                heapq.heappush(min_heap, (num3[elem_idx + 1], 2, elem_idx + 1))\n    \n    # Return the result list\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(int(s[i:], 2) + int(s[:i], 2)).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    for i in range(strt_val, stop_val + 1):\n        if i not in test_list:\n            missing_ranges.append(str(i) + '-' + str(i))\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    return all(not dict1 for dict1 in list1)  # True if all dicts are empty, False otherwise\n"}
{"task_id": "MBPP/116", "completion": "\n    # Convert the tuple into a string\n    str_nums = str(nums)\n    # Remove the parentheses\n    str_nums = str_nums.replace(\"(\", \"\").replace(\")\", \"\")\n    # Convert the string back into an integer\n    result = int(str_nums)\n    return result\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) if isinstance(i, (int, float)) else i for i in test_list]\n"}
{"task_id": "MBPP/118", "completion": "\n    return list(string)\n"}
{"task_id": "MBPP/119", "completion": "\n    for i in range(n):\n        if i == 0 or arr[i] != arr[i - 1]:\n            if i == 0 or arr[i] != arr[i - 1]:\n                print(arr[i])\n                return\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize the list to store smart numbers\n    smartNumbers = []\n    # Initialize the counter\n    counter = 1\n    # Initialize the number\n    num = 1\n    # Loop until we find the nth smart number\n    while len(smartNumbers) < n:\n        # Check if the number is a smart number\n        if isSmart(num):\n            # If it is, add it to the list\n            smartNumbers.append(num)\n        # Increment the number\n        num += 1\n    # Return the nth smart number\n    return smartNumbers[-1]\n\n"}
{"task_id": "MBPP/123", "completion": "\nCalculate the sum of proper divisors of a number.\"\"\"\n        return sum(i for i in range(1, n) if n % i == 0)\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        n = sum_proper_divisors(i)\n        m = sum_proper_divisors(n)\n        if i != m and i < m and m < limit and sum_proper_divisors(i) == m:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)  # Return the sum of all amicable numbers\n\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))  # Using cmath.phase() to get the phase (angle) of a complex number\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    count = 0\n    for char in string:\n        if char == '0':\n            count -= 1\n        else:\n            count += 1\n        max_diff = max(max_diff, abs(count))\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Find the common divisors of a and b\n    common_divisors = [i for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0]\n    \n    # Calculate the sum of the common divisors\n    sum_of_common_divisors = sum(common_divisors)\n    \n    return sum_of_common_divisors\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    while y > 0:\n        if y % 2 == 1:\n            result += x\n        x <<= 1\n        y >>= 1\n    return result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]  # This line is already correct\n"}
{"task_id": "MBPP/129", "completion": "\n    n = len(my_matrix)\n    if n != len(my_matrix[0]):\n        return \"Error: Matrix is not a square matrix.\"\n    if n != len(my_matrix[0]):\n        return \"Error: Matrix is not a square matrix.\"\n    if n == 1:\n        return my_matrix[0][0]\n    if n == 2:\n        return my_matrix[0][0] + my_matrix[1][1]\n    if n == 3:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2]\n    if n == 4:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3]\n    if n == 5:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3] + my_matrix[4][4]\n    if n == 6:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3] + my_matrix[4][4] + my_matrix[5][5]\n    if n == 7:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3] + my_matrix[4][4] + my_matrix[5][5] + my_matrix[6][6]\n    if n == 8:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3] + my_matrix[4][4] + my_matrix[5][5] + my_matrix[6][6] + my_matrix[7][7]\n    if n == 9:\n        return my_matrix[0][0] + my_matrix[1][1] + my_matrix[2][2] + my_matrix[3][3] + my_matrix[4][4] + my_matrix[5][5] + my_matrix[6][6] + my_matrix[7][7] + my_matrix[8][8]\n    return \"Error: Matrix size is not supported.\"  # Added this line\n"}
{"task_id": "MBPP/130", "completion": "\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    return max(freq, key=freq.get)\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left = 0\n    right = len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))  # filter() function returns an iterator, so we use sum() to calculate the sum of the negative numbers. The lambda function x < 0 is used to filter out the negative numbers.  # noqa: E501\n"}
{"task_id": "MBPP/134", "completion": "\n    for _ in range(p):\n        arr[-1] = arr[-1] % 2\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    # Define the base rate and the rate per unit\n    base_rate = 100\n    rate_per_unit = 1.5\n\n    # Calculate the total bill\n    total_bill = base_rate + (units * rate_per_unit)\n\n    return total_bill\n"}
{"task_id": "MBPP/137", "completion": "\n    return nums.count(0) / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0's\n    return '0' not in binary\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for element in test_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    # Create a list to store the elements that occur singly\n    singly_list = []\n    for key, value in freq_dict.items():\n        if value == 1:\n            singly_list.append(key)\n\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:size]))\n        \n        # If the maximum element is not at the beginning of the unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip the maximum element to the beginning\n            nums[:max_index + 1] = nums[:max_index + 1][::-1]\n            # Flip the unsorted part of the list\n            nums[:size] = nums[:size][::-1]\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for the same pair\n    count = 0\n    # Iterate over the first list\n    for i in list1:\n        # Iterate over the second list\n        for j in list2:\n            # Check if the pair (i, j) exists in the third list\n            if (i, j) in list3 or (j, i) in list3:\n                # If the pair exists, increment the counter\n                count += 1\n    # Return the count of the same pair\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    # Initialize sum of absolute differences\n    sum_abs_diff = 0\n    # Iterate over the array\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the absolute difference and add it to the sum\n            sum_abs_diff += abs(arr[i] - arr[j])\n    return sum_abs_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    # Initialize the maximum difference\n    max_diff = 0\n    # Iterate over the array to find the maximum difference\n    for i in range(1, n):\n        # Calculate the difference between the current element and the previous element\n        diff = arr[i] - arr[i - 1]\n        # Update the maximum difference if the current difference is greater\n        max_diff = max(max_diff, diff)\n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 1):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n    return tri[0][0]  # return the maximum path sum\n"}
{"task_id": "MBPP/148", "completion": "\n    if x == 0:\n        return 0\n    max_sum = 0\n    for i in range(1, x):\n        left_sum = sum(int(digit) for digit in str(i))\n        right_sum = sum(int(digit) for digit in str(x - i))\n        max_sum = max(max_sum, left_sum + right_sum)\n    return max_sum\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) - 1  # subtract 1 because we want the length of the subsequence, not the maximum value in dp\n\n"}
{"task_id": "MBPP/150", "completion": "\n    n = 1\n    while True:\n        if a in [n, n + 1, n + 2, n + 3]:\n            return True\n        n += 4\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\nWrite a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) <= 1:\n        return x\n    mid = len(x) // 2\n    left = merge_sort(x[:mid])\n    right = merge_sort(x[mid:])\n    return merge(left, right)\n\n"}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    specified = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                specified.append(nums[i][j])\n    return specified\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Sort the array\n    arr.sort()\n    # Initialize the result\n    res = 0\n    # Calculate the median\n    median = arr[n // 2]\n    # Iterate over the array\n    for i in range(n):\n        # Add the absolute difference between the current element and the median to the result\n        res += abs(arr[i] - median)\n    # Return the result\n    return res\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    else:\n        return x * (n // gcd), y * (n // gcd)  # return x and y\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    sum = 0\n    i = n\n    while i >= 0:\n        sum += i\n        i -= 2\n    return sum\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * s * tan(pi / l)) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_div = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_div += i\n    return sum_div\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    char_count = {}\n    for i in range(len(str1)):\n        if str1[i] in char_count:\n            char_count[str1[i]] += 1\n        else:\n            char_count[str1[i]] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)  # count() is a built-in method in python that returns the number of occurrences of a specified value in a list. \n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])  # Include n in the range\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for i in range(len(s)):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^A-Za-z0-9]+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for k, v in l:\n        if k in d:\n            d[k].append(v)\n        else:\n            d[k] = [v]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] < R[j] and R[i] < L[j] and L[i] <= L[j] <= R[j] or R[i] <= R[j] <= L[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= L[j] <= R[j] or L[i] <= R[j] <= L[j] <= R[i]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= R[j] <= L[j] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[j] <= R[i] <= L[j] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= L[j] <= R[j] or R[i] <= R[j] <= L[j] <= L[i]:\n                return [L[i], L[j]]\n            elif L[i] <= R[j] <= L[j] <= R[i] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= R[j] <= L[j] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[j] <= R[i] <= L[j] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= L[j] <= R[j] or R[i] <= R[j] <= L[j] <= L[i]:\n                return [L[i], L[j]]\n            elif L[i] <= R[j] <= L[j] <= R[i] or R[i] <= L[j] <= L[i] <= R[j]:\n                return [L[i], L[j]]\n            elif L[i] <= R[i] <= R[j] <= L[j] or R"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Initialize the sum of divisors\n    sum_divisors = 0\n    # Loop through all numbers from 1 to x\n    for i in range(1, x):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If it is, add it to the sum\n            sum_divisors += i\n    # If the sum of divisors is equal to the number, it's a keith number\n    return sum_divisors == x\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n    # Radius of the Earth in kilometers\n    R = 6371\n    return R * c\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Define the pattern for each type of character\n    uppercase_pattern = r'[A-Z]'\n    lowercase_pattern = r'[a-z]'\n    special_pattern = r'[^A-Za-z0-9]'\n    numeric_pattern = r'\\d'\n\n    # Find all matches for each pattern in the string\n    uppercase_matches = re.findall(uppercase_pattern, string)\n    lowercase_matches = re.findall(lowercase_pattern, string)\n    special_matches = re.findall(special_pattern, string)\n    numeric_matches = re.findall(numeric_pattern, string)\n\n    # Return the matches\n    return uppercase_matches, lowercase_matches, special_matches, numeric_matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    count = 0\n    i = 0\n    j = 1\n    while j < n:\n        if arr[j] - arr[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif arr[j] - arr[i] < k:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]  # Using list comprehension for a more concise solution\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus coordinates\n    focus_x = -focal_length\n    focus_y = 0\n    \n    return (focus_x, focus_y)\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequence of substrings.\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index + 1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character is part of LCS\n        if X[i - 1] == Y[j - 1]:\n            lcs[index - 1] = X[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    for i in range(1, int(n**0.5) + 1):\n        if n % (i * i) == 0:\n            return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers in the array\n    num_set = set()\n    for num in arr:\n        if num > 0:\n            num_set.add(num)\n    \n    # Initialize the first missing positive number as 1\n    first_missing = 1\n    \n    # Iterate from 1 to n (inclusive) to find the first missing positive number\n    while first_missing in num_set:\n        first_missing += 1\n    \n    return first_missing\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points in the square\n    count = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    return month_days.get(monthname3, None) == 30\n"}
{"task_id": "MBPP/192", "completion": "\n    if any(char.isalpha() for char in str) and any(char.isdigit() for char in str):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Initialize the result as 1\n    result = 1\n    # Iterate over the elements of the first tuple\n    for i in test_tup1:\n        # For each element, multiply the result by the corresponding element in the second tuple\n        result *= test_tup2[i]\n    # Return the final result\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major axis\n    a = a / 2\n    # Calculate the semi-minor axis\n    b = b / 2\n    # Calculate the area of the ellipse\n    area = math.pi * a * b\n    # Calculate the area of the largest triangle\n    triangle_area = area / 2\n    # Return the area of the largest triangle\n    return triangle_area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (1 << i) <= n:\n        i += 1\n    return 1 << (i - 1)  # return the highest power of 2 less than or equal to n\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    return [i for i, x in enumerate(list1) if x == max_val]\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)  # count() is a built-in string method in Python\n"}
{"task_id": "MBPP/205", "completion": "\n    inversions = []\n    for tup in test_tup:\n        for i in range(len(tup)):\n            for j in range(i + 1, len(tup)):\n                if tup[i] > tup[j]:\n                    inversions.append((tup[i], tup[j]))\n    return inversions\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for tup in test_tup:\n        new_tup = []\n        for i in range(len(tup)):\n            if i == 0:\n                new_tup.append(tup[i])\n            elif i == len(tup) - 1:\n                new_tup.append(tup[i])\n            else:\n                new_tup.append(tup[i] + tup[i - 1] + tup[i + 1])\n        result.append(new_tup)\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[n][n] - 1\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))  # return True or False\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)  # O(log n) time complexity\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    return bool(pattern.match(string))\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if (i & (1 << n)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum(i**4 for i in range(1, n+1))\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return test_tup1 + test_tup2\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.extend([char] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    # Check if both lists are lists\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    # Check if all elements in list1 are in list2\n    for element in list1:\n        if not isinstance(element, list):\n            if element not in list2:\n                return False\n        else:\n            if not check_subset_list(element, list2):\n                return False\n\n    return True\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str:\n        if char_count[char] > 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    \n    # Calculate the minimum operations required\n    min_operations = math.ceil(diff / 2)\n    \n    return min_operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple into a list\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the minimum k elements\n    min_k = test_list[:K]\n    \n    # Extract the maximum k elements\n    max_k = test_list[-K:]\n    \n    # Return the minimum and maximum k elements\n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, or dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n    \n    # Sort the matches by their position in the text\n    matches.sort(key=text.find)\n    \n    # Replace the first n occurrences with a colon\n    for i in range(min(n, len(matches))):\n        text = text.replace(matches[i], ':', 1)\n    \n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    return len(set(type(x) for x in test_tuple)) == 1\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize the count of majority element\n    count = 0\n    # Initialize the index of majority element\n    idx = -1\n    # Iterate over the array\n    for i in range(n):\n        # If the count is zero, set the index to the current element\n        if count == 0:\n            idx = i\n            count = 1\n        # If the current element is the same as the majority element, increment the count\n        elif arr[i] == arr[idx]:\n            count += 1\n        # If the current element is different from the majority element, decrement the count\n        else:\n            count -= 1\n    # Check if the majority element is the same as the last element in the array\n    if arr[idx] == arr[n - 1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    if high < low:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    elif arr[mid] < arr[low]:\n        return find_Min(arr, low, mid - 1)\n    else:\n        return arr[mid]\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for i, char in enumerate(str) if i % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)  # return the smallest of the three numbers\n"}
{"task_id": "MBPP/228", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Pad the binary string with leading zeros to make it of length r-l+1\n    binary = binary.zfill(r-l+1)\n    \n    # Check if all the bits in the given range are unset\n    return all(bit == '0' for bit in binary[l-1:r])\n"}
{"task_id": "MBPP/229", "completion": "\n    # Separate the array into two lists, one for negative numbers and one for positive numbers\n    negative = [x for x in arr if x < 0]\n    positive = [x for x in arr if x >= 0]\n    \n    # Combine the two lists to get the final result\n    return negative + positive\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Iterate over each element in the current row\n        for j in range(i + 1):\n            # Update the maximum sum if the current element is greater\n            max_sum = max(max_sum, tri[i][j])\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n | n & -n\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of triangles that can be formed\n    return (N * (N - 1) * (N - 2)) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(test_list)\n    # Find the maximum count\n    max_count = max(record_count.values())\n    # Find the records with the maximum count\n    max_count_records = [record for record, count in record_count.items() if count == max_count]\n    return max_count_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    # Initialize a list to store the number of sequences of length i\n    dp = [0] * (n + 1)\n    # There is only one way to have a sequence of length 0\n    dp[0] = 1\n    # Iterate over the length of the sequence\n    for i in range(1, n + 1):\n        # Iterate over the possible last element of the sequence\n        for j in range(1, m + 1):\n            # If the last element is greater than or equal to twice of the previous element\n            if j >= 2 * (i - 1):\n                # Add the number of sequences of length i - 1 to the number of sequences of length i\n                dp[i] += dp[i - 1]\n    # Return the number of sequences of length n\n    return dp[n] - 1  # subtract 1 because we counted the empty sequence\n\n"}
{"task_id": "MBPP/240", "completion": "\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1] = list2\n        return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: lst.count(x[0]))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    # Calculate the next integer greater than the square root\n    next_int = math.ceil(sqrt_N)\n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of increasing and decreasing sub-sequences\n    max_increasing = [0] * n\n    max_decreasing = [0] * n\n\n    # Initialize the maximum sum of increasing sub-sequence for the first element\n    max_increasing[0] = arr[0]\n\n    # Initialize the maximum sum of decreasing sub-sequence for the first element\n    max_decreasing[0] = arr[0]\n\n    # Iterate over the array from the second element to the last element\n    for i in range(1, n):\n        # Update the maximum sum of increasing sub-sequence for the current element\n        max_increasing[i] = max(max_increasing[i-1], max_decreasing[i-1] + arr[i])\n\n        # Update the maximum sum of decreasing sub-sequence for the current element\n        max_decreasing[i] = max(max_decreasing[i-1], max_increasing[i-1] - arr[i])\n\n    # Return the maximum sum of bi-tonic sub-sequence\n    return max(max_increasing[-1], max_decreasing[-1])  # Changed to max_increasing[-1] and max_decreasing[-1] to get the maximum sum of bi-tonic sub-sequence\n\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    if number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.00001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 1\n            elif str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]  # return the longest palindromic subsequence length\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))  # 1.0 is used to ensure floating point division\n\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(filter(lambda x: x in array_nums2, array_nums1))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] + list + [element]\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = []\n    for number in numbers:\n        r = cmath.polar(number)[0]\n        theta = cmath.polar(number)[1]\n        polar_coordinates.append((r, theta))\n    return polar_coordinates\n\n\nnumbers = [1 + 2j, 2 + 3j, 3 + 4j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\b[aAeE]\\w*\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(map(lambda x: x % 2 != 0, array_nums))  # Using map to apply the lambda function to each element in the array and sum to count the odd numbers\n\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum element\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    return tuple(a / b for a, b in zip(test_tup1, test_tup2))  # Using zip() to iterate over two tuples in parallel\n\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # A dog's first year is equal to 15 human years.\n    # After that, each year is equal to 1 human year.\n    if h_age <= 0:\n        return 0\n    elif h_age == 1:\n        return 15\n    else:\n        return 15 + (h_age - 1)\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    # The lateral surface area of a cube is 4 times the area of one of its faces.\n    # Since all faces of a cube are squares, we can find the area of one face by squaring the length of a side.\n    # So, the lateral surface area is 4 times the square of the length of a side.\n    return 4 * l ** 2\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum(i**2 for i in range(1, n*2, 2))  # sum of squares of first n odd natural numbers\n"}
{"task_id": "MBPP/268", "completion": "\n    # Initialize the first star number\n    star_num = 1\n    # Initialize the current number\n    num = 1\n    # Initialize the count of star numbers\n    count = 0\n    # Loop until we find the n'th star number\n    while True:\n        # Check if the current number is a star number\n        if is_star(num):\n            # Increment the count of star numbers\n            count += 1\n            # If the count is equal to n, return the current star number\n            if count == n:\n                return star_num\n        # Increment the current number\n        num += 1\n        # Increment the star number\n        star_num += 1\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    # Initialize sum variable\n    sum = 0\n    # Loop through first n even natural numbers\n    for i in range(2, n*2, 2):\n        # Add the fifth power of the current number to the sum\n        sum += i**5\n    # Return the sum\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return [record[-1] for record in test_list]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a + n) % m\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {k: v for k, v in dict.items() if v >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return test_tup.count(test_tup[0]) - 1\n"}
{"task_id": "MBPP/279", "completion": "\n    if n < 1:\n        return None\n    return (10*n**2 - 10*n + 1)//9\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))  # Output: [-3, -2, -1, 0, 1, 2, 3]\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if count > int(digit):\n            return False\n    \n    # If the function has not returned False, return True\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)  # or return all(item == element for item in list) == True\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # Repeat the array k times and find the maximum sum\n    for _ in range(k - 1):\n        # Initialize the current sum\n        current_sum = 0\n\n        # Iterate over the array\n        for i in range(n):\n            # Add the current element to the current sum\n            current_sum += a[i]\n\n            # If the current sum is greater than the maximum sum, update the maximum sum\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n            # If the current sum is negative, reset it to 0\n            if current_sum < 0:\n                current_sum = 0\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum(i**2 for i in range(2, n*2+2, 2))\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate the number of odd days in a year\n    odd_days = 0\n    for i in range(1, N+1):\n        if i % 2 != 0:\n            odd_days += 1\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(list1, key=len) if list1 else None\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from the 3rd post to the nth post\n    for i in range(3, n + 1):\n        # The number of ways to paint the ith post is the sum of the number of ways to paint the (i-1)th post and the (i-2)th post\n        # because we can paint the ith post with the same color as the (i-1)th post or the (i-2)th post\n        ways[i] = ways[i - 1] + ways[i - 2] * (k - 1)\n\n    return ways[n]  # Return the number of ways to paint the nth post\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)  # This will work because max() can handle any type of object that can be compared\n"}
{"task_id": "MBPP/295", "completion": "\n    sum_div = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum_div += i\n    return sum_div\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    return [element for element in l1 if element in l2]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_dict = defaultdict(int)\n    \n    # Iterate over the list of tuples\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_dict[num] = max(max_dict[num], aggregate)\n    \n    # Return the maximum aggregate\n    return max(max_dict.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return 2 * count_binary_seq(n - 1)  # This is a recursive solution, but it's not efficient for large inputs. We can use dynamic programming to improve it.\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values()) if d else 0\n"}
{"task_id": "MBPP/302", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    # Initialize the most significant bit number\n    msb = 0\n    # Iterate over the binary string from right to left\n    for i in range(len(binary) - 1, -1, -1):\n        # If the current bit is 1, update the most significant bit number\n        if binary[i] == '1':\n            msb = len(binary) - i - 1\n            break\n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversions += 1\n    return inversions\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Check if the index is within the range of the array\n    if index < 0 or index >= len(arr):\n        return None\n\n    # Check if the index is within the range of the rotated array\n    if index < ranges[0] or index >= ranges[1]:\n        return None\n\n    # Calculate the effective index after rotations\n    effective_index = (index - ranges[0]) % (ranges[1] - ranges[0])\n\n    # Return the element at the effective index\n    return arr[ranges[0] + effective_index]\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = re.compile(r'^p\\w+')\n    return [word for word in words if pattern.match(word)]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    # Initialize a list to store the maximum sum of increasing subsequence\n    max_sum = [0] * n\n\n    # Initialize the maximum sum of increasing subsequence till 0th index\n    max_sum[0] = a[0]\n\n    # Iterate over the array from 1st index to ith index\n    for i in range(1, index):\n        # Initialize the maximum sum of increasing subsequence till ith index\n        max_sum[i] = a[i]\n\n        # Iterate over the array from 0th index to (i-1)th index\n        for j in range(i):\n            # If the current element is greater than the element at jth index\n            if a[i] > a[j]:\n                # Update the maximum sum of increasing subsequence till ith index\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n\n    # Initialize the maximum sum of increasing subsequence till ith index\n    max_sum[index] = a[index]\n\n    # Iterate over the array from (index+1)th index to kth index\n    for i in range(index + 1, k):\n        # Initialize the maximum sum of increasing subsequence till ith index\n        max_sum[i] = a[i]\n\n        # Iterate over the array from 0th index to (i-1)th index\n        for j in range(i):\n            # If the current element is greater than the element at jth index\n            if a[i] > a[j]:\n                # Update the maximum sum of increasing subsequence till ith index\n                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])\n\n    # Return the maximum sum of increasing subsequence till kth index\n    return max(max_sum[:k])\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Combine the two lists into a list of pairs\n    pairs = list(zip(nums1, nums2))\n    \n    # Sort the pairs in descending order based on the product of the numbers\n    pairs.sort(key=lambda x: x[0]*x[1], reverse=True)\n    \n    # Return the specified number of largest products\n    return [pair[0]*pair[1] for pair in pairs[:N]]\n\n"}
{"task_id": "MBPP/309", "completion": "\n    return max(a, b)\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Find the position of the left most unset bit\n    left_most_unset_bit_position = binary.find('0')\n    \n    # If no unset bit is found, return the number as it is\n    if left_most_unset_bit_position == -1:\n        return n\n    \n    # Set the left most unset bit\n    binary = binary[:left_most_unset_bit_position] + '1' + binary[left_most_unset_bit_position + 1:]\n    \n    # Convert the binary string back to an integer\n    n = int(binary, 2)\n    \n    return n\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n    \n    # Initialize the dp array\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n    \n    # Fill the dp array\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n    \n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n    \n    # Return the maximum sum\n    return max(dp[0][n-1], dp[1][n-1])  # Changed from dp[0][n-1] to dp[1][n-1] to fix the bug\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    result = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        result.append((key, count))\n    return result\n\n"}
{"task_id": "MBPP/318", "completion": "\n    # Initialize the maximum volume\n    max_volume = 0\n    \n    # Iterate over all possible combinations of sides\n    for a in range(1, s):\n        for b in range(a, s):\n            c = s - a - b\n            # Calculate the volume of the cuboid\n            volume = a * b * c\n            # Update the maximum volume\n            max_volume = max(max_volume, volume)\n    \n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    # Use regex to find all five characters long word in the given string\n    pattern = r'\\b\\w{5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    square_of_sum = n * (n + 1) // 2\n    return square_of_sum ** 2 - sum_of_squares\n"}
{"task_id": "MBPP/321", "completion": "\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through the digits of the number\n    for i in range(len(s)):\n        # Add the digit to the demlo number\n        demlo += int(s[i])\n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    return [i for i, x in enumerate(list1) if x == min_val]\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # Create a new array with the first element of the original array\n        new_arr = [arr[0]]\n        # Add the first element of the original array to the new array\n        new_arr.append(arr[1])\n        # Add the rest of the array to the new array\n        new_arr.extend(arr[2:])\n        # Return the new array\n        return new_arr\n\n    # If the current element is positive, add it to the new array\n    if cur >= 0:\n        new_arr.append(cur)\n    # If the current element is negative, add it to the new array\n    else:\n        new_arr.append(cur)\n    # Recursively call the function with the rest of the array\n    return right_rotate(arr[1:], n - 1, out_of_place, arr[0]) if n > 1 else new_arr\n\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(sum(x) for x in zip(*[test_tuple[i::2] for i in range(len(test_tuple))]))\n\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current number is greater than or equal to the square\n            if i >= j ** 2:\n                # Update the minimum number of squares for the current number\n                min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n] if min_squares[n] != float('inf') else -1\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return sum(1 for num in list if num < 0)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a counter for unset bits\n    unset_bits = 0\n    \n    # Iterate over each bit in the binary representation\n    for bit in binary:\n        # If the bit is '0', increment the counter\n        if bit == '0':\n            unset_bits += 1\n    \n    # Return the count of unset bits\n    return unset_bits\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # reverse = None (Sorts in Ascending order)\n    # or reverse = True (Sorts in Descending order)\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if the sum of any two sides is greater than the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return n/2 * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        'January': 31,\n        'February': 28,\n        'March': 31,\n        'April': 30,\n        'May': 31,\n        'June': 30,\n        'July': 31,\n        'August': 31,\n        'September': 30,\n        'October': 31,\n        'November': 30,\n        'December': 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    # Define a regular expression pattern that matches a word followed by optional punctuation\n    pattern = r'\\w+[^\\w\\s]*$'\n    \n    # Use the fullmatch function from the re module to check if the entire string matches the pattern\n    match = re.fullmatch(pattern, text)\n    \n    # Return True if the string matches the pattern, False otherwise\n    return match is not None\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty dictionary to store the frequency of each divisor\n    freq = {}\n    \n    # Iterate over all numbers from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, increment its frequency in the dictionary\n            freq[i] = freq.get(i, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq.values(), default=0)\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [i for i in freq if freq[i] == max_freq]\n    \n    # Return the maximum divisor\n    return max(max_divisors)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we filter out non-positive numbers from the list\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Then, we sort the list of positive numbers in ascending order\n    positive_nums.sort()\n    \n    # Finally, we return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])  # We use list slicing to get the first three elements of the sorted list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_range = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_range = max(max_range, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if node.index + 1 == len(list[node.list_num]):\n            return [node.value, max_range]\n        next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n        heappush(min_heap, next_node)\n        heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n        max_range = max(max_range, -list[node.list_num][node.index + 1])\n\n    return []\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = sum(c.isdigit() for c in s)\n    letters = sum(c.isalpha() for c in s)\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    if len(nums) < 2:\n        return None\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    if n == 9:\n        return 256\n    if n == 10:\n        return 512\n    if n == 11:\n        return 1024\n    if n == 12:\n        return 2048\n    if n == 13:\n        return 4096\n    if n == 14:\n        return 8192\n    if n == 15:\n        return 16384\n    if n == 16:\n        return 32768\n    if n == 17:\n        return 65536\n    if n == 18:\n        return 131072\n    if n == 19:\n        return 262144\n    if n == 20:\n        return 524288\n    if n == 21:\n        return 1048576\n    if n == 22:\n        return 2097152\n    if n == 23:\n        return 4194304\n    if n == 24:\n        return 8388608\n    if n == 25:\n        return 16777216\n    if n == 26:\n        return 33554432\n    if n == 27:\n        return 67108864\n    if n == 28:\n        return 134217728\n    if n == 29:\n        return 268435456\n    if n == 30:\n        return 536870912\n    if n == 31:\n        return 1073741824\n    if n == 32:\n        return 2147483648\n    if n == 33:\n        return 4294967296\n    if n == 34:\n        return 8589934592\n    if n == 35:\n        return 17179869184\n    if n == 36:\n        return 34359738368\n    if n == 37:\n        return 68719476736\n    if n == 38:\n        return 137438953472\n    if"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < 0:\n        return 0\n    return bin_coff(n - r, r) + bin_coff(n - r, r - 1)  # return the sum of two cases\n\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}  # Using set comprehension to check if all characters are either '0' or '1'.\n\n"}
{"task_id": "MBPP/350", "completion": "\n    # Initialize a dictionary to store the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Initialize a variable to store the minimum length\n    min_len = len(s)\n\n    # Iterate over each character and its frequency\n    for char, count in freq.items():\n        # If the frequency is more than 1, update the minimum length\n        if count > 1:\n            min_len = min(min_len, len(s) - count + 1)\n\n    return min_len\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element occurring k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [x[:n] + x[n+1:] for x in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    # The number of rectangles is equal to the number of squares with side length 2r.\n    # Since the number of squares is infinite, we will return infinity.\n    return float('inf')  # or math.inf in Python 3.5+\n"}
{"task_id": "MBPP/356", "completion": "\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    return 180 - a - b\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = float('-inf')\n    for record in test_list:\n        for value in record:\n            if value > max_val:\n                max_val = value\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))  # Using map and lambda function\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n    \n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n    \n    # Check if one root is twice of the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = [1, 1]\n    for i in range(2, n):\n        carol.append(carol[i-1] + carol[i-2])\n    return carol[n-1]  # Return the nth carol number\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum count\n    max_count = max(count_dict.values())\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_items\n"}
{"task_id": "MBPP/363", "completion": "\n    return tuple(x + K for x in test_list)\n"}
{"task_id": "MBPP/364", "completion": "\n    flips = 0\n    for i in range(1, len(ch)):\n        if ch[i] != ch[i - 1]:\n            flips += 1\n    return flips  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to make the string alternate.  # This is the minimum number of flips required to"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(1, len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    # The lateral surface area of a cuboid is given by the formula 2lw + 2lh + 2wh\n    lateral_surface_area = 2 * (l * w + l * h + w * h)\n    return lateral_surface_area\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))  # return a new sorted list\n"}
{"task_id": "MBPP/371", "completion": "\n    # Initialize the smallest missing element as the left element plus one\n    smallest_missing = left_element + 1\n    \n    # Iterate over the array from the left element to the right element\n    for i in range(left_element, right_element + 1):\n        # If the current element is not equal to the smallest missing element\n        if A[i] != smallest_missing:\n            # Return the smallest missing element\n            return smallest_missing\n        # If the current element is equal to the smallest missing element, increment the smallest missing element by one\n        else:\n            smallest_missing += 1\n    \n    # If the loop completes without finding a missing element, return the smallest missing element\n    return smallest_missing\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with custom value for duplicates\n    new_tup = ()\n    for element in test_tup:\n        if count_dict[element] == 1:\n            new_tup += (element,)\n        else:\n            new_tup += ('Custom Value',)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')  # replace() function is used to replace all occurrences of a character in a string\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) == 0:\n        return test_list\n    else:\n        return [test_list[-1]] + test_list[:-1]\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)  # return the surface area of the cuboid\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    for i in range(n):\n        if A[i] > A[(i + 1) % n]:\n            return i\n    return n\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '1' (odd bit), toggle it to '0'\n        if char == '1':\n            result += '0'\n        # If the character is '0' (even bit), toggle it to '1'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # First, find the smallest value in the array\n    smallest = min(arr)\n    \n    # Then, count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)  # This is the recursive formula for perrin numbers\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(s[i])\n        elif s[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert the hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    if n <= 0:\n        return 0\n    return 2 ** (n.bit_length() - 1)  # Using bit_length() to get the number of bits in the binary representation of n\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    # Initialize an empty dictionary\n    d = {}\n    # Iterate over the lists\n    for i in range(len(l1)):\n        # Create a dictionary with the lists as values\n        d[l1[i]] = {l2[i]: l3[i]}\n    return d\n"}
{"task_id": "MBPP/392", "completion": "\n    def f(n):\n        if n == 1:\n            return 0\n        if n in memo:\n            return memo[n]\n        max_sum = n\n        for i in [2, 3, 4, 5]:\n            if n % i == 0:\n                max_sum = max(max_sum, f(n // i) + f(n))\n        memo[n] = max_sum\n        return max_sum\n    memo = {}\n    return f(n)  # return the result of the function f(n) with the input n\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)  # Return the list with the maximum length\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    return bool(re.match(regex, string))\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]  # Using list comprehension and generator expression\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))  # Using zip() to iterate over both tuples simultaneously\n\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        tup = tuple(sorted(tup))\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Check if the current element is a tuple\n        if isinstance(test_tup1[i], tuple):\n            # Recursively call the function to add the nested tuples\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If the current element is not a tuple, add it to the result\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    def mul(a, b, p):\n        return (a * b) % p\n\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        if (x == 0):\n            return 0\n        while (y > 0):\n            if ((y & 1) == 1):\n                res = (res * x) % p\n            y = y >> 1\n            x = (x * x) % p\n        return res\n\n    def inverse(x, p):\n        return power(x, p - 2, p)\n\n    if (r > n or r < 0 or n < 0):\n        return 0\n    pwr = 1\n    for i in range(1, r + 1):\n        pwr = mul(pwr, n - i + 1, p)\n    fact = 1\n    for i in range(1, r + 1):\n        fact = mul(fact, i, p)\n    inv = inverse(fact, p)\n    return (mul(pwr, inv, p)) % p\n"}
{"task_id": "MBPP/403", "completion": "\n    url_pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(url_pattern.match(str))\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return min(a, b)\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex == tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    # The parity of a number is 0 if it is even and 1 if it is odd.\n    # We can use the modulus operator to find the remainder of the number when divided by 2.\n    # If the remainder is 0, the number is even, otherwise it is odd.\n    return x % 2\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    i = len(n) - 1\n    while i > 0 and n[i - 1] >= n[i]:\n        i -= 1\n    if i <= 0:\n        return -1\n    j = len(n) - 1\n    while n[j] <= n[i - 1]:\n        j -= 1\n    n = list(n)\n    n[i - 1], n[j] = n[j], n[i - 1]\n    n[i : ] = n[len(n) - 1 : i - 1 : -1]\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    # Push the first element of the first array and the first element of the second array into the heap\n    heapq.heappush(min_heap, (nums1[0] + nums2[0], 0, 0))\n    # Create a set to store the pairs we have seen\n    seen = set()\n    # Create a list to store the k smallest pairs\n    k_smallest = []\n    # While the heap is not empty and we have not found k pairs\n    while min_heap and len(k_smallest) < k:\n        # Get the pair with the smallest sum from the heap\n        pair_sum, i, j = heapq.heappop(min_heap)\n        # If we have not seen this pair before\n        if (i, j) not in seen:\n            # Add the pair to the list of k smallest pairs\n            k_smallest.append((nums1[i], nums2[j]))\n            # Add the pair to the set of seen pairs\n            seen.add((i, j))\n        # If the current pair is not the last pair in the first array\n        if i + 1 < len(nums1):\n            # Push the next pair into the heap\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        # If the current pair is not the last pair in the second array\n        if j + 1 < len(nums2):\n            # Push the next pair into the heap\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    # Return the k smallest pairs\n    return k_smallest\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize the minimum product with a large number\n    min_product = float('inf')\n    \n    # Iterate over the list with index\n    for i in range(len(list1)):\n        # Check if the current element is a tuple\n        if isinstance(list1[i], tuple):\n            # Iterate over the rest of the list\n            for j in range(i + 1, len(list1)):\n                # Check if the current element is a tuple\n                if isinstance(list1[j], tuple):\n                    # Calculate the product of the current pair of tuples\n                    product = 1\n                    for k in list1[i]:\n                        product *= k\n                    for k in list1[j]:\n                        product *= k\n                    \n                    # Update the minimum product if the current product is smaller\n                    min_product = min(min_product, product)\n    \n    # Return the minimum product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)  # This will work because min() can handle any type of object that can be compared\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the snake case string\n    words = re.findall(r'\\w+', word)\n    \n    # Use list comprehension to capitalize the first letter of each word except the first one\n    camel_case_words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words together to form the camel case string\n    camel_case_string = ''.join(camel_case_words)\n    \n    return camel_case_string\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]  # subtract 1 because list indices start at 0\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n    max1 = max2 = float('-inf')\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n    return max1 * max2\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n < 0:\n        return -MAX\n    if n == 1:\n        return 1\n    max_sum = 0\n    for i in range(1, n):\n        max_sum = max(max_sum, breakSum(i-1) + breakSum(n-i-1) + n)\n    return max_sum\n\n"}
{"task_id": "MBPP/417", "completion": "\n    # Initialize an empty set to store unique first elements\n    first_elements = set()\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Add the first element of the tuple to the set\n        first_elements.add(tup[0])\n    \n    # Return the set of unique first elements\n    return first_elements\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(list1))\n"}
{"task_id": "MBPP/420", "completion": "\n    # Initialize sum as 0\n    sum = 0\n    # Loop through first n even natural numbers\n    for i in range(2, 2*n+2, 2):\n        # Add cube of current number to sum\n        sum += i**3\n    # Return the sum\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    return delimiter.join(test_tup)\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through first n natural numbers\n    for i in range(1, n+1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill in the rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum gold that can be collected at this cell is the maximum of the gold that can be collected from the cell above, the cell to the left, and the cell diagonally above and to the left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]  # Return the maximum gold that can be collected\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple(string[-1] for string in test_tuple)  # return a tuple of the last character of each string\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to find the pattern of yyyy-mm-dd\n    pattern = re.compile(r'(\\d{4})-(\\d{2})-(\\d{2})')\n    # Replace the pattern with the new format\n    new_dt = pattern.sub(r'\\3-\\2-\\1', dt)\n    return new_dt\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize empty lists to store the elementwise and tuples\n    elementwise = []\n    tuples = []\n\n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Append the elementwise result to the list\n        elementwise.append(tup1 + tup2)\n        \n        # Append the tuple result to the list\n        tuples.append((tup1, tup2))\n\n    # Return the elementwise and tuples lists\n    return elementwise, tuples\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the directrix\n    directrix = -focal_length\n    \n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # The median of a trapezium is the average of the bases\n    median = (base1 + base2) / 2\n    \n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > i for i in arr)  # Using all() function with generator expression\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    return re.match(pattern, text) is not None\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])  # Using list comprehension and ord() function to check if the character is even or odd\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a list of adverbs\n    adverbs = [\"quickly\", \"slowly\", \"loudly\", \"wisely\", \"happily\", \"sadly\", \"angrily\", \"silently\", \"patiently\"]\n    \n    # Initialize an empty list to store the positions of adverbs\n    adverb_positions = []\n    \n    # Split the text into words\n    words = text.split()\n    \n    # Iterate over the words and their indices\n    for i, word in enumerate(words):\n        # Check if the word is an adverb\n        if word in adverbs:\n            # If it is, append its position to the list\n            adverb_positions.append(i)\n    \n    # Return the list of adverb positions\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l**2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values indicating whether each number is positive\n    is_positive = array('b', [num > 0 for num in nums])\n    \n    # Count the number of positive numbers\n    positive_count = is_positive.count(1)\n    \n    # Count the total number of numbers\n    total_count = len(nums)\n    \n    # Return the ratio of positive numbers\n    return positive_count / total_count if total_count > 0 else 0\n\n"}
{"task_id": "MBPP/443", "completion": "\n    # Check if the list is empty\n    if not list1:\n        return None\n    # Check if all numbers in the list are positive\n    if all(num >= 0 for num in list1):\n        return None\n    # Find the largest negative number\n    largest_neg_num = max(num for num in list1 if num < 0)\n    return largest_neg_num\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][j] for j in range(len(test_list[i])-K)) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    return tuple(a * b for a, b in zip(test_tup1, test_tup2))  # Using zip() to iterate over two tuples in parallel\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup_list = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Count the occurrence of each element in the tuple\n    tup_count = Counter(tup_list)\n    # Return the difference between the two counts\n    return count - tup_count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))  # Using map() function to apply lambda function to each element in the list\n"}
{"task_id": "MBPP/448", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    else:\n        a, b = 2, 5\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]  # This line has been modified\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    return re.search(r'\\b\\w*z\\w*\\b', text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif monthnum2 == 2:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    # Using regex to find all uppercase substrings\n    uppercase_substrings = re.findall(r'[A-Z]+', str1)\n    \n    # Removing the uppercase substrings from the original string\n    result = re.sub(r'[A-Z]+', '', str1)\n    \n    return result, uppercase_substrings\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]  # return a list of first elements\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for c in str if c.isupper())  # count the number of upper case characters in the string\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}  # return a new dictionary with non-empty items\n\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return arr[low]\n    if high == low + 1:\n        if arr[low] > arr[high]:\n            return arr[low]\n        else:\n            return arr[high]\n\n    # Find the middle point\n    mid = (low + high) // 2\n\n    # If the middle element is greater than its neighbors, it is the peak\n    if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == n - 1 or arr[mid] >= arr[mid + 1]):\n        return arr[mid]\n\n    # If the middle element is smaller than its left neighbor, the peak must be in the left half\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    # If the middle element is smaller than its right neighbor, the peak must be in the right half\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product of subsequence ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product of subsequence ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product ending at the first position\n    max_product[0] = arr[0]\n    # Initialize the minimum product ending at the first position\n    min_product[0] = arr[0]\n    # Iterate over the array starting from the second position\n    for i in range(1, n):\n        # Initialize the maximum product ending at the current position\n        max_product[i] = arr[i]\n        # Initialize the minimum product ending at the current position\n        min_product[i] = arr[i]\n        # Iterate over the previous positions\n        for j in range(i):\n            # If the product of the current number and the maximum product ending at the previous position is greater than the current maximum product\n            if arr[i] * max_product[j] > max_product[i]:\n                # Update the maximum product ending at the current position\n                max_product[i] = arr[i] * max_product[j]\n            # If the product of the current number and the minimum product ending at the previous position is greater than the current minimum product\n            if arr[i] * min_product[j] > min_product[i]:\n                # Update the minimum product ending at the current position\n                min_product[i] = arr[i] * min_product[j]\n    # Return the maximum product ending at the last position\n    return max(max_product)\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2 or k == 0:\n        return 0\n\n    # Create a 2D table to store the maximum profit for each subproblem\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            max_profit = 0\n            for m in range(i):\n                # Calculate the maximum profit for the current subproblem\n                profit = price[i] - price[m] + dp[m][j - 1]\n                max_profit = max(max_profit, profit)\n            dp[i][j] = max(dp[i - 1][j], max_profit)\n\n    return dp[n - 1][k]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next element\n            for j in range(i + 1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result as 1\n    result = 1\n    \n    # Multiply all elements in the array and store the result in result\n    for i in range(lens):\n        result = (result * arr[i]) % n\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] == 1:\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    # Convert the lists to sets for efficient lookup\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection_set = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and return it\n    return list(intersection_set)\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)  # This line is the solution to the problem\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    # Convert the number to a string to easily access the first character\n    str_n = str(n)\n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If the number is negative, return the first digit after the negative sign\n        return int(str_n[1])\n    else:\n        # If the number is not negative, return the first digit\n        return int(str_n[0])  # Corrected the return statement to return an integer\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_freq:\n            char_freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n    \n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    # Create a 2D table to store the results of subproblems\n    dp = [[False] * (sum + 1) for _ in range(len(set) + 1)]\n\n    # Base case: The sum 0 can be achieved with an empty subset\n    for i in range(len(set) + 1):\n        dp[i][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, len(set) + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the current sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            # Otherwise, consider two cases: include the current element or not\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The result is stored in the bottom-right cell of the table\n    return dp[-1][-1]\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    n = 1\n    while True:\n        if factorial(n) % x == 0:\n            return n\n        n += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [t for t in test_list1 if t not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_palindrome = 0\n    for num in n:\n        if is_palindrome(num) and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r to avoid duplicate calculations\n        r = n - r\n    result = 1\n    for i in range(r):\n        result = result * (n - i) / (i + 1)\n    return result\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])  # Use the sorted function with a lambda function as the key to sort by the last element of each tuple\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) / 4) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # First, find the maximum value in the array\n    max_val = max(arr)\n    \n    # Then, count the number of occurrences of the maximum value\n    frequency = arr.count(max_val)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid of hexagons\n    grid = [[None for _ in range(num_hexagons_x)] for _ in range(num_hexagons_y)]\n\n    # Calculate the coordinates of each hexagon\n    for y in range(num_hexagons_y):\n        for x in range(num_hexagons_x):\n            # Calculate the x and y coordinates of the hexagon\n            hex_x = startx + x * 2 * radius\n            hex_y = starty + y * 2 * radius\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = hex_x + radius * math.cos(angle)\n                point_y = hex_y + radius * math.sin(angle)\n                points.append((point_x, point_y))\n\n            # Store the coordinates of the hexagon in the grid\n            grid[y][x] = points\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert the binary tuple to a string\n    binary_str = ''.join(test_tup)\n    \n    # Convert the binary string to an integer\n    integer = int(binary_str, 2)\n    \n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # The formula for the surface area of a cone is pi*r*(r + sqrt(r^2 + h^2))\n    # where r is the radius of the base and h is the height of the cone.\n    return math.pi * r * (r + math.sqrt(r**2 + h**2))\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)  # or return ''.join(map(str, list)) for non-string elements\n"}
{"task_id": "MBPP/501", "completion": "\n    # Find the greatest common divisor of two numbers\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the common divisor between two numbers\n    def common_divisor(x, y):\n        return gcd(x, y)\n\n    return common_divisor(x, y)  # Return the common divisor\n\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(nums[i] + nums[i+1] for i in range(len(nums)-1))\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    # Convert the list of words to remove to a set for efficient lookups\n    set2 = set(removewords)\n    # Use set difference to remove the words\n    result = set1 - set2\n    # Convert the result back to a list and return it\n    return list(result)\n"}
{"task_id": "MBPP/508", "completion": "\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements between the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Initialize an empty list to store the common elements in the order they appear in the first list\n    common_elements_in_order = []\n    \n    # Iterate over the first list and add the common elements to the list in the order they appear\n    for element in l1:\n        if element in common_elements:\n            common_elements_in_order.append(element)\n            common_elements.remove(element)\n    \n    # Initialize an empty list to store the common elements in the order they appear in the second list\n    common_elements_in_order_2 = []\n    \n    # Iterate over the second list and add the common elements to the list in the order they appear\n    for element in l2:\n        if element in common_elements:\n            common_elements_in_order_2.append(element)\n            common_elements.remove(element)\n    \n    # Check if the common elements in both lists are in the same order\n    return common_elements_in_order == common_elements_in_order_2\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product < k:\n            count += 2 ** (n - i - 1)\n    return count\n"}
