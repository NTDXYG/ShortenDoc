{"task_id": "valid/0", "completion": "\n    categories = {\n        \"sports\": [\"football\", \"basketball\", \"tennis\", \"soccer\"],\n        \"technology\": [\"computer\", \"software\", \"hardware\", \"internet\"],\n        \"finance\": [\"bank\", \"money\", \"invest\", \"stock\"],\n        \"health\": [\"doctor\", \"hospital\", \"medicine\", \"healthcare\"],\n        \"politics\": [\"government\", \"election\", \"policy\", \"politician\"]\n    }\n    \n    text_lower = text.lower()\n    \n    for category, keywords in categories.items():\n        for keyword in keywords:\n            if keyword in text_lower:\n                return category\n    \n    return \"unknown\"\n"}
{"task_id": "valid/1", "completion": "\n    return frozenset(s)\n"}
{"task_id": "valid/2", "completion": "\n    return num1 ^ num2\n"}
{"task_id": "valid/3", "completion": "\n    sorted_instruments = sorted(instruments, reverse=True)\n    return sorted_instruments\n"}
{"task_id": "valid/4", "completion": "\n    try:\n        data = json.loads(json_string)\n        if isinstance(data, list):\n            return data\n        else:\n            raise ValueError(\"The JSON string does not represent a list of dictionaries.\")\n    except json.JSONDecodeError:\n        raise ValueError(\"The input is not a valid JSON string.\")\n"}
{"task_id": "valid/5", "completion": "\n    if not isinstance(n, int) or n < 0:\n        return False\n    \n    sum_of_digits = sum(int(digit) for digit in str(n))\n    \n    return n % 5 == 0 and sum_of_digits % 3 == 0\n"}
{"task_id": "valid/6", "completion": "\n    result = 0\n    while n >= base:\n        n //= base\n        result += 1\n    return result\n"}
{"task_id": "valid/7", "completion": "\n    try:\n        parsed_json = json.loads(json_str)\n        pprint.pprint(parsed_json)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON string: {e}\")\n"}
{"task_id": "valid/8", "completion": "\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    return False\n"}
{"task_id": "valid/9", "completion": "\n    import re\n\n    def replace_placeholders(template, values):\n        def replace(match):\n            key = match.group(1)\n            return values.get(key, match.group(0))\n\n        pattern = re.compile(r'\\{\\{(\\w+)\\}\\}')\n        return pattern.sub(replace, template)\n"}
{"task_id": "valid/10", "completion": "\n    char_set = set()\n    for char in string:\n        if char in char_set:\n            return False\n        char_set.add(char)\n    return True\n"}
{"task_id": "valid/11", "completion": "\n    date_obj = datetime.strptime(date_string, '%Y-%m-%d')\n    new_date_obj = date_obj + timedelta(days=days)\n    return new_date_obj.strftime('%Y-%m-%d')\n"}
{"task_id": "valid/12", "completion": "\n    # Remove leading and trailing whitespace\n    text = text.strip()\n    \n    # Remove extra whitespace between words\n    text = ' '.join(text.split())\n    \n    return text\n"}
{"task_id": "valid/13", "completion": "\n    # Remove punctuation\n    text = text.translate(str.maketrans('', '', string.punctuation))\n    \n    # Convert to lowercase\n    text = text.lower()\n    \n    # Remove extra whitespace\n    text = ' '.join(text.split())\n    \n    # Handle common multilingual variations\n    text = text.replace('\u00df', 'ss')  # German \u00df to ss\n    text = text.replace('\u00e6', 'ae')  # Latin ae to ae\n    text = text.replace('\u0153', 'oe')  # Latin oe to oe\n    text = text.replace('\u0111', 'd')  # Croatian \u0111 to d\n    text = text.replace('\u00f8', 'o')  # Danish \u00f8 to o\n    text = text.replace('\u00e5', 'a')  # Danish \u00e5 to a\n    text = text.replace('\u00e4', 'a')  # German \u00e4 to a\n    text = text.replace('\u00f6', 'o')  # German \u00f6 to o\n    text = text.replace('\u00fc', 'u')  # German \u00fc to u\n    text = text.replace('\u00f1', 'n')  # Spanish \u00f1 to n\n    text = text.replace('\u00e7', 'c')  # French \u00e7 to c\n    text = text.replace('\u011f', 'g')  # Turkish \u011f to g\n    text = text.replace('\u0131', 'i')  # Turkish \u0131 to i\n    text = text.replace('\u015f', 's')  # Turkish \u015f to s\n    text = text.replace('\u0259', 'e')  # Azerbaijani \u0259 to e\n    text = text.replace('\u011f', 'g')  # Azerbaijani \u011f to g\n    text = text.replace('\u0131', 'i')  # Azerbaijani \u0131 to i\n    text = text.replace('\u00f6', 'o')  # Azerbaijani \u00f6 to o\n    text = text.replace('\u00fc', 'u')  # Azerbaijani \u00fc to u\n    text = text.replace('\u015f', 's')  # Azerbaijani \u015f to s\n    text = text.replace('\u00e7', 'c')  # Azerbaijani \u00e7 to c\n    \n    # Normalize diacritics (optional, depending on the use case)\n    # This can be done using a library like unidecode or unicodedata\n    # Example using unidecode:\n    # from unidecode import unidecode\n    # text = unidecode(text)\n    \n    return text\n"}
{"task_id": "valid/14", "completion": "\n    pattern = re.compile(rf'\\b({word1}|{word2})\\b')\n    return bool(pattern.search(text))\n"}
{"task_id": "valid/15", "completion": "\n    def is_layer(i, j, n):\n        \"\"\"\n        Helper function to determine if a cell (i, j) is on the boundary of a layer.\n        \"\"\"\n        return i == 0 or i == n - 1 or j == 0 or j == n - 1 or i == j or i + j == n - 1\n\n    n = len(array)\n    if n == 0:\n        return []\n\n    layers = []\n    for layer in range(n // 2 + 1):\n        layer_sum = 0\n        for i in range(n):\n            for j in range(n):\n                if is_layer(i, j, n) and (i >= layer and i < n - layer and j >= layer and j < n - layer):\n                    layer_sum += array[i][j]\n        if layer_sum > 0:\n            layers.append(layer_sum)\n\n    return layers\n"}
{"task_id": "valid/16", "completion": "\n    settings = {}\n    lines = comment.strip().split('\\n')\n    \n    for line in lines:\n        line = line.strip()\n        if line.startswith('set'):\n            parts = line.split()\n            for part in parts:\n                if '=' in part:\n                    key, value = part.split('=')\n                    if key in ['tabstop', 'expandtab', 'shiftwidth', 'softtabstop']:\n                        settings[key] = value\n    \n    return settings\n"}
{"task_id": "valid/17", "completion": "\n    words = sentence.split()\n    return words\n"}
{"task_id": "valid/18", "completion": "\n    if num < 10:\n        return 1\n    else:\n        return 1 + find_digits_count(num // 10)\n"}
{"task_id": "valid/19", "completion": "\n    reversed_list1 = list1[::-1]\n    reversed_list2 = list2[::-1]\n    combined_list = reversed_list1 + reversed_list2\n    sorted_list = sorted(combined_list)\n    return sorted_list\n"}
{"task_id": "valid/20", "completion": "\n    words = input_string.split()\n    replaced_words = [new_word if word == old_word else word for word in words]\n    return ' '.join(replaced_words)\n"}
{"task_id": "valid/21", "completion": "\n    return z * z\n"}
{"task_id": "valid/22", "completion": "\n    try:\n        return dictionary['name']\n    except KeyError:\n        return None\n"}
{"task_id": "valid/23", "completion": "\n    result = {}\n    for key, value in struct.items():\n        if isinstance(value, dict):\n            result[key] = struct_to_dict(value)\n        elif isinstance(value, list):\n            result[key] = [struct_to_dict(item) if isinstance(item, dict) else item for item in value]\n        else:\n            result[key] = value\n    return result\n"}
{"task_id": "valid/24", "completion": "\n    def isPalindrome(n):\n        return str(n) == str(n)[::-1]\n\n    if isPalindrome(num):\n        return num\n\n    lower = num - 1\n    upper = num + 1\n\n    while True:\n        if isPalindrome(lower):\n            return lower\n        if isPalindrome(upper):\n            return upper\n        lower -= 1\n        upper += 1\n"}
{"task_id": "valid/25", "completion": "\n    if num < 0:\n        raise ValueError(\"Cannot calculate square root of a negative number\")\n    \n    guess = num / 2.0\n    tolerance = 0.0001\n    \n    while True:\n        better_guess = (guess + num / guess) / 2.0\n        if abs(guess - better_guess) < tolerance:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "valid/26", "completion": "\n    num_rows = len(matrix)\n    num_cols = len(matrix[0]) if num_rows > 0 else 0\n    diagonal_sum = 0\n    is_square = num_rows == num_cols\n\n    for i in range(min(num_rows, num_cols)):\n        diagonal_sum += matrix[i][i]\n\n    return num_rows, num_cols, diagonal_sum, is_square\n"}
{"task_id": "valid/27", "completion": "\n    string_bytes = string.encode('utf-8')\n    base64_bytes = base64.b64encode(string_bytes)\n    base64_string = base64_bytes.decode('utf-8')\n    return base64_string\n"}
{"task_id": "valid/28", "completion": "\n    cleaned_string = ''.join(char for char in s if char.isalpha())\n    return cleaned_string.lower()\n"}
{"task_id": "valid/29", "completion": "\n    if not lst:\n        return None  # Return None if the list is empty\n    min_element = lst[0]\n    for element in lst:\n        if element < min_element:\n            min_element = element\n    return min_element\n"}
{"task_id": "valid/30", "completion": "\n    if isinstance(json_data, str):\n        try:\n            json_data = json.loads(json_data)\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON string provided.\")\n    \n    if not isinstance(json_data, dict):\n        raise ValueError(\"The provided JSON data must be a dictionary.\")\n    \n    if key in json_data and json_data[key] == value:\n        return False\n    \n    return True\n"}
{"task_id": "valid/31", "completion": "\n    button_table = []\n    row = []\n    \n    for i, button in enumerate(buttons):\n        row.append(button)\n        if (i + 1) % num_columns == 0:\n            button_table.append(row)\n            row = []\n    \n    if row:\n        button_table.append(row)\n    \n    return button_table\n"}
{"task_id": "valid/32", "completion": "\n    s = s.lower()\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for i in range(len(alphabet) - 1):\n        if alphabet[i:i+2] not in s:\n            return False\n    return True\n"}
{"task_id": "valid/33", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "valid/34", "completion": "\n    import re\n\n    # Find all numeric substrings using regex\n    numeric_substrings = re.findall(r'\\d+', ts)\n    \n    # Convert each numeric substring to an integer and sum them up\n    total_sum = sum(int(num) for num in numeric_substrings)\n    \n    return total_sum\n"}
{"task_id": "valid/35", "completion": "\n    return [word[:-1] + word[-1].upper() for word in words]\n"}
{"task_id": "valid/36", "completion": "\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"Array must contain only numerical values.\")\n    \n    return sum(arr)\n"}
{"task_id": "valid/37", "completion": "\n    neighborhoods = [neighborhood['name'] for neighborhood in json_data]\n    return sorted(neighborhoods)\n"}
{"task_id": "valid/38", "completion": "\n    # To store the result\n    min_l, min_r = 0, 1\n    min_sum = arr[0] + arr[1]\n\n    # Iterate over the array\n    for l in range(n - 1):\n        for r in range(l + 1, n):\n            sum = arr[l] + arr[r]\n            if abs(min_sum) > abs(sum):\n                min_sum = sum\n                min_l = l\n                min_r = r\n\n    # Print the result\n    print(f\"The two elements whose sum is minimum are {arr[min_l]} and {arr[min_r]}\")\n"}
{"task_id": "valid/39", "completion": "\n    stack = []\n    for char in p:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "valid/40", "completion": "\n    results = {}\n    total_votes = 0\n\n    for vote in votes:\n        candidate_name, number_of_votes = vote\n        if not candidate_name.isupper() or len(candidate_name) > 10 or number_of_votes <= 0 or number_of_votes > 1000:\n            raise ValueError(\"Invalid vote data\")\n        if candidate_name in results:\n            results[candidate_name] += number_of_votes\n        else:\n            results[candidate_name] = number_of_votes\n        total_votes += number_of_votes\n\n    if total_votes < 100:\n        raise ValueError(\"Total number of votes must be at least 100\")\n\n    for candidate in results:\n        results[candidate] = (results[candidate], round((results[candidate] / total_votes) * 100, 2))\n\n    return results\n"}
{"task_id": "valid/41", "completion": "\n    try:\n        # Attempt to parse the date string with the DD-MM-YYYY format\n        date_obj = datetime.strptime(date_string, \"%d-%m-%Y\")\n    except ValueError:\n        try:\n            # Attempt to parse the date string with the DD-MMM-YYYY format\n            date_obj = datetime.strptime(date_string, \"%d-%b-%Y\")\n        except ValueError:\n            raise ValueError(\"Invalid date format. Please use DD-MM-YYYY or DD-MMM-YYYY format.\")\n    \n    # Check if the parsed date is valid\n    if date_obj.year < 1 or date_obj.month < 1 or date_obj.month > 12 or date_obj.day < 1:\n        raise ValueError(\"Invalid date: The date components are out of valid range.\")\n    \n    # Check for valid day in the month\n    try:\n        datetime(date_obj.year, date_obj.month, date_obj.day)\n    except ValueError:\n        raise ValueError(\"Invalid date: The day is out of range for the month.\")\n    \n    # Return the date in the standardized format\n    return date_obj.strftime(\"%B %d, %Y\")\n"}
{"task_id": "valid/42", "completion": "\n    allowed_extensions = {\n        'image': ['.jpg', '.jpeg', '.png', '.gif', '.bmp'],\n        'document': ['.doc', '.docx', '.pdf', '.txt', '.rtf'],\n        'video': ['.mp4', '.avi', '.mkv', '.mov'],\n        'audio': ['.mp3', '.wav', '.ogg', '.flac']\n    }\n\n    # Extract the file extension from the new name\n    _, ext = os.path.splitext(newname)\n\n    # Check if the extension is in the allowed list for the given type\n    if ext.lower() in allowed_extensions.get(allowed_type, []):\n        return True\n    else:\n        return False\n"}
{"task_id": "valid/43", "completion": "\n    def is_even(x):\n        if isinstance(x, int) or isinstance(x, float):\n            return x % 2 == 0\n        elif isinstance(x, str):\n            try:\n                return float(x) % 2 == 0\n            except ValueError:\n                return False\n        return False\n\n    def remove_uneven_helper(item):\n        if isinstance(item, tuple):\n            return tuple(remove_uneven_helper(x) for x in item if is_even(x))\n        elif isinstance(item, list):\n            return [remove_uneven_helper(x) for x in item if is_even(x)]\n        else:\n            return item if is_even(item) else None\n\n    return remove_uneven_helper(lst)\n"}
{"task_id": "valid/44", "completion": "\n    minutes = hours * 60\n    return minutes\n"}
{"task_id": "valid/45", "completion": "\n    count = 0\n    for char in string:\n        if char == specific_character:\n            count += 1\n    return count\n"}
{"task_id": "valid/46", "completion": "\n    # Ensure the histogram data is a list\n    if not isinstance(histogram_data, list):\n        histogram_data = []\n\n    # Ensure the generation number is within the bounds of the histogram data\n    if generation < 0:\n        raise ValueError(\"Generation number must be non-negative.\")\n\n    # Extend the histogram data if necessary\n    if len(histogram_data) <= generation:\n        histogram_data.extend([None] * (generation - len(histogram_data) + 1))\n\n    # Add the accuracy data to the histogram\n    histogram_data[generation] = accs\n\n    return histogram_data\n"}
{"task_id": "valid/47", "completion": "\n    pattern = r'^[a-zA-Z0-9]{5}$'\n    return bool(re.match(pattern, string))\n"}
{"task_id": "valid/48", "completion": "\n    unique_languages = set()\n    \n    for classifier in classifiers:\n        parts = classifier.split(\" :: \")\n        if len(parts) == 3 and parts[0] == \"Programming Language\":\n            unique_languages.add(parts[1])\n    \n    return len(unique_languages)\n"}
{"task_id": "valid/49", "completion": "\n    from collections import defaultdict\n\n    count_dict = defaultdict(int)\n    \n    for row in arr:\n        for num in row:\n            count_dict[num] += 1\n    \n    return [count_dict[key] for key in sorted(count_dict)]\n"}
{"task_id": "valid/50", "completion": "\n    urlpatterns = [\n        re.compile(r'^videos/(?P<video_id>\\d+)/$').match,\n        re.compile(r'^categories/(?P<category_id>\\d+)/$').match,\n    ]\n\n    for pattern in urlpatterns:\n        match = pattern(url)\n        if match:\n            return match.groupdict()\n\n    return None\n"}
{"task_id": "valid/51", "completion": "\n    if position < 0:\n        position = 0\n    elif position > len(list):\n        position = len(list)\n    \n    list.insert(position, item)\n    return list\n"}
{"task_id": "valid/52", "completion": "\n    user_input = input(\"Enter a string: \")\n    sentence = \"This is a sample sentence.\"\n    concatenated_string = user_input + \" \" + sentence\n    return concatenated_string\n"}
{"task_id": "valid/53", "completion": "\n    substrings = set()\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substrings.add(s[i:j])\n    \n    return substrings\n"}
{"task_id": "valid/54", "completion": "\n    total_sum = 0\n    for dictionary in list_of_dicts:\n        for key in dictionary:\n            if key.startswith(\"price_\"):\n                try:\n                    price_value = float(dictionary[key])\n                    total_sum += price_value\n                except ValueError:\n                    # If the value is not a valid float, skip it\n                    continue\n    return total_sum\n"}
{"task_id": "valid/55", "completion": "\n    intersection = list(set(list1) & set(list2))\n    list2[:] = [item for item in list2 if item not in intersection]\n    return intersection\n"}
{"task_id": "valid/56", "completion": "\n    if request_method == 'GET':\n        return api_advisor_view\n    elif request_method == 'POST':\n        return api_advisor_view_post\n    else:\n        raise ValueError(\"Unsupported request method\")\n"}
{"task_id": "valid/57", "completion": "\n    if not isinstance(a, int) or not isinstance(b, int) or a <= 0 or b <= 0:\n        raise ValueError(\"Both arguments must be positive integers.\")\n    \n    if b == 0:\n        return a\n    else:\n        return gcd_recursive(b, a % b)\n"}
{"task_id": "valid/58", "completion": "\n    categorized_files = {}\n\n    for file_path in file_paths:\n        # Split the file path into its components\n        path_parts = file_path.split('/')\n        \n        # The category will be the second part of the path\n        if len(path_parts) > 1:\n            category = path_parts[1]\n        else:\n            category = 'uncategorized'\n        \n        # Add the file to the corresponding category in the dictionary\n        if category not in categorized_files:\n            categorized_files[category] = []\n        categorized_files[category].append(file_path)\n    \n    return categorized_files\n"}
{"task_id": "valid/59", "completion": "\n    # Sort the five numbers using a simple sorting algorithm\n    if a > b: a, b = b, a\n    if c > d: c, d = d, c\n    if a > c: a, c = c, a\n    if b > d: b, d = d, b\n    if b > c: b, c = c, b\n    if e > c: e, c = c, e\n    if e > d: e, d = d, e\n    if b > e: b, e = e, b\n    if c > e: c, e = e, c\n    \n    # The median is now the third element in the sorted list\n    return c\n"}
{"task_id": "valid/60", "completion": "\n    unique_elements = set()\n    for item in my_list:\n        if item in unique_elements:\n            return False\n        unique_elements.add(item)\n    return True\n"}
{"task_id": "valid/61", "completion": "\n    if timeStart > timeEnd:\n        raise ValueError(\"timeStart should be less than or equal to timeEnd\")\n    \n    return timeEnd - timeStart\n"}
{"task_id": "valid/62", "completion": "\n    if start > end:\n        return -1\n\n    mid = (start + end) // 2\n\n    if array[mid] == target:\n        return mid\n    elif array[mid] < target:\n        return binary_search_recursive(array, target, mid + 1, end)\n    else:\n        return binary_search_recursive(array, target, start, mid - 1)\n"}
{"task_id": "valid/63", "completion": "\n    if color == \"WHITE\":\n        return \"RED\"\n    elif color == \"RED\":\n        return \"GREEN\"\n    elif color == \"GREEN\":\n        return \"BLUE\"\n    elif color == \"BLUE\":\n        return \"WHITE\"\n    else:\n        raise ValueError(\"Invalid color input\")\n"}
{"task_id": "valid/64", "completion": "\n    def increment_list_values(lst):\n    return [x + 1 for x in lst]\n"}
{"task_id": "valid/65", "completion": "\n    for num in range(start, end + 1):\n        if (int(num**0.5)**2) == num:\n            return True\n    return False\n"}
{"task_id": "valid/66", "completion": "\n    for word in words:\n        if target in word:\n            return word.index(target)\n    return -1\n"}
{"task_id": "valid/67", "completion": "\n    words = sentence.split()\n    return words\n"}
{"task_id": "valid/68", "completion": "\n    print(\"The keys in the given dictionary are:\")\n    for key in dict.keys():\n        print(key)\n"}
{"task_id": "valid/69", "completion": "\n    input_string = input(\"Enter a string: \")\n    phrase = \" is a great example of string interpolation.\"\n    concatenated_string = f\"{input_string}{phrase}\"\n    return concatenated_string\n"}
{"task_id": "valid/70", "completion": "\n    def is_valid(s):\n        return not re.search(r'[^a-zA-Z0-9\\s]', s)\n\n    return [s.capitalize() for s in strings if is_valid(s)]\n"}
{"task_id": "valid/71", "completion": "\n    for index, c in enumerate(string):\n        if c == char:\n            return index\n    return -1  # Return -1 if the character is not found in the string\n"}
{"task_id": "valid/72", "completion": "\n    bold_texts = []\n    i = 0\n    while i < len(html_code):\n        start_tag = html_code.find('<b>', i)\n        if start_tag == -1:\n            break\n        end_tag = html_code.find('</b>', start_tag)\n        if end_tag == -1:\n            break\n        bold_text = html_code[start_tag + 3:end_tag]\n        bold_texts.append(bold_text)\n        i = end_tag + 4\n    \n    return bold_texts\n"}
{"task_id": "valid/73", "completion": "\n    items = {\n        \"Coke\": {\"price\": 1.50, \"stock\": 10},\n        \"Pepsi\": {\"price\": 1.50, \"stock\": 10},\n        \"Water\": {\"price\": 1.00, \"stock\": 15},\n        \"Chips\": {\"price\": 1.25, \"stock\": 8},\n        \"Candy\": {\"price\": 0.75, \"stock\": 20}\n    }\n\n    if item not in items:\n        return \"Item not available\"\n\n    item_info = items[item]\n    price = item_info[\"price\"]\n    stock = item_info[\"stock\"]\n\n    if stock == 0:\n        return \"Item out of stock\"\n\n    if money_inserted < price:\n        return \"Insufficient funds\"\n\n    change = money_inserted - price\n    items[item][\"stock\"] -= 1\n\n    return f\"Dispensing {item}, change: ${change:.2f}\"\n"}
{"task_id": "valid/74", "completion": "\n    merged_list = list1 + list2\n    return list(set(merged_list))\n"}
{"task_id": "valid/75", "completion": "\n    count = 0\n    for element in list:\n        if element == target:\n            count += 1\n    return count\n"}
{"task_id": "valid/76", "completion": "\n    encoded_bytes = base64.b64encode(string.encode('utf-8'))\n    encoded_string = encoded_bytes.decode('utf-8')\n    return encoded_string\n"}
{"task_id": "valid/77", "completion": "\n    non_zero_indices = [i for i, value in enumerate(vector) if value != 0]\n    return non_zero_indices\n"}
{"task_id": "valid/78", "completion": "\n    value = 42  # Assign a specific value to the variable\n    \n    # Validate the value\n    if value == 42:\n        print(\"Validation successful: The value is 42.\")\n    else:\n        print(\"Validation failed: The value is not 42.\")\n\nassign_and_validate()\n"}
{"task_id": "valid/79", "completion": "\n    word_list = list(word)\n    random.shuffle(word_list)\n    return ''.join(word_list)\n"}
{"task_id": "valid/80", "completion": "\n    if isinstance(element, int):\n        return \"Integer\"\n    elif isinstance(element, float):\n        return \"Float\"\n    elif isinstance(element, str):\n        return \"String\"\n    elif isinstance(element, list):\n        return \"List\"\n    elif isinstance(element, dict):\n        return \"Dictionary\"\n    elif isinstance(element, tuple):\n        return \"Tuple\"\n    elif isinstance(element, set):\n        return \"Set\"\n    elif isinstance(element, bool):\n        return \"Boolean\"\n    else:\n        return \"Unknown Type\"\n"}
{"task_id": "valid/81", "completion": "\n    merged_arr = []\n    i = 0\n    while i < len(arr):\n        current_element = arr[i]\n        count = 1\n        while i + 1 < len(arr) and arr[i + 1] == current_element:\n            count += 1\n            i += 1\n        merged_arr.append((current_element, count))\n        i += 1\n    return merged_arr\n"}
{"task_id": "valid/82", "completion": "    # Define the regular expression pattern for tokenization\n    pattern = r'\\b\\w+\\b'  # This pattern matches words\n\n    # Use re.findall to find all tokens in the text\n    tokens = re.findall(pattern, text)\n\n    return tokens"}
{"task_id": "valid/83", "completion": "\n    divisible_numbers = [num for num in numbers if num % 3 == 0 and num % 7 == 0]\n    \n    if not divisible_numbers:\n        print(\"No numbers divisible by both 3 and 7 found.\")\n        return\n    \n    average = sum(divisible_numbers) / len(divisible_numbers)\n    max_value = max(divisible_numbers)\n    min_value = min(divisible_numbers)\n    \n    print(f\"Average of numbers divisible by both 3 and 7: {average}\")\n    print(f\"Maximum value: {max_value}\")\n    print(f\"Minimum value: {min_value}\")\n    \n    occurrences = {num: divisible_numbers.count(num) for num in set(divisible_numbers)}\n    print(\"Number of occurrences of each unique number divisible by both 3 and 7:\")\n    for num, count in occurrences.items():\n        print(f\"{num}: {count}\")\n"}
{"task_id": "valid/84", "completion": "\n    words = sentence.split()\n    frequency = {}\n    \n    for word in words:\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    \n    max_frequency = 0\n    most_frequent_word = \"\"\n    \n    for word, freq in frequency.items():\n        if freq > max_frequency:\n            max_frequency = freq\n            most_frequent_word = word\n    \n    return most_frequent_word\n"}
{"task_id": "valid/85", "completion": "\n    e = 0\n    factorial = 1\n    n = 0\n    while True:\n        if n > 0:\n            factorial *= n\n        term = 1 / factorial\n        e += term\n        if term < 10 ** (-decimal_places - 1):\n            break\n        n += 1\n    return round(e, decimal_places)\n"}
{"task_id": "valid/86", "completion": "\n    total_sum = sum(numbers)\n    average = total_sum / len(numbers)\n    return average, total_sum\n"}
{"task_id": "valid/87", "completion": "\n    if not time_series:\n        raise ValueError(\"The time series is empty.\")\n    \n    try:\n        min_value = min(time_series)\n        max_value = max(time_series)\n    except TypeError:\n        raise ValueError(\"The time series contains non-numerical values.\")\n    \n    return (min_value, max_value)\n"}
{"task_id": "valid/88", "completion": "\n    related_counts = {}\n    \n    for entry in encyclopedia:\n        related_articles = entry.get('related_articles', [])\n        related_counts[entry['title']] = len(related_articles)\n    \n    return related_counts\n"}
{"task_id": "valid/89", "completion": "\n    max_value = lst[0]\n    max_index = 0\n    \n    for i in range(1, len(lst)):\n        if lst[i] > max_value:\n            max_value = lst[i]\n            max_index = i\n    \n    return max_index\n"}
{"task_id": "valid/90", "completion": "\n    set1 = set(list1)\n    set2 = set(list2)\n    return not set1.isdisjoint(set2)\n"}
{"task_id": "valid/91", "completion": "\n    root = Element('data')\n    for key, value in dictionary.items():\n        child = Element(key)\n        child.text = str(value)\n        root.append(child)\n    return tostring(root, encoding='unicode')\n"}
{"task_id": "valid/92", "completion": "\n    # The matrix is sorted in a row-wise manner, meaning each row is sorted in ascending order.\n    # Each row's first element is greater than the last element of the previous row.\n    # The matrix is also sorted in a column-wise manner, meaning each column is sorted in ascending order.\n    # Each column's first element is greater than the last element of the previous column.\n\n    # Given these properties, I can leverage binary search to efficiently locate the target value.\n\n    if not matrix or not matrix[0]:\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Start from the top-right corner of the matrix\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            # Move left in the same row\n            col -= 1\n        else:\n            # Move down to the next row\n            row += 1\n\n    return False\n"}
{"task_id": "valid/93", "completion": "\n    odd_sum = 0\n    odd_count = 0\n    \n    for num in lst:\n        if num & 1:  # Bitwise check for odd number\n            odd_sum += num\n            odd_count += 1\n    \n    if odd_count == 0:\n        return None  # No odd elements found\n    \n    average = odd_sum // odd_count  # Integer division for average\n    return odd_sum, average\n"}
{"task_id": "valid/94", "completion": "\n    if n < 1 or n > len(lst):\n        return None\n    \n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[n-1]\n"}
{"task_id": "valid/95", "completion": "\n    return sum(lst)\n"}
{"task_id": "valid/96", "completion": "\n    exclusive_elements = set_a.symmetric_difference(set_b)\n    return exclusive_elements\n"}
{"task_id": "valid/97", "completion": "\n    description = (\n        \"This Discord bot is designed to manage and play music in a server. \"\n        \"It offers a variety of features including:\\n\"\n        \"- **Music Playback**: Play, pause, skip, and control the volume of music.\\n\"\n        \"- **Playlist Management**: Create, edit, and delete personal playlists.\\n\"\n        \"- **Server Settings**: Customize server-specific settings such as default volume and playlist.\\n\"\n        \"- **Command Categorization**: Organize commands into categories for easier navigation.\\n\"\n        \"- **Help Information**: Provide detailed help for each command.\\n\"\n        \"- **Web App Integration**: Access a web app to manage personal playlists and server settings.\\n\"\n        \"\\n\"\n        \"The bot is designed to be user-friendly and efficient, making it easy for server members to enjoy music together.\"\n    )\n    \n    return description\n"}
{"task_id": "valid/98", "completion": "\n    if n == 0:\n        return '0'\n    \n    abs_n = abs(n)\n    ternary_representation = []\n    \n    while abs_n:\n        ternary_representation.append(str(abs_n % 3))\n        abs_n //= 3\n    \n    ternary_representation.reverse()\n    return ''.join(ternary_representation)\n"}
{"task_id": "valid/99", "completion": "\n    extensions = []\n    for file_name in file_names:\n        if '.' in file_name:\n            extensions.append(file_name.split('.')[-1])\n        else:\n            extensions.append(None)\n    return tuple(extensions)\n"}
{"task_id": "valid/100", "completion": "\n    if age < 0:\n        return \"Invalid age\"\n    elif age <= 1:\n        return \"Infant\"\n    elif age <= 12:\n        return \"Child\"\n    elif age <= 19:\n        return \"Teenager\"\n    elif age <= 64:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n"}
{"task_id": "valid/101", "completion": "\n    if numerical_grade < 0 or numerical_grade > 100:\n        return \"Invalid grade\"\n    \n    letter_grade = (\n        \"A\" if numerical_grade >= 90 else\n        \"B\" if numerical_grade >= 80 else\n        \"C\" if numerical_grade >= 70 else\n        \"D\" if numerical_grade >= 60 else\n        \"F\"\n    )\n    \n    gpa = (\n        4.0 if numerical_grade >= 90 else\n        3.0 if numerical_grade >= 80 else\n        2.0 if numerical_grade >= 70 else\n        1.0 if numerical_grade >= 60 else\n        0.0\n    )\n    \n    return letter_grade, gpa\n"}
{"task_id": "valid/102", "completion": "\n    total = 0\n    for item in listing:\n        total += item['price']\n    return total\n"}
{"task_id": "valid/103", "completion": "\n    vowels = set('aeiou')\n    result = {}\n    \n    for palindrome in palindrome_tuples:\n        vowel_count = sum(1 for char in palindrome if char in vowels)\n        result[palindrome] = vowel_count\n    \n    return result\n"}
{"task_id": "valid/104", "completion": "\n    # Rule 1: If the string is empty, return \"Empty String\"\n    if not s:\n        return \"Empty String\"\n    \n    # Rule 2: If the string has only one character, return the character itself\n    if len(s) == 1:\n        return s\n    \n    # Rule 3: If the string has more than one character, reverse the string and return it\n    return s[::-1]\n"}
{"task_id": "valid/105", "completion": "\n    seen = set()\n    for num in arr:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n"}
{"task_id": "valid/106", "completion": "\n    latest_versions = {}\n    \n    for package, version in dependencies:\n        version_id, timestamp = version.split('_auto_')\n        if package not in latest_versions:\n            latest_versions[package] = (version_id, timestamp)\n        else:\n            current_version_id, current_timestamp = latest_versions[package]\n            if timestamp > current_timestamp or (timestamp == current_timestamp and version_id > current_version_id):\n                latest_versions[package] = (version_id, timestamp)\n    \n    return [(package, f\"{version_id}_auto_{timestamp}\") for package, (version_id, timestamp) in latest_versions.items()]\n"}
{"task_id": "valid/107", "completion": "\n    categorized_causes = {}\n\n    for cause in causes:\n        action, result = cause.split(\" \", 1)\n        if action in categorized_causes:\n            categorized_causes[action].append(result)\n        else:\n            categorized_causes[action] = [result]\n\n    return categorized_causes\n"}
{"task_id": "valid/108", "completion": "\n    code_name = name.replace(\" \", \"-\").lower()\n    return code_name\n"}
{"task_id": "valid/109", "completion": "\n    non_ascii_chars = [char for char in text if ord(char) > 127]\n    return non_ascii_chars\n"}
{"task_id": "valid/110", "completion": "\n    import string\n    return string.translate(str.maketrans('', '', string.punctuation))\n"}
{"task_id": "valid/111", "completion": "\n    try:\n        if not isinstance(num_list, list):\n            raise TypeError(\"The first argument must be a list.\")\n        if not isinstance(exp, (int, float)):\n            raise TypeError(\"The exponent must be an integer or float.\")\n        \n        result = [x ** exp for x in num_list]\n        return result\n    except TypeError as e:\n        print(f\"Error: {e}\")\n        return None\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n        return None\n"}
{"task_id": "valid/112", "completion": "\n    for row in grid:\n        if row:  # Check if the row is not empty\n            min_value = min(row)\n            print(min_value)\n"}
{"task_id": "valid/113", "completion": "\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    if current_num >= 2 * n:\n        return\n    \n    if current_num % 2 == 0:\n        print(\"Thank you\")\n    \n    print_thank_you(n, current_num + 1)\n"}
{"task_id": "valid/114", "completion": "\n    count = 0\n    max_count = 0\n    \n    for item in lst:\n        if item == element:\n            count += 1\n            if count > max_count:\n                max_count = count\n        else:\n            count = 0\n    \n    return max_count\n"}
{"task_id": "valid/115", "completion": "\n    num_str = format(num, f'0{base}b') if base == 2 else format(num, f'0{base}o') if base == 8 else format(num, f'0{base}x') if base == 16 else str(num)\n    first_digit = num_str[0]\n    return all(digit == first_digit for digit in num_str)\n"}
{"task_id": "valid/116", "completion": "\n    if not s:\n        return s\n    \n    vowels = \"aeiouAEIOU\"\n    if s[0] in vowels:\n        return remove_vowels_recursive(s[1:])\n    else:\n        return s[0] + remove_vowels_recursive(s[1:])\n"}
{"task_id": "valid/117", "completion": "\n    help_message = \"Usage: my_app [options]\\n\\nOptions:\\n\"\n    for option, description in options:\n        help_message += f\"  --{option:<20} {description}\\n\"\n    return help_message\n"}
{"task_id": "valid/118", "completion": "\n    if input_string:\n        return input_string[0]\n    else:\n        return None\n"}
{"task_id": "valid/119", "completion": "\n    counts = {}\n    for item in Val:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return counts\n"}
{"task_id": "valid/120", "completion": "\n    inverted_bitset = ~sample_bitset & 0xFF  # Assuming 8-bit bitset\n    return inverted_bitset\n"}
{"task_id": "valid/121", "completion": "\n    vowels = set('aeiouAEIOU')\n    return all(char in vowels for char in s)\n"}
{"task_id": "valid/122", "completion": "\n    count = 0\n    sub_len = len(subsequence)\n    seq_len = len(sequence)\n    \n    for i in range(seq_len - sub_len + 1):\n        if sequence[i:i + sub_len] == subsequence:\n            count += 1\n    \n    return count\n"}
{"task_id": "valid/123", "completion": "\n    if t == 0:\n        raise ValueError(\"The divisor cannot be zero.\")\n    \n    if h < 0:\n        h = -h\n        negative_result = True\n    else:\n        negative_result = False\n    \n    if t < 0:\n        t = -t\n        negative_result = not negative_result\n    \n    quotient = 0\n    while h >= t:\n        h -= t\n        quotient += 1\n    \n    if negative_result:\n        quotient = -quotient\n    \n    return quotient\n"}
{"task_id": "valid/124", "completion": "\n    total = 0\n    for num in input_list:\n        if num % 2 != 0:\n            total += num\n    return total\n"}
{"task_id": "valid/125", "completion": "\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    count = 0\n    for char in string:\n        if char in consonants:\n            count += 1\n    return count\n"}
{"task_id": "valid/126", "completion": "\n    # Calculate the number of electrons based on the grid energies and ADOS\n    num_electrons = 0\n    for i in range(dos_grid_size):\n        num_electrons += ados[i] * grid_energies[i]\n\n    # Adjust the number of electrons based on doping levels\n    num_electrons += dope\n\n    return num_electrons\n"}
{"task_id": "valid/127", "completion": "\n    return tuple(set(tuple_to_process))\n"}
{"task_id": "valid/128", "completion": "\n    n = len(arr)\n    arr.sort()\n    result = []\n    \n    for i in range(n // 2):\n        result.append(arr[i])\n        result.append(arr[n - i - 1])\n    \n    if n % 2 != 0:\n        result.append(arr[n // 2])\n    \n    return result\n"}
{"task_id": "valid/129", "completion": "\n    color_dict = {}\n    for color_tuple in color_list:\n        color_name, color_value = color_tuple\n        color_dict[color_name] = color_value\n    return color_dict\n"}
{"task_id": "valid/130", "completion": "\n    stack = []\n    opening_brackets = {'(': ')', '[': ']', '{': '}'}\n    closing_brackets = {')': '(', ']': '[', '}': '{'}\n    \n    for char in string:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack[-1] != closing_brackets[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n"}
{"task_id": "valid/131", "completion": "\n    unique_elements = []\n    count = 0\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n            count += 1\n            if count == 3:\n                break\n    return unique_elements\n"}
{"task_id": "valid/132", "completion": "\n    sorted_list = sorted(fruit_list)\n    return ', '.join(sorted_list)\n"}
{"task_id": "valid/133", "completion": "\n    sublists = []\n    n = len(lst)\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            sublists.append(lst[i:j])\n    return sublists\n"}
{"task_id": "valid/134", "completion": "\n    pattern = r'\\d\\.\\d'\n    return bool(re.search(pattern, string))\n"}
{"task_id": "valid/135", "completion": "\n    from django.db import migrations, models\n\n    def generate_migration_operation(app_name, model_name, field_name):\n        class Migration(migrations.Migration):\n            dependencies = [\n                (app_name, '0001_initial'),  # Assuming the initial migration is named '0001_initial'\n            ]\n\n            operations = [\n                migrations.AlterField(\n                    model_name=model_name,\n                    name=field_name,\n                    field=models.CharField(max_length=255, null=True),  # Example alteration\n                ),\n            ]\n\n        return Migration\n\n    # Example usage:\n    # migration_class = generate_migration_operation('history', 'CommitteeMember', 'position')\n    # print(migration_class.operations)\n"}
{"task_id": "valid/136", "completion": "\n    common_elements = set(list1) & set(list2)\n    return sum(common_elements)\n"}
{"task_id": "valid/137", "completion": "\n    # Calculate the length of the dataset\n    dataset_length = len(df)\n    \n    # Calculate 1% of the dataset length\n    one_percent_length = dataset_length * 0.01\n    \n    # Round up to the nearest integer\n    forecast_period = math.ceil(one_percent_length)\n    \n    return forecast_period\n"}
{"task_id": "valid/138", "completion": "\n    return sorted(array, key=lambda x: x.get(attr))\n"}
{"task_id": "valid/139", "completion": "\n    start_index = (page_number - 1) * items_per_page\n    end_index = start_index + items_per_page\n    return items[start_index:end_index]\n"}
{"task_id": "valid/140", "completion": "\n    result = []\n    carry = 0\n\n    for digit in reversed(n_str):\n        # Convert the current digit to an integer\n        current_digit = int(digit)\n        \n        # Double the current digit and add the carry\n        doubled_digit = current_digit * 2 + carry\n        \n        # Determine the new digit and the new carry\n        new_digit = doubled_digit % 10\n        carry = doubled_digit // 10\n        \n        # Append the new digit to the result\n        result.append(str(new_digit))\n    \n    # If there's a carry left after the last digit, add it\n    if carry:\n        result.append(str(carry))\n    \n    # The result is currently reversed, so reverse it back\n    result.reverse()\n    \n    # Join the list into a string and return\n    return ''.join(result)\n"}
{"task_id": "valid/141", "completion": "\n    presets = {\n        \"home\": (0.0, 0.0, 0.0),\n        \"pick\": (1.0, 2.0, 0.5),\n        \"place\": (3.0, 4.0, 0.5),\n        \"inspection\": (2.0, 2.0, 1.0)\n    }\n\n    if preset_name in presets:\n        return presets[preset_name]\n    else:\n        raise ValueError(f\"Preset '{preset_name}' not found.\")\n"}
{"task_id": "valid/142", "completion": "\n    common_elements = set(list1) & set(list2)\n    if not common_elements:\n        return 0\n    product = 1\n    for element in common_elements:\n        product *= element\n    return product\n"}
{"task_id": "valid/143", "completion": "\n    if allow_multiple_answer:\n        print(\"Multiple answers are allowed for this quiz.\")\n    else:\n        print(\"Only one answer is allowed for this quiz.\")\n\n    if zoom_level > 100:\n        print(\"The zoom level is set to a high value. Users may experience difficulty reading small text.\")\n    elif zoom_level < 50:\n        print(\"The zoom level is set to a low value. Users may experience difficulty reading large text.\")\n    else:\n        print(\"The zoom level is set to an optimal value for readability.\")\n"}
{"task_id": "valid/144", "completion": "\n    return math.floor(num)\n"}
{"task_id": "valid/145", "completion": "\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in sentence if char not in vowels])\n"}
{"task_id": "valid/146", "completion": "\n    def is_alphabetic_key(key):\n        return all(c.isalpha() for c in key)\n\n    def merge_nested(a, b):\n        merged = {}\n        for key in set(a.keys()).union(b.keys()):\n            if is_alphabetic_key(key):\n                if isinstance(a.get(key), dict) and isinstance(b.get(key), dict):\n                    merged[key] = merge_nested(a[key], b[key])\n                else:\n                    merged[key] = b.get(key, a.get(key))\n        return merged\n\n    merged = merge_nested(a, b)\n    sorted_keys = sorted(merged.keys())\n    sorted_merged = {key: merged[key] for key in sorted_keys}\n    return sorted_merged\n"}
{"task_id": "valid/147", "completion": "\n    try:\n        def recursive_max(d):\n            max_value = float('-inf')\n            for key, value in d.items():\n                if isinstance(value, dict):\n                    max_value = max(max_value, recursive_max(value))\n                else:\n                    max_value = max(max_value, value)\n            return max_value\n        \n        return recursive_max(d)\n    except (TypeError, ValueError, AttributeError) as e:\n        return f\"An error occurred: {e}\"\n"}
{"task_id": "valid/148", "completion": "\n    if key in dict:\n        values = dict[key]\n        avg = sum(values) / len(values)\n        return avg\n    else:\n        return None\n"}
{"task_id": "valid/149", "completion": "\n    if not string:\n        return None\n    return string.replace('e', '*')\n"}
{"task_id": "valid/150", "completion": "\n    if n <= 0:\n        return []\n    \n    heap = lst[:n]\n    heapq.heapify(heap)\n    \n    for item in lst[n:]:\n        if item < heap[0]:\n            heapq.heapreplace(heap, item)\n    \n    return sorted(heap)\n"}
{"task_id": "valid/151", "completion": "\n    if x <= 0:\n        return False\n    root = int(sqrt(x))\n    return root * root == x\n"}
{"task_id": "valid/152", "completion": "\n    return date + datetime.timedelta(days=10)\n"}
