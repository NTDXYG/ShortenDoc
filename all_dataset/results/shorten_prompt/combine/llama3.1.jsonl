{"task_id": "EvoEval/0", "completion": "\n    def is_happy(s):\n        return len(s) >= 3 and len(set(s[i:i+3] for i in range(len(s)-2))) == len(s)//3\n\n    if not is_happy(a) and not is_happy(b):\n        return None\n    elif is_happy(a) and is_happy(b):\n        a = float(a.replace(',', '.'))\n        b = float(b.replace(',', '.'))\n        return str(max(a, b))\n    elif is_happy(a) and not is_happy(b):\n        return a\n    else:\n        return b\n"}
{"task_id": "EvoEval/1", "completion": "\n    import math\n    num, string = value.split('.')\n    num = float(num)\n    rounded_num = math.ceil(num) if num - math.floor(num) >= 0.5 else math.floor(num)\n    flipped_string = string.swapcase()\n    return f'{rounded_num} {flipped_string}'\n"}
{"task_id": "EvoEval/2", "completion": "\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(pow(2, n, p))\n    return result\n"}
{"task_id": "EvoEval/3", "completion": "\n\n    \"\"\"\n    from typing import List def sort_parentheses(lst: List[str]) -> str: ''' You are given a list of strings, each string consist of open parentheses '(' or close parentheses ')' and numberals from 'zero' to 'nine' in text form. Your job is to sort numbers from smallest to largest and then check if it is possible to concatenate the strings in this order so that the resulting string will be good. A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string '(three)(one)(five)' is good, while the string '(three)(one(five)' is not. Return 'Yes' if there's a way to make a good string after sorting, and return 'No' otherwise. Examples: sort_parentheses(['(three)(', '(five)', '(one)']) == 'No' sort_parentheses(['(five)', '(three)', '(one)']) == 'Yes' '''\n    \"\"\"\n    from typing import List\n    def sort_parentheses(lst: List[str]) -> str:\n        # Sort the list of strings based on the numbers in the strings\n        sorted_lst = sorted(lst, key=lambda x: int(''.join(filter(str.isdigit, x))))\n        \n        # Initialize an empty string to store the result\n        result = ''\n        \n        # Iterate over the sorted list of strings\n        for s in sorted_lst:\n            # Remove the parentheses from the string and add the number to the result\n            result += ''.join(filter(str.isdigit, s))\n        \n        # Check if the result string is good\n        if result.count('(') == result.count(')'):\n            return 'Yes'\n        else:\n            return 'No'\n   "}
{"task_id": "EvoEval/4", "completion": "\nCheck if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def largest_prime_divisor(n: int) -> int:\n        \"\"\"Find the largest prime divisor of a number.\"\"\"\n        for i in range(n - 1, 1, -1):\n            if n % i == 0 and is_prime(i):\n                return i\n        return n\n\n    def sum_of_digits(n: int) -> int:\n        \"\"\"Calculate the sum of digits of a number.\"\"\"\n        return sum(int(digit) for digit in str(n))\n\n    return max(sum_of_digits(largest_prime_divisor(num)) for num in lst) if lst else 0\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    # Check if any two numbers are closer than the threshold\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # Sort the array according to the given rules\n                if round(numbers[0] + numbers[-1]) % 2 == 0:\n                    # Sort in descending order if the sum of the first and last numbers is even\n                    numbers.sort(reverse=True)\n                else:\n                    # Sort in ascending order if the sum of the first and last numbers is odd\n                    numbers.sort()\n                return numbers\n    # If no two numbers are closer than the threshold, return the array as it is\n    return numbers\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Initialize an empty list to store the number of stones in each level\n    stones = []\n    \n    # Loop through each level\n    for i in range(1, n + 1):\n        # If n is odd, the number of stones in the current level is the next odd number\n        if n % 2 != 0:\n            stones.append(i * 2 - 1)\n        # If n is even, the number of stones in the current level is the next even number\n        else:\n            stones.append(i * 2)\n    \n    # Sort the list of stones in ascending order\n    stones.sort()\n    \n    # Calculate the median of the list of stones\n    median = stones[len(stones) // 2] if len(stones) % 2 != 0 else (stones[len(stones) // 2 - 1] + stones[len(stones) // 2]) / 2\n    \n    # Return the median\n    return median\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize an empty list to store the results\n    result = []\n    # Loop through the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if the index is a multiple of 3\n        if i % 3 == 0:\n            # If it is, square the integer and append it to the result list\n            result.append(i ** 2)\n        # Check if the index is a multiple of 4 but not 3\n        elif i % 4 == 0 and i % 3 != 0:\n            # If it is, cube the integer and append it to the result list\n            result.append(i ** 3)\n        else:\n            # If it's neither, just append the integer to the result list\n            result.append(i)\n    # Return the sum of all entries in the result list\n    return sum(result)  # Changed from sum(result) to sum(result) to make it more explicit\n\n"}
{"task_id": "EvoEval/8", "completion": "\n    # Initialize counters for opening and closing brackets\n    opening_brackets = 0\n    closing_brackets = 0\n    # Initialize a flag to track if the brackets are correctly paired\n    is_correctly_paired = True\n    # Initialize a counter for the specific bracket\n    specific_bracket_count = 0\n    # Iterate over the string\n    for char in string:\n        # Check if the character is an opening bracket\n        if char == bracket:\n            # Increment the opening brackets counter\n            opening_brackets += 1\n            # Increment the specific bracket counter\n            specific_bracket_count += 1\n        # Check if the character is a closing bracket\n        elif char == '>' if bracket == '<' else '<':\n            # Increment the closing brackets counter\n            closing_brackets += 1\n            # Check if the brackets are correctly paired\n            if opening_brackets < closing_brackets:\n                # If not, set the flag to False\n                is_correctly_paired = False\n    # Check if the brackets are correctly paired\n    if opening_brackets != closing_brackets:\n        # If not, set the flag to False\n        is_correctly_paired = False\n    # Return the result as a tuple\n    return is_correctly_paired, specific_bracket_count\n"}
{"task_id": "EvoEval/9", "completion": "\n    planets = [\"mercury\", \"venus\", \"earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"]\n    roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"]\n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    if planet1 == planet2:\n        return {}\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        start = index1 + 1\n        end = index2\n    else:\n        start = index2 + 1\n        end = index1\n    result = {}\n    for i in range(start, end):\n        result[planets[i]] = roman_numerals[i]\n    return result\n"}
{"task_id": "EvoEval/10", "completion": "\n    # Define the grading table\n    grading_table = {\n        'A+': (4.0, float('inf')),\n        'A': (3.7, 4.0),\n        'A-': (3.3, 3.7),\n        'B+': (3.0, 3.3),\n        'B': (2.7, 3.0),\n        'B-': (2.3, 2.7),\n        'C+': (2.0, 2.3),\n        'C': (1.7, 2.0),\n        'C-': (1.3, 1.7),\n        'D+': (1.0, 1.3),\n        'D': (0.7, 1.0),\n        'D-': (0.0, 0.7),\n        'E': (0.0, 0.0)\n    }\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over each student in the input list\n    for name, grade in name_grade_list:\n        # Convert the name to proper case\n        proper_name = name.title()\n\n        # Find the corresponding letter grade\n        for letter_grade, (lower_bound, upper_bound) in grading_table.items():\n            if lower_bound <= grade <= upper_bound:\n                result.append((proper_name, letter_grade))\n                break\n\n    # Return the result\n    return result\n"}
{"task_id": "EvoEval/11", "completion": "\n    # Define the list of planets in our solar system, sorted by proximity to the Sun\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if planet1 and planet2 are valid planet names\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    \n    # Find the indices of planet1 and planet2 in the list of planets\n    idx1 = planets.index(planet1)\n    idx2 = planets.index(planet2)\n    \n    # Find the planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    between_planets = planets[idx1+1:idx2]\n    \n    # Initialize the count of vowels\n    vowel_count = 0\n    \n    # Iterate over the planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    for planet in between_planets:\n        # Count the number of vowels in the name of the planet\n        vowel_count += sum(1 for char in planet if char.lower() in 'aeiouy' and (char.lower() != 'y' or planet[-1].lower() != 'y'))\n    \n    # Return the total count of vowels\n    return vowel_count\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Define the grading scale\n    grading_scale = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-'\n    }\n    \n    # Initialize an empty list to store the final grades\n    final_grades = []\n    \n    # Iterate over each student in the list\n    for student in student_info:\n        # Count the number of consonants in the student's name\n        consonant_count = sum(1 for char in student['name'].lower() if char.isalpha() and char not in 'aeiou')\n        \n        # If the student's name contains exactly n consonants, bump up their grade\n        if consonant_count == n:\n            # Find the next highest grade in the grading scale\n            for grade in sorted(grading_scale.keys(), reverse=True):\n                if student['GPA'] >= grade:\n                    final_grades.append({'name': student['name'], 'grade': grading_scale[grade]})\n                    break\n        else:\n            # Otherwise, just use the student's GPA to determine their grade\n            for grade in sorted(grading_scale.keys(), reverse=True):\n                if student['GPA'] >= grade:\n                    final_grades.append({'name': student['name'], 'grade': grading_scale[grade]})\n                    break\n    \n    # Return the list of final grades\n    return final_grades\n"}
{"task_id": "EvoEval/13", "completion": "\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    def is_even(n):\n        return n % 2 == 0\n    \n    filtered_arr = [num for num in arr if sum_of_digits(num) > 0]\n    lst1 = [num for num in lst1 if is_even(num)]\n    \n    if not lst1:\n        return \"YES\"\n    \n    for num in filtered_arr:\n        if is_even(num):\n            lst1.append(num)\n            filtered_arr.remove(num)\n            if all(is_even(n) for n in lst1):\n                return \"YES\"\n            lst1.remove(num)\n            filtered_arr.append(num)\n    \n    return \"NO\" if lst1 else \"YES\"  # if lst1 is empty, return \"YES\" because all elements in lst1 are even\n"}
{"task_id": "EvoEval/14", "completion": "\n    if n > m:\n        return -1\n    primes = [i for i in range(n, m+1) if all(i % j != 0 for j in range(2, int(i**0.5) + 1))]\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)[2:]  # remove '0b' prefix\n"}
{"task_id": "EvoEval/15", "completion": "\n    balance = 0\n    seen = set()\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return False\n        if balance in seen:\n            return True\n        seen.add(balance)\n    return False\n"}
{"task_id": "EvoEval/16", "completion": "\n    # Find the index of the first vowel from the right side of the word\n    idx = len(word) - 1\n    while idx >= 0 and word[idx] not in 'aeiou':\n        idx -= 1\n    if idx < 0:\n        return []\n    \n    # Find the index of the second vowel from the right side of the word\n    idx2 = idx - 1\n    while idx2 >= 0 and word[idx2] not in 'aeiou':\n        idx2 -= 1\n    if idx2 < 0:\n        return []\n    \n    # Get the corresponding beats in the music string up to the closest vowel (inclusive)\n    beats = []\n    for i in range(idx2 + 1):\n        if music_string[i] == 'o':\n            beats.append(4)\n        elif music_string[i] == 'o|':\n            beats.append(2)\n        elif music_string[i] == '.|':\n            beats.append(1)\n    \n    return beats\n"}
{"task_id": "EvoEval/17", "completion": "\n    # First, we need to calculate the n-th element of the FibFib sequence\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        # Initialize the first three elements of the FibFib sequence\n        a, b, c = 0, 0, 1\n        # Calculate the n-th element of the FibFib sequence\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        # Now, we need to find the greatest integer in the list that has a frequency equal or greater than the calculated n-th FibFib element\n        # First, we count the frequency of each integer in the list\n        freq = {}\n        for num in lst:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        # Then, we find the greatest integer that has a frequency equal or greater than the calculated n-th FibFib element\n        max_num = -1\n        for num in sorted(freq.keys(), reverse=True):\n            if freq[num] >= c:\n                max_num = num\n                break\n        return max_num\n"}
{"task_id": "EvoEval/18", "completion": "\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        for j in range(i + 1, len(nums) - 1):\n            for k in range(j + 1, len(nums)):\n                min_sum = min(min_sum, nums[i] + nums[j] + nums[k])\n    return min_sum if min_sum != float('inf') else 0\n"}
{"task_id": "EvoEval/19", "completion": "\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    below_zero = False\n    for operation in operations:\n        balance += operation\n        if operation < 0 and balance < 0:\n            below_zero = True\n        if operation > 0:\n            if smallest_deposit is None or operation < smallest_deposit:\n                smallest_deposit = operation\n        if operation < 0:\n            if largest_withdrawal is None or operation > largest_withdrawal:\n                largest_withdrawal = operation\n    return largest_withdrawal, smallest_deposit, below_zero\n"}
{"task_id": "EvoEval/20", "completion": "\n    result = []\n    for i in range(len(s)):\n        # Reverse the case of the student name\n        reversed_name = ''.join([c.upper() if c.islower() else c.lower() for c in s[i]])\n        # Assign a letter grade to the student based on their GPA\n        if grades[i] > 4.0:\n            grade = 'A+'\n        elif grades[i] > 3.7:\n            grade = 'A'\n        elif grades[i] > 3.3:\n            grade = 'A-'\n        elif grades[i] > 3.0:\n            grade = 'B+'\n        elif grades[i] > 2.7:\n            grade = 'B'\n        elif grades[i] > 2.3:\n            grade = 'B-'\n        elif grades[i] > 2.0:\n            grade = 'C+'\n        elif grades[i] > 1.7:\n            grade = 'C'\n        elif grades[i] > 1.3:\n            grade = 'C-'\n        elif grades[i] > 1.0:\n            grade = 'D+'\n        elif grades[i] > 0.7:\n            grade = 'D'\n        elif grades[i] > 0.0:\n            grade = 'D-'\n        else:\n            grade = 'E'\n        # Append the reversed name and grade to the result list\n        result.append((reversed_name, grade))\n    return result\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Convert the number to the new base\n    new_base = ''\n    while x:\n        new_base = str(x % base) + new_base\n        x //= base\n\n    # Generate all prefixes\n    prefixes = []\n    for i in range(1, len(new_base) + 1):\n        prefixes.append(new_base[:i])\n\n    return prefixes\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Define the order of the planets in our solar system\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if the input planet names are valid\n    if planet1 not in planets or planet2 not in planets:\n        return \"\"\n    \n    # Find the indices of the input planets in the list of planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Find the planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    between_planets = [planet for i, planet in enumerate(planets) if index1 < i < index2]\n    \n    # Sort the planets by their proximity to the Sun\n    between_planets.sort(key=lambda x: planets.index(x))\n    \n    # Convert the number of planets to binary format\n    binary = bin(len(between_planets))[2:]\n    \n    # Add the extra characters 'bd' at the beginning and at the end of the string\n    binary = \"bd\" + binary + \"bd\"\n    \n    return binary\n"}
{"task_id": "EvoEval/23", "completion": "\n    if n <= 0:\n        return []\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            next_num = i + 2\n        else:\n            next_num = i + 1\n        factorial = 1\n        for j in range(i, 0, -1):\n            factorial *= j\n        result.append(factorial)\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    # Remove spaces from the string\n    numbers = numbers.replace(' ', '')\n\n    # Check if the string is happy\n    if len(numbers) % 3 == 0:\n        for i in range(0, len(numbers), 3):\n            if len(set(numbers[i:i+3])) != 3:\n                return 'Not a happy string'\n    else:\n        return 'Not a happy string'\n\n    # Sort the string with numbers from smallest to largest\n    numbers = sorted(numbers)\n\n    # Return the sorted string\n    return ' '.join(numbers)\n"}
{"task_id": "EvoEval/25", "completion": "\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_of_first_elements = 0\n    product_of_first_elements = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    sum_of_first_elements += a[i]\n                    product_of_first_elements *= a[i]\n    return sum_of_first_elements, product_of_first_elements\n"}
{"task_id": "EvoEval/26", "completion": "\n    # Define a dictionary to map string numerals to their integer values\n    numeral_map = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n\n    # Initialize variables to store the smallest even numeral and its original index\n    smallest_even = None\n    smallest_even_index = None\n\n    # Iterate over the list of strings\n    for i, value in enumerate(values):\n        # Split the string into a list of numerals\n        numerals = value.split()\n\n        # Sort the list of numerals\n        numerals.sort(key=lambda x: numeral_map[x])\n\n        # Iterate over the sorted list of numerals\n        for numeral in numerals:\n            # Check if the numeral is even\n            if numeral_map[numeral] % 2 == 0:\n                # If this is the first even numeral, or it has a smaller value than the current smallest even numeral, update the smallest even numeral and its index\n                if smallest_even is None or numeral_map[numeral] < numeral_map[smallest_even]:\n                    smallest_even = numeral\n                    smallest_even_index = i\n                # If this even numeral has the same value as the current smallest even numeral, but it has a smaller index, update the smallest even numeral and its index\n                elif numeral_map[numeral] == numeral_map[smallest_even] and numerals.index(numeral) < numerals.index(smallest_even):\n                    smallest_even = numeral\n                    smallest_even_index = i\n\n    # If no even numerals were found, return an empty tuple\n    if smallest_even is None:\n        return ()\n\n    # Return the smallest even numeral and its original index\n    return (smallest_even, smallest_even_index)  # Return the smallest even numeral and its original index\n"}
{"task_id": "EvoEval/27", "completion": "\n    # First, we define a helper function to check if a number is prime\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Then, we create a set of prime numbers from lst2\n    prime_set = set(num for num in lst2 if is_prime(num))\n\n    # We initialize a variable to store the result\n    result = x\n\n    # We iterate over the elements in lst1\n    for num in lst1:\n        # If the number is not in the prime set, we try to find a prime number in lst2 that can replace it\n        if num not in prime_set:\n            # We iterate over the elements in lst2\n            for num2 in lst2:\n                # If the number is prime and not in lst1, we add it to the prime set and remove it from lst2\n                if is_prime(num2) and num2 not in lst1:\n                    prime_set.add(num2)\n                    lst2.remove(num2)\n                    # We break the loop to try the next number in lst1\n                    break\n            else:\n                # If we couldn't find a prime number to replace the current number, we return y\n                return y\n        # If the number is in the prime set, we remove it from the prime set and add it to lst2\n        else:\n            prime_set.remove(num)\n            lst2.append(num)\n\n    # If we've iterated over all numbers in lst1 and we haven't returned y, it means we can make lst1 a list of only prime numbers\n    # So, we return x\n    return result\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Define the grading system\n    grading_system = {\n        'A+': 4.0,\n        'A': 3.7,\n        'A-': 3.3,\n        'B+': 3.0,\n        'B': 2.7,\n        'B-': 2.3,\n        'C+': 2.0,\n        'C': 1.7,\n        'C-': 1.3,\n        'D+': 1.0,\n        'D': 0.7,\n        'D-': 0.0,\n        'E': 0.0\n    }\n    \n    # Initialize an empty list to store the grades\n    grades_list = []\n    \n    # Iterate over the GPAs\n    for g in grades:\n        # Check if the GPA is in the grading system\n        if g in grading_system.values():\n            # Check if the name and course title have the same characters\n            if set(s0).issubset(set(s1)) and set(s1).issubset(set(s0)):\n                # Get the corresponding grade\n                grade = [k for k, v in grading_system.items() if v == g][0]\n                # Add the grade to the list\n                grades_list.append(grade)\n    \n    # Return the list of grades\n    return grades_list\n"}
{"task_id": "EvoEval/29", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if n == 1:\n        return y\n    if is_prime(n):\n        return x\n    for i in range(n - 1, 1, -1):\n        if n % i == 0 and is_prime(i):\n            return i\n    return n  # if no prime factor found, return n itself\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Split the music string into individual notes\n    notes = music_string.split()\n    \n    # Initialize the result list\n    result = []\n    \n    # Split the fraction into numerator and denominator\n    numerator, denominator = map(int, x.split('/'))\n    \n    # Iterate over each note\n    for note in notes:\n        # Get the duration of the note\n        if note == 'o':\n            beats = 4\n        elif note == 'o|':\n            beats = 2\n        elif note == 'o|o|':\n            beats = 1\n        elif note == '.|':\n            beats = 0.5\n        elif note == 'o|o|o|':\n            beats = 0.25\n        elif note == 'o|o|o|o|':\n            beats = 0.125\n        else:\n            raise ValueError(\"Invalid note\")\n        \n        # Check if the product of the fraction and the note's duration is a whole number\n        if (numerator * beats) % denominator == 0:\n            result.append(True)\n        else:\n            result.append(False)\n    \n    return result\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Initialize an empty dictionary to store the prime factors and their counts\n    prime_factors = {}\n    \n    # Initialize the divisor to 2 (the smallest prime number)\n    divisor = 2\n    \n    # Loop through all numbers from 2 to n (inclusive)\n    while divisor <= n:\n        # If n is divisible by the current divisor, it's a prime factor\n        if n % divisor == 0:\n            # If the divisor is already in the dictionary, increment its count\n            if divisor in prime_factors:\n                prime_factors[divisor] += 1\n            # Otherwise, add it to the dictionary with a count of 1\n            else:\n                prime_factors[divisor] = 1\n            # Divide n by the divisor to remove this prime factor\n            n = n // divisor\n        # If n is not divisible by the current divisor, increment the divisor\n        else:\n            divisor += 1\n    \n    # Initialize the special factorial to 1\n    special_factorial = 1\n    \n    # Loop through the prime factors and their counts\n    for factor, count in prime_factors.items():\n        # Calculate the factorial of the current prime factor\n        factorial = 1\n        for i in range(1, count + 1):\n            factorial *= factor\n        # Multiply the special factorial by the factorial of the current prime factor\n        special_factorial *= factorial\n    \n    # Return the special factorial\n    return special_factorial\n"}
{"task_id": "EvoEval/32", "completion": "\n    # Initialize an empty list to store the nesting depths\n    nesting_depths = []\n    \n    # Iterate over each string in the input list\n    for s in input:\n        # Initialize a counter to keep track of the current nesting depth\n        depth = 0\n        \n        # Initialize a flag to indicate whether we are currently inside a group of parentheses\n        inside_group = False\n        \n        # Initialize a counter to keep track of the maximum nesting depth\n        max_depth = 0\n        \n        # Iterate over each character in the string\n        for c in s:\n            # If the character is an opening parenthesis, increment the current nesting depth\n            if c == '(':\n                depth += 1\n                # If we are not currently inside a group, set the flag to True\n                if not inside_group:\n                    inside_group = True\n            # If the character is a closing parenthesis, decrement the current nesting depth\n            elif c == ')':\n                depth -= 1\n                # If the current nesting depth is 0, we are no longer inside a group\n                if depth == 0:\n                    inside_group = False\n            # If we are inside a group and the current nesting depth is greater than the maximum nesting depth, update the maximum nesting depth\n            if inside_group and depth > max_depth:\n                max_depth = depth\n        \n        # Append the maximum nesting depth to the list of nesting depths\n        nesting_depths.append(max_depth)\n    \n    # Convert the list of nesting depths to a single number\n    num = int(''.join(map(str, nesting_depths)))\n    \n    # Apply the circular shift to the number\n    num = int(str(num)[shift:] + str(num)[:shift])\n    \n    # Convert the number back to a list of individual digits\n    result = [int(d) for d in str(num)]\n    \n    return result\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Define the mapping of Roman numerals to integers\n    roman_map = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    \n    # Check if the length of the string is at least 3\n    if len(s) < 3:\n        return False\n    \n    # Initialize the total value to 0\n    total = 0\n    \n    # Iterate over the string from left to right\n    for i in range(len(s)):\n        # If the current numeral is less than the next one, subtract its value\n        if i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i + 1]]:\n            total -= roman_map[s[i]]\n        # Otherwise, add its value\n        else:\n            total += roman_map[s[i]]\n    \n    # Check if the total value is less than or equal to 1000\n    if total > 1000:\n        return False\n    \n    # Check if every 3 consecutive letters are distinct\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n    \n    # If all conditions are met, return the total value\n    return total\n"}
{"task_id": "EvoEval/34", "completion": "\n    import hashlib\n    import re\n    result = []\n    for group in paren_string.split():\n        # find the deepest level of nesting of parentheses for each group\n        deepest_level = 0\n        current_level = 0\n        for char in group:\n            if char == '(':\n                current_level += 1\n                deepest_level = max(deepest_level, current_level)\n            elif char == ')':\n                current_level -= 1\n        if current_level != 0:\n            result.append('None')\n            continue\n        # convert the deepest level to a string\n        deepest_level_str = str(deepest_level)\n        # compute md5 hash of the string\n        md5_hash = hashlib.md5(deepest_level_str.encode()).hexdigest()\n        result.append(md5_hash)\n    return result\n"}
{"task_id": "EvoEval/35", "completion": "\n    if not dict:\n        return False\n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    if not all_lower and not all_upper:\n        return False\n    for key in dict.keys():\n        if len(key) < 3:\n            return False\n        for i in range(len(key) - 2):\n            if len(set(key[i:i+3])) < 3:\n                return False\n    return True\n"}
{"task_id": "EvoEval/36", "completion": "\n    # Check if the array is empty\n    if not arr:\n        return True\n\n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n\n    # Calculate the maximum number of shifts allowed\n    max_shifts = (2 ** n) % p\n\n    # Perform right shift operations\n    for _ in range(max_shifts):\n        # Shift the array to the right\n        arr = arr[-1:] + arr[:-1]\n\n        # Check if the array is sorted\n        if arr == sorted(arr):\n            return True\n\n    # If the array is not sorted after the maximum number of shifts, return False\n    return False\n\n"}
{"task_id": "EvoEval/37", "completion": "\n    n = len(nums)\n    min_sum = float('inf')\n    even_count = 0\n    odd_count = 0\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n            if curr_sum < min_sum:\n                min_sum = curr_sum\n    return (even_count, odd_count)\n"}
{"task_id": "EvoEval/38", "completion": "\n    even_palindromes = 0\n    odd_palindromes = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_palindromes += 1\n            else:\n                odd_palindromes += 1\n    even_sum = False\n    odd_sum = False\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == even_palindromes:\n                even_sum = True\n            elif l[i] + l[j] == odd_palindromes:\n                odd_sum = True\n    return (even_sum, odd_sum)  # return a tuple of two booleans"}
{"task_id": "EvoEval/39", "completion": "\n    # Create a dictionary to store the frequency of each number in the array\n    freq = {}\r\n    for num in arr:\r\n        if num in freq:\r\n            freq[num] += 1\r\n        else:\r\n            freq[num] = 1\r\n\r\n    # Initialize the count of changes and the sum of x and y\r\n    changes = 0\r\n    total = x + y\r\n\r\n    # Iterate over the frequency dictionary\r\n    for num, count in freq.items():\r\n        # If the count is odd, increment the changes by 1 and add the number to the total\r\n        if count % 2 != 0:\r\n            changes += 1\r\n            total += num\r\n        # If the count is even, increment the changes by the count divided by 2\r\n        else:\r\n            changes += count // 2\r\n\r\n    # Return the total changes plus the sum of x and y\r\n    return changes + total\r\n\r"}
{"task_id": "EvoEval/40", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_odd_ends(n):\n        return n % 10 % 10 % 1 == 0\n\n    def largest_prime_factor(n):\n        max_prime = 1\n        for i in range(2, int(n**0.5) + 1):\n            while n % i == 0:\n                max_prime = max(max_prime, i)\n                n //= i\n        if n > 1:\n            max_prime = max(max_prime, n)\n        return max_prime\n\n    result = None\n    for num in nums:\n        if is_odd_ends(abs(num)) and num > 10 and is_prime(largest_prime_factor(num)):\n            result = max(result, largest_prime_factor(num)) if result else largest_prime_factor(num)\n    return result\n"}
{"task_id": "EvoEval/41", "completion": "\n    # Reverse the string if shift is greater than the length of the string\n    if shift > len(s):\n        s = s[::-1]\n        shift = shift % len(s)\n    \n    # Perform the circular shift on the ASCII values of the characters in the string\n    shifted_s = ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a')) if c.isalpha() else c for c in s)\n    \n    # Count the uppercase vowels in even indices after the shift\n    count = 0\n    for i in range(len(shifted_s)):\n        if i % 2 == 0 and shifted_s[i].upper() in 'AEIOU':\n            count += 1\n    \n    return count\n"}
{"task_id": "EvoEval/42", "completion": "\n    # Remove the first and last characters from the string\n    expression = expression[1:-1]\n    \n    # Split the string into fractions\n    fractions = expression.split(',')\n    \n    # Initialize the product of fractions\n    product = 1\n    \n    # Iterate over each fraction\n    for fraction in fractions:\n        # Split the fraction into numerator and denominator\n        numerator, denominator = fraction.split('/')\n        \n        # Multiply the product by the fraction\n        product *= int(numerator) / int(denominator)\n    \n    # Check if the product is a whole number\n    return product == int(product)\n"}
{"task_id": "EvoEval/43", "completion": "\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 0]\n    elif n == 3:\n        return [0, 0, 2]\n    elif n == 4:\n        return [0, 0, 2, 2]\n    else:\n        fib4_sequence = [0, 0, 2, 2]\n        for i in range(4, n):\n            fib4_sequence.append(fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4])\n        if sum(fib4_sequence) % 2 == 0:\n            return sorted(fib4_sequence, reverse=True)\n        else:\n            return sorted(fib4_sequence)  # return sorted list in ascending order"}
{"task_id": "EvoEval/44", "completion": "\n    # Define a dictionary to map integers to their roman numeral equivalents\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    # Convert the input number to its roman numeral equivalent\n    roman_num = ''\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            roman_num += roman_numerals[value]\n            number -= value\n    \n    # Initialize an empty list to store the prefixes\n    prefixes = []\n    \n    # Iterate over the length of the roman numeral string\n    for i in range(1, len(roman_num) + 1):\n        # Append the prefix of the current length to the list\n        prefixes.append(roman_num[:i])\n    \n    # Return the list of prefixes\n    return prefixes\n"}
{"task_id": "EvoEval/45", "completion": "\n\n        Helper function to check if a number is prime.\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    prime_product = 1\n    for num in numbers:\n        if is_prime(num):\n            prime_sum += num\n            prime_product *= num\n    return prime_sum, prime_product\n"}
{"task_id": "EvoEval/46", "completion": "\n    # Filter out negative numbers from the list\n    positive_numbers = [num for num in l if num > 0]\n    \n    # If the list of positive numbers is empty, return -1\n    if not positive_numbers:\n        return -1\n    \n    # Filter out odd numbers from the list of positive numbers\n    even_numbers = [num for num in positive_numbers if num % 2 == 0]\n    \n    # If the list of even numbers is empty, return -1\n    if not even_numbers:\n        return -1\n    \n    # Return the maximum even number\n    return max(even_numbers)  # Use max() function to find the maximum number in the list\n\n"}
{"task_id": "EvoEval/47", "completion": "\n    n = sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in 'AEIOU')\n    return [f\"In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {sum(1 for c in s if int(c) % 2 != 0)}\" for s in lst]  # count odd digits in string 's' and return the result as a list\n"}
{"task_id": "EvoEval/48", "completion": "\nCheck if a number is prime.\"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def length_is_prime(s: str) -> bool:\n        \"\"\"Check if the length of a string is a prime number.\"\"\"\n        return is_prime(len(s))\n\n    return [s for s in strings if s.startswith(prefix) and length_is_prime(s)]\n\n"}
{"task_id": "EvoEval/49", "completion": "\n    # Calculate 2^n modulo p\n    result = pow(2, n, p)\n    \n    # Initialize count of numbers with sum of digits > result\n    count = 0\n    \n    # Iterate over each number in the array\n    for num in arr:\n        # Convert the number to a string to easily calculate the sum of its digits\n        str_num = str(num)\n        \n        # If the number is negative, remove the negative sign and add 1 to the sum of its digits\n        if str_num[0] == '-':\n            sum_of_digits = sum(int(digit) for digit in str_num[1:]) + 1\n        else:\n            sum_of_digits = sum(int(digit) for digit in str_num)\n        \n        # If the sum of the digits is greater than the result, increment the count\n        if sum_of_digits > result:\n            count += 1\n    \n    # Return the count\n    return count\n"}
{"task_id": "EvoEval/50", "completion": "\n    vowels = \"AEIOU\"\n    for i in range(len(word) - 1, 0, -1):\n        if word[i].upper() in vowels and i % 2 == 0:\n            if word[i - 1].isalpha() and not word[i - 1].upper() in vowels:\n                if word[i + 1].isalpha() and not word[i + 1].upper() in vowels:\n                    return word[i].upper()\n    return \"\"\n\n"}
{"task_id": "EvoEval/51", "completion": "\n    # Check if inputs are strings\n    if isinstance(a, str) and isinstance(b, str):\n        # Check if strings contain alphabets\n        if any(char.isalpha() for char in a) or any(char.isalpha() for char in b):\n            # Convert strings to lower case if they are upper case, and vice versa\n            if a.isupper():\n                a = a.lower()\n            elif a.islower():\n                a = a.upper()\n            if b.isupper():\n                b = b.lower()\n            elif b.islower():\n                b = b.upper()\n        # If strings contain no alphabets, reverse the string\n        else:\n            a = a[::-1]\n            b = b[::-1]\n    # Check if inputs are real numbers\n    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        # If inputs are real numbers, return the original type\n        return a\n    # If at least one input does not represent real numbers, return 'b'\n    else:\n        return b\n    # Compare 'a' and 'b'\n    if a == b:\n        return None\n    else:\n        return b\n"}
{"task_id": "EvoEval/52", "completion": "\n    if not arr:\n        return [], None\n    even = [x for x in arr if x % 2 == 0]\n    if not even:\n        return [], None\n    smallest_even = min(even)\n    idx = arr.index(smallest_even)\n    arr.pop(idx)\n    product_of_signs = 1\n    for x in arr:\n        product_of_signs *= 1 if x >= 0 else -1\n    return [smallest_even, idx], sum(abs(x) for x in arr) * product_of_signs\n"}
{"task_id": "EvoEval/53", "completion": "\n    prime_grades = ['D', 'B', '7', '5', '3']\n    count = 0\n    for grade in grades:\n        if grade >= 4.0:\n            grade = 'F'\n        elif grade >= 3.7:\n            grade = 'E'\n        elif grade >= 3.3:\n            grade = 'D'\n        elif grade >= 3.0:\n            grade = 'C'\n        elif grade >= 2.7:\n            grade = 'B'\n        elif grade >= 2.3:\n            grade = 'A'\n        elif grade >= 2.0:\n            grade = '9'\n        elif grade >= 1.7:\n            grade = '8'\n        elif grade >= 1.3:\n            grade = '7'\n        elif grade >= 1.0:\n            grade = '6'\n        elif grade >= 0.7:\n            grade = '5'\n        elif grade >= 0.0:\n            grade = '4'\n        if grade in prime_grades:\n            count += 1\n    return count\n"}
{"task_id": "EvoEval/54", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum\n"}
{"task_id": "EvoEval/55", "completion": "\n    if number < 0 or number > 1000:\r\n        return None\r\n\r\n    roman_numerals = {\r\n        1000: 'm',\r\n        900: 'cm',\r\n        500: 'd',\r\n        400: 'cd',\r\n        100: 'c',\r\n        90: 'xc',\r\n        50: 'l',\r\n        40: 'xl',\r\n        10: 'x',\r\n        9: 'ix',\r\n        5: 'v',\r\n        4: 'iv',\r\n        1: 'i'\r\n    }\r\n\r\n    roman_num = ''\r\n    for value, numeral in roman_numerals.items():\r\n        while number >= value:\r\n            roman_num += numeral\r\n            number -= value\r\n\r\n    return hashlib.md5(roman_num.encode()).hexdigest()  # encode string to bytes before hashing\r\n\r"}
{"task_id": "EvoEval/56", "completion": "\n    # Initialize an empty list to store odd prime factors\n    odd_prime_factors = []\n    \n    # Iterate from 3 to sqrt(n) with a step of 2 (since we're only interested in odd numbers)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # If i is a factor, check if it's prime\n            if is_prime(i):\n                # If i is prime, add it to the list of odd prime factors\n                odd_prime_factors.append(i)\n            # Divide n by i to remove the factor\n            n //= i\n    \n    # If n is greater than 2, it means n is a prime number\n    if n > 2:\n        # Check if n is prime\n        if is_prime(n):\n            # If n is prime, add it to the list of odd prime factors\n            odd_prime_factors.append(n)\n    \n    # If the list of odd prime factors is empty, return 0\n    if not odd_prime_factors:\n        return 0\n    # Otherwise, return the product of the odd prime factors\n    else:\n        return math.prod(odd_prime_factors)\n"}
{"task_id": "EvoEval/57", "completion": "\n    # Count the number of odd digits in the array\n    odd_digits = sum(1 for num in arr if num % 2 != 0)\r\n    # Count the number of pairs of digits that are not the same\n    pairs = sum(1 for i in range(len(arr) - 1) if arr[i] != arr[i + 1])\r\n    # The minimum number of changes needed is the maximum of the number of odd digits and the number of pairs\n    return max(odd_digits, pairs) if odd_digits + pairs > 0 else 0\r\n\r"}
{"task_id": "EvoEval/58", "completion": "\n    # Create a dictionary to store the frequency of each number in the list\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Find the maximum frequency\n    max_freq = -1\n    for num, freq in freq_dict.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n\n    # Check if either a or b is equal to the sum of max_freq and the other integer\n    if a == max_freq + b or b == max_freq + a:\n        return (max_freq, True)\n    else:\n        return (max_freq, False)  # Changed this line to return (max_freq, False) instead of (False, False)\n"}
{"task_id": "EvoEval/59", "completion": "\n    output = []\n    for i in lst:\n        odd_count = 0\n        for digit in i:\n            # Convert the digit to the given base and count the odd digits\n            num = int(digit, 10)\n            base_num = ''\n            while num > 0:\n                base_num = str(num % base) + base_num\n                num //= base\n            for d in base_num:\n                if int(d) % 2 != 0:\n                    odd_count += 1\n        # Replace the string with the count of odd digits\n        output.append(\"the number of odd elements \" + str(odd_count) + \"n the str\" + str(odd_count) + \"ng \" + str(odd_count) + \" of the \" + str(odd_count) + \"nput.\")\n    return output\n"}
{"task_id": "EvoEval/60", "completion": "\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triple = []\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if not triple or a[i] < triple[0]:\n                        triple = [a[i], a[j], a[k]]\n    if triple:\n        arr.append(triple[0])\n        for i in range(len(arr)):\n            if arr[i] % 2 == 0:\n                return [arr[i], i]\n    return []  # Return an empty list if no even values or the array is empty\n"}
{"task_id": "EvoEval/61", "completion": "\n\n        This function takes a starting planet name as string planet1 and ending planet name as string planet2, \n        and list of chains. The function should return the longest chain that starts with planet1 and ends with planet2. \n        If there are multiple chains of the same length that starts with planet1 and ends with planet2, return the first one. \n        If there is no chain that starts with planet1 and ends with planet2, or if planet1 or planet2 are not correct planet names, return None.\n        \n        Parameters:\n        planet1 (str): The starting planet name.\n        planet2 (str): The ending planet name.\n        chains (List[Tuple[str,...]]): A list of planet chains, represented as tuples, where each chain consists of a sequence of planet names.\n        \n        Returns:\n        Optional[Tuple[str,...]]: The longest chain that starts with planet1 and ends with planet2, or None if no such chain exists.\n        \"\"\"\n        \n        # Define the correct planet names\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        \n        # Check if planet1 and planet2 are correct planet names\n        if planet1 not in planets or planet2 not in planets:\n            return None\n        \n        # Initialize the longest chain\n        longest_chain = None\n        \n        # Iterate over each chain\n        for chain in chains:\n            # Check if the chain starts with planet1 and ends with planet2\n            if chain[0] == planet1 and chain[-1] == planet2:\n                # If the chain is longer than the current longest chain, update the longest chain\n                if longest_chain is None or len(chain) > len(longest_chain):\n                    longest_chain = chain\n        \n        # Return the longest chain\n        return longest_chain\n"}
{"task_id": "EvoEval/62", "completion": "\n    words = text.split()\n    words = [word.lower() for word in words]\n    words.sort()\n    result = []\n    while words:\n        result.append(words.pop(0))\n        if words:\n            words.sort(reverse=True)\n            result.append(words.pop(0))\n    result = ['_' + word if len(result) % 2 == 1 else word for word in result]\n    result = ['-' + word if word == '-' else word for word in result]\n    return ''.join(result)  # or return ''.join(result) if you want to remove the last underscore\n"}
{"task_id": "EvoEval/63", "completion": "\n    # Define a dictionary to map planet names to their corresponding numbers\n    planets = {\n        \"Mercury\": \"zero\",\n        \"Venus\": \"one\",\n        \"Earth\": \"two\",\n        \"Mars\": \"three\",\n        \"Jupiter\": \"four\",\n        \"Saturn\": \"five\",\n        \"Uranus\": \"six\",\n        \"Neptune\": \"seven\"\n    }\n\n    # Check if planet1 and planet2 are valid planet names\n    if planet1 not in planets or planet2 not in planets:\n        return \"Invalid\"\n\n    # Get the numbers corresponding to planet1 and planet2\n    num1 = planets[planet1]\n    num2 = planets[planet2]\n\n    # Check if the order string contains numbers outside the range 'zero' to 'seven'\n    for num in order.split():\n        if num not in planets.values():\n            return \"Invalid\"\n\n    # Check if the order string contains duplicates\n    if len(order.split()) != len(set(order.split())):\n        return \"Invalid\"\n\n    # Get the list of planets in the given order\n    order_list = [planets[planet] for planet in order.split()]\n\n    # Find the indices of planet1 and planet2 in the order list\n    idx1 = order_list.index(num1)\n    idx2 = order_list.index(num2)\n\n    # Find the planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    between_planets = [num for num in order_list if idx1 < order_list.index(num) < idx2]\n\n    # Sort the planets by their proximity to the sun according to the given order\n    between_planets.sort(key=lambda x: order_list.index(x))\n\n    # Return the sorted list of planets as a string\n    return \" \".join(between_planets)  # Changed here\n"}
{"task_id": "EvoEval/64", "completion": "\n    # Calculate 2^n modulo p\n    result = pow(2, n, p)\n    \n    # Initialize an empty list to store prime numbers\n    primes = []\n    \n    # Iterate from 2 to result (inclusive)\n    for i in range(2, result + 1):\n        # Assume i is prime\n        is_prime = True\n        \n        # Check if i is divisible by any number up to its square root\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                # If i is divisible, it's not a prime number\n                is_prime = False\n                break\n        \n        # If i is prime, add it to the list\n        if is_prime:\n            primes.append(i)\n    \n    # Return the list of prime numbers\n    return primes\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Calculate 2^n modulo p\n    result = pow(2, n, p)\n    # Find the largest divisor of result smaller than p\n    for i in range(p - 1, 0, -1):\n        if result % i == 0:\n            return i\n    # If no such number exists, return 1\n    return 1\n"}
{"task_id": "EvoEval/66", "completion": "\n    # Find the largest even integer in the range [x, y] inclusive\n    max_even = max(i for i in range(x, y+1) if i % 2 == 0)\n    \n    # If no even integer is found, return -1\n    if max_even == 0:\n        return -1\n    \n    # Create an array a of length n\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    \n    # Initialize the maximum sum\n    max_sum = -1\n    \n    # Iterate over the array to find the largest triple\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                # Check if the sum of the triple is a multiple of 3\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    # Update the maximum sum\n                    max_sum = max(max_sum, a[i] + a[j] + a[k])\n    \n    # Add the largest even integer to the maximum sum\n    max_sum += max_even\n    \n    return max_sum\n"}
{"task_id": "EvoEval/67", "completion": "\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Iterate over the list of numbers\n    for i in range(len(numbers)):\n        # Iterate over the remaining numbers in the list\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            diff = abs(numbers[i] - numbers[j])\n            # If the difference is less than the threshold and greater than the current max difference, update the max difference\n            if diff < threshold and diff > max_diff:\n                max_diff = diff\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "EvoEval/68", "completion": "\n    min_product = float('inf')\n    for num in nums:\n        product = 1\n        for digit in str(num):\n            if int(digit) % 2 != 0:\n                product *= int(digit)\n        if product != 0:\n            min_product = min(min_product, product)\n    return min_product if min_product != float('inf') else 0\n"}
{"task_id": "EvoEval/69", "completion": "\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if len(set(s[i:i+3])) != 3:\n                return False\n        return True\n\n    happy_strings = [s for s in lst if is_happy(s)]\n    return sorted(happy_strings, key=lambda x: (len(x), x))  # sorted by length and then alphabetically\n"}
{"task_id": "EvoEval/70", "completion": "\n    # First, we need to calculate the special factorials for each number in the list\n    special_factorials = [math.factorial(n) for n in numbers]\n    \n    # Then, we need to find the closest pair of special factorials\n    # We can do this by sorting the list of special factorials and then finding the pair with the smallest difference\n    special_factorials.sort()\n    \n    # Initialize the minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')\n    min_pair = ()\n    \n    # Iterate over the sorted list of special factorials\n    for i in range(len(special_factorials) - 1):\n        # Calculate the difference between the current special factorial and the next one\n        diff = special_factorials[i + 1] - special_factorials[i]\n        \n        # If the difference is smaller than the current minimum difference, update the minimum difference and the pair of numbers\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (numbers[i], numbers[i + 1])\n    \n    # Return the pair of numbers with the minimum difference\n    return min_pair\n\n"}
{"task_id": "EvoEval/71", "completion": "\n    # Calculate the Brazilian factorial\n    brazilian_factorial = math.factorial(n)\n    for i in range(n-1, 0, -1):\n        brazilian_factorial *= math.factorial(i)\n    \n    # Check if the sum of weights is less than or equal to the Brazilian factorial\n    if sum(w) <= brazilian_factorial:\n        # Check if the weights are balanced (palindromic list)\n        if w == w[::-1]:\n            return True\n    return False\n"}
{"task_id": "EvoEval/72", "completion": "\n    # Check if the input list is empty\n    if not numbers:\n        return False\n\n    # Initialize the result variable to False\n    result = False\n\n    # Iterate over the list of numbers\n    for i in range(len(numbers)):\n        # Calculate the special factorial for the current number\n        special_factorial = factorial(numbers[i])\n\n        # Check if the current number is not the first number in the list\n        if i > 0:\n            # Calculate the special factorial for the previous number\n            prev_special_factorial = factorial(numbers[i-1])\n\n            # Check if the difference between the two special factorials is less than the threshold\n            if abs(special_factorial - prev_special_factorial) < threshold:\n                # If the difference is less than the threshold, set the result to True\n                result = True\n                # Break the loop as we have found the first pair of special factorials that are closer than the threshold\n                break\n\n    # Return the result\n    return result\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Convert the input string to a Fraction object\n    n = Fraction(n)\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over each fraction in the input list\n    for fraction in fractions:\n        # Convert the fraction string to a Fraction object\n        f = Fraction(fraction)\n        \n        # Multiply the fraction by n\n        product = f * n\n        \n        # Check if the product is a whole number (i.e., its denominator is 1)\n        result.append(product.denominator == 1)\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "EvoEval/74", "completion": "\n    # Check if all elements in lst1 are even\n    if all(num % 2 == 0 for num in lst1):\r\n        return \"YES\"\r\n    # Check if all elements in lst2 are even\r\n    elif all(num % 2 == 0 for num in lst2):\r\n        return \"YES\"\r\n    # If neither list contains only even numbers, return \"NO\"\r\n    else:\r\n        return \"NO\"\r\n\r\n    # Check if one of the integers is equal to the sum of the other two\r\n    if (x == y + z) or (y == x + z) or (z == x + y):\r\n        return \"SUM\"\r\n    else:\r\n        return \"NO_SUM\"  # This line will never be reached\r\n\r"}
{"task_id": "EvoEval/75", "completion": "\n    if not all(isinstance(key, str) for key in input_dict.keys()) or not (all(key.isupper() for key in input_dict.keys()) or all(key.islower() for key in input_dict.keys())) or not input_dict:\n        return {}\n    new_dict = {}\n    for key, value in input_dict.items():\n        new_dict[key] = round(float(value))\n    return new_dict\n"}
{"task_id": "EvoEval/76", "completion": "\n    def is_prime(n):\r\n        if n < 2:\r\n            return False\r\n        for i in range(2, int(n**0.5) + 1):\r\n            if n % i == 0:\r\n                return False\r\n        return True\r\n\r\n    def sum_of_digits(n):\r\n        return sum(int(digit) for digit in str(n))\r\n\r\n    lst_copy = lst.copy()\r\n    for i in range(len(lst_copy)):\r\n        if is_prime(lst_copy[i]):\r\n            lst_copy[i] = sum_of_digits(lst_copy[i])\r\n\r\n    if sum(lst_copy[-1]) % 2 == 0:\r\n        return sorted(lst_copy, reverse=True)\r\n    else:\r\n        return sorted(lst_copy)\r\n"}
{"task_id": "EvoEval/77", "completion": "\n    result = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 != 0 and sum(int(digit) for digit in str(abs(arr[i]))) > 0:\n            result += arr[i]\n    return result\n"}
{"task_id": "EvoEval/78", "completion": "\n    vowels = \"AEIOU\"\n    result = \"\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].isalpha():\n            if s[i].isupper():\n                s = s[:i] + s[i].lower() + s[i+1:]\n            else:\n                s = s[:i] + s[i].upper() + s[i+1:]\n        result += s[i]\n    if not any(c.isalpha() for c in s):\n        result = result[::-1]\n    for i in range(0, len(result), 2):\n        if result[i].upper() in vowels:\n            count += 1\n    return result, count\n"}
{"task_id": "EvoEval/79", "completion": "\n    if len(s) < 3:\n        return s[::-1]\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] == s[i+2]:\n            return s[::-1]\n    for i in range(len(s)):\n        if s[i].isalpha():\n            s = s[:i] + s[i].swapcase() + s[i+1:]\n    return s.swapcase() if s.isalpha() else s[::-1]  # return s[::-1] if s is not a string of letters\n"}
{"task_id": "EvoEval/80", "completion": "\n    encoded = cyclic_encode(s)\r\n    encoded = encoded.replace(c, \"\")\r\n    if is_palindrome(encoded):\r\n        return encoded, True\r\n    else:\r\n        return cyclic_decode(encoded), False\r\n\r"}
{"task_id": "EvoEval/81", "completion": "\n    # Initialize the first three elements of the FibFib sequence\n    fibfib_sequence = [0, 0, 1]\n    \n    # Generate the rest of the sequence up to the nth element\n    for i in range(3, n):\n        # Calculate the next element as the sum of the previous three elements\n        next_element = fibfib_sequence[i-1] + fibfib_sequence[i-2] + fibfib_sequence[i-3]\n        # Append the new element to the sequence\n        fibfib_sequence.append(next_element)\n    \n    # Calculate the mean of the sequence\n    mean = sum(fibfib_sequence) / len(fibfib_sequence)\n    \n    # Initialize the sum of absolute deviations\n    sum_abs_dev = 0\n    \n    # Calculate the sum of absolute deviations from the mean\n    for num in fibfib_sequence:\n        sum_abs_dev += abs(num - mean)\n    \n    # Calculate the mean absolute deviation\n    mad = sum_abs_dev / len(fibfib_sequence)\n    \n    return mad\n"}
{"task_id": "EvoEval/82", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n            if c % 2 == 0:\n                c = int(''.join(filter(str.isdigit, str(c))))\n                if c == 0:\n                    c = 0\n                elif all(int(digit) % 2 == 0 for digit in str(c)):\n                    c = 0\n        return c\n"}
{"task_id": "EvoEval/83", "completion": "\n    # Replace more than 2 consecutive spaces with a single underscore\n    text = re.sub(' +', '_', text)\n    \n    # Replace all spaces with a single underscore\n    text = text.replace(' ', '_')\n    \n    # Check if the string is a number\n    if text.isdigit():\n        # Convert the string to an integer\n        num = int(text)\n        \n        # Check if the number is prime\n        if num > 1:\n            for i in range(2, num):\n                if (num % i) == 0:\n                    return False\n            return True\n        else:\n            return False\n    else:\n        return False\n\n"}
{"task_id": "EvoEval/84", "completion": "\n    result = {}\n    for i in range(len(string)):\n        prefix = string[:i+1]\n        letter_counts = {}\n        for letter in string:\n            if letter in letter_counts:\n                letter_counts[letter] += 1\n            else:\n                letter_counts[letter] = 1\n        max_count = max(letter_counts.values())\n        max_letters = [letter for letter, count in letter_counts.items() if count == max_count]\n        result[prefix] = {letter: max_count for letter in max_letters}\n    return result\n"}
{"task_id": "EvoEval/85", "completion": "\n    if not lst:\n        return None\n\n    # Count the number of ones in the binary representation of each number\n    ones_count = {}\n    for num in lst:\n        binary = bin(num)[2:]\n        ones_count[num] = binary.count('1')\n\n    # Sort the list based on the number of ones and the original value\n    sorted_lst = sorted(lst, key=lambda x: (ones_count[x], x))\n\n    # Return the 2nd smallest element\n    return sorted_lst[1] if len(sorted_lst) > 1 else None\n\n"}
{"task_id": "EvoEval/86", "completion": "\n    # Find common operands between all operand_lists\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands &= set(operand_list)\n    \n    # If there are no common operands, return None\n    if not common_operands:\n        return None\n    \n    # Sort the common_operands in ascending order\n    common_operands = sorted(list(common_operands))\n    \n    # Evaluate the algebraic expression built using the common_operands with the given operators\n    result = common_operands[0]\n    for i in range(len(operators)):\n        result = eval(f\"{result} {operators[i]} {common_operands[i+1]}\")\n    \n    return result\n"}
{"task_id": "EvoEval/87", "completion": "\n    stack = []\n    vowels = 'aeiouAEIOU'\n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(char)\n    if stack:\n        text = ''.join([char for char in text if char not in vowels])\n    return text\n"}
{"task_id": "EvoEval/88", "completion": "\n    # Split the string into words\n    words = s.replace(',', ' ').split()\n    \n    # Filter out words with odd lengths\n    words = [word for word in words if len(word) % 2 == 0]\n    \n    # Sort the list of words by length and then alphabetically\n    words.sort(key=lambda x: (len(x), x))\n    \n    return words\n"}
{"task_id": "EvoEval/89", "completion": "\n    if not strings:\n        return None\n    return [s for s in strings if hash_substring in md5(s).hexdigest()]  # <--- Changed here\n"}
{"task_id": "EvoEval/90", "completion": "\n    vowels = 'aeiou'\n    if not dict:\n        return {}\n    if not all(isinstance(key, str) for key in dict.keys()):\n        return {}\n    if not all(key.islower() or key.isupper() for key in dict.keys()):\n        return {}\n    result = {}\n    for key in dict.keys():\n        count = 0\n        for char in key:\n            if char.lower() in vowels:\n                count += 1\n        result[key] = count\n    return result\n"}
{"task_id": "EvoEval/91", "completion": "\n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over the indices and values of the input list\n    for i, val in enumerate(l):\n        # If the index is even, check if the value is prime\n        if i % 2 == 0:\n            # Check if the value is prime\n            if is_prime(val):\n                # If the value is prime, append x to the result list\n                result.append(x)\n            else:\n                # If the value is not prime, append y to the result list\n                result.append(y)\n        else:\n            # If the index is odd, append the value to the result list\n            result.append(val)\n    \n    # Return the result list\n    return result\n"}
{"task_id": "EvoEval/92", "completion": "\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common = [x for x in l1 if x in a]\n    common.sort()\n    if not any(x % 3 == 0 for x in common):\n        return common, 0\n    count = 0\n    for i in range(len(common)):\n        for j in range(i + 1, len(common)):\n            for k in range(j + 1, len(common)):\n                if (common[i] + common[j] + common[k]) % 3 == 0:\n                    count += 1\n    return common, count\n"}
{"task_id": "EvoEval/93", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not is_prime(len(string)):\n        return \"\"\n\n    vowels = \"aeiou\"\n    for i in range(len(string) - 1, 0, -1):\n        if string[i] in vowels:\n            if string[i - 1] not in vowels and string[i + 1] not in vowels:\n                return string[i]\n    return \"\"  # if no vowel found between two consonants\n\n"}
{"task_id": "EvoEval/94", "completion": "\n    # Count the number of elements which has a sum of digits > 0\n    count = sum(1 for num in arr if sum(int(digit) for digit in str(abs(num))) > 0)\n    \n    # Create a copy of the array to avoid modifying the original array\n    arr_copy = arr.copy()\n    \n    # Sort the copied array in ascending order if the count is odd, or in descending order if the count is even\n    arr_copy.sort(key=lambda x: sum(int(digit) for digit in str(abs(x))) > 0, reverse=(count % 2 == 0))\n    \n    return arr_copy\n"}
{"task_id": "EvoEval/95", "completion": "\n    # Filter the list to include only strings that contain the substring and have an even length\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    \n    # Sort the filtered list first by the length of each string, then alphabetically\n    sorted_strings = sorted(filtered_strings, key=lambda s: (len(s), s))\n    \n    return sorted_strings\n"}
{"task_id": "EvoEval/96", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Iterate over the common elements\n    for element in common_elements:\n        # Check if the negation of the element is in the set\n        if -element in set1 and -element in set2:\n            return True\n    \n    # If no pair with sum zero is found, return False\n    return False\n"}
{"task_id": "EvoEval/97", "completion": "\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count\n"}
{"task_id": "EvoEval/98", "completion": "\n    if not dict:\n        return False\n    for key, value in dict.items():\n        if not (key.islower() or key.isupper()):\n            return False\n        if not (value.count(\"(\") == value.count(\")\") and value.count(\"(\") > 0 and value.count(\")\") > 0):\n            return False\n    return True\n"}
{"task_id": "EvoEval/99", "completion": "\n    # Convert the number to the desired base and count the number of digits\n    return len(convert_base(x, base))\n"}
