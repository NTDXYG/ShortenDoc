{"task_id": "EvoEval/0", "completion": "\n    # Initialize total cost and additional charge\n    total_cost = 0.0\n    additional_charge = 0.0\n\n    # Check if any item is a string\n    string_item = False\n    for item in items:\n        if isinstance(item, str):\n            string_item = True\n            break\n\n    # Calculate total cost and additional charge\n    for item in items:\n        if isinstance(item, str):\n            # If item is a string, consider its weight as 1kg and add 1.5 to the total cost\n            total_cost += 5.0 * 1.5\n            additional_charge += 10.0 * 1.5\n        else:\n            # If item is a float, calculate its cost and additional charge\n            total_cost += 5.0\n            if item > 5.0:\n                additional_charge += 10.0\n\n    # Apply location factor\n    if location == \"National\":\n        total_cost *= 1.5\n    elif location == \"International\":\n        total_cost *= 2.5\n\n    # Add additional charge\n    total_cost += additional_charge\n\n    # Return total cost rounded to two decimal places\n    return \"{:.2f}\".format(total_cost)  # Changed here\n"}
{"task_id": "EvoEval/1", "completion": "\n    # Initialize total cost to 0\n    total_cost = 0.0\n    \n    # Define the location factors\n    location_factors = {\n        \"Local\": 1.0,\n        \"National\": 1.5,\n        \"International\": 2.5\n    }\n    \n    # Get the location factor\n    factor = location_factors.get(location, 1.0)\n    \n    # Iterate over each item\n    for item in items:\n        # If the item is a string, consider its weight as 1kg\n        if isinstance(item, str):\n            weight = 1.0\n        # If the item is a float, use its value as the weight\n        elif isinstance(item, float):\n            weight = item\n        # If the item is neither a string nor a float, skip it\n        else:\n            continue\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 5.0\n        \n        # If the weight is more than 5kg, add an additional charge\n        if weight > 5.0:\n            total_cost += 10.0\n        \n        # Multiply the total cost by the location factor\n        total_cost *= factor\n    \n    # Return the total shipping cost rounded to two decimal places\n    return round(total_cost, 2)  # Changed here\n"}
{"task_id": "EvoEval/2", "completion": "\n    # Convert key to integer\n    if isinstance(key, str):\n        key = sum(ord(char) for char in key)\n    \n    # Initialize an empty list to store the encrypted words\n    encrypted_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Initialize an empty string to store the encrypted word\n        encrypted_word = \"\"\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Find the ASCII value of 'a' or 'A' depending on the case of the character\n                ascii_offset = ord('a') if char.islower() else ord('A')\n                \n                # Calculate the new character by shifting the current character by the key\n                new_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n                \n                # Add the new character to the encrypted word\n                encrypted_word += new_char\n            else:\n                # If the character is not a letter, add it to the encrypted word as-is\n                encrypted_word += char\n        \n        # Add the encrypted word to the list of encrypted words\n        encrypted_words.append(encrypted_word)\n    \n    # Return the list of encrypted words\n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    if not input_string:\n        return []\n\n    # Convert the input string to a list of integers\n    input_list = [int(char) for char in input_string]\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Define a helper function to generate all combinations\n    def generate_combinations(current_combination, start_index):\n        # If the current combination is complete, add it to the result list\n        if start_index == len(input_list):\n            result.append(''.join(chr(num + 96) for num in current_combination))\n            return\n\n        # Try each possible digit at the current position\n        for i in range(input_list[start_index]):\n            # Add the current digit to the current combination\n            current_combination.append(i)\n\n            # Recursively generate combinations for the remaining positions\n            generate_combinations(current_combination, start_index + 1)\n\n            # Backtrack by removing the last digit from the current combination\n            current_combination.pop()\n\n    # Start generating combinations from the first position\n    generate_combinations([], 0)\n\n    return result\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    max_height = candles[0]\n    count = 1\n    for height in candles[1:]:\n        if height > max_height:\n            max_height = height\n            count += 1\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    for i in range(len(matrix)):\n        if i % 2 == 0:\n            result += matrix[i][left:right + 1]\n        else:\n            result += matrix[i][right:left - 1:-1]\n        left += 1\n        right -= 1\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Check if the position is out of the grid\n    if position[0] < 0 or position[0] >= rows or position[1] < 0 or position[1] >= cols:\n        return grid\n    \n    # Get the value of the cell at the clicked position\n    cell_value = grid[position[0]][position[1]]\n    \n    # If the cell is a mine, return the initial grid\n    if cell_value == 1:\n        return grid\n    \n    # If the cell is already revealed, return the initial grid\n    if cell_value == 0:\n        return grid\n    \n    # Mark the cell as revealed\n    grid[position[0]][position[1]] = 0\n    \n    # Get the adjacent cells\n    adjacent_cells = get_adjacent_cells(position, rows, cols)\n    \n    # Convert all the adjacent cells to 0\n    for cell in adjacent_cells:\n        grid[cell[0]][cell[1]] = 0\n    \n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize the current position at (0,0)\n    current_position = [0, 0]\r\n    # Iterate over each direction in the code sequence\r\n    for direction in code_sequence:\r\n        # Update the current position based on the direction\r\n        if direction == 0:\r\n            current_position[1] += 1\r\n        elif direction == 1:\r\n            current_position[0] += 1\r\n        elif direction == 2:\r\n            current_position[1] -= 1\r\n        elif direction == 3:\r\n            current_position[0] -= 1\r\n    # Check if the current position is the same as the starting point\r\n    if current_position == [0, 0]:\r\n        # If it is, return 'Shangri-La found'\r\n        return 'Shangri-La found'\r\n    else:\r\n        # If it's not, return 'Shangri-La not found'\r\n        return 'Shangri-La not found'\r\n"}
{"task_id": "EvoEval/8", "completion": "\n    # Split the canvas into rows\n    rows = canvas.split('\\n')\n    \n    # Initialize variables to keep track of the painter's position and the number of painted spaces\n    painter_positions = []\n    painted_spaces = 0\n    \n    # Iterate over each row in the canvas\n    for i, row in enumerate(rows):\n        # Find the position of the painter in the current row\n        painter_position = row.find('P')\n        \n        # If the painter is found, add its position to the list of painter positions\n        if painter_position != -1:\n            painter_positions.append((i, painter_position))\n            painted_spaces += len(row) - row.find('P') - 1\n    \n    # If there is more than one painter, return 'Invalid canvas'\n    if len(painter_positions) > 1:\n        return 'Invalid canvas'\n    \n    # If the number of painted spaces divides the empty spaces evenly, return 'Invalid canvas'\n    if painted_spaces % (len(canvas) - canvas.count('#') - 1) == 0:\n        return 'Invalid canvas'\n    \n    # Initialize a variable to keep track of the current row\n    current_row = 0\n    \n    # Iterate over each painter position\n    for painter_position in painter_positions:\n        # Get the current row and column of the painter\n        row, col = painter_position\n        \n        # Initialize a variable to keep track of the current column\n        current_col = col\n        \n        # While the current column is within the bounds of the canvas and the current cell is not a wall\n        while current_col < len(rows[row]) and rows[row][current_col] != '#':\n            # If the current cell is an empty space, paint it\n            if rows[row][current_col] == '-':\n                rows[row] = rows[row][:current_col] + '*' + rows[row][current_col + 1:]\n                painted_spaces += 1\n            \n            # Move to the next column\n            current_col += 1\n        \n        # If the number of painted spaces divides the empty spaces evenly, return 'Invalid canvas'\n        if painted_spaces % (len(canvas) - canvas.count('#') - 1) == 0:\n            return 'Invalid canvas'\n    \n    # Join the updated rows back into a string and return the result\n    return '\\n'.join(rows)  # Removed the 'P' from the painter's position\n"}
{"task_id": "EvoEval/9", "completion": "\n    # Convert string to lower case to ignore case sensitivity\n    string = string.lower()\n    # Remove punctuation\n    string = ''.join(e for e in string if e.isalnum() or e.isspace())\n    # Split string into words\n    words = string.split()\n    # Create a dictionary to store word frequencies\n    word_frequency = {}\n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word is already in the dictionary, increment its frequency by 1\n        if word in word_frequency:\n            word_frequency[word] += 1\n        # If the word is not in the dictionary, add it with a frequency of 1\n        else:\n            word_frequency[word] = 1\n    # Return the dictionary of word frequencies\n    return word_frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_dict = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\r\n    animal_count = {}\r\n    animal_sounds = animal_string.split()\r\n    animal_count_list = []\r\n    for animal_sound in animal_sounds:\r\n        animal = animal_sound[0]\r\n        if animal in animal_dict:\r\n            if animal not in animal_count or animal_count[animal] < 2:\r\n                animal_count[animal] = animal_sound.count('|')\r\n                animal_count_list.append(animal_count[animal])\r\n            if len(animal_count_list) == 5:\r\n                break\r\n    return animal_count_list\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    # Check if the list of fruits has only one element\n    if len(fruits) == 1:\n        # If it has only one element, return the message with the singular form of the fruit\n        return f\"Oh, those {fruits[0]} from {location}? Marvelous!\"\n    # If the list of fruits has more than one element, return the message with the plural form of the fruits\n    else:\n        # Join all the fruits in the list except the last one with a comma and a space\n        fruits_str = ', '.join(fruits[:-1])\n        # Add the last fruit to the string\n        fruits_str += f', and {fruits[-1]}'\n        # Return the message with the plural form of the fruits\n        return f\"Oh, are those {fruits_str} from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Count the occurrence of each number in the list\n    count_dict = {}\n    for num in flux_values:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the number with the maximum occurrence\n    max_count = max(count_dict.values())\n    most_occurred_num = min([num for num, count in count_dict.items() if count == max_count])\n    \n    # Calculate the sum of all elements in the list\n    total_sum = sum(flux_values)\n    \n    # Multiply the sum of all elements with the most occurred number\n    energy_signature = total_sum * most_occurred_num\n    \n    return energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n    count_dict = {}\n    for elem in elems:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    min_count = min(count_dict.values())\n    rarest_elems = [elem for elem, count in count_dict.items() if count == min_count]\n    return min(rarest_elems, key=elems.index)  # return the first rarest element appears in the list\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = (vowels.index(char.lower()) + 1) % len(vowels)\n                alias += vowels[index] if char.islower() else vowels[index].upper()\n            else:\n                index = (consonants.index(char.lower()) + 1) % len(consonants)\n                alias += consonants[index] if char.islower() else consonants[index].upper()\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Define a dictionary to map card values to their corresponding scores\n    card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 1}\n    \n    # Initialize a dictionary to store the count of each card value\n    value_counts = {}\n    \n    # Iterate over each card in the hand\n    for card in hand:\n        # Extract the value of the card\n        value = card[:-1]\n        \n        # Increment the count of the card value in the dictionary\n        if value in value_counts:\n            value_counts[value] += 1\n        else:\n            value_counts[value] = 1\n    \n    # Initialize the score to 0\n    score = 0\n    \n    # Check for pairs, triples, fours, and fives\n    for value, count in value_counts.items():\n        # If the count is 2, it's a pair\n        if count == 2:\n            score += card_values[value]\n        # If the count is 3, it's a triple\n        elif count == 3:\n            score += 2 * card_values[value]\n        # If the count is 4, it's a four of a kind\n        elif count == 4:\n            score += 3 * card_values[value]\n        # If the count is 5, it's a five of a kind\n        elif count == 5:\n            score += 4 * card_values[value]\n    \n    # Return the score\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard_name, magic_power in wizards:\n        dragon_hp -= magic_power\n        if dragon_hp <= 0:\n            return wizard_name\n    return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after"}
{"task_id": "EvoEval/18", "completion": "\n    if n == 1:\n        return 7\n    else:\n        return int(str(magical_seven(n - 1)) + '0') + magical_seven(n - 1) // 10\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize count of humans in danger\n    count = 0\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a vampire, increment the count by the number of humans in the row\n            if cell == 2:\n                count += row.count(1)\n            # If the cell is a human, increment the count by the number of vampires in the row\n            elif cell == 1:\n                count += row.count(2)\n    # Iterate over each column in the matrix\n    for col in zip(*m):\n        # Iterate over each cell in the column\n        for cell in col:\n            # If the cell is a vampire, increment the count by the number of humans in the column\n            if cell == 2:\n                count += sum(1 for r in m if r[col.index(cell)] == 1)\n            # If the cell is a human, increment the count by the number of vampires in the column\n            elif cell == 1:\n                count += sum(1 for r in m if r[col.index(cell)] == 2)\n    # Return the count of humans in danger\n    return count\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join(map(str, range(1, i + 1))))\n        pattern.append(','.join(map(str, range(i, 0, -1))))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Check if the grid is a square\n    if len(grid) != len(grid[0]):\n        return False\n\n    # Check if all words are in the grid\n    for word in words:\n        found = False\n        # Check horizontally\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == word[0]:\n                    k = 1\n                    while k < len(word) and j + k < len(grid[0]) and grid[i][j + k] == word[k]:\n                        k += 1\n                    if k == len(word):\n                        found = True\n                        break\n        if not found:\n            # Check vertically\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == word[0]:\n                        k = 1\n                        while k < len(word) and i + k < len(grid) and grid[i + k][j] == word[k]:\n                            k += 1\n                        if k == len(word):\n                            found = True\n                            break\n        if not found:\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Convert the velocity from km/s to light years per year\n    v_lyr = v / (9.461 * 10**12)\n    \n    # Calculate the distance traveled in light years\n    distance_lyr = t * v_lyr\n    \n    return distance_lyr\n"}
{"task_id": "EvoEval/23", "completion": "\n    # Create a dictionary to store the prime numbers\n    prime_dict = {}\n    # Initialize the counter for prime numbers\n    prime_counter = 1\n    # Initialize the number to check for primality\n    num = 2\n    # Loop until we have 26 prime numbers\n    while prime_counter <= 26:\n        # Check if the number is prime\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            # If the number is prime, add it to the dictionary\n            prime_dict[num] = prime_counter\n            # Increment the prime counter\n            prime_counter += 1\n        # Increment the number to check for primality\n        num += 1\n    # Initialize the result string\n    result = \"\"\n    # Loop over each character in the string\n    for char in s:\n        # Check if the character is a lowercase letter\n        if char.isalpha() and char.islower():\n            # If the character is a lowercase letter, replace it with the corresponding prime number\n            result += str(prime_dict[ord(char) - 96])\n        else:\n            # If the character is not a lowercase letter, leave it unchanged\n            result += char\n    # Return the result string\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_language = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'\n    }\n    return ''.join(alien_language.get(char, char) for char in english_word.lower())  # Convert to lowercase to handle case-insensitive translation\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\n    sentences = text.split(\". \")\n    # Initialize a dictionary to store the frequency of the word in each sentence\n    frequency = {}\r\n    # Initialize a variable to store the sentence with the max frequency of the word\n    max_sentence = \"\"\r\n    # Initialize a variable to store the max frequency of the word\r\n    max_frequency = 0\r\n    # Iterate over each sentence\r\n    for sentence in sentences:\r\n        # Split the sentence into words\r\n        words = sentence.split()\r\n        # Count the frequency of the word in the sentence\r\n        frequency[sentence] = words.count(word)\r\n        # If the frequency of the word in the sentence is greater than the max frequency, update the max frequency and the max sentence\r\n        if frequency[sentence] > max_frequency:\r\n            max_frequency = frequency[sentence]\r\n            max_sentence = sentence\r\n    # Return the frequency of the word and the sentence with the max frequency\r\n    return (max_frequency, max_sentence) if max_frequency > 0 else (0, \"\")\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    # Check if the start and end are the same\n    if start == end:\n        return []\n\n    # Define the possible directions\n    directions = [(0, 1, \"right\"), (0, -1, \"left\"), (1, 0, \"down\"), (-1, 0, \"up\")]\n\n    # Create a queue for BFS and add the start point\n    queue = [(start, [start])]\n\n    # Create a set to store the visited points\n    visited = set([start])\n\n    while queue:\n        # Get the current point and the path that leads to it\n        (x, y), path = queue.pop(0)\n\n        # Check all possible directions\n        for dx, dy, direction in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check if the new point is within the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                # Add the new point to the queue and mark it as visited\n                queue.append(((nx, ny), path + [direction]))\n                visited.add((nx, ny))\n\n                # Check if the new point is the end point\n                if (nx, ny) == end:\n                    # Return the path that leads to the end point\n                    return path\n\n    # If the path does not exist, return an empty list\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Calculate the taxable income by subtracting the deductions from the income\n    taxable_income = income - deductions\n    \n    # Initialize the tax amount to 0\n    tax_amount = 0\n    \n    # If the taxable income is less than 0, return 0\n    if taxable_income < 0:\n        return 0\n    \n    # Calculate the tax for the first $10,000 of income\n    tax_amount += min(taxable_income, 10000) * 0\n    \n    # Calculate the tax for the next $25,000 of income\n    tax_amount += min(max(taxable_income - 10000, 0), 25000) * 0.15\n    \n    # Calculate the tax for the next $45,000 of income\n    tax_amount += min(max(taxable_income - 32500, 0), 45000) * 0.25\n    \n    # Calculate the tax for any income over $130,000\n    tax_amount += max(taxable_income - 70000, 0) * 0.30\n    \n    # Apply the deductions to the tax amount\n    tax_amount -= min(deductions, 1000) * 1\n    tax_amount -= min(max(deductions - 1000, 0), 2000) * 2\n    tax_amount -= min(max(deductions - 3000, 0), float('inf')) * 3\n    \n    # Return the tax amount\n    return tax_amount\n"}
{"task_id": "EvoEval/29", "completion": "\n    n = len(s)\n    # Initialize a 2D table to store whether a substring is palindrome or not\n    is_palindrome = [[False] * n for _ in range(n)]\n    # Initialize a set to store unique palindrome substrings\n    palindrome_substrings = set()\n    # Iterate over all substrings\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            # Check if the substring is palindrome\n            if length == 1:\n                is_palindrome[i][j] = True\n            elif length == 2:\n                is_palindrome[i][j] = (s[i] == s[j])\n            else:\n                is_palindrome[i][j] = (s[i] == s[j]) and is_palindrome[i + 1][j - 1]\n            # If the substring is palindrome, add it to the set\n            if is_palindrome[i][j]:\n                palindrome_substrings.add(s[i:j + 1])\n    # Return the list of unique palindrome substrings, sorted in ascending order\n    return sorted(list(palindrome_substrings))\n\n\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements in the maze (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Create a queue for BFS, enqueue the start point\n    queue = [(start, [start])]\n    \n    # Create a set to store the visited points\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the next point\n        (x, y), path = queue.pop(0)\n        \n        # If this is the end point, return the path\n        if (x, y) == end:\n            return path\n        \n        # For each possible movement\n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n            \n            # If the new point is inside the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new point as visited\n                visited.add((nx, ny))\n                \n                # Enqueue the new point\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    \n    # If no path is found, return an empty list\n    return []  # pragma: no cover\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # There is only one way to reach any cell in the first row or first column\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 1\n    \n    # Fill in the rest of the 2D array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # The number of unique paths to a cell is the sum of the number of unique paths to the cell above it and the cell to its left\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    # The number of unique paths to the bottom-right corner is stored in the bottom-right cell of the 2D array\n    return dp[m][n]\n"}
{"task_id": "EvoEval/32", "completion": "\n    # Create a copy of the original playlist to avoid modifying it\n    shuffled_playlist = playlist.copy()\n    \n    # Initialize the seed and the playlist length\n    seed = seed\n    playlist_length = len(shuffled_playlist)\n    \n    # Iterate over the indices of the playlist\n    for i in range(playlist_length):\n        # Calculate the new seed for the current index\n        seed = (seed * 16807) % 2147483647\n        \n        # Calculate the index to swap with\n        swap_index = (seed % playlist_length)\n        \n        # Check if the song at the current index contains the word \"Rock\"\n        if \"Rock\" in shuffled_playlist[i]:\n            # If it does, skip the swap operation\n            continue\n        \n        # Swap the song at the current index with the song at the swap index\n        shuffled_playlist[i], shuffled_playlist[swap_index] = shuffled_playlist[swap_index], shuffled_playlist[i]\n    \n    # Return the shuffled playlist\n    return shuffled_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\n    ways = [0] * (n + 1)\r\n    # There is one way to reach the first step (i.e., by not jumping at all)\r\n    ways[0] = 1\r\n    # For each step from 1 to n\r\n    for i in range(1, n + 1):\r\n        # For each magic stone\r\n        for stone in magic_stones:\r\n            # If the stone's power is less than or equal to the current step\r\n            if stone <= i:\r\n                # Add the number of ways to reach the step minus the stone's power to the current number of ways\r\n                ways[i] += ways[i - stone]\r\n    # Return the number of ways to reach the top of the staircase\r\n    return ways[n]\r\n\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize the list to store the transformation percentages\n    transformation_percentages = [0]\n    \n    # Calculate the transformation percentages for the days before the m-th day\n    for i in range(1, m):\n        # If it's the first day, the transformation percentage is 10%\n        if i == 1:\n            transformation_percentages.append(10)\n        # Otherwise, the transformation percentage increases by 10% from the previous day\n        else:\n            transformation_percentages.append(min(100, transformation_percentages[i-1] + 10))\n    \n    # Calculate the transformation percentages for the m-th day\n    transformation_percentages.append(min(100, transformation_percentages[m-1] * 2))\n    \n    # Calculate the transformation percentages for the days after the m-th day\n    for i in range(m+1, n):\n        # The transformation percentage decreases by 10% from the previous day\n        transformation_percentages.append(max(0, transformation_percentages[i-1] - 10))\n    \n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email:\r\n        return False\r\n    if email[0] == \"@\" or email[-1] == \"@\":\r\n        return False\r\n    if email.count(\"@\") > 1:\r\n        return False\r\n    if \".\" not in email.split(\"@\")[1]:\r\n        return False\r\n    return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coefficients = [0]  # The constant term is always 0\n    for i in range(len(xs)):\n        integral_coefficients.append(xs[i] / (i + 1))\n    return integral_coefficients\n\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for char in s:\n        if char in vowels:\n            idx = vowels.index(char)\n            result += vowels[(idx + 1) % len(vowels)]\n        elif char in consonants:\n            idx = consonants.index(char)\n            result += consonants[(idx + 1) % len(consonants)]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \"\ud83d\ude00\",\n        \";)\": \"\ud83d\ude09\",\n        # Add more emoticons here if needed\n    }\n    for emoticon, emoji in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\n    # Create the top and bottom border of the ASCII art\n    top_bottom_border = \"*\" + \"*\" * (len(s) * n) + \"*\\n\"\n    \n    # Create the middle part of the ASCII art\n    middle_part = \"\"\n    for i in range(n):\n        middle_part += \"*\" + s * n + \"*\\n\"\n    \n    # Combine the top and bottom border with the middle part\n    ascii_art = top_bottom_border + middle_part + top_bottom_border\n    \n    return ascii_art\n"}
{"task_id": "EvoEval/40", "completion": "\n    # Split each potion into name and power level, and store them in a list of tuples\n    potions = [tuple(potion.split()) for potion in potions]\n    \n    # Sort the list of potions by power level in descending order\n    potions.sort(key=lambda x: int(x[1]), reverse=True)\n    \n    # Initialize a list to store the result\n    result = []\n    \n    # Initialize a variable to store the remaining power level\n    remaining = target\n    \n    # Iterate over the sorted list of potions\n    for potion in potions:\n        # If the remaining power level is greater than or equal to the power level of the current potion\n        if remaining >= int(potion[1]):\n            # Add the current potion to the result\n            result.append(potion)\n            # Subtract the power level of the current potion from the remaining power level\n            remaining -= int(potion[1])\n    \n    # If the remaining power level is greater than 0, it means that we cannot reach the target power level with the given potions\n    if remaining > 0:\n        return []\n    \n    # Sort the result by name in ascending order\n    result.sort(key=lambda x: x[0])\n    \n    # Return the result\n    return [potion[0] + ' ' + potion[1] for potion in result]  # Return the potions in the correct format\n"}
{"task_id": "EvoEval/41", "completion": "\n    rows, cols = len(arr), len(arr[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    min_energy = float('inf')\n    def dfs(r, c, energy):\n        nonlocal min_energy\n        if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c] or arr[r][c] == 0:\n            return\n        visited[r][c] = True\n        if r == rows - 1 and c == cols - 1:\n            min_energy = min(min_energy, energy)\n            return\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(r + dr, c + dc, energy + arr[r][c])\n        visited[r][c] = False\n    dfs(0, 0, 0)\n    return min_energy\n"}
{"task_id": "EvoEval/42", "completion": "\n    # First, we check if the player has acquired a legendary item\n    has_legendary_item = 5 in player_input\n    \n    # If the player has acquired a legendary item, we find the second most valuable item\n    if has_legendary_item:\n        # We remove the legendary item from the list\n        player_input.remove(5)\n        \n        # We sort the list in descending order\n        player_input.sort(reverse=True)\n        \n        # We return True and the rarity of the second most valuable item\n        return (True, player_input[1] if len(player_input) > 1 else -1)\n    \n    # If the player has not acquired a legendary item, we return False and None\n    else:\n        return (False, None)  # Changed from None to None to match the expected output\n"}
{"task_id": "EvoEval/43", "completion": "\n    # Calculate the duration of the trip\n    trip_duration = distance / speed\n    \n    # Check if the spaceship can reach the planet\n    if trip_duration <= fuel:\n        # Calculate the fuel consumption of the trip\n        fuel_consumption = trip_duration * spaceship_weight * planet_gravity * 0.1\n        \n        # Calculate the remaining fuel\n        remaining_fuel = fuel - fuel_consumption\n        \n        # Return the remaining fuel\n        return round(remaining_fuel, 2)\n    else:\n        # Return 'Insufficient fuel' if the spaceship cannot reach the planet\n        return 'Insufficient fuel'  # Changed this line to return a string instead of None\n"}
{"task_id": "EvoEval/44", "completion": "\n    # Sort the list of weights in descending order\n    q.sort(reverse=True)\n    \n    # Initialize the total capacity of unicorns and dragons/griffins\n    unicorn_capacity = w\n    dragon_capacity = e\n    \n    # Iterate over the list of weights\n    for weight in q:\n        # If the weight is greater than the total capacity, return False\n        if weight > unicorn_capacity + dragon_capacity:\n            return False\n        \n        # If the weight is greater than the unicorn capacity, use the unicorn capacity and subtract it from the unicorn capacity\n        if weight > unicorn_capacity:\n            unicorn_capacity -= weight\n            # If the unicorn capacity is 0, use the dragon capacity\n            if unicorn_capacity == 0:\n                if weight > dragon_capacity:\n                    return False\n                dragon_capacity -= weight\n        # If the weight is greater than the dragon capacity, return False\n        elif weight > dragon_capacity:\n            return False\n        # If the weight is less than or equal to the unicorn capacity, subtract it from the unicorn capacity\n        else:\n            unicorn_capacity -= weight\n    \n    # If the function hasn't returned False, return True\n    return True\n"}
{"task_id": "EvoEval/45", "completion": "\n    if not arr:\n        return 0\n    max_view = 0\n    for i in range(len(arr)):\n        view = 0\n        for j in range(i, -1, -1):\n            if arr[j] <= arr[i]:\n                view += 1\n            else:\n                break\n        for j in range(i, len(arr)):\n            if arr[j] <= arr[i]:\n                view += 1\n            else:\n                break\n        max_view = max(max_view, view)\n    return max_view\n"}
{"task_id": "EvoEval/46", "completion": "\n    secret_messages = []\n    for test_case in test_cases:\n        secret_message = ''\n        for word in test_case:\n            word = ''.join(filter(str.isalpha, word))\n            secret_message += word[0].lower()\n        if secret_message == 'Take the cannoli.':\n            secret_messages.append(secret_message)\n        else:\n            secret_messages.append(secret_message)\n    return secret_messages\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}  # Filter out items with quantity 0 or less\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code_map = {\n        'A': '01', 'B': '1000', 'C': '1010', 'D': '100', 'E': '0', 'F': '0010',\n        'G': '110', 'H': '0000', 'I': '00', 'J': '0111', 'K': '101', 'L': '0100',\n        'M': '11', 'N': '10', 'O': '111', 'P': '0110', 'Q': '1101', 'R': '010',\n        'S': '000', 'T': '1', 'U': '001', 'V': '0001', 'W': '011', 'X': '1001',\n        'Y': '1011', 'Z': '1100', '1': '01111', '2': '00111', '3': '00011',\n        '4': '00001', '5': '00000', '6': '10000', '7': '11000', '8': '11100',\n        '9': '11110', '0': '11111'\n    }\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        word = word.replace(\" \", \"\")\n        decoded_word = ''\n        for i in range(0, len(word), 2):\n            code = word[i:i+2]\n            if code in morse_code_map:\n                decoded_word += morse_code_map[code]\n        decoded_words.append(decoded_word)\n    return ''.join(decoded_words)\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': ' '}\n    morse_code = ''\n    for char in text.upper():\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not list_of_alphabets:\n        return string\n    result = ''\n    for i, char in enumerate(string):\n        result += list_of_alphabets[i % len(list_of_alphabets)]\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # First, sort the orders in descending order\n    orders.sort(reverse=True)\n    \n    # Initialize the count of fulfilled orders\n    fulfilled_orders = 0\n    \n    # Initialize the remaining capacity of the oven\n    remaining_capacity = n\n    \n    # Iterate over each order\n    for order in orders:\n        # If the order can be fulfilled with the remaining capacity, increment the count of fulfilled orders and reset the remaining capacity\n        if order <= remaining_capacity:\n            fulfilled_orders += 1\n            remaining_capacity = n\n        # If the order cannot be fulfilled with the remaining capacity, increment the count of batches and reset the remaining capacity\n        else:\n            # Calculate the number of batches needed to fulfill the order\n            batches_needed = (order - 1) // n + 1\n            \n            # If the number of batches needed is less than or equal to the maximum number of batches, increment the count of fulfilled orders and reset the remaining capacity\n            if batches_needed <= m:\n                fulfilled_orders += 1\n                remaining_capacity = n\n            # If the number of batches needed is more than the maximum number of batches, break the loop\n            else:\n                break\n    \n    # Return the count of fulfilled orders\n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for i, char in enumerate(s):\n        if char in vowels:\n            index = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[index]\n        elif char in consonants:\n            index = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[index]\n        elif char == '?':\n            if i % 2 == 0:\n                result += '!'\n            else:\n                result += '?'\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = ''\n    shift_counter = shift\n    for char in message:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + shift_counter) % 26 + ascii_offset)\n            shift_counter += 1\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    words = s.split()\n    morse_code = ''\n    for word in words:\n        for char in word:\n            morse_code += morse_code_dict.get(char, '') + ' '\n        morse_code += '/ '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        transformed_dish = ''\n        for i, letter in enumerate(dish):\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        new_menu[transformed_dish] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for char in earth_phrase:\n        if char in vowels:\n            if char == 'u':\n                translated_phrase += 'a'\n            else:\n                translated_phrase += chr(ord(char) + 1)\n        elif char in consonants:\n            if char == 'z':\n                translated_phrase += 'b'\n            else:\n                translated_phrase += chr(ord(char) + 1)\n        elif char == ' ':\n            translated_phrase += '@'\n    translated_phrase = translated_phrase.title()\n    words = translated_phrase.split('@')\n    for i, word in enumerate(words):\n        if word[0] in vowels:\n            words[i] += 'xy'\n        else:\n            words[i] += 'yz'\n    translated_phrase = '@'.join(words)\n    return translated_phrase\n"}
{"task_id": "EvoEval/59", "completion": "\n    # First, we sort the dictionary items based on the number of recipes in descending order and then by the ingredient name in ascending order\n    sorted_items = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Then, we convert the sorted items into a list of tuples\n    result = [(ingredient, recipes) for ingredient, recipes in sorted_items]\n    \n    # Finally, we return the result\n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    # Create a list to store the sugar locations\n    sugar_locations = sugar_locations.copy()\n    \n    # Initialize a list to store the number of happy ants at each position\n    happy_ants_count = [0] * path_length\n    \n    # Iterate over each ant\n    for position, direction in ant_positions:\n        # If the ant is moving to the right\n        if direction == \"right\":\n            # Iterate over the positions the ant will visit\n            for i in range(position, path_length):\n                # If the current position has sugar\n                if i in sugar_locations:\n                    # Mark the ant as happy\n                    happy_ants_count[i] += 1\n                # If the current position does not have sugar\n                else:\n                    # Break the loop as the ant will not visit any more positions with sugar\n                    break\n        # If the ant is moving to the left\n        else:\n            # Iterate over the positions the ant will visit\n            for i in range(position, -1, -1):\n                # If the current position has sugar\n                if i in sugar_locations:\n                    # Mark the ant as happy\n                    happy_ants_count[i] += 1\n                # If the current position does not have sugar\n                else:\n                    # Break the loop as the ant will not visit any more positions with sugar\n                    break\n    \n    # Return the total number of happy ants\n    return sum(happy_ants_count)  # Changed here\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n    for i, c in enumerate(s):\n        if c.isalpha():\n            if i % 2 == 1:\n                c = c.swapcase()\n            if c.lower() in vowels:\n                idx = (vowels.index(c.lower()) + 1) % len(vowels)\n                result.append(vowels[idx])\n            else:\n                idx = (consonants.index(c.lower()) - 1) % len(consonants)\n                result.append(consonants[idx])\n        else:\n            result.append(c)\n    return ''.join(result)  # Join the list of characters into a string\n"}
{"task_id": "EvoEval/62", "completion": "\n    # Initialize an empty dictionary to store the converted recipe\n    converted_recipe = {}\n    \n    # Iterate over each ingredient and quantity in the recipe\n    for ingredient, quantity in recipe.items():\n        # Multiply the quantity by the conversion factor and store it in the converted recipe dictionary\n        converted_recipe[ingredient] = quantity * conversion_factor\n    \n    # Return the converted recipe dictionary\n    return converted_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\r\n    while p > 0:\r\n        pyramid.append(p)\r\n        if p % 2 == 0:\r\n            p -= 2\r\n        else:\r\n            p -= 3\r\n    return pyramid[::-1]  # reverse the list to get the correct order\r\n\r"}
{"task_id": "EvoEval/64", "completion": "\n\n        This helper function checks if a number 'n' is prime.\n        \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Create a copy of the original menu to avoid modifying it directly\n    final_order = menu.copy()\n    \n    # Iterate over each food item in the order dictionary\n    for food, custom_order in order.items():\n        # Check if the food item is in the menu\n        if food in final_order:\n            # Get the original ingredients for the food item\n            original_ingredients = final_order[food]\n            \n            # Get the ingredients to be added\n            added_ingredients = custom_order.get(\"add\", [])\n            \n            # Get the ingredients to be removed\n            removed_ingredients = custom_order.get(\"remove\", [])\n            \n            # Update the final order with the added ingredients\n            final_order[food] = original_ingredients + added_ingredients\n            \n            # Remove the ingredients to be removed from the final order\n            final_order[food] = [ingredient for ingredient in final_order[food] if ingredient not in removed_ingredients]\n    \n    # Return the final order\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    prime_nums = [i for i in range(2, n) if is_prime(i)]\n    prime_anagrams = []\n    for i in range(len(prime_nums)):\n        for j in range(i + 1, len(prime_nums)):\n            if is_anagram(prime_nums[i], prime_nums[j]):\n                prime_anagrams.append((prime_nums[i], prime_nums[j]))\n    return sorted(prime_anagrams)  # sort based on the first number in each tuple, then the second number\n"}
{"task_id": "EvoEval/67", "completion": "\n    # Initialize an empty dictionary to store the total calories for each customer\n    total_calories = {}\n    \n    # Iterate over each customer in the customers list\n    for customer in customers:\n        # Initialize the total calories for the current customer to 0\n        total_calories[customer] = 0\n        \n        # Check if the customer exists in the meals dictionary\n        if customer in meals:\n            # If the customer exists, iterate over each meal consumed by the customer\n            for meal in meals[customer]:\n                # Add the calories of the current meal to the total calories of the customer\n                total_calories[customer] += meal['calories']\n    \n    # Return the dictionary containing the total calories for each customer\n    return total_calories\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return True\n        else:\n            return False\n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n    # Check if the array can be sorted by rotating and swapping\n    for i in range(len(arr)):\n        # Rotate the array\n        arr = arr[-1:] + arr[:-1]\n        # Check if the array is sorted after rotation\n        if arr == sorted(arr):\n            return True\n        # Check if the array can be sorted by swapping\n        for j in range(len(arr) - 1):\n            if arr[j] > arr[j + 1]:\n                # Swap the elements\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                # Check if the array is sorted after swapping\n                if arr == sorted(arr):\n                    return True\n                # Swap the elements back\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return False\n"}
{"task_id": "EvoEval/69", "completion": "\n    # Create a dictionary to store the indices of the cards\n    card_indices = {card: i for i, card in enumerate(cards)}\n    \n    # Iterate over the cards\n    for i, card in enumerate(cards):\n        # Calculate the magic number divided by the current card\n        magic_divided = magicNumber / card\n        \n        # Check if the magic number divided by the current card is in the dictionary\n        if magic_divided in card_indices and card_indices[magic_divided] != i:\n            # If it is, return the indices of the two cards\n            return (min(i, card_indices[magic_divided]), max(i, card_indices[magic_divided]))\n    \n    # If no pair of cards is found, return \"No magic today\"\n    return \"No magic today\"  # This line will never be reached, but it's required by the problem statement\n"}
{"task_id": "EvoEval/70", "completion": "\n    # Check if the path list is empty or the planets dictionary is empty\n    if not planets or not path:\r\n        return False\r\n\r\n    # Check if the first planet in the path exists in the planets dictionary\r\n    if path[0] not in planets:\r\n        return False\r\n\r\n    # Iterate over the path list starting from the second planet\r\n    for i in range(1, len(path)):\r\n        # Check if the current planet exists in the planets dictionary\r\n        if path[i] not in planets:\r\n            return False\r\n\r\n        # Check if the current planet is in the list of planets directly connected to the previous planet\r\n        if path[i] not in planets[path[i-1]]:\r\n            return False\r\n\r\n    # If all checks pass, return True\r\n    return True\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    vowels = 'aeiou'\n    result = ''\n    vowel_count = 0\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            if char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return result, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    return [f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{i}' who was known for telling {j} tales a day\" for i, j in zip(lst, map(len, map(str, map(int, ''.join(filter(str.isdigit, i)) for i in lst))))]  # count the digits in each string, then use zip to pair the strings with their digit counts, then use a list comprehension to create the fairy tale stories\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Calculate the total number of treasures in the pyramid\r\n    total_treasures = sum(sum(row) for row in grid)\r\n    \r\n    # Calculate the number of trips needed to collect all treasures\r\n    # We use the ceiling of the division of total_treasures by bag_capacity to get the number of trips\r\n    # We add 1 to account for the initial trip into the pyramid\r\n    trips = math.ceil(total_treasures / bag_capacity) + 1\r\n    \r\n    return trips\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    # Create a new string to store the result\n    new_string = \"\"\n    # Iterate over each character in the string 's'\n    for char in s:\n        # Check if the character exists in the cipher dictionary\n        if char in cipher:\n            # If it exists, append the corresponding value to the new string\n            new_string += cipher[char]\n        else:\n            # If it does not exist, append the character as it is to the new string\n            new_string += char\n    # Return the new string\n    return new_string\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    digits = '0123456789'\n    punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\n\n    result = ''\n    for i, char in enumerate(input_str):\n        if char in vowels:\n            next_vowel_index = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[next_vowel_index]\n        elif char in consonants:\n            next_consonant_index = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[next_consonant_index]\n        elif char in digits:\n            result += str((int(char) + 1) % 10)\n        elif char in punctuation:\n            if i % 2 == 0 and char == '?':\n                result += '!'\n            elif i % 2 != 0 and char == '!':\n                result += '?'\n            else:\n                result += char\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/76", "completion": "\n    pyramid = []\n    level = 0\n    for num in lst:\n        level_str = '#' * num\n        pyramid.append(level_str)\n        level += 1\n    return pyramid[::-1]  # reverse the list to get the correct order of levels\n"}
{"task_id": "EvoEval/77", "completion": "\n    # Initialize an empty list to store the points for each number in the sequence\n    points = []\n    \n    # Iterate over each number in the sequence\n    for num in sequence:\n        # Initialize a variable to store the points for the current number\n        total_points = 0\n        \n        # While the number is divisible by k\n        while num % k == 0:\n            # Increment the total points by 1\n            total_points += 1\n            # Divide the number by k\n            num //= k\n        \n        # Append the total points for the current number to the list\n        points.append(total_points)\n    \n    # Return the list of points in decreasing order\n    return sorted(points, reverse=True)  # Changed to reverse=True to sort in descending order\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                result.append(mat[i][j])\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n    # Initialize the minimum price and maximum profit\n    min_price = float('inf')\r\n    max_profit = 0\r\n\r\n    # Iterate over the prices for each day\n    for i in range(days):\r\n        # Update the minimum price if the current price is lower\r\n        if prices[i] < min_price:\r\n            min_price = prices[i]\r\n\r\n        # Update the maximum profit if the current profit is higher\r\n        if prices[i] - min_price > max_profit:\r\n            max_profit = prices[i] - min_price\r\n\r\n    # Return the maximum profit\r\n    return max_profit\r\n\r"}
{"task_id": "EvoEval/80", "completion": "\n    # Initialize the player's position and path\n    player_row, player_col = next((i, j) for i, row in enumerate(map) for j, cell in enumerate(row) if cell == 'S')\n    path = [(player_row, player_col)]\n    \n    # Process each instruction\n    for instruction in instructions:\n        # Get the current player position\n        current_row, current_col = player_row, player_col\n        \n        # Move the player according to the instruction\n        if instruction == 'up' and current_row > 0 and map[current_row - 1][current_col] != 'X':\n            player_row -= 1\n        elif instruction == 'down' and current_row < len(map) - 1 and map[current_row + 1][current_col] != 'X':\n            player_row += 1\n        elif instruction == 'left' and current_col > 0 and map[current_row][current_col - 1] != 'X':\n            player_col -= 1\n        elif instruction == 'right' and current_col < len(map[0]) - 1 and map[current_row][current_col + 1] != 'X':\n            player_col += 1\n        \n        # Add the new player position to the path\n        path.append((player_row, player_col))\n        \n        # Check if the player has reached the end\n        if map[player_row][player_col] == 'E':\n            break\n    \n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n    alien_dict = {char: i for i, char in enumerate(alien_dictionary)}\n    for i in range(len(word_list) - 1):\n        for j in range(min(len(word_list[i]), len(word_list[i + 1]))):\n            if alien_dict[word_list[i][j]] > alien_dict[word_list[i + 1][j]]:\n                return \"INCORRECT\"\n            elif alien_dict[word_list[i][j]] < alien_dict[word_list[i + 1][j]]:\n                break\n        else:\n            if len(word_list[i]) > len(word_list[i + 1]):\n                return \"INCORRECT\"\n    return \"CORRECT\"  # Corrected the return statement to return \"CORRECT\" instead of \"CORRECT\".\n\n"}
{"task_id": "EvoEval/82", "completion": "\n    # Initialize an empty dictionary to store the count of birthdays for each element\n    element_count = {}\n    \n    # Define the zodiac signs and their corresponding elements\n    zodiac_signs = {\n        \"Aries\": \"Fire\",\n        \"Taurus\": \"Earth\",\n        \"Gemini\": \"Air\",\n        \"Cancer\": \"Water\",\n        \"Leo\": \"Fire\",\n        \"Virgo\": \"Earth\",\n        \"Libra\": \"Air\",\n        \"Scorpio\": \"Water\",\n        \"Sagittarius\": \"Fire\",\n        \"Capricorn\": \"Earth\",\n        \"Aquarius\": \"Air\",\n        \"Pisces\": \"Water\"\n    }\n    \n    # Iterate over each birthday in the list\n    for birthday in birthdays:\n        # Extract the month and day from the birthday\n        month, day = birthday.split(\"-\")\n        \n        # Determine the zodiac sign based on the month and day\n        if (int(month) == 3 and int(day) >= 21) or (int(month) == 4 and int(day) <= 19):\n            zodiac_sign = \"Aries\"\n        elif (int(month) == 4 and int(day) >= 20) or (int(month) == 5 and int(day) <= 20):\n            zodiac_sign = \"Taurus\"\n        elif (int(month) == 5 and int(day) >= 21) or (int(month) == 6 and int(day) <= 20):\n            zodiac_sign = \"Gemini\"\n        elif (int(month) == 6 and int(day) >= 21) or (int(month) == 7 and int(day) <= 22):\n            zodiac_sign = \"Cancer\"\n        elif (int(month) == 7 and int(day) >= 23) or (int(month) == 8 and int(day) <= 22):\n            zodiac_sign = \"Leo\"\n        elif (int(month) == 8 and int(day) >= 23) or (int(month) == 9 and int(day) <= 22):\n            zodiac_sign = \"Virgo\"\n        elif (int(month) == 9 and int(day) >= 23) or (int(month) == 10 and int(day) <= 22):\n            zodiac_sign = \"Libra\"\n        elif (int(month) == 10 and int(day) >= 23) or (int(month) == "}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n    return ''.join(s)  # return the modified string\n"}
{"task_id": "EvoEval/84", "completion": "\n    def dfs(node, path):\n        if not node:\n            return []\n        if not node:\n            return [path]\n        if not node:\n            return []\n        paths = []\n        for key, value in node.items():\n            paths.extend(dfs(value, path + [key]))\n        return paths\n\n    return dfs(tree, [])  # Start the DFS traversal from the root node\n"}
{"task_id": "EvoEval/85", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a 2D list to store the minimum number of moves to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Initialize the minimum number of moves to reach the top-left cell as 0\n    dp[0][0] = 0\n    \n    # Fill in the minimum number of moves to reach each cell in the first row\n    for col in range(1, cols):\n        if grid[0][col] == 0:\n            dp[0][col] = dp[0][col-1] + 1\n    \n    # Fill in the minimum number of moves to reach each cell in the first column\n    for row in range(1, rows):\n        if grid[row][0] == 0:\n            dp[row][0] = dp[row-1][0] + 1\n    \n    # Fill in the minimum number of moves to reach each cell in the rest of the grid\n    for row in range(1, rows):\n        for col in range(1, cols):\n            if grid[row][col] == 0:\n                dp[row][col] = min(dp[row-1][col], dp[row][col-1]) + 1\n    \n    # If the princess is at a cell that has a monster, return -1\n    if grid[coord[0]][coord[1]] == 1:\n        return -1\n    \n    # Return the minimum number of moves to reach the princess\n    return dp[coord[0]][coord[1]] if dp[coord[0]][coord[1]] != float('inf') else -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    # First, we sort the movies based on the ratings in descending order and then by the release year in ascending order\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n    # Then, we extract the movie names from the sorted list of tuples\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n    # Finally, we return the sorted list of movie names\n    return sorted_movie_names\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr:\n        return ''\n\n    result = ''\n    top, bottom, left, right = 0, len(arr) - 1, 0, len(arr[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse from left to right\n        for i in range(left, right + 1):\n            result += arr[top][i]\n        top += 1\n\n        # Traverse from top to bottom\n        for i in range(top, bottom + 1):\n            result += arr[i][right]\n        right -= 1\n\n        # Traverse from right to left\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result += arr[bottom][i]\n            bottom -= 1\n\n        # Traverse from bottom to top\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result += arr[i][left]\n            left += 1\n\n    return result  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string.  # Return the result string."}
{"task_id": "EvoEval/88", "completion": "\n    result = {}\n    for planet, population in dict_of_planets.items():\n        if population[0] is not None and population[1] is not None:\n            result[planet] = round(population[0] / population[1], 2)\n    return result\n"}
{"task_id": "EvoEval/89", "completion": "\n    # Create a set to store the positions of the remaining aliens\n    remaining_aliens = set()\n    \n    # Iterate over the positions of the aliens\n    for alien in aliens:\n        # If the alien is not at the position of the ray gun and not in the adjacent positions, add it to the set of remaining aliens\n        if alien != ray and (alien - 1 != ray or alien + 1 != ray):\n            remaining_aliens.add(alien)\n    \n    # Return the set of remaining aliens as a list\n    return list(remaining_aliens)  # Return the list of remaining aliens' positions\n"}
{"task_id": "EvoEval/90", "completion": "\n    # Convert the input strings to lists of integers\n    s1 = [int(x) for x in s1]\n    s2 = [int(x) for x in s2]\n\n    # Initialize a list to store the sums of combinations\n    sums = []\n\n    # Generate all possible combinations of digits\n    for i in range(len(s1)):\n        for j in range(len(s2)):\n            # Calculate the sum of the current combination\n            combination_sum = s1[i] + s2[j]\n            # Add the sum to the list\n            sums.append(combination_sum)\n\n    # Return the sum of all unique combinations\n    return sum(set(sums))  # Using set to remove duplicates\n\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceships_data:\n        if status == 'On Ground' and action == 'Launch':\n            status = 'In Space'\n        elif status == 'In Space' and action == 'Move':\n            pass\n        elif status == 'In Space' and action == 'Land':\n            status = 'On Ground'\n        else:\n            return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Initialize an empty string to store the result\n    result = ''\n    # Initialize a counter to keep track of the current letter\n    letter = 0\n    # Loop through each layer\n    for i in range(1, n + 1):\n        # Calculate the width of the current layer\n        width = 2 * i - 1\n        # Calculate the number of spaces needed to center the layer\n        spaces = (width - 1) // 2\n        # Initialize an empty string to store the current layer\n        layer = ''\n        # Loop through each character in the current layer\n        for j in range(spaces):\n            # Add a space to the layer\n            layer += ' '\n        # Loop through each character in the current layer\n        for j in range(i):\n            # Add the current letter to the layer\n            layer += chr(65 + letter)\n            # Increment the letter counter\n            letter = (letter + 1) % 26\n        # Loop through each character in the current layer in reverse order\n        for j in range(i - 1, -1, -1):\n            # Add the current letter to the layer\n            layer += chr(65 + letter)\n            # Increment the letter counter\n            letter = (letter + 1) % 26\n        # Loop through each character in the current layer\n        for j in range(spaces):\n            # Add a space to the layer\n            layer += ' '\n        # Add the current layer to the result\n        result += layer.center(width) + '\\n'\n    # Return the result\n    return result.strip()  # Remove the trailing newline character\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i in range(len(message)):\n        if message[i].isalpha():\n            n = n_values[i % len(n_values)]\n            if message[i].isupper():\n                result += chr((ord(message[i]) - 65 + n) % 26 + 65)\n            else:\n                result += chr((ord(message[i]) - 97 + n) % 26 + 97)\n        else:\n            result += message[i]\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(word.split(), key=len)) for word in strings]  # Your code here\n"}
{"task_id": "EvoEval/95", "completion": "\n    # Check if the matrix is square\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n\n    # Initialize variables to store the sum of the diagonals\n    diagonal1 = 0\n    diagonal2 = 0\n\n    # Calculate the sum of the first diagonal\n    for i in range(len(m)):\n        diagonal1 += m[i][i]\n\n    # Calculate the sum of the second diagonal\n    for i in range(len(m)):\n        diagonal2 += m[i][len(m) - i - 1]\n\n    # Return the absolute difference between the sums of the diagonals\n    return abs(diagonal1 - diagonal2)  # Changed to abs() to get the absolute difference\n\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] % (i + 1) == 0:\n            product = 1\n            for digit in str(abs(lst[i])):\n                product *= int(digit)\n            if product == i + 1:\n                magic_indices.append(i)\n    return sorted(magic_indices)  # Return a list of magic indices sorted in ascending order\n"}
{"task_id": "EvoEval/97", "completion": "\n    # Check if the alien name is valid\n    if not isinstance(alien, str) or len(alien) == 0:\n        return []\n    \n    # Check if the humans dictionary is valid\n    if not isinstance(humans, dict):\n        return []\n    \n    # Define the order of the continents\n    continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n    \n    # Initialize an empty list to store the humans that will encounter the alien\n    humans_encountered = []\n    \n    # Iterate over the continents in the order they will be invaded\n    for continent in continents:\n        # Check if the alien is in the current continent\n        if continent == \"Asia\":\n            # If the alien is in Asia, add all humans in Asia to the list\n            humans_encountered.extend([human for human, location in humans.items() if location == continent])\n        else:\n            # If the alien is not in Asia, add all humans in the current continent to the list\n            humans_encountered.extend([human for human, location in humans.items() if location == continent])\n    \n    # Return the list of humans that will encounter the alien, sorted by the order of their encounter\n    return sorted(humans_encountered)  # Changed from humans_encountered to sorted(humans_encountered) to sort the list\n"}
{"task_id": "EvoEval/98", "completion": "\n    sequence = [a, b]\n    for i in range(2, n):\n        next_number = sequence[-1] + sequence[-2] + i\n        sequence.append(next_number)\n    for i in range(len(sequence)):\n        if sequence[i] > 1:\n            is_prime = True\n            for j in range(2, int(sequence[i]**0.5) + 1):\n                if sequence[i] % j == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                sequence[i] = 'prime'\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    position = 0\n    for round in rounds:\n        for _ in range(round):\n            position = (position + music) % n\n            players.pop(position - 1)\n    return players\n"}
