{"task_id": "Go/0", "generation": "\n    for i, num1 := range numbers {\n        for j, num2 := range numbers {\n            if i != j && math.Abs(num1-num2) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}"}
{"task_id": "Go/1", "generation": "\n\t// Your code goes here\n}\n// Test function to verify the correctness of the SeparateParenGroups function\nfunc TestSeparateParenGroups(t *testing.T) {\n\ttest_cases := []struct {\n\t\tinput    string\n\t\texpected []string\n\t}{\n\t\t{\"( ) (( )) (( )( ))\", []string{\"()\", \"(())\", \"(()())\"}},\n\t\t{\"((()))(())()\", []string{\"((()))\", \"(())\", \"()\"}},\n\t\t{\"()\", []string{\"()\"}},\n\t\t{\"\", []string{}},\n\t}\n\tfor _, tc := range test_cases {\n\t\tresult := SeparateParenGroups(tc.input)\n\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\tt.Errorf(\"For input '%s', expected %v but got %v\", tc.input, tc.expected, result)\n\t\t}\n\t}\n}\n"}
{"task_id": "Go/2", "generation": "\n    // math.Floor returns the largest integer smaller than the given number\n    // so subtracting it from the original number leaves us with the decimal part\n    return number - math.Floor(number)\n}"}
{"task_id": "Go/3", "generation": "\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}"}
{"task_id": "Go/4", "generation": "\n    var sum, mean, mad float64\n    n := float64(len(numbers))\n\n    // Calculate the mean\n    for _, number := range numbers {\n        sum += number\n    }\n    mean = sum / n\n\n    // Calculate the MAD\n    for _, number := range numbers {\n        mad += math.Abs(number - mean)\n    }\n    mad /= n\n\n    return mad\n}"}
{"task_id": "Go/5", "generation": "\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        result = append(result, num)\n        if i < len(numbers)-1 {\n            result = append(result, delimeter)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/6", "generation": "\n    groups := strings.Split(paren_string, \" \")\n    max_depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        depth := 0\n        max_depth := 0\n        for _, char := range group {\n            if char == '(' {\n                depth++\n                if depth > max_depth {\n                    max_depth = depth\n                }\n            } else if char == ')' {\n                depth--\n            }\n        }\n        max_depths[i] = max_depth\n    }\n\n    return max_depths\n}"}
{"task_id": "Go/7", "generation": "\n    var filteredList []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}"}
{"task_id": "Go/8", "generation": "\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return [2]int{sum, product}\n}"}
{"task_id": "Go/9", "generation": "\n    maxSoFar := math.MinInt64\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}"}
{"task_id": "Go/10", "generation": "\n    if str == \"\" {\n        return \"\"\n    }\n    for i := 0; i < len(str); i++ {\n        if IsPalindrome(str[i:]) {\n            return str + strings.Replace(str[:i], \"\", \"\", -1)\n        }\n    }\n    return str\n}\n// Find the shortest palindrome that can be formed by appending characters to the end of a supplied string.\n// Algorithm idea is simple:\n// - Find the longest prefix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string suffix that comes after the palindromic prefix.\n// >>> MakePalindromeEnd('')\n// ''\n// >>> MakePalindromeEnd('cat')\n// 'catac'\n// >>> MakePalindromeEnd('cata')\n// 'catac'\nfunc MakePalindromeEnd(str string) string {\n    if str == \"\" {\n        return \"\"\n    }\n    for i := len(str); i >= 0; i-- {\n        if IsPalindrome(str[:i]) {\n            return str + strings.Replace(str[i:], \"\", \"\", -1)\n        }\n    }\n    return str\n}\n// Find the shortest palindrome that can be formed by appending characters to the beginning of a supplied string.\n// Algorithm idea is simple:\n// - Find the longest suffix of supplied string that is a palindrome.\n// - Append to the beginning of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> MakePalindromeStart('')\n// ''\n// >>> MakePalindromeStart('cat')\n// 'tacat'\n// >>> MakePalindromeStart('cata')\n// 'atacata'\nfunc MakePalindromeStart(str string) string {\n    if str == \"\" {\n        return \"\"\n    }\n    for i := 0; i < len(str); i++ {\n        if IsPalindrome(str[i:]) {\n            return strings.Replace(str[:i], \"\", \"\", -1) + str\n        }\n    }\n    return str\n}\n// Find the shortest palindrome that can"}
{"task_id": "Go/11", "generation": "\n    var result string\n    for i := range a {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/12", "generation": "\n    if len(strings) == 0 {\n        return nil\n    }\n    longest := strings[0]\n    for _, str := range strings[1:] {\n        if len(str) > len(longest) {\n            longest = str\n        }\n    }\n    return longest\n}"}
{"task_id": "Go/13", "generation": "\n    if b == 0 {\n        return a\n    }\n    return GreatestCommonDivisor(b, a % b)\n}"}
{"task_id": "Go/14", "generation": "\n    var prefixes []string\n    for i := 1; i <= len(str); i++ {\n        prefixes = append(prefixes, str[:i])\n    }\n    return prefixes\n}"}
{"task_id": "Go/15", "generation": "\n    var result string\n    for i := 0; i <= n; i++ {\n        result += strconv.Itoa(i) + \" \"\n    }\n    return result\n}"}
{"task_id": "Go/16", "generation": "\n    str = strings.ToLower(str)\n    charMap := make(map[rune]bool)\n    for _, char := range str {\n        charMap[char] = true\n    }\n    return len(charMap)\n}"}
{"task_id": "Go/17", "generation": "\n    // Your code here\n}\n// Test function to verify the correctness of the ParseMusic function\nfunc TestParseMusic(t *testing.T) {\n    test_cases := []struct{\n        input string\n        expected []int\n    }{\n        {\"o o| .| o| o| .| .| .| .| o o\", []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}},\n        {\"o| o| o| o| o| o| o| o| o| o|\", []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 2}},\n        {\"o .| .| .| .| .| .| .| .| .|\", []int{4, 1, 1, 1, 1, 1, 1, 1, 1, 1}},\n    }\n    for _, tc := range test_cases {\n        result := ParseMusic(tc.input)\n        if !reflect.DeepEqual(result, tc.expected) {\n            t.Errorf(\"ParseMusic(%s) = %v; want %v\", tc.input, result, tc.expected)\n        }\n    }\n}\n"}
{"task_id": "Go/18", "generation": "\n    count := 0\n    for i:=0;i<len(str);i++{\n        if str[i:i+len(substring)] == substring{\n            count++\n        }\n    }\n    return count\n}"}
{"task_id": "Go/19", "generation": "\n    numMap := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n\n    numSlice := strings.Fields(numbers)\n    sort.Slice(numSlice, func(i, j int) bool {\n        return numMap[numSlice[i]] < numMap[numSlice[j]]\n    })\n\n    return strings.Join(numSlice, \" \")\n}"}
{"task_id": "Go/20", "generation": "\n\tsort.Float64s(numbers)\n\tsmallestDiff := math.MaxFloat64\n\tclosestPair := [2]float64{0, 0}\n\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tdiff := numbers[i+1] - numbers[i]\n\t\tif diff < smallestDiff {\n\t\t\tsmallestDiff = diff\n\t\t\tclosestPair[0] = numbers[i]\n\t\t\tclosestPair[1] = numbers[i+1]\n\t\t}\n\t}\n\n\treturn closestPair\n}"}
{"task_id": "Go/21", "generation": "\n    min, max := numbers[0], numbers[0]\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n    rangeVal := max - min\n    rescaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        rescaled[i] = (num - min) / rangeVal\n    }\n    return rescaled\n}"}
{"task_id": "Go/22", "generation": "\n    var result []int\n    for _, value := range values {\n        if intValue, ok := value.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/23", "generation": "\n\treturn len(str)\n}"}
{"task_id": "Go/24", "generation": "\n    for i := n / 2; i >= 1; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        for n%i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}"}
{"task_id": "Go/26", "generation": "\n    occurrences := make(map[int]int)\n    for _, number := range numbers {\n        occurrences[number]++\n    }\n\n    var result []int\n    for _, number := range numbers {\n        if occurrences[number] == 1 {\n            result = append(result, number)\n        }\n    }\n\n    return result\n}"}
{"task_id": "Go/27", "generation": "\n    var result strings.Builder\n    for _, char := range str {\n        if char >= 'a' && char <= 'z' {\n            result.WriteRune(char - 32)\n        } else if char >= 'A' && char <= 'Z' {\n            result.WriteRune(char + 32)\n        } else {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}"}
{"task_id": "Go/28", "generation": "\n\tresult := \"\"\n\tfor _, str := range strings {\n\t\tresult += str\n\t}\n\treturn result\n}"}
{"task_id": "Go/29", "generation": "\n    var result []string\n    for _, s := range strings {\n        if strings.HasPrefix(s, prefix) {\n            result = append(result, s)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/30", "generation": "\n\tvar result []int\n\tfor _, v := range l {\n\t\tif v > 0 {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    sqrtN := int(math.Sqrt(float64(n)))\n    for i := 3; i <= sqrtN; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "Go/32", "generation": "\n    if len(xs) % 2 != 0 {\n        return 0\n    }\n    var a, b float64\n    a = float64(xs[len(xs) - 1])\n    b = float64(xs[len(xs) - 2])\n    for i := len(xs) - 3; i >= 0; i-- {\n        a, b = b, (a - b*float64(xs[i])) / float64(xs[i+1])\n    }\n    return b\n}"}
{"task_id": "Go/33", "generation": "\n    // Create a slice to hold the elements at indices divisible by three\n    divThree := make([]int, 0)\n    for i, v := range l {\n        if i%3 == 0 {\n            divThree = append(divThree, v)\n        }\n    }\n\n    // Sort the slice of elements at indices divisible by three\n    sort.Ints(divThree)\n\n    // Create a slice to hold the sorted elements\n    sorted := make([]int, len(l))\n    j := 0\n    for i := range l {\n        if i%3 == 0 {\n            // If the index is divisible by three, use the sorted element\n            sorted[i] = divThree[j]\n            j++\n        } else {\n            // Otherwise, use the original element\n            sorted[i] = l[i]\n        }\n    }\n\n    return sorted\n}"}
{"task_id": "Go/34", "generation": "\n    uniqueMap := make(map[int]bool)\n    var uniqueSlice []int\n\n    for _, value := range l {\n        if _, exists := uniqueMap[value]; !exists {\n            uniqueMap[value] = true\n            uniqueSlice = append(uniqueSlice, value)\n        }\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}"}
{"task_id": "Go/35", "generation": "\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}"}
{"task_id": "Go/36", "generation": "\n\tcount := 0\n\tfor i := 1; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount += countSevens(i)\n\t\t}\n\t}\n\treturn count\n}"}
{"task_id": "Go/37", "generation": "\n\t// Extract the even-indexed elements\n\tevenIndexedElements := make([]int, 0)\n\tfor i, v := range l {\n\t\tif i%2 == 0 {\n\t\t\tevenIndexedElements = append(evenIndexedElements, v)\n\t\t}\n\t}\n\n\t// Sort the even-indexed elements\n\tsort.Ints(evenIndexedElements)\n\n\t// Create a new list l' with the same odd-indexed elements as l\n\tlPrime := make([]int, len(l))\n\tcopy(lPrime, l)\n\n\t// Replace the even-indexed elements of l' with the sorted elements\n\tj := 0\n\tfor i := 0; i < len(lPrime); i += 2 {\n\t\tlPrime[i] = evenIndexedElements[j]\n\t\tj++\n\t}\n\n\treturn lPrime\n}"}
{"task_id": "Go/38", "generation": "\n    groups := make([]string, 0)\n    for i := 0; i < ((len(s) + 2) / 3); i++ {\n        groups = append(groups, s[3*i:int(math.Min(float64(3*i+3), float64(len(s))))])\n    }\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        runes := []rune(group)\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(append(runes[2:], runes[0], runes[1])))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}"}
{"task_id": "Go/39", "generation": "\n\tcount := 0\n\tfor i := 2; ; i++ {\n\t\tif isPrime(i) && isFibonacci(i) {\n\t\t\tcount++\n\t\t\tif count == n {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n}"}
{"task_id": "Go/40", "generation": "\n\tfor i := 0; i < len(l)-2; i++ {\n\t\tfor j := i + 1; j < len(l)-1; j++ {\n\t\t\tfor k := j + 1; k < len(l); k++ {\n\t\t\t\tif l[i]+l[j]+l[k] == 0 {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}"}
{"task_id": "Go/41", "generation": "\n\treturn n * n\n}"}
{"task_id": "Go/42", "generation": "\n    for i, v := range l {\n        l[i] = v + 1\n    }\n    return l\n}"}
{"task_id": "Go/43", "generation": "\n\tseen := make(map[int]bool)\n\tfor _, v := range l {\n\t\tif seen[-v] {\n\t\t\treturn true\n\t\t}\n\t\tseen[v] = true\n\t}\n\treturn false\n}"}
{"task_id": "Go/44", "generation": "\n    if x == 0 {\n        return \"0\"\n    }\n    result := \"\"\n    for x > 0 {\n        result = strconv.Itoa(x%base) + result\n        x /= base\n    }\n    return result\n}\n"}
{"task_id": "Go/45", "generation": "\n\treturn (a * h) / 2\n}\n\n"}
{"task_id": "Go/46", "generation": "\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 1 {\n\t\treturn float64(l[n/2])\n\t}\n\treturn float64(l[n/2-1]+l[n/2]) / 2.0\n}"}
{"task_id": "Go/48", "generation": "\n\tfor i := 0; i < len(text)/2; i++ {\n\t\tif text[i] != text[len(text)-i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"task_id": "Go/49", "generation": "\n    if n == 0 {\n        return 1\n    }\n    half := Modp(n/2, p)\n    if n%2 == 0 {\n        return (half * half) % p\n    } else {\n        return (half * half * n) % p\n    }\n}"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-5-'a')%26+'a')\n    }\n    return string(newRunes)\n}\n"}
{"task_id": "Go/51", "generation": "\n    re := regexp.MustCompile(\"[aeiouAEIOU]\")\n    return re.ReplaceAllString(text, \"\")\n}"}
{"task_id": "Go/52", "generation": "\n    for _, v := range l {\n        if v >= t {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "Go/53", "generation": "\n\treturn x + y\n}"}
{"task_id": "Go/54", "generation": "\n\tif len(s0) != len(s1) {\n\t\treturn false\n\t}\n\tcount := make(map[rune]int)\n\tfor _, c := range s0 {\n\t\tcount[c]++\n\t}\n\tfor _, c := range s1 {\n\t\tif count[c] == 0 {\n\t\t\treturn false\n\t\t}\n\t\tcount[c]--\n\t}\n\treturn true\n}"}
{"task_id": "Go/55", "generation": "\n    if n <= 1 {\n        return n\n    }\n    return Fib(n-1) + Fib(n-2)\n}"}
{"task_id": "Go/56", "generation": "\n\t// Your code goes here\n}"}
{"task_id": "Go/57", "generation": "\n\tincreasing := true\n\tdecreasing := true\n\n\tfor i := 1; i < len(l); i++ {\n\t\tif l[i] > l[i-1] {\n\t\t\tdecreasing = false\n\t\t}\n\t\tif l[i] < l[i-1] {\n\t\t\tincreasing = false\n\t\t}\n\t}\n\n\treturn increasing || decreasing\n}"}
{"task_id": "Go/58", "generation": "\n    m := make(map[int]bool)\n    var result []int\n\n    for _, value := range l1 {\n        m[value] = true\n    }\n\n    for _, value := range l2 {\n        if _, ok := m[value]; ok {\n            result = append(result, value)\n            delete(m, value) // To ensure unique elements\n        }\n    }\n\n    sort.Ints(result) // Sorting the result\n    return result\n}"}
{"task_id": "Go/59", "generation": "\n    var largest int = 2\n    for n%2 == 0 {\n        n = n / 2\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i = i + 2 {\n        for n%i == 0 {\n            largest = i\n            n = n / i\n        }\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n}"}
{"task_id": "Go/60", "generation": "\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tsum += i\n\t}\n\treturn sum\n}"}
{"task_id": "Go/61", "generation": "\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '(' {\n            stack = append(stack, c)\n        } else if c == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}"}
{"task_id": "Go/62", "generation": "\n\tif len(xs) <= 1 {\n\t\treturn []int{}\n\t}\n\tresult := make([]int, len(xs)-1)\n\tfor i := 1; i < len(xs); i++ {\n\t\tresult[i-1] = xs[i] * i\n\t}\n\treturn result\n}"}
{"task_id": "Go/63", "generation": "\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        a, b, c = b, c, a+b+c\n    }\n    return c\n}"}
{"task_id": "Go/64", "generation": "\n    vowels := \"aeiou\"\n    count := 0\n    s = strings.ToLower(s)\n\n    for i := 0; i < len(s); i++ {\n        if strings.ContainsRune(vowels, rune(s[i])) {\n            count++\n        }\n    }\n\n    if strings.HasSuffix(s, \"y\") {\n        count++\n    }\n\n    return count\n}"}
{"task_id": "Go/65", "generation": "\n    s := strconv.Itoa(x)\n    n := len(s)\n    if shift >= n {\n        return reverse(s)\n    }\n    return s[n-shift:] + s[:n-shift]\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/66", "generation": "\n    sum := 0\n    for _, v := range x {\n        if v >= 'A' && v <= 'Z' {\n            sum += int(v)\n        }\n    }\n    return sum\n}\n// Task\n// Given a string, return the sum of the ASCII values of all uppercase letters in the string.\n// \n// Examples:\n// sum_uppercase(\"\") => 0\n// sum_uppercase(\"abAB\") => 131\n// sum_uppercase(\"abcCd\") => 67\n// sum_uppercase(\"helloE\") => 69\n// sum_uppercase(\"woArBld\") => 131\n// sum_uppercase(\"aAaaaXa\") => 153\nfunc sum_uppercase(s string) int {\n    sum := 0\n    for _, c := range s {\n        if 'A' <= c && c <= 'Z' {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n// Task\n// Write a function that takes a string as input and returns the sum of the ASCII values of all uppercase letters in the string.\n// \n// Examples:\n// sum_uppercase(\"\") => 0\n// sum_uppercase(\"abAB\") => 131\n// sum_uppercase(\"abcCd\") => 67\n// sum_uppercase(\"helloE\") => 69\n// sum_uppercase(\"woArBld\") => 131\n// sum_uppercase(\"aAaaaXa\") => 153\nfunc sum_uppercase(s string) int {\n    sum := 0\n    for _, c := range s {\n        if 'A' <= c && c <= 'Z' {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n// Task\n// Write a function that takes a string as input and returns the sum of the ASCII values of all uppercase letters in the string.\n// \n// Examples:\n// sum_uppercase(\"\") => 0\n// sum_uppercase(\"abAB\") => 131\n// sum_uppercase(\"abcCd\") =>"}
{"task_id": "Go/67", "generation": "\n\t// split the string into two parts\n\tparts := strings.Fields(s)\n\t// convert the first part to an integer\n\tapples, _ := strconv.Atoi(parts[0])\n\t// convert the second part to an integer\n\toranges, _ := strconv.Atoi(parts[3])\n\t// return the difference between the total number of fruits and the number of apples and oranges\n\treturn n - apples - oranges\n}"}
{"task_id": "Go/68", "generation": "\n    min := math.MaxInt32\n    minIndex := -1\n    for i, v := range arr {\n        if v%2 == 0 && v < min {\n            min = v\n            minIndex = i\n        }\n    }\n    if minIndex == -1 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n}"}
{"task_id": "Go/69", "generation": "\n\tfreqMap := make(map[int]int)\n\tfor _, num := range lst {\n\t\tfreqMap[num]++\n\t}\n\n\tmaxVal := -1\n\tfor num, freq := range freqMap {\n\t\tif num <= freq && num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\treturn maxVal\n}"}
{"task_id": "Go/70", "generation": "\n    sort.Ints(lst)\n    result := make([]int, len(lst))\n    i, j := 0, len(lst)-1\n    for i <= j {\n        if i == j {\n            result[i] = lst[i]\n            break\n        }\n        result[i] = lst[i]\n        result[j] = lst[j]\n        i++\n        j--\n    }\n    return result\n}"}
{"task_id": "Go/71", "generation": "\n    if a+b > c && a+c > b && b+c > a {\n        s := (a + b + c) / 2\n        area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n        return math.Round(area*100) / 100\n    }\n    return -1\n}"}
{"task_id": "Go/72", "generation": "\n    // Check if the slice is a palindrome\n    for i := 0; i < len(q)/2; i++ {\n        if q[i] != q[len(q)-1-i] {\n            return false\n        }\n    }\n    // Check if the sum of the slice's elements is less than or equal to w\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n// This function checks if a slice of integers is a palindrome.\n// A palindrome is a sequence that reads the same backward as forward.\n// It returns true if the slice is a palindrome, false otherwise.\nfunc isPalindrome(slice []int) bool {\n    for i := 0; i < len(slice)/2; i++ {\n        if slice[i] != slice[len(slice)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n// This function checks if the sum of the elements in a slice of integers is less than or equal to a given limit.\n// It returns true if the sum is less than or equal to the limit, false otherwise.\nfunc sumLessThanLimit(slice []int, limit int) bool {\n    sum := 0\n    for _, v := range slice {\n        sum += v\n    }\n    return sum <= limit\n}\n// This function combines the above three functions to check if an object q will fly.\n// It returns true if the object is balanced, its sum is less than or equal to the maximum possible weight, and false otherwise.\nfunc WillItFly(q []int, w int) bool {\n    return isPalindrome(q) && sumLessThanLimit(q, w)\n}\n// This function checks if a slice of integers is a palindrome.\n// A palindrome is a sequence that reads the same backward as forward.\n// It returns true if the slice is a palindrome, false otherwise.\nfunc isPalindrome(slice []int) bool {\n    for i := 0; i < len(slice)/2; i++ {\n        if slice[i] != slice[len(slice)-1-i] {\n            return"}
{"task_id": "Go/73", "generation": "\n    changes := 0\n    for i := 0; i < len(arr)/2; i++ {\n        if arr[i] != arr[len(arr)-1-i] {\n            changes++\n        }\n    }\n    return changes\n}"}
{"task_id": "Go/74", "generation": "\n    sum1 := 0\n    sum2 := 0\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return lst2\n}\n// Write a function that accepts a list of strings and returns a new list with the strings in alphabetical order.\n// \n// Examples\n// AlphabeticalOrder([]) \u279e []\n// AlphabeticalOrder(['b', 'a', 'c']) \u279e ['a', 'b', 'c']\n// AlphabeticalOrder(['ba', 'a', 'aaa', 'cd']) \u279e ['a', 'ba', 'cd', 'aaa']\nfunc AlphabeticalOrder(lst []string) []string {\n    sort.Strings(lst)\n    return lst\n}\n// Write a function that accepts a list of strings and returns a new list with the strings in reverse alphabetical order.\n// \n// Examples\n// ReverseAlphabeticalOrder([]) \u279e []\n// ReverseAlphabeticalOrder(['b', 'a', 'c']) \u279e ['c', 'b', 'a']\n// ReverseAlphabeticalOrder(['ba', 'a', 'aaa', 'cd']) \u279e ['cd', 'aaa', 'ba', 'a']\nfunc ReverseAlphabeticalOrder(lst []string) []string {\n    sort.Sort(sort.Reverse(sort.StringSlice(lst)))\n    return lst\n}\n// Write a function that accepts a list of strings and returns a new list with the strings in reverse alphabetical order.\n// \n// Examples\n// ReverseAlphabeticalOrder([]) \u279e []\n// ReverseAlphabeticalOrder(['b', 'a', 'c']) \u279e ['c', 'b', 'a']\n// ReverseAlphabeticalOrder(['ba', 'a', 'aaa', 'cd']) \u279e ['cd', 'aaa', 'ba', 'a']\nfunc ReverseAlphabeticalOrder(lst []string) []string {\n    sort.Sort(sort.Reverse(sort.StringSlice(lst)))\n    return"}
{"task_id": "Go/75", "generation": "\n\t// Your code here\n}\n// Test function\nfunc TestIsMultiplyPrime(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{30, true},\n\t\t{60, true},\n\t\t{100, false},\n\t\t{7, false},\n\t\t{2, false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input: %d\", tc.input), func(t *testing.T) {\n\t\t\tresult := IsMultiplyPrime(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n// Hint: You can use the Sieve of Eratosthenes algorithm to find all prime numbers less than 100.\n// Then, check if the given number is the multiplication of 3 prime numbers."}
{"task_id": "Go/76", "generation": "\n    if n==1{\n        return x==1\n    }\n    for i:=2;i<=x;i++{\n        if int(math.Pow(float64(n),float64(i)))==x{\n            return true\n        }\n    }\n    return false\n}\n//func IsSimplePower(x int,n int) bool {\n//    if n==1{\n//        return x==1\n//    }\n//    for i:=2;i<=x;i++{\n//        if int(math.Pow(float64(n),float64(i)))==x{\n//            return true\n//        }\n//    }\n//    return false\n//}\n"}
{"task_id": "Go/77", "generation": "\n    if a < 0 {\n        a = -a\n    }\n    cubeRoot := math.Cbrt(float64(a))\n    return cubeRoot == float64(int(cubeRoot))\n}"}
{"task_id": "Go/78", "generation": "\n\tcount := 0\n\tfor _, v := range num {\n\t\tswitch v {\n\t\tcase '2', '3', '5', '7', 'B', 'D':\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}"}
{"task_id": "Go/79", "generation": "\n\tbinary := \"\"\n\tfor decimal > 0 {\n\t\tbinary = fmt.Sprintf(\"%d%s\", decimal%2, binary)\n\t\tdecimal = decimal / 2\n\t}\n\treturn fmt.Sprintf(\"db%sdb\", binary)\n}"}
{"task_id": "Go/80", "generation": "\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n// Time complexity: O(n)\n// Space complexity: O(1)\n// where n is the length of the string s."}
{"task_id": "Go/81", "generation": "\n\tvar letterGrades []string\n\tfor _, grade := range grades {\n\t\tswitch {\n\t\tcase grade == 4.0:\n\t\t\tletterGrades = append(letterGrades, \"A+\")\n\t\tcase grade > 3.7:\n\t\t\tletterGrades = append(letterGrades, \"A\")\n\t\tcase grade > 3.3:\n\t\t\tletterGrades = append(letterGrades, \"A-\")\n\t\tcase grade > 3.0:\n\t\t\tletterGrades = append(letterGrades, \"B+\")\n\t\tcase grade > 2.7:\n\t\t\tletterGrades = append(letterGrades, \"B\")\n\t\tcase grade > 2.3:\n\t\t\tletterGrades = append(letterGrades, \"B-\")\n\t\tcase grade > 2.0:\n\t\t\tletterGrades = append(letterGrades, \"C+\")\n\t\tcase grade > 1.7:\n\t\t\tletterGrades = append(letterGrades, \"C\")\n\t\tcase grade > 1.3:\n\t\t\tletterGrades = append(letterGrades, \"C-\")\n\t\tcase grade > 1.0:\n\t\t\tletterGrades = append(letterGrades, \"D+\")\n\t\tcase grade > 0.7:\n\t\t\tletterGrades = append(letterGrades, \"D\")\n\t\tcase grade > 0.0:\n\t\t\tletterGrades = append(letterGrades, \"D-\")\n\t\tdefault:\n\t\t\tletterGrades = append(letterGrades, \"E\")\n\t\t}\n\t}\n\treturn letterGrades\n}"}
{"task_id": "Go/82", "generation": "\n\tlength := len(s)\n\tif length < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= length; i++ {\n\t\tif length%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"task_id": "Go/83", "generation": "\n    if n == 1 {\n        return 1\n    }\n    return int(math.Pow(10, float64(n-1)))*2 - int(math.Pow(10, float64(n-2)))\n}"}
{"task_id": "Go/84", "generation": "\n    sum := 0\n    for _, c := range strconv.Itoa(N) {\n        sum += int(c - '0')\n    }\n    return strconv.FormatInt(int64(sum), 2)\n}\n\n"}
{"task_id": "Go/85", "generation": "\n\tsum := 0\n\tfor i, v := range lst {\n\t\tif i%2 != 0 && v%2 == 0 {\n\t\t\tsum += v\n\t\t}\n\t}\n\treturn sum\n}"}
{"task_id": "Go/86", "generation": "\n    words := strings.Fields(s)\n    for i, word := range words {\n        words[i] = sortWord(word)\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc sortWord(word string) string {\n    chars := []rune(word)\n    sort.Slice(chars, func(i, j int) bool {\n        return chars[i] < chars[j]\n    })\n    return string(chars)\n}\n"}
{"task_id": "Go/87", "generation": "\n    var res [][2]int\n    for i, row := range lst {\n        for j, val := range row {\n            if val == x {\n                res = append(res, [2]int{i, j})\n            }\n        }\n    }\n    sort.Slice(res, func(i, j int) bool {\n        if res[i][0] == res[j][0] {\n            return res[i][1] > res[j][1]\n        }\n        return res[i][0] < res[j][0]\n    })\n    return res\n}"}
{"task_id": "Go/88", "generation": "\n    if len(array) == 0 {\n        return array\n    }\n\n    sortedArray := make([]int, len(array))\n    copy(sortedArray, array)\n\n    if (sortedArray[0]+sortedArray[len(sortedArray)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(sortedArray)))\n    } else {\n        sort.Ints(sortedArray)\n    }\n\n    return sortedArray\n}"}
{"task_id": "Go/89", "generation": "\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            shift := (char - 'a' + 2*2) % 26\n            result += string('a' + shift)\n        } else if char >= 'A' && char <= 'Z' {\n            shift := (char - 'A' + 2*2) % 26\n            result += string('A' + shift)\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/90", "generation": "\n    if len(lst) < 2 {\n        return nil\n    }\n    sort.Ints(lst)\n    return lst[1]\n}"}
{"task_id": "Go/91", "generation": "\n    // Your code here\n}\n"}
{"task_id": "Go/92", "generation": "\n\t// Check if all numbers are integers\n\tif !isInt(x) || !isInt(y) || !isInt(z) {\n\t\treturn false\n\t}\n\n\t// Convert numbers to int\n\txInt, _ := x.(int)\n\tyInt, _ := y.(int)\n\tzInt, _ := z.(int)\n\n\t// Check if one number is equal to the sum of the other two\n\treturn xInt == yInt+zInt || yInt == xInt+zInt || zInt == xInt+yInt\n}"}
{"task_id": "Go/93", "generation": "\n    vowels := \"aeiou\"\n    vowelMap := make(map[rune]rune)\n    for i, v := range vowels {\n        vowelMap[v] = rune(vowels[(i+2)%len(vowels)])\n        vowelMap[v-32] = rune(vowels[(i+2)%len(vowels)])\n    }\n\n    var encoded strings.Builder\n    for _, c := range message {\n        if strings.ContainsRune(vowels, c) {\n            encoded.WriteRune(vowelMap[c])\n        } else {\n            encoded.WriteRune(c - 32*int32(c%2) + 32*int32(1-c%2))\n        }\n    }\n\n    return encoded.String()\n}"}
{"task_id": "Go/94", "generation": "\n    maxPrime := 0\n    for _, num := range lst {\n        if isPrime(num) && num > maxPrime {\n            maxPrime = num\n        }\n    }\n    return sumDigits(maxPrime)\n}\n\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(num))); i++ {\n        if num%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc sumDigits(num int) int {\n    sum := 0\n    for _, digit := range strconv.Itoa(num) {\n        sum += int(digit - '0')\n    }\n    return sum\n}\n"}
{"task_id": "Go/95", "generation": "\n    if len(dict) == 0 {\n        return false\n    }\n\n    allLower := true\n    allUpper := true\n\n    for key := range dict {\n        strKey, ok := key.(string)\n        if !ok {\n            return false\n        }\n\n        if allLower && strKey != strings.ToLower(strKey) {\n            allLower = false\n        }\n\n        if allUpper && strKey != strings.ToUpper(strKey) {\n            allUpper = false\n        }\n    }\n\n    return allLower || allUpper\n}"}
{"task_id": "Go/96", "generation": "\n\t// Your implementation goes here\n}\n// The function should be efficient and should not use any external libraries.\n// The function should also handle edge cases where n is less than 2.\n// The function should also handle cases where n is a large number.\n// The function should also handle cases where n is a prime number itself.\n// The function should also handle cases where n is a multiple of a prime number.\n// The function should also handle cases where n is a multiple of a composite number.\n// The function should also handle cases where n is a multiple of a prime number raised to a power.\n// The function should also handle cases where n is a multiple of a composite number raised to a power.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a prime number.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a prime number.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a composite number.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a composite number.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a prime number raised to a power.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a prime number raised to a power.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a composite number raised to a power.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a composite number raised to a power.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a prime number raised to a power of a prime number.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a prime number raised to a power of a composite number.\n// The function should also handle cases where n is a multiple of a prime number raised to a power of a composite number raised to a power of a prime number raised to a power.\n// The function should also handle cases where n is a multiple of a composite number raised to a power of a prime number raised to a power of a"}
{"task_id": "Go/97", "generation": "\n    return int(math.Abs(float64(a % 10))) * int(math.Abs(float64(b % 10)))\n}"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for i, c := range s {\n        if i%2 == 0 && strings.ContainsRune(\"AEIOU\", c) {\n            count++\n        }\n    }\n    return count\n}"}
{"task_id": "Go/99", "generation": "\n    // Convert the string to a float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n\n    // Check if the number is negative\n    isNegative := num < 0\n\n    // Get the absolute value of the number\n    absNum := math.Abs(num)\n\n    // Get the fractional part of the number\n    fractionalPart := absNum - math.Floor(absNum)\n\n    // Check if the fractional part is exactly 0.5\n    if fractionalPart == 0.5 {\n        // If the number is negative, round down (away from zero)\n        // If the number is positive, round up (away from zero)\n        if isNegative {\n            return int(math.Floor(absNum))\n        } else {\n            return int(math.Ceil(absNum))\n        }\n    } else {\n        // If the fractional part is not 0.5, use the built-in rounding function\n        return int(math.Round(absNum))\n    }\n}"}
{"task_id": "Go/100", "generation": "\n    var result []int\n    var current int = n\n    for i := 0; i < n; i++ {\n        result = append(result, current)\n        if n%2 == 0 {\n            current += 2\n        } else {\n            current += 2\n        }\n    }\n    return result\n}\n// This code snippet defines a function `MakeAPile` that takes an integer `n` as input\n// and returns a slice of integers representing the number of stones in each level of a pile.\n// The function initializes an empty slice `result` and a variable `current` with the value of `n`.\n// It then enters a loop that runs `n` times, appending the current value of `current` to the `result` slice.\n// Depending on whether `n` is even or odd, the value of `current` is incremented by 2 in each iteration.\n// Finally, the function returns the `result` slice containing the number of stones in each level."}
{"task_id": "Go/101", "generation": "\n    // Split the string by commas and spaces\n    words := strings.FieldsFunc(s, func(r rune) bool {\n        return r == ',' || r == ' '\n    })\n\n    return words\n}"}
{"task_id": "Go/102", "generation": "\n\tif x > y {\n\t\treturn -1\n\t}\n\tif y%2 == 0 {\n\t\treturn y\n\t}\n\tif (y-1) >= x {\n\t\treturn y - 1\n\t}\n\treturn -1\n}"}
{"task_id": "Go/103", "generation": "\n    if n > m {\n        return -1\n    }\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n    avg := math.Round(float64(sum) / float64(m-n+1))\n    return fmt.Sprintf(\"0b%b\", int(avg))\n}"}
{"task_id": "Go/104", "generation": "\n    var result []int\n    for _, num := range x {\n        if hasNoEvenDigit(num) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}"}
{"task_id": "Go/105", "generation": "\n    var result []string\n    var temp []int\n    for _, v := range arr {\n        if v >= 1 && v <= 9 {\n            temp = append(temp, v)\n        }\n    }\n    sort.Ints(temp)\n    for i := len(temp) - 1; i >= 0; i-- {\n        switch temp[i] {\n        case 1:\n            result = append(result, \"One\")\n        case 2:\n            result = append(result, \"Two\")\n        case 3:\n            result = append(result, \"Three\")\n        case 4:\n            result = append(result, \"Four\")\n        case 5:\n            result = append(result, \"Five\")\n        case 6:\n            result = append(result, \"Six\")\n        case 7:\n            result = append(result, \"Seven\")\n        case 8:\n            result = append(result, \"Eight\")\n        case 9:\n            result = append(result, \"Nine\")\n        }\n    }\n    return result\n}"}
{"task_id": "Go/106", "generation": "\n\tresult := make([]int, n)\n\tfor i := 1; i <= n; i++ {\n\t\tif i%2 == 0 {\n\t\t\tresult[i-1] = factorial(i)\n\t\t} else {\n\t\t\tresult[i-1] = sum(i)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}\n\nfunc sum(n int) int {\n\treturn (n * (n + 1)) / 2\n}"}
{"task_id": "Go/107", "generation": "\n    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n    return [2]int{even, odd}\n}"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        if sumOfDigits(num) > 0 {\n            count++\n        }\n    }\n    return count\n}"}
{"task_id": "Go/109", "generation": "\n    if len(arr) == 0 {\n        return true\n    }\n    \n    // Find the index of the smallest element\n    minIndex := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[minIndex] {\n            minIndex = i\n        }\n    }\n    \n    // Check if the array is already sorted\n    for i := 1; i < len(arr); i++ {\n        if arr[(minIndex+i)%len(arr)] < arr[(minIndex+i-1)%len(arr)] {\n            return false\n        }\n    }\n    \n    return true\n}"}
{"task_id": "Go/110", "generation": "\n\t// Your code here\n}\n// In this problem, you will implement a function that takes a list of numbers\n// and determines whether it is possible to perform a Rotation of elements\n// between them to make lst a list of only even numbers.\n// There is no limit on the number of Rotations between lst and itself.\n// If it is possible to Rotate elements between the lst and itself to make\n// all the elements of lst to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Rotate([1, 2, 3, 4]) => \"YES\"\n// Rotate([1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input list will be non-empty.\nfunc Rotate(lst []int) string {\n\t// Your code here\n}\n// In this problem, you will implement a function that takes a list of numbers\n// and determines whether it is possible to perform a Merge of elements\n// between two lists to make the first list a list of only even numbers.\n// There is no limit on the number of Merges between the two lists.\n// If it is possible to Merge elements between the two lists to make\n// all the elements of the first list to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// Merge([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// Merge([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\nfunc Merge(lst1, lst2 []int) string {\n\t// Your code here\n}\n// In this problem, you will implement a function that takes a list of numbers\n// and determines whether it is possible to perform a Split of elements\n// between two lists to make the first list a list of only even numbers.\n// There is no limit on the number of Splits between the two lists.\n// If it is possible to Split elements between the two lists to make\n// all the elements of the first list to be even, return \"YES"}
{"task_id": "Go/111", "generation": "\n    histogram := make(map[rune]int)\n    maxCount := 0\n    for _, char := range strings.ReplaceAll(test, \" \", \"\") {\n        histogram[char]++\n        if histogram[char] > maxCount {\n            maxCount = histogram[char]\n        }\n    }\n    for key, value := range histogram {\n        if value != maxCount {\n            delete(histogram, key)\n        }\n    }\n    return histogram\n}"}
{"task_id": "Go/112", "generation": "\n    var result string\n    for _, v := range s {\n        if !strings.ContainsRune(c, v) {\n            result += string(v)\n        }\n    }\n    reverse := \"\"\n    for i := len(result) - 1; i >= 0; i-- {\n        reverse += string(result[i])\n    }\n    if result == reverse {\n        return [2]interface{}{result, true}\n    }\n    return [2]interface{}{result, false}\n}\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        count := 0\n        for _, char := range str {\n            if (char-'0')%2 != 0 {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number of odd elements %dn the str%dnng %d of the %dnput.\", count, count, count, count))\n    }\n    return result\n}"}
{"task_id": "Go/114", "generation": "\n    minSum := math.MaxInt32\n    currentSum := 0\n\n    for _, num := range nums {\n        currentSum += num\n        if currentSum < minSum {\n            minSum = currentSum\n        }\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n\n    return minSum\n}"}
{"task_id": "Go/115", "generation": "\n    var max int\n    for _, row := range grid {\n        for _, cell := range row {\n            if cell == 1 {\n                max++\n            }\n        }\n    }\n    return int(math.Ceil(float64(max) / float64(capacity)))\n}\n"}
{"task_id": "Go/116", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        if countOnes(arr[i]) == countOnes(arr[j]) {\n            return arr[i] < arr[j]\n        }\n        return countOnes(arr[i]) < countOnes(arr[j])\n    })\n    return arr\n}\n\nfunc countOnes(n int) int {\n    count := 0\n    for n > 0 {\n        count += n & 1\n        n >>= 1\n    }\n    return count\n}"}
{"task_id": "Go/117", "generation": "\n    words := strings.Fields(s)\n    var result []string\n    for _, word := range words {\n        if countConsonants(word) == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for i := len(word) - 2; i > 0; i-- {\n        if bytes.ContainsRune([]byte{word[i]}, vowels[0]) && !bytes.ContainsRune([]byte{word[i-1]}, vowels[0]) && !bytes.ContainsRune([]byte{word[i+1]}, vowels[0]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}"}
{"task_id": "Go/119", "generation": "\n}"}
{"task_id": "Go/120", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    return arr[:k]\n}"}
{"task_id": "Go/121", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution(lst []int) int {\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n// another solution\nfunc Solution"}
{"task_id": "Go/122", "generation": "\n    sum := 0\n    for i := 0; i < k; i++ {\n        if len(strconv.Itoa(arr[i])) <= 2 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/123", "generation": "\n    var oddCollatz []int\n    for n != 1 {\n        if n%2 != 0 {\n            oddCollatz = append(oddCollatz, n)\n        }\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n    oddCollatz = append(oddCollatz, 1)\n    sort.Ints(oddCollatz)\n    return oddCollatz\n}"}
{"task_id": "Go/124", "generation": "\n    if len(date) != 10 {\n        return false\n    }\n    if date[2] != '-' || date[5] != '-' {\n        return false\n    }\n    month, _ := strconv.Atoi(date[:2])\n    day, _ := strconv.Atoi(date[3:5])\n    year, _ := strconv.Atoi(date[6:])\n    if month < 1 || month > 12 {\n        return false\n    }\n    if day < 1 || day > 31 {\n        return false\n    }\n    if month == 2 && day > 29 {\n        return false\n    }\n    if month == 4 || month == 6 || month == 9 || month == 11 && day > 30 {\n        return false\n    }\n    return true\n}"}
{"task_id": "Go/125", "generation": "\n    if strings.Contains(txt, \" \") {\n        return strings.Fields(txt)\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        count := 0\n        for _, char := range txt {\n            if (char-'a')%2 == 1 {\n                count++\n            }\n        }\n        return count\n    }\n}"}
{"task_id": "Go/126", "generation": "\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "Go/127", "generation": "\n}\n// \n// \n// [input/output] samples:\n// IsPrime(2) ==> true\n// IsPrime(11) ==> true\n// IsPrime(13441) ==> true\n// IsPrime(61) ==> true\n// IsPrime(4) ==> false\n// IsPrime(1) ==> false\nfunc IsPrime(n int) bool {\n}\n// \n// \n// [input/output] samples:\n// IsPalindrome(121) ==> true\n// IsPalindrome(123) ==> false\n// IsPalindrome(1) ==> true\n// IsPalindrome(22) ==> true\n// IsPalindrome(12321) ==> true\nfunc IsPalindrome(n int) bool {\n}\n// \n// \n// [input/output] samples:\n// IsPerfectSquare(1) ==> true\n// IsPerfectSquare(16) ==> true\n// IsPerfectSquare(14) ==> false\n// IsPerfectSquare(9) ==> true\n// IsPerfectSquare(25) ==> true\nfunc IsPerfectSquare(n int) bool {\n}\n// \n// \n// [input/output] samples:\n// IsPerfectCube(1) ==> true\n// IsPerfectCube(27) ==> true\n// IsPerfectCube(28) ==> false\n// IsPerfectCube(125) ==> true\n// IsPerfectCube(26) ==> false\nfunc IsPerfectCube(n int) bool {\n}\n// \n// \n// [input/output] samples:\n// IsPerfectPower(1) ==> true\n// IsPerfectPower(2) ==> true\n// IsPerfectPower(64) ==> true\n// IsPerfectPower(81) ==> true\n// IsPerfectPower(10) ==> false\nfunc IsPerfectPower(n int) bool {\n}\n// \n// \n// [input/output] samples:\n// IsPerfectPowerOf2(1) ==> true\n// IsPerfectPowerOf2(2) ==> true\n// IsPer"}
{"task_id": "Go/128", "generation": "\n    if len(arr) == 0 {\n        return nil\n    }\n    \n    sumOfMagnitudes := 0\n    productOfSigns := 1\n    \n    for _, num := range arr {\n        sumOfMagnitudes += int(math.Abs(float64(num)))\n        \n        if num == 0 {\n            productOfSigns = 0\n            break\n        } else if num < 0 {\n            productOfSigns *= -1\n        }\n    }\n    \n    return sumOfMagnitudes * productOfSigns\n}"}
{"task_id": "Go/129", "generation": "\n    // Your code here\n}\n"}
{"task_id": "Go/130", "generation": "\n\tif n == 0 {\n\t\treturn []float64{1}\n\t}\n\tif n == 1 {\n\t\treturn []float64{1, 3}\n\t}\n\tif n == 2 {\n\t\treturn []float64{1, 3, 2}\n\t}\n\tres := make([]float64, n+1)\n\tres[0], res[1], res[2] = 1, 3, 2\n\tfor i := 3; i <= n; i++ {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = float64(i) / 2\n\t\t} else {\n\t\t\tres[i] = res[i-1] + res[i-2] + res[i+1]\n\t\t}\n\t}\n\treturn res\n}\n// Time complexity: O(n)\n// Space complexity: O(n)\n// This solution uses dynamic programming to solve the problem. It iterates from 3 to n,\n// and for each number, it calculates the value based on the recurrence relation.\n// The time complexity is O(n) because we need to iterate through the sequence once.\n// The space complexity is O(n) because we need to store the sequence in a list.\n// This solution is efficient and works well for large values of n."}
{"task_id": "Go/131", "generation": "\n    product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit % 2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n /= 10\n    }\n\n    if !hasOdd {\n        return 0\n    }\n\n    return product\n}"}
{"task_id": "Go/132", "generation": "\n    stack := []rune{}\n    for _, c := range s {\n        if c == '[' {\n            stack = append(stack, c)\n        } else if c == ']' {\n            if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) > 0\n}\n// This function uses a stack to keep track of the opening brackets.\n// If it encounters a closing bracket and the stack is not empty, it means there is a nested bracket.\n// If the stack is empty when it encounters a closing bracket, it means there is no nested bracket.\n// The function returns true if there is at least one nested bracket, and false otherwise.\n// \n// The time complexity of this function is O(n), where n is the length of the input string.\n// The space complexity of this function is also O(n), where n is the length of the input string.\n// This is because in the worst case, the function may need to store all the opening brackets in the stack."}
{"task_id": "Go/133", "generation": "\n    sum := 0\n    for _, v := range lst {\n        sum += int(math.Pow(math.Ceil(v), 2))\n    }\n    return sum\n}"}
{"task_id": "Go/134", "generation": "\n    // Trim any trailing spaces from the string\n    txt = strings.TrimSpace(txt)\n\n    // Check if the string is empty after trimming\n    if len(txt) == 0 {\n        return false\n    }\n\n    // Get the last character of the string\n    lastChar := txt[len(txt)-1]\n\n    // Check if the last character is an alphabetical character\n    if (lastChar >= 'a' && lastChar <= 'z') || (lastChar >= 'A' && lastChar <= 'Z') {\n        // Check if the last character is a part of a word\n        if len(txt) == 1 || txt[len(txt)-2] == ' ' {\n            return true\n        }\n    }\n\n    return false\n}"}
{"task_id": "Go/135", "generation": "\n\t// Your code here\n}"}
{"task_id": "Go/136", "generation": "\n    var largestNegative, smallestPositive *int\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = &num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = &num\n            }\n        }\n    }\n    return [2]interface{}{largestNegative, smallestPositive}\n}"}
{"task_id": "Go/137", "generation": "\n    var aVal, bVal float64\n    var aType, bType string\n\n    switch a.(type) {\n    case int:\n        aVal = float64(a.(int))\n        aType = \"int\"\n    case float64:\n        aVal = a.(float64)\n        aType = \"float64\"\n    case string:\n        aVal, _ = strconv.ParseFloat(strings.Replace(a.(string), \",\", \".\", -1), 64)\n        aType = \"string\"\n    }\n\n    switch b.(type) {\n    case int:\n        bVal = float64(b.(int))\n        bType = \"int\"\n    case float64:\n        bVal = b.(float64)\n        bType = \"float64\"\n    case string:\n        bVal, _ = strconv.ParseFloat(strings.Replace(b.(string), \",\", \".\", -1), 64)\n        bType = \"string\"\n    }\n\n    if aVal == bVal {\n        return nil\n    }\n\n    if aVal > bVal {\n        if aType == \"string\" {\n            return strings.Replace(strconv.FormatFloat(aVal, 'f', -1, 64), \".\", \",\", -1)\n        }\n        return a\n    }\n\n    if bType == \"string\" {\n        return strings.Replace(strconv.FormatFloat(bVal, 'f', -1, 64), \".\", \",\", -1)\n    }\n    return b\n}\n\n"}
{"task_id": "Go/138", "generation": "\n    // Your code here\n}\n"}
{"task_id": "Go/139", "generation": "\n    result := 1\n    for i := 1; i <= n; i++ {\n        factorial := 1\n        for j := 1; j <= i; j++ {\n            factorial *= j\n        }\n        result *= factorial\n    }\n    return result\n}"}
{"task_id": "Go/140", "generation": "\n    // Your code here\n}\n// Example usage:\n// fmt.Println(FixSpaces(\"Example\")) // Output: \"Example\"\n// fmt.Println(FixSpaces(\"Example 1\")) // Output: \"Example_1\"\n// fmt.Println(FixSpaces(\" Example 2\")) // Output: \"_Example_2\"\n// fmt.Println(FixSpaces(\" Example   3\")) // Output: \"_Example-3\"\n"}
{"task_id": "Go/141", "generation": "\n    // Check if the file name contains more than three digits\n    digitCount := 0\n    for _, char := range file_name {\n        if char >= '0' && char <= '9' {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    // Check if the file name contains exactly one dot\n    dotCount := strings.Count(file_name, \".\")\n    if dotCount != 1 {\n        return \"No\"\n    }\n\n    // Split the file name into two parts: before and after the dot\n    parts := strings.Split(file_name, \".\")\n    namePart := parts[0]\n    extensionPart := parts[1]\n\n    // Check if the name part is not empty and starts with a latin alphapet letter\n    if len(namePart) == 0 || (namePart[0] < 'a' || namePart[0] > 'z') && (namePart[0] < 'A' || namePart[0] > 'Z') {\n        return \"No\"\n    }\n\n    // Check if the extension part is one of the allowed ones\n    allowedExtensions := []string{\"txt\", \"exe\", \"dll\"}\n    isAllowedExtension := false\n    for _, extension := range allowedExtensions {\n        if extensionPart == extension {\n            isAllowedExtension = true\n            break\n        }\n    }\n    if !isAllowedExtension {\n        return \"No\"\n    }\n\n    // If all checks pass, the file name is valid\n    return \"Yes\"\n}\n"}
{"task_id": "Go/142", "generation": "\n    sum := 0\n    for i, num := range lst {\n        if i % 3 == 0 {\n            sum += int(math.Pow(float64(num), 2))\n        } else if i % 4 == 0 {\n            sum += int(math.Pow(float64(num), 3))\n        } else {\n            sum += num\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/143", "generation": "\n    words := strings.Split(sentence, \" \")\n    var result []string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n    return strings.Join(result, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/144", "generation": "\n    // Split the numerator and denominator of x\n    xNumerator, xDenominator := splitFraction(x)\n    // Split the numerator and denominator of n\n    nNumerator, nDenominator := splitFraction(n)\n\n    // Calculate the product of the numerators and denominators\n    productNumerator := xNumerator * nNumerator\n    productDenominator := xDenominator * nDenominator\n\n    // Check if the product of the numerators is divisible by the product of the denominators\n    return productNumerator%productDenominator == 0\n}"}
{"task_id": "Go/145", "generation": "\n    sort.SliceStable(nums, func(i, j int) bool {\n        return sumDigits(nums[i]) < sumDigits(nums[j])\n    })\n    return nums\n}"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        if num > 10 {\n            strNum := strconv.Itoa(num)\n            firstDigit, _ := strconv.Atoi(string(strNum[0]))\n            lastDigit, _ := strconv.Atoi(string(strNum[len(strNum)-1]))\n            if firstDigit%2 != 0 && lastDigit%2 != 0 {\n                count++\n            }\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/147", "generation": "\n    a := make([]int, n)\n    for i := 0; i < n; i++ {\n        a[i] = i * i - i + 1\n    }\n    count := 0\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i]+a[j]+a[k])%3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}\n// Time complexity: O(n^3)\n// Space complexity: O(n)\n// \n// Constraints:\n// 1 \u2264 n \u2264 10^5\n// \n// Note:\n// The given problem is a variation of the problem of finding the number of valid triples in an array.\n// The given problem is a bit more complex than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more challenging than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in an array.\n// The given problem is a bit more difficult than the problem of finding the number of valid triples in"}
{"task_id": "Go/148", "generation": "\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tvar result []string\n\tplanet1Index, planet2Index := -1, -1\n\n\tfor i, planet := range planets {\n\t\tif planet == planet1 {\n\t\t\tplanet1Index = i\n\t\t}\n\t\tif planet == planet2 {\n\t\t\tplanet2Index = i\n\t\t}\n\t}\n\n\tif planet1Index == -1 || planet2Index == -1 {\n\t\treturn result\n\t}\n\n\tif planet1Index > planet2Index {\n\t\tplanet1Index, planet2Index = planet2Index, planet1Index\n\t}\n\n\tfor i := planet1Index + 1; i < planet2Index; i++ {\n\t\tresult = append(result, planets[i])\n\t}\n\n\treturn result\n}"}
{"task_id": "Go/149", "generation": "\n    // Remove strings with odd lengths\n    evenLengthStrings := make([]string, 0)\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            evenLengthStrings = append(evenLengthStrings, str)\n        }\n    }\n\n    // Sort the list by length, then alphabetically\n    sort.Slice(evenLengthStrings, func(i, j int) bool {\n        if len(evenLengthStrings[i]) == len(evenLengthStrings[j]) {\n            return evenLengthStrings[i] < evenLengthStrings[j]\n        }\n        return len(evenLengthStrings[i]) < len(evenLengthStrings[j])\n    })\n\n    return evenLengthStrings\n}"}
{"task_id": "Go/150", "generation": "\n    if isPrime(n) {\n        return x\n    }\n    return y\n}"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && math.Mod(num, 2) == 1 {\n            sum += int(math.Pow(num, 2))\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/152", "generation": "\n    var result []int\n    for i := 0; i < len(game); i++ {\n        result = append(result, int(math.Abs(float64(game[i] - guess[i]))))\n    }\n    return result\n}"}
{"task_id": "Go/153", "generation": "\n    maxStrength := -math.MaxFloat64\n    strongestExtension := \"\"\n    for _, extension := range extensions {\n        upperCount := 0\n        lowerCount := 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                upperCount++\n            } else if char >= 'a' && char <= 'z' {\n                lowerCount++\n            }\n        }\n        strength := float64(upperCount - lowerCount)\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n    return class_name + \".\" + strongestExtension\n}"}
{"task_id": "Go/154", "generation": "\n    if len(b) > len(a) {\n        return false\n    }\n    for i := 0; i < len(b); i++ {\n        if strings.Contains(a, b[i:]+b[:i]) {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/155", "generation": "\n    if num < 0 {\n        num = -num\n    }\n    evenCount, oddCount := 0, 0\n    for _, digitChar := range strconv.Itoa(num) {\n        digit, _ := strconv.Atoi(string(digitChar))\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n    }\n    return [2]int{evenCount, oddCount}\n}"}
{"task_id": "Go/156", "generation": "\n    var romanPairs = []struct {\n        Value  int\n        Symbol string\n    }{\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"},\n    }\n\n    var roman strings.Builder\n    for _, pair := range romanPairs {\n        for number >= pair.Value {\n            roman.WriteString(pair.Symbol)\n            number -= pair.Value\n        }\n    }\n    return roman.String()\n}"}
{"task_id": "Go/157", "generation": "\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\nfunc CountDistinctLetters(s string) int {\n\t// Your code here\n}\n// Given a string s, return the number of substrings that have only one distinct\n// letter.\n// Example:\n// CountDistinctLetters(\"abcabc\") == 3\n// CountDistinctLetters(\"aaaba\") == 3\n"}
{"task_id": "Go/158", "generation": "\n    maxUnique := 0\n    maxWord := \"\"\n    for _, word := range words {\n        uniqueChars := make(map[rune]bool)\n        for _, char := range word {\n            uniqueChars[char] = true\n        }\n        if len(uniqueChars) > maxUnique || (len(uniqueChars) == maxUnique && word < maxWord) {\n            maxUnique = len(uniqueChars)\n            maxWord = word\n        }\n    }\n    return maxWord\n}"}
{"task_id": "Go/159", "generation": "\n\t// your code here\n}\n"}
{"task_id": "Go/160", "generation": "\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n    \n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"//\":\n            result = int(math.Floor(float64(result) / float64(operand[i+1])))\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(operand[i+1])))\n        }\n    }\n    \n    return result\n}"}
{"task_id": "Go/161", "generation": "\n\thasLetter := false\n\tresult := \"\"\n\tfor _, c := range s {\n\t\tif c >= 'a' && c <= 'z' {\n\t\t\thasLetter = true\n\t\t\tresult += string(c - 32)\n\t\t} else if c >= 'A' && c <= 'Z' {\n\t\t\thasLetter = true\n\t\t\tresult += string(c + 32)\n\t\t} else {\n\t\t\tresult += string(c)\n\t\t}\n\t}\n\tif !hasLetter {\n\t\tresult = reverseString(result)\n\t}\n\treturn result\n}\n\nfunc reverseString(s string) string {\n\tresult := \"\"\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tresult += string(s[i])\n\t}\n\treturn result\n}"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hasher := md5.New()\n    hasher.Write([]byte(text))\n    return fmt.Sprintf(\"%x\", hasher.Sum(nil))\n}"}
{"task_id": "Go/163", "generation": "\n\tif a > b {\n\t\ta, b = b, a\n\t}\n\n\tvar result []int\n\tfor i := a; i <= b; i++ {\n\t\tif i%2 == 0 {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}"}
