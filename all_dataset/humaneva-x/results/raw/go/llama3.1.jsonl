{"task_id": "Go/0", "generation": "\n    for i := 0; i < len(numbers)-1; i++ {\n        if math.Abs(numbers[i] - numbers[i+1]) < threshold {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/1", "generation": "\n\t// Initialize an empty list to store the groups\n\tgroups := []string{}\n\n\t// Initialize an empty string to build the current group\n\tcurrent_group := \"\"\n\n\t// Initialize a counter to track the balance of the parentheses\n\tbalance := 0\n\n\t// Iterate over each character in the input string\n\tfor _, char := range paren_string {\n\t\t// If the character is an open parenthesis, increment the balance\n\t\tif char == '(' {\n\t\t\tbalance++\n\t\t\tcurrent_group += string(char)\n\t\t}\n\t\t// If the character is a close parenthesis, decrement the balance\n\t\telse if char == ')' {\n\t\t\tbalance--\n\t\t\tcurrent_group += string(char)\n\t\t\t// If the balance is zero, we've found a complete group\n\t\t\tif balance == 0 {\n\t\t\t\tgroups = append(groups, current_group)\n\t\t\t\tcurrent_group = \"\"\n\t\t\t}\n\t\t}\n\t\t// If the character is not a parenthesis, ignore it\n\t}\n\n\treturn groups\n} // SeparateParenGroups"}
{"task_id": "Go/2", "generation": "\n    // The integer part of the number is the largest integer smaller than the number.\n    // We can get it by using the math.Floor function.\n    integerPart := math.Floor(number)\n    \n    // The decimal part is the difference between the number and the integer part.\n    // We can get it by subtracting the integer part from the number.\n    decimalPart := number - integerPart\n    \n    // Return the decimal part.\n    return decimalPart\n} "}
{"task_id": "Go/3", "generation": "\n\tbalance := 0\n\tfor _, operation := range operations {\n\t\tbalance += operation\n\t\tif balance < 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"task_id": "Go/4", "generation": "\n    // Calculate the mean of the dataset\n    mean := Mean(numbers)\n    \n    // Calculate the absolute difference between each number and the mean\n    deviations := make([]float64, len(numbers))\n    for i, num := range numbers {\n        deviations[i] = math.Abs(num - mean)\n    }\n    \n    // Calculate the mean of the absolute deviations\n    mad := Mean(deviations)\n    \n    return mad\n}"}
{"task_id": "Go/5", "generation": "\n    result := make([]int, 0, len(numbers)*2-1)\n    for _, num := range numbers {\n        result = append(result, num)\n        result = append(result, delimeter)\n    }\n    return result[:len(result)-1] // remove the last delimeter\n}\n"}
{"task_id": "Go/6", "generation": "\n    groups := strings.Split(paren_string, \" \")\n    result := make([]int, len(groups))\n    for i, group := range groups {\n        stack := 0\n        max_depth := 0\n        for _, c := range group {\n            if c == '(' {\n                stack++\n                if stack > max_depth {\n                    max_depth = stack\n                }\n            } else if c == ')' {\n                stack--\n            }\n        }\n        result[i] = max_depth\n    }\n    return result\n}\n\n"}
{"task_id": "Go/7", "generation": "\n    var filteredList []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}"}
{"task_id": "Go/8", "generation": "\n\tsum := 0\n\tproduct := 1\n\tfor _, number := range numbers {\n\t\tsum += number\n\t\tproduct *= number\n\t}\n\treturn [2]int{sum, product}\n}"}
{"task_id": "Go/9", "generation": "\n    result := make([]int, len(numbers))\n    max := math.MinInt\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}"}
{"task_id": "Go/10", "generation": "\n    // Find the longest palindromic suffix of the string.\n    for i := len(str) - 1; i >= 0; i-- {\n        if IsPalindrome(str[i:]) {\n            return str + Reverse(str[:i])\n        }\n    }\n    return str\n}"}
{"task_id": "Go/11", "generation": "\n    // Convert the input strings to byte slices\n    aBytes := []byte(a)\n    bBytes := []byte(b)\n\n    // Use a loop to perform the XOR operation on each pair of bytes\n    result := make([]byte, len(aBytes))\n    for i := range aBytes {\n        result[i] = aBytes[i] ^ bBytes[i]\n    }\n\n    // Convert the result byte slice back to a string\n    resultString := string(result)\n\n    // Return the result string\n    return resultString\n}\n\n"}
{"task_id": "Go/12", "generation": "\n\tif len(strings) == 0 {\n\t\treturn nil\n\t}\n\tlongest := strings[0]\n\tfor _, s := range strings {\n\t\tif len(s) > len(longest) {\n\t\t\tlongest = s\n\t\t}\n\t}\n\treturn longest\n}"}
{"task_id": "Go/13", "generation": "\n    // Use the Euclidean algorithm to find the GCD\n    for b != 0 {\n        a, b = b, a % b\n    }\n    return a\n} "}
{"task_id": "Go/14", "generation": "\n    prefixes := []string{}\n    for i := 1; i <= len(str); i++ {\n        prefixes = append(prefixes, str[:i])\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    var sb strings.Builder\n    for i := 0; i <= n; i++ {\n        sb.WriteString(strconv.Itoa(i))\n        if i != n {\n            sb.WriteByte(' ')\n        }\n    }\n    return sb.String()\n}\n\n"}
{"task_id": "Go/16", "generation": "\n    // Convert the string to lower case\n    lowerStr := strings.ToLower(str)\n    // Create a map to store the characters and their counts\n    charCount := make(map[rune]int)\n    // Iterate over the string\n    for _, char := range lowerStr {\n        // If the character is already in the map, increment its count\n        if _, ok := charCount[char]; ok {\n            charCount[char]++\n        } else {\n            // If the character is not in the map, add it with a count of 1\n            charCount[char] = 1\n        }\n    }\n    // Return the number of distinct characters\n    return len(charCount)\n} "}
{"task_id": "Go/17", "generation": "\n    // Split the string into individual notes\n    notes := strings.Split(music_string, \" \")\n    \n    // Initialize an empty list to store the beat counts\n    beat_counts := make([]int, 0)\n    \n    // Loop over each note\n    for _, note := range notes {\n        // Check the note type\n        switch note {\n        case \"o\":\n            // If it's a whole note, add 4 to the list\n            beat_counts = append(beat_counts, 4)\n        case \"o|\":\n            // If it's a half note, add 2 to the list\n            beat_counts = append(beat_counts, 2)\n        case \".|\":\n            // If it's a quarter note, add 1 to the list\n            beat_counts = append(beat_counts, 1)\n        }\n    }\n    \n    // Return the list of beat counts\n    return beat_counts\n} "}
{"task_id": "Go/18", "generation": "\n    count := 0\n    for i := 0; i < len(str); i++ {\n        if strings.Index(str[i:], substring) != -1 {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/19", "generation": "\n    // Split the string into a slice of strings\n    words := strings.Split(numbers, \" \")\n    \n    // Sort the slice of strings\n    sort.Strings(words)\n    \n    // Join the sorted slice of strings into a string\n    return strings.Join(words, \" \")\n}\n\n"}
{"task_id": "Go/20", "generation": "\n    // Sort the list of numbers\n    sort.Float64s(numbers)\n    // Find the smallest difference between two adjacent numbers\n    minDiff := numbers[1] - numbers[0]\n    // Find the pair of numbers with the smallest difference\n    for i := 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            // Store the pair of numbers with the smallest difference\n            closestPair = [2]float64{numbers[i-1], numbers[i]}\n    }\n    return closestPair\n}"}
{"task_id": "Go/21", "generation": "\n\tmin := numbers[0]\n\tmax := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < min {\n\t\t\tmin = num\n\t\t}\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\tresult := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\tresult[i] = (num - min) / (max - min)\n\t}\n\treturn result\n}"}
{"task_id": "Go/22", "generation": "\n\tvar result []int\n\tfor _, value := range values {\n\t\tif v, ok := value.(int); ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}"}
{"task_id": "Go/23", "generation": "\n    return len(str)\n}"}
{"task_id": "Go/24", "generation": "\n    for i := n - 1; i > 0; i-- {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 0\n}"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    var divisor int = 2\n    for n > 1 {\n        for n%divisor == 0 {\n            factors = append(factors, divisor)\n            n = n / divisor\n        }\n        divisor++\n    }\n    return factors\n}"}
{"task_id": "Go/26", "generation": "\n    // Create a map to store the count of each number\n    countMap := make(map[int]int)\n    // Create a new slice to store the result\n    result := make([]int, 0)\n    // Iterate over the input slice\n    for _, num := range numbers {\n        // If the number is not in the map, add it to the map and the result slice\n        if countMap[num] == 0 {\n            countMap[num] = 1\n            result = append(result, num)\n        }\n    }\n    // Return the result slice\n    return result\n}"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, char := range str {\n        if char >= 'a' && char <= 'z' {\n            result += string(char - 32)\n        } else if char >= 'A' && char <= 'Z' {\n            result += string(char + 32)\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/28", "generation": "\n\tvar result string\n\tfor _, s := range strings {\n\t\tresult += s\n\t}\n\treturn result\n}"}
{"task_id": "Go/29", "generation": "\n\tvar result []string\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n}"}
{"task_id": "Go/30", "generation": "\n    var result []int\n    for _, v := range l {\n        if v > 0 {\n            result = append(result, v)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/32", "generation": "\n    // Check if xs has even number of coefficients\n    if len(xs)%2 == 1 {\n        panic(\"xs must have even number of coefficients\")\n    }\n    // Check if largest non zero coefficient is not zero\n    if xs[len(xs)-1] == 0 {\n        panic(\"largest non zero coefficient must not be zero\")\n    }\n    // Find x such that Poly(x) = 0\n    // We use Newton's method to find the root of the polynomial\n    // We start with x = 1\n    x := 1.0\n    // We iterate until we find a root\n    for {\n        // Calculate the derivative of the polynomial at x\n        // We use the fact that the derivative of x^n is n * x^(n-1)\n        // We use the fact that the derivative of a constant is 0\n        derivative := 0.0\n        for i, coeff := range xs {\n            if i > 0 {\n                derivative += float64(i) * float64(coeff) * math.Pow(x, float64(i-1))\n            }\n        }\n        // Calculate the value of the polynomial at x\n        value := Poly(xs, x)\n        // If the value is close to 0, we have found a root\n        if math.Abs(value) < 1e-6 {\n            return x\n        }\n        // Otherwise, we use Newton's method to find a better estimate of the root\n        // We use the fact that the derivative of the polynomial at x is the limit of\n        // (f(x + h) - f(x)) / h as h approaches 0\n        // We use the fact that the derivative of the polynomial at x is the limit of\n        // (f(x + h) - f(x)) / h as h approaches 0\n        x = x - value / derivative\n    }\n}\n"}
{"task_id": "Go/33", "generation": "\n    // Create a new slice to store the result\n    result := make([]int, len(l))\n    \n    // Iterate over the input slice\n    for i, v := range l {\n        // If the index is divisible by three, sort the slice\n        if i%3 == 0 {\n            // Sort the slice\n            sort.Ints(l[i:])\n            // Copy the sorted slice to the result\n            copy(result[i:], l[i:])\n        } else {\n            // If the index is not divisible by three, just copy the value to the result\n            result[i] = v\n        }\n    }\n    \n    // Return the result\n    return result\n}"}
{"task_id": "Go/34", "generation": "\n    sort.Slice(l, func(i, j int) bool {\n        return l[i] < l[j]\n    })\n    unique := make([]int, 0)\n    for _, v := range l {\n        if len(unique) == 0 || v != unique[len(unique)-1] {\n            unique = append(unique, v)\n        }\n    }\n    return unique\n}\n\n"}
{"task_id": "Go/35", "generation": "\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}"}
{"task_id": "Go/36", "generation": "\n\tcount := 0\n\tfor i := 1; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount += strings.Count(strconv.Itoa(i), \"7\")\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/37", "generation": "\n\t// Create a copy of the input list\n\tlCopy := make([]int, len(l))\n\tcopy(lCopy, l)\n\n\t// Sort the even indicies of the copy\n\tsort.Slice(lCopy, func(i, j int) bool {\n\t\tif i%2 == 0 && j%2 == 0 {\n\t\t\treturn lCopy[i] < lCopy[j]\n\t\t}\n\t\treturn false\n\t})\n\n\t// Return the original list for odd indicies and the sorted copy for even indicies\n\treturn lCopy\n}\n\n"}
{"task_id": "Go/38", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for i := 0; i < len(runes); i++ {\n        if i%3 == 0 {\n            newRunes = append(newRunes, runes[i])\n        } else {\n            newRunes = append(newRunes, runes[i-1])\n        }\n    }\n    return string(newRunes)\n}\n\n"}
{"task_id": "Go/39", "generation": "\n\tfib := fib()\n\tfor i := 0; i < n; i++ {\n\t\tf := <-fib\n\t\tif isPrime(f) {\n\t\t\treturn f\n\t\t}\n\t}\n\tpanic(\"should not reach here\")\n}\n\nfunc fib() chan int {\n\tf := make(chan int)\n\tgo func() {\n\t\ta, b := 0, 1\n\t\tfor {\n\t\t\tf <- a\n\t\t\ta, b = b, a+b\n\t\t}\n\t}()\n\treturn f\n}\n\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/40", "generation": "\n\tsort.Ints(l)\n\tfor i := 0; i < len(l)-2; i++ {\n\t\tif i > 0 && l[i] == l[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tleft, right := i+1, len(l)-1\n\t\tfor left < right {\n\t\t\tsum := l[i] + l[left] + l[right]\n\t\t\tif sum == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif sum < 0 {\n\t\t\t\tleft++\n\t\t\t} else {\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}"}
{"task_id": "Go/41", "generation": "\n    // The number of collisions is equal to the number of pairs of cars that can\n    // meet each other.  Since the cars are moving in opposite directions, the\n    // number of pairs is equal to the number of ways to choose two cars from\n    // the total of 2n cars.\n    return n*(n+1)/2\n} // CarRaceCollision\n\n"}
{"task_id": "Go/42", "generation": "\n    for i := range l {\n        l[i]++\n    }\n    return l\n}"}
{"task_id": "Go/43", "generation": "\n\t// Create a set to store the elements we have seen so far\n\tseen := make(map[int]bool)\n\tfor _, num := range l {\n\t\t// If the negation of the current number is in the set, return true\n\t\tif seen[-num] {\n\t\t\treturn true\n\t\t}\n\t\t// Otherwise, add the current number to the set\n\t\tseen[num] = true\n\t}\n\t// If we have iterated over the entire list and haven't found a pair that sums to zero, return false\n\treturn false\n} // PairsSumToZero"}
{"task_id": "Go/44", "generation": "\n    // Convert the number to a string\n    str := strconv.Itoa(x)\n    \n    // Convert the string to the desired base\n    result := \"\"\n    for i := len(str) - 1; i >= 0; i-- {\n        digit := int(str[i] - '0')\n        result = convertDigit(digit, base) + result\n    }\n    \n    return result\n}"}
{"task_id": "Go/45", "generation": "\n\treturn 0.5 * a * h\n}"}
{"task_id": "Go/46", "generation": "\n\tif n <= 1 {\n\t\treturn 0\n\t} else if n == 2 {\n\t\treturn 2\n\t} else {\n\t\ta, b, c, d := 0, 0, 2, 0\n\t\tfor i := 3; i <= n; i++ {\n\t\t\ta, b, c, d = b, c, d, a+b+c+d\n\t\t}\n\t\treturn d\n\t}\n} // end of Fib4"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64((l[n/2-1] + l[n/2]) / 2)\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}"}
{"task_id": "Go/48", "generation": "\n\treturn text == reverse(text)\n}"}
{"task_id": "Go/49", "generation": "\n    if n == 0 {\n        return 1\n    }\n    if n < 0 {\n        return Modp(-n,p)\n    }\n    if n%2 == 0 {\n        return Modp(n/2,p)*Modp(n/2,p)%p\n    }\n    return (Modp(n-1,p)*Modp(n-1,p)%p)*Modp(2,p)%p\n}\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-'a'+26)%26+'a')\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/51", "generation": "\n    // Create a regular expression that matches any vowel (both lowercase and uppercase)\n    // and replace all matches with an empty string.\n    return regexp.MustCompile(\"[aeiouAEIOU]\").ReplaceAllString(text, \"\")\n}"}
{"task_id": "Go/52", "generation": "\n\tfor _, num := range l {\n\t\tif num >= t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/53", "generation": "\n\treturn x + y\n}"}
{"task_id": "Go/54", "generation": "\n\t// Convert the strings to slices of runes.\n\tr0 := []rune(s0)\n\tr1 := []rune(s1)\n\t// Sort the slices.\n\tsort.Slice(r0, func(i, j int) bool { return r0[i] < r0[j] })\n\tsort.Slice(r1, func(i, j int) bool { return r1[i] < r1[j] })\n\t// Compare the sorted slices.\n\treturn bytes.Equal([]byte(r0), []byte(r1))\n} // SameChars\n"}
{"task_id": "Go/55", "generation": "\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn Fib(n-1) + Fib(n-2)\n}"}
{"task_id": "Go/56", "generation": "\n    stack := make([]rune, 0)\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n} "}
{"task_id": "Go/57", "generation": "\n\tif len(l) < 2 {\n\t\treturn true\n\t}\n\tincreasing := true\n\tdecreasing := true\n\tfor i := 1; i < len(l); i++ {\n\t\tif l[i] > l[i-1] {\n\t\t\tincreasing = true\n\t\t} else {\n\t\t\tincreasing = false\n\t\t}\n\t\tif l[i] < l[i-1] {\n\t\t\tdecreasing = true\n\t\t} else {\n\t\t\tdecreasing = false\n\t\t}\n\t\tif increasing && decreasing {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"task_id": "Go/58", "generation": "\n    // Convert the lists to sets\n    set1 := make(map[int]bool)\n    set2 := make(map[int]bool)\n    for _, v := range l1 {\n        set1[v] = true\n    }\n    for _, v := range l2 {\n        set2[v] = true\n    }\n    // Find the intersection of the two sets\n    common := make(map[int]bool)\n    for k := range set1 {\n        if set2[k] {\n            common[k] = true\n        }\n    }\n    // Convert the intersection back to a list and sort it\n    var result []int\n    for k := range common {\n        result = append(result, k)\n    }\n    sort.Ints(result)\n    return result\n}\n\n"}
{"task_id": "Go/59", "generation": "\n    // Start with the smallest prime number, 2\n    i := 2\n    // While i is less than or equal to the square root of n\n    for i * i <= n {\n        // If n is divisible by i, then i is a prime factor\n        if n % i == 0 {\n            // Update n to be the quotient of n divided by i\n            n /= i\n        } else {\n            // If n is not divisible by i, increment i by 1\n            i += 1\n        }\n    }\n    // At this point, n is a prime number and is the largest prime factor of the original n\n    return n\n}"}
{"task_id": "Go/60", "generation": "\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tsum += i\n\t}\n\treturn sum\n}"}
{"task_id": "Go/61", "generation": "\n    // count the number of opening and closing brackets\n    opening := 0\n    closing := 0\n    for _, bracket := range brackets {\n        if bracket == '(' {\n            opening++\n        } else if bracket == ')' {\n            closing++\n        }\n    }\n    // if the number of opening brackets is not equal to the number of closing brackets, return false\n    return opening == closing\n}"}
{"task_id": "Go/62", "generation": "\n    if len(xs) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        result[i-1] = i * xs[i]\n    }\n    return result\n}\n"}
{"task_id": "Go/63", "generation": "\n\tif n <= 1 {\n\t\treturn 0\n\t}\n\tif n == 2 {\n\t\treturn 1\n\t}\n\ta, b, c := 0, 0, 1\n\tfor i := 3; i <= n; i++ {\n\t\ta, b, c = b, c, a+b+c\n\t}\n\treturn c\n}"}
{"task_id": "Go/64", "generation": "\n    // Convert the string to lowercase to simplify the problem\n    s = strings.ToLower(s)\n    \n    // Initialize a counter for vowels\n    count := 0\n    \n    // Iterate over each character in the string\n    for _, char := range s {\n        // Check if the character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // If it is, increment the counter\n            count++\n        }\n    }\n    \n    // Return the count of vowels\n    return count\n} "}
{"task_id": "Go/65", "generation": "\n    // Convert the integer to a string\n    str := strconv.Itoa(x)\n    // Get the length of the string\n    lenStr := len(str)\n    // Calculate the effective shift\n    effectiveShift := shift % lenStr\n    // Split the string into two parts\n    firstPart := str[lenStr-effectiveShift:]\n    secondPart := str[:lenStr-effectiveShift]\n    // Return the result\n    return firstPart + secondPart\n}"}
{"task_id": "Go/66", "generation": "\n    var sum int\n    for _, r := range x {\n        if unicode.IsUpper(r) {\n            sum += int(r)\n        }\n    }\n    return sum\n} "}
{"task_id": "Go/67", "generation": "\n\t// Split the string into two parts: the first part contains the number of apples and oranges\n\t// and the second part contains the total number of fruits in the basket\n\tparts := strings.Split(s, \" and \")\n\t// Split the first part into two parts: the first part contains the number of apples\n\t// and the second part contains the number of oranges\n\tapplesOranges := strings.Split(parts[0], \" \")\n\t// Convert the number of apples and oranges to integers\n\tapples, _ := strconv.Atoi(applesOranges[0])\n\toranges, _ := strconv.Atoi(applesOranges[1])\n\t// Return the total number of fruits in the basket minus the number of apples and oranges\n\treturn n - apples - oranges\n}"}
{"task_id": "Go/68", "generation": "\n    // Initialize the smallest even value and its index\n    smallestEvenValue := math.MaxInt32\n    smallestEvenIndex := -1\n\n    // Iterate over the array\n    for i, value := range arr {\n        // Check if the value is even\n        if value%2 == 0 {\n            // If the value is smaller than the current smallest even value, update the smallest even value and its index\n            if value < smallestEvenValue {\n                smallestEvenValue = value\n                smallestEvenIndex = i\n            }\n        }\n    }\n\n    // If the smallest even value is still the maximum integer, return an empty list\n    if smallestEvenValue == math.MaxInt32 {\n        return []int{}\n    }\n\n    // Return the smallest even value and its index\n    return []int{smallestEvenValue, smallestEvenIndex}\n}  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here.  // Pluck function ends here."}
{"task_id": "Go/69", "generation": "\n\tm := make(map[int]int)\n\tfor _, v := range lst {\n\t\tm[v]++\n\t}\n\tfor i := 1; i <= len(lst); i++ {\n\t\tif m[i] >= i {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}"}
{"task_id": "Go/70", "generation": "\n    sort.Slice(lst, func(i, j int) bool {\n        if lst[i] < lst[j] {\n            return true\n        }\n        if lst[i] > lst[j] {\n            return false\n        }\n        return i < j\n    })\n    return lst\n}\n\n"}
{"task_id": "Go/71", "generation": "\n    // Check if the three sides form a valid triangle\n    if a+b > c && a+c > b && b+c > a {\n        // Calculate the semi-perimeter\n        s := (a + b + c) / 2\n        // Calculate the area using Heron's formula\n        area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n        // Return the area rounded to 2 decimal points\n        return math.Round(area*100) / 100\n    } else {\n        // Return -1 if the three sides do not form a valid triangle\n        return -1\n    }\n} \n"}
{"task_id": "Go/72", "generation": "\n    // Check if the list is a palindrome\n    // A palindrome is a sequence that reads the same backwards as forwards\n    // We can check this by comparing the list to its reverse\n    // If they are the same, then the list is a palindrome\n    if !reflect.DeepEqual(q, reverse(q)) {\n        return false\n    }\n    \n    // Check if the sum of the elements is less than or equal to the maximum possible weight\n    // We can do this by summing up all the elements in the list\n    // If the sum is less than or equal to the maximum possible weight, then the object will fly\n    if sum(q) <= w {\n        return true\n    }\n    \n    // If the list is not a palindrome or the sum of the elements is more than the maximum possible weight, then the object will not fly\n    return false\n}"}
{"task_id": "Go/73", "generation": "\n    // Create a map to store the frequency of each element in the array\n    freq := make(map[int]int)\n    for _, num := range arr {\n        freq[num]++\n    }\n    // Initialize the count of elements that need to be changed\n    count := 0\n    // Initialize the number of elements that appear an odd number of times\n    oddCount := 0\n    // Iterate over the map\n    for _, v := range freq {\n        // If the frequency is odd, increment the odd count\n        if v%2 != 0 {\n            oddCount++\n        }\n        // If the frequency is greater than 1, increment the count by the number of elements that need to be changed\n        if v > 1 {\n            count += v - 1\n        }\n    }\n    // If there are more than one elements that appear an odd number of times, increment the count by 1\n    if oddCount > 1 {\n        count++\n    }\n    // Return the count\n    return count\n} "}
{"task_id": "Go/74", "generation": "\n    sum1 := 0\n    sum2 := 0\n    for _,v := range lst1 {\n        sum1 += len(v)\n    }\n    for _,v := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else if sum1 > sum2 {\n        return lst2\n    } else {\n        return lst1\n    }\n} "}
{"task_id": "Go/75", "generation": "\n\t// Check if the number is less than 3\n\tif a < 3 {\n\t\treturn false\n\t}\n\n\t// Check if the number is 3\n\tif a == 3 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 5\n\tif a == 5 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 7\n\tif a == 7 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 11\n\tif a == 11 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 13\n\tif a == 13 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 17\n\tif a == 17 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 19\n\tif a == 19 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 23\n\tif a == 23 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 29\n\tif a == 29 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 31\n\tif a == 31 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 37\n\tif a == 37 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 41\n\tif a == 41 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 43\n\tif a == 43 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 47\n\tif a == 47 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 53\n\tif a == 53 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 59\n\tif a == 59 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 61\n\tif a == 61 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 67\n\tif a == 67 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 71\n\tif a == 71 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 73\n\tif a == 73 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 79\n\tif a == 79 {\n\t\treturn true\n\t}\n\n\t// Check if the number is 83\n\tif a == 83 {\n\t\treturn true\n\t}\n\n\t// Check if"}
{"task_id": "Go/76", "generation": "\n    // Check if n is 0\n    if n == 0 {\n        return false\n    }\n    // Check if x is 0\n    if x == 0 {\n        return true\n    }\n    // Check if x is a power of n\n    for i := 0; i < 100; i++ {\n        if n**i == x {\n            return true\n        }\n    }\n    return false\n} \n"}
{"task_id": "Go/77", "generation": "\n    // Calculate the cube root of the number\n    cubeRoot := math.Round(math.Pow(float64(a), 1.0/3.0))\n    // Check if the cube of the cube root equals the number\n    return cubeRoot*cubeRoot*cubeRoot == a\n} \n"}
{"task_id": "Go/78", "generation": "\n\t// Define the prime hexadecimal digits\n\tprimeHex := \"2357BD\"\n\n\t// Initialize the count of prime hexadecimal digits\n\tcount := 0\n\n\t// Iterate over each character in the input string\n\tfor _, c := range num {\n\t\t// Check if the character is a prime hexadecimal digit\n\t\tif string(c) == string(primeHex) {\n\t\t\t// If it is, increment the count\n\t\t\tcount++\n\t\t}\n\t}\n\n\t// Return the count of prime hexadecimal digits\n\treturn count\n} // func HexKey(num string) int\n"}
{"task_id": "Go/79", "generation": "\n\t// Convert the decimal number to binary and remove the '0b' prefix\n\tbinary := fmt.Sprintf(\"%b\", decimal)\n\t// Add the extra characters 'db' at the beginning and at the end of the string\n\treturn \"db\" + binary + \"db\"\n}\n\n"}
{"task_id": "Go/80", "generation": "\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] && s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n} "}
{"task_id": "Go/81", "generation": "\n    var letterGrades []string\n    for _, g := range grades {\n        if g >= 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if g > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if g > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if g > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if g > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if g > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if g > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if g > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if g > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if g > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if g > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if g > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n} "}
{"task_id": "Go/82", "generation": "\n\t// Convert the string to a number\n\tnum := len(s)\n\t// Check if the number is prime\n\treturn isPrime(num)\n}"}
{"task_id": "Go/83", "generation": "\n    // The number of n-digit numbers that start with 1 is 9^(n-1) since\n    // the first digit is fixed and the rest are free.\n    start := int(math.Pow(9, float64(n-1)))\n    \n    // The number of n-digit numbers that end with 1 is 9^(n-1) since\n    // the last digit is fixed and the rest are free.\n    end := int(math.Pow(9, float64(n-1)))\n    \n    // The total count is the sum of the numbers that start and end with 1.\n    return start + end\n} "}
{"task_id": "Go/84", "generation": "\n    // Convert N to binary and remove the '0b' prefix\n    binary := strconv.FormatInt(int64(N), 2)\n    \n    // Initialize a variable to store the sum of the digits\n    sum := 0\n    \n    // Iterate over each character in the binary string\n    for _, char := range binary {\n        // Convert the character to an integer and add it to the sum\n        sum += int(char - '0')\n    }\n    \n    // Convert the sum to a binary string and remove the '0b' prefix\n    binarySum := strconv.FormatInt(int64(sum), 2)\n    \n    // Return the binary sum\n    return binarySum\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%2 == 1 && v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n} "}
{"task_id": "Go/86", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    \n    // Sort the words\n    sort.Strings(words)\n    \n    // Sort the characters in each word\n    for i := range words {\n        word := words[i]\n        sortedWord := \"\"\n        for _, r := range word {\n            sortedWord += string(r)\n        }\n        sortedWord = strings.SortString(sortedWord)\n        words[i] = sortedWord\n    }\n    \n    // Join the words back into a string\n    return strings.Join(words, \" \")\n}\n\n"}
{"task_id": "Go/87", "generation": "\n    // Initialize an empty slice to store the coordinates\n    var coordinates [][2]int\n\n    // Iterate over each row in the list\n    for i, row := range lst {\n        // Iterate over each element in the row\n        for j, element := range row {\n            // Check if the element is equal to x\n            if element == x {\n                // If it is, append the coordinates to the slice\n                coordinates = append(coordinates, [2]int{i, j})\n            }\n        }\n    }\n\n    // Sort the coordinates by row in ascending order\n    sort.Slice(coordinates, func(i, j int) bool {\n        return coordinates[i][0] < coordinates[j][0]\n    })\n\n    // Sort the coordinates of each row in descending order\n    for i := range coordinates {\n        sort.Slice(coordinates[i], func(i, j int) bool {\n            return coordinates[i][1] > coordinates[j][1]\n        })\n    }\n\n    // Return the sorted coordinates\n    return coordinates\n} "}
{"task_id": "Go/88", "generation": "\n    // Check if the array is empty\n    if len(array) == 0 {\n        return array\n    }\n\n    // Check if the array has only one element\n    if len(array) == 1 {\n        return array\n    }\n\n    // Calculate the sum of the first and last index values\n    sum := array[0] + array[len(array)-1]\n\n    // Sort the array in ascending order if the sum is odd\n    if sum%2 == 1 {\n        sort.Ints(array)\n    } else {\n        // Sort the array in descending order if the sum is even\n        sort.Slice(array, func(i, j int) bool {\n            return array[i] > array[j]\n        })\n    }\n\n    return array\n} \n"}
{"task_id": "Go/89", "generation": "\n    // Convert the string to a byte slice\n    b := []byte(s)\n    // Create a new byte slice to store the encrypted string\n    encrypted := make([]byte, len(b))\n    // Iterate over the byte slice\n    for i, c := range b {\n        // Check if the character is a letter\n        if unicode.IsLetter(c) {\n            // Get the ASCII value of the character\n            ascii := int(c)\n            // Check if the character is uppercase\n            if unicode.IsUpper(c) {\n                // Shift the character down by 4 places\n                ascii = (ascii - 65 + 4) % 26 + 65\n            } else {\n                // Shift the character down by 4 places\n                ascii = (ascii - 97 + 4) % 26 + 97\n            }\n            // Store the encrypted character in the encrypted byte slice\n            encrypted[i] = byte(ascii)\n        } else {\n            // If the character is not a letter, store it as is\n            encrypted[i] = c\n        }\n    }\n    // Convert the encrypted byte slice to a string and return it\n    return string(encrypted)\n}\n\n"}
{"task_id": "Go/90", "generation": "\n    // Check if the list is empty\n    if len(lst) == 0 {\n        return nil\n    }\n    \n    // Sort the list in ascending order\n    sort.Ints(lst)\n    \n    // Check if the list has at least two elements\n    if len(lst) < 2 {\n        return nil\n    }\n    \n    // Return the 2nd smallest element\n    return lst[1]\n}\n\n"}
{"task_id": "Go/91", "generation": "\n    // Split the string into sentences\n    sentences := regexp.MustCompile(`[.!?]`).Split(S, -1)\n    \n    // Initialize a counter for boredoms\n    boredoms := 0\n    \n    // Iterate over each sentence\n    for _, sentence := range sentences {\n        // Remove leading and trailing whitespace\n        sentence = strings.TrimSpace(sentence)\n        \n        // Check if the sentence starts with \"I\"\n        if strings.HasPrefix(sentence, \"I\") {\n            // If it does, increment the boredom counter\n            boredoms++\n        }\n    }\n    \n    // Return the number of boredoms\n    return boredoms\n}  // IsBored\n"}
{"task_id": "Go/92", "generation": "\n    // Convert the input to integers\n    xInt, yInt, zInt := int64(x), int64(y), int64(z)\n    \n    // Check if the sum of two numbers is equal to the third number\n    return (xInt+yInt == zInt) || (xInt+zInt == yInt) || (yInt+zInt == xInt)\n} "}
{"task_id": "Go/93", "generation": "\n    // Define the vowels\n    vowels := \"aeiou\"\n    \n    // Define the shifted vowels\n    shiftedVowels := \"cdefgh\"\n    \n    // Convert the message to a byte slice\n    messageBytes := []byte(message)\n    \n    // Initialize an empty byte slice to store the encoded message\n    encodedMessage := make([]byte, 0)\n    \n    // Iterate over each byte in the message\n    for _, byte := range messageBytes {\n        // Check if the byte is a vowel\n        if strings.IndexRune(vowels, rune(byte)) != -1 {\n            // If it is, find the index of the vowel in the vowels string\n            vowelIndex := strings.IndexRune(vowels, rune(byte))\n            \n            // Add the shifted vowel to the encoded message\n            encodedMessage = append(encodedMessage, shiftedVowels[vowelIndex])\n        } else {\n            // If it's not a vowel, swap the case and add it to the encoded message\n            if byte >= 'a' && byte <= 'z' {\n                encodedMessage = append(encodedMessage, byte - 32)\n            } else {\n                encodedMessage = append(encodedMessage, byte + 32)\n            }\n        }\n    }\n    \n    // Convert the encoded message back to a string and return it\n    return string(encodedMessage)\n}  // Encode() function\n\n"}
{"task_id": "Go/94", "generation": "\n    // Find the largest prime number in the list\n    maxPrime := 0\n    for _, num := range lst {\n        if isPrime(num) && num > maxPrime {\n            maxPrime = num\n        }\n    }\n    \n    // If no prime numbers were found, return 0\n    if maxPrime == 0 {\n        return 0\n    }\n    \n    // Calculate the sum of the digits of the largest prime number\n    sum := 0\n    for _, digit := range strconv.Itoa(maxPrime) {\n        sum += int(digit - '0')\n    }\n    \n    return sum\n}"}
{"task_id": "Go/95", "generation": "\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n\n    // Check if all keys are strings\n    for key := range dict {\n        if !strings.ContainsAny(string(key), \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n            return false\n        }\n    }\n\n    // Check if all keys are in lower case or all keys are in upper case\n    lowerCase := true\n    upperCase := true\n    for key := range dict {\n        if strings.ToLower(string(key)) != string(key) {\n            lowerCase = false\n        }\n        if strings.ToUpper(string(key)) != string(key) {\n            upperCase = false\n        }\n    }\n\n    return lowerCase || upperCase\n} "}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}"}
{"task_id": "Go/97", "generation": "\n    // Get the unit digit of a\n    unitDigitA := a % 10\n    // Get the unit digit of b\n    unitDigitB := b % 10\n    // Multiply the unit digits\n    product := unitDigitA * unitDigitB\n    // Return the product\n    return product\n}\n\n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for i, c := range s {\n        if i%2 == 0 && strings.ToUpper(string(c)) == string(c) {\n            if strings.Contains(\"AEIOU\", string(c)) {\n                count++\n            }\n        }\n    }\n    return count\n} \n\n"}
{"task_id": "Go/99", "generation": "\n    // Convert the string to a float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n    \n    // Round the number to the nearest integer\n    // If the number is equidistant from two integers, round away from zero\n    return int(math.Round(num + 0.5 * math.Copysign(1, num)))\n}\n\n"}
{"task_id": "Go/100", "generation": "\n    // Initialize an empty slice to store the number of stones in each level\n    pile := make([]int, n)\n    \n    // Initialize a variable to keep track of the number of stones in the current level\n    currentLevel := n\n    \n    // Loop through each level\n    for i := 0; i < n; i++ {\n        // Add the number of stones in the current level to the slice\n        pile[i] = currentLevel\n        \n        // If the current level is odd, increment the number of stones in the next level by 2\n        if currentLevel%2 == 1 {\n            currentLevel += 2\n        } \n        // If the current level is even, increment the number of stones in the next level by 1\n        else {\n            currentLevel += 1\n        }\n    }\n    \n    // Return the slice of the number of stones in each level\n    return pile\n} "}
{"task_id": "Go/101", "generation": "\n    // Split the string into words using comma and space as delimiters\n    words := strings.Split(s, \",\")\n    for i := range words {\n        words[i] = strings.TrimSpace(words[i])\n    }\n    // Split the string into words using space as delimiter\n    words = append(words, strings.Split(s, \" \")...)\n    return words\n}\n\n"}
{"task_id": "Go/102", "generation": "\n    // Check if x is greater than y\n    if x > y {\n        // If x is greater than y, return -1\n        return -1\n    }\n    // Check if y is even\n    if y % 2 == 0 {\n        // If y is even, return y\n        return y\n    }\n    // Check if x is even\n    if x % 2 == 0 {\n        // If x is even, return x\n        return x\n    }\n    // If none of the above conditions are met, return -1\n    return -1\n} "}
{"task_id": "Go/103", "generation": "\n    // Check if n is greater than m\n    if n > m {\n        return -1\n    }\n\n    // Calculate the sum of the integers from n through m\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n\n    // Calculate the average\n    avg := math.Round(float64(sum) / float64(m-n+1))\n\n    // Convert the average to binary and remove the \"0b\" prefix\n    binary := fmt.Sprintf(\"%b\", avg)\n\n    return binary\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    // Convert each number to a string to easily check for even digits\n    var result []int\n    for _, num := range x {\n        str := strconv.Itoa(num)\n        // Check if any digit in the number is even\n        even := false\n        for _, digit := range str {\n            if digit%2 == 0 {\n                even = true\n                break\n            }\n        }\n        if !even {\n            result = append(result, num)\n        }\n    }\n    // Sort the result\n    sort.Ints(result)\n    return result\n}\n"}
{"task_id": "Go/105", "generation": "\n    // Filter out numbers that are not between 1 and 9\n    filtered := make([]int, 0)\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n    \n    // Sort the filtered array\n    sort.Ints(filtered)\n    \n    // Reverse the sorted array\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n    \n    // Replace each digit by its corresponding name\n    names := make([]string, len(filtered))\n    for i, num := range filtered {\n        switch num {\n        case 1:\n            names[i] = \"One\"\n        case 2:\n            names[i] = \"Two\"\n        case 3:\n            names[i] = \"Three\"\n        case 4:\n            names[i] = \"Four\"\n        case 5:\n            names[i] = \"Five\"\n        case 6:\n            names[i] = \"Six\"\n        case 7:\n            names[i] = \"Seven\"\n        case 8:\n            names[i] = \"Eight\"\n        case 9:\n            names[i] = \"Nine\"\n        }\n    }\n    \n    return names\n} \n\n"}
{"task_id": "Go/106", "generation": "\n    // Initialize an empty list to store the results\n    result := make([]int, n)\n    // Loop through the range from 1 to n\n    for i := 1; i <= n; i++ {\n        // If i is even, the value of the element at index i is the factorial of i\n        if i%2 == 0 {\n            // Calculate the factorial of i\n            factorial := 1\n            for j := 1; j <= i; j++ {\n                factorial *= j\n            }\n            // Assign the factorial to the element at index i in the result list\n            result[i-1] = factorial\n        } else {\n            // If i is odd, the value of the element at index i is the sum of numbers from 1 to i\n            // Calculate the sum of numbers from 1 to i\n            sum := 0\n            for j := 1; j <= i; j++ {\n                sum += j\n            }\n            // Assign the sum to the element at index i in the result list\n            result[i-1] = sum\n        }\n    }\n    // Return the result list\n    return result\n} "}
{"task_id": "Go/107", "generation": "\n    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        str := strconv.Itoa(i)\n        if str == reverse(str) {\n            if i%2 == 0 {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n    return [2]int{even, odd}\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            num = -num\n        }\n        sum := 0\n        for _, digit := range strconv.Itoa(num) {\n            sum += int(digit - '0')\n        }\n        if sum > 0 {\n            count++\n        }\n        if num == 0 {\n            break\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/109", "generation": "\n    // If the array is empty, return true\n    if len(arr) == 0 {\n        return true\n    }\n    // Sort the array in ascending order\n    sort.Ints(arr)\n    // Initialize a variable to store the number of right shifts\n    rightShifts := 0\n    // Iterate over the array from the end to the start\n    for i := len(arr) - 1; i >= 0; i-- {\n        // If the current element is not equal to the previous element, increment the right shifts\n        if i > 0 && arr[i] != arr[i-1] {\n            rightShifts++\n        }\n    }\n    // If the number of right shifts is equal to the length of the array minus one, return true\n    // Otherwise, return false\n    return rightShifts == len(arr)-1\n}\n\n"}
{"task_id": "Go/110", "generation": "\n\t// Check if all elements in lst1 are even\n\tif allEven(lst1) {\n\t\treturn \"YES\"\n\t}\n\t// Check if all elements in lst2 are even\n\tif allEven(lst2) {\n\t\treturn \"YES\"\n\t}\n\t// Check if there are odd numbers in lst1 and even numbers in lst2\n\tif hasOdd(lst1) && hasEven(lst2) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}"}
{"task_id": "Go/111", "generation": "\n    // Split the string into a slice of strings\n    words := strings.Split(test, \" \")\n    \n    // Create a map to store the frequency of each word\n    frequency := make(map[rune]int)\n    \n    // Iterate over each word in the slice\n    for _, word := range words {\n        // If the word is not empty, increment its frequency in the map\n        if len(word) > 0 {\n            frequency[rune(word[0])]++\n        }\n    }\n    \n    // Find the maximum frequency\n    maxFrequency := 0\n    for _, frequency := range frequency {\n        if frequency > maxFrequency {\n            maxFrequency = frequency\n        }\n    }\n    \n    // Create a new map to store the words with the maximum frequency\n    maxFrequencyWords := make(map[rune]int)\n    \n    // Iterate over each word in the frequency map\n    for word, frequency := range frequency {\n        // If the frequency of the word is equal to the maximum frequency, add it to the new map\n        if frequency == maxFrequency {\n            maxFrequencyWords[word] = frequency\n        }\n    }\n    \n    // Return the map of words with the maximum frequency\n    return maxFrequencyWords\n} "}
{"task_id": "Go/112", "generation": "\n    // Convert the string c to a set of characters for efficient lookups\n    cSet := make(map[rune]bool)\n    for _, r := range c {\n        cSet[r] = true\n    }\n    // Initialize an empty string to store the result\n    result := \"\"\n    // Iterate over the string s\n    for _, r := range s {\n        // If the character is not in the set of characters in c, add it to the result\n        if !cSet[r] {\n            result += string(r)\n        }\n    }\n    // Check if the result string is a palindrome\n    isPalindrome := strings.EqualFold(result, strings.Reverse(result))\n    // Return the result string and the palindrome check\n    return [2]interface{}{result, isPalindrome}\n}\n\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, s := range lst {\n        count := 0\n        for _, c := range s {\n            if c%2 != 0 {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number of odd elements %dn the str%dn of the %dnput.\", count, count, count))\n    }\n    return result\n}"}
{"task_id": "Go/114", "generation": "\n    // Initialize the minimum sum to the first element of the array\n    minSum := nums[0]\n    // Initialize the current sum to the first element of the array\n    currentSum := nums[0]\n    // Iterate over the array starting from the second element\n    for i := 1; i < len(nums); i++ {\n        // Update the current sum by adding the current element\n        currentSum += nums[i]\n        // Update the minimum sum if the current sum is smaller\n        if currentSum < minSum {\n            minSum = currentSum\n        }\n        // If the current sum is greater than 0, reset it to 0\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n    // Return the minimum sum\n    return minSum\n}"}
{"task_id": "Go/115", "generation": "\n    // Initialize the total number of water units\n    totalWater := 0\n    // Iterate over each row in the grid\n    for _, row := range grid {\n        // Add the number of water units in the current row to the total\n        totalWater += len(row)\n    }\n    // Calculate the number of times the bucket needs to be lowered\n    return totalWater / capacity\n}\n\n"}
{"task_id": "Go/116", "generation": "\n    // Convert each number to binary and count the number of ones\n    ones := make([]int, len(arr))\n    for i, num := range arr {\n        binary := fmt.Sprintf(\"%b\", num)\n        ones[i] = strings.Count(binary, \"1\")\n    }\n    \n    // Sort the array based on the number of ones and the decimal value\n    sort.Slice(arr, func(i, j int) bool {\n        if ones[i] == ones[j] {\n            return arr[i] < arr[j]\n        }\n        return ones[i] < ones[j]\n    })\n    \n    return arr\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    // Initialize an empty list to store the result\n    result := make([]string, 0)\n    // Iterate over each word in the list of words\n    for _, word := range words {\n        // Count the number of consonants in the word\n        count := 0\n        for _, char := range word {\n            // Check if the character is a consonant\n            if strings.ToLower(string(char)) >= \"a\" && strings.ToLower(string(char)) <= \"z\" && strings.ToLower(string(char)) != \"a\" && strings.ToLower(string(char)) != \"e\" && strings.ToLower(string(char)) != \"i\" && strings.ToLower(string(char)) != \"o\" && strings.ToLower(string(char)) != \"u\" {\n                count++\n            }\n        }\n        // Check if the count of consonants is equal to n\n        if count == n {\n            // If it is, append the word to the result list\n            result = append(result, word)\n        }\n    }\n    // Return the result list\n    return result\n}\n\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i > 0; i-- {\n        if bytes.IndexByte(vowels, word[i]) != -1 {\n            if bytes.IndexByte(vowels, word[i-1]) == -1 && bytes.IndexByte(vowels, word[i+1]) == -1 {\n                return string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\n"}
{"task_id": "Go/119", "generation": "\n    // Check if the first string is good\n    if IsGood(lst[0]) {\n        return \"Yes\"\n    }\n    // Check if the second string is good\n    if IsGood(lst[1]) {\n        return \"Yes\"\n    }\n    // Check if the first string is a prefix of the second string\n    if strings.HasPrefix(lst[1], lst[0]) {\n        return \"Yes\"\n    }\n    // Check if the second string is a prefix of the first string\n    if strings.HasPrefix(lst[0], lst[1]) {\n        return \"Yes\"\n    }\n    return \"No\"\n}"}
{"task_id": "Go/120", "generation": "\n    // Sort the array in descending order\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    \n    // Return the first k elements of the sorted array\n    return arr[:k]\n} "}
{"task_id": "Go/121", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n} "}
{"task_id": "Go/122", "generation": "\n    sum := 0\n    for i := 0; i < k; i++ {\n        if len(strconv.Itoa(arr[i])) <= 2 {\n            sum += arr[i]\n        }\n    }\n    return sum\n} \n\n"}
{"task_id": "Go/123", "generation": "\n    // Create a map to store the collatz sequence for each number\n    collatzMap := make(map[int][]int)\n    \n    // Create a map to store the odd numbers in the collatz sequence for each number\n    oddCollatzMap := make(map[int][]int)\n    \n    // Create a queue to store the numbers to be processed\n    queue := make(chan int)\n    \n    // Create a channel to store the odd numbers in the collatz sequence\n    oddCollatzChan := make(chan int)\n    \n    // Start a goroutine to process the numbers in the queue\n    go func() {\n        for num := range queue {\n            // Get the collatz sequence for the current number\n            collatzSeq := GetCollatzSeq(num, collatzMap)\n            \n            // Get the odd numbers in the collatz sequence\n            oddCollatz := GetOddCollatzSeq(collatzSeq, oddCollatzMap)\n            \n            // Send the odd numbers to the channel\n            for _, odd := range oddCollatz {\n                oddCollatzChan <- odd\n            }\n        }\n    }()\n    \n    // Add the number to the queue\n    queue <- n\n    \n    // Close the queue\n    close(queue)\n    \n    // Create a slice to store the odd numbers\n    oddCollatz := make([]int, 0)\n    \n    // Receive the odd numbers from the channel\n    for odd := range oddCollatzChan {\n        // Add the odd number to the slice\n        oddCollatz = append(oddCollatz, odd)\n    }\n    \n    // Sort the slice\n    sort.Ints(oddCollatz)\n    \n    // Return the sorted slice\n    return oddCollatz\n}"}
{"task_id": "Go/124", "generation": "\n    // Split the date string into parts\n    parts := strings.Split(date, \"-\")\n    \n    // Check if the date string is not empty\n    if len(parts) != 3 {\n        return false\n    }\n    \n    // Convert the month and day to integers\n    month, err := strconv.Atoi(parts[0])\n    if err != nil {\n        return false\n    }\n    \n    day, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return false\n    }\n    \n    // Check if the month is valid\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    // Check if the day is valid\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n    \n    // Check if the year is valid\n    year, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return false\n    }\n    \n    // Check if the year is valid\n    if year < 1 {\n        return false\n    }\n    \n    // If all checks pass, the date is valid\n    return true\n} \n\n"}
{"task_id": "Go/125", "generation": "\n    // Split the string on whitespace\n    words := strings.Fields(txt)\n    // If no words were found, split on commas\n    if len(words) == 0 {\n        words = strings.Split(txt, \",\")\n    }\n    // If no words were found, return the number of lower-case letters with odd order in the alphabet\n    if len(words) == 0 {\n        count := 0\n        for i := 0; i < len(txt); i++ {\n            if txt[i] >= 'a' && txt[i] <= 'z' && (i%2) == 1 {\n                count++\n            }\n        }\n        return count\n    }\n    return words\n} "}
{"task_id": "Go/126", "generation": "\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        if lst[i] == lst[i+1] {\n            return false\n        }\n    }\n    return true\n} // end IsSorted"}
{"task_id": "Go/127", "generation": "\n\t// find the intersection of the two intervals\n\tstart := max(interval1[0], interval2[0])\n\tend := min(interval1[1], interval2[1])\n\n\t// if the intersection is empty, return \"NO\"\n\tif start > end {\n\t\treturn \"NO\"\n\t}\n\n\t// find the length of the intersection\n\tlength := end - start + 1\n\n\t// check if the length is a prime number\n\tif isPrime(length) {\n\t\treturn \"YES\"\n\t} else {\n\t\treturn \"NO\"\n\t}\n}"}
{"task_id": "Go/128", "generation": "\n    if len(arr) == 0 {\n        return nil\n    }\n    var prod int64 = 1\n    for _, num := range arr {\n        if num == 0 {\n            return 0\n        }\n        prod *= int64(math.Abs(float64(num)))\n    }\n    var sign int64 = 1\n    for _, num := range arr {\n        if num < 0 {\n            sign *= -1\n        }\n    }\n    return prod * sign\n} \n"}
{"task_id": "Go/129", "generation": "\n    m, n := len(grid), len(grid[0])\n    visited := make([][]bool, m)\n    for i := range visited {\n        visited[i] = make([]bool, n)\n    }\n    queue := make([][]int, 0)\n    queue = append(queue, []int{0, 0, 0})\n    visited[0][0] = true\n    ans := make([]int, 0)\n    for len(queue) > 0 {\n        path := queue[0]\n        queue = queue[1:]\n        if len(path) == k {\n            ans = path\n            break\n        }\n        for i := -1; i <= 1; i++ {\n            for j := -1; j <= 1; j++ {\n                if i == 0 && j == 0 {\n                    continue\n                }\n                x, y := path[0]+i, path[1]+j\n                if x < 0 || y < 0 || x >= m || y >= n || visited[x][y] {\n                    continue\n                }\n                visited[x][y] = true\n                queue = append(queue, []int{x, y, path[len(path)-1]})\n            }\n        }\n    }\n    return ans\n}"}
{"task_id": "Go/130", "generation": "\n\tif n == 0 {\n\t\treturn []float64{}\n\t}\n\tif n == 1 {\n\t\treturn []float64{3}\n\t}\n\tif n == 2 {\n\t\treturn []float64{3, 2}\n\t}\n\tsequence := []float64{3, 2}\n\tfor i := 3; i <= n+1; i++ {\n\t\tif i%2 == 0 {\n\t\t\tsequence = append(sequence, 1+i/2)\n\t\t} else {\n\t\t\tsequence = append(sequence, sequence[i-2]+sequence[i-3]+sequence[i-1])\n\t\t}\n\t}\n\treturn sequence\n}"}
{"task_id": "Go/131", "generation": "\n    var product int\n    for n > 0 {\n        digit := n % 10\n        if digit % 2 != 0 {\n            product *= digit\n        }\n        n /= 10\n    }\n    return product\n}\n\n"}
{"task_id": "Go/132", "generation": "\n    stack := []rune{}\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) > 0\n} // IsNested\n\n"}
{"task_id": "Go/133", "generation": "\n    var sum int\n    for _, num := range lst {\n        // Round the number to the upper int(Ceiling)\n        roundedNum := math.Ceil(num)\n        // Square the rounded number\n        square := int(math.Pow(float64(roundedNum), 2))\n        // Add the square to the sum\n        sum += square\n    }\n    return sum\n} "}
{"task_id": "Go/134", "generation": "\n    // Split the string into words\n    words := strings.Split(txt, \" \")\n    \n    // Get the last word\n    lastWord := words[len(words)-1]\n    \n    // Check if the last word is not empty\n    if len(lastWord) == 0 {\n        return false\n    }\n    \n    // Get the last character of the last word\n    lastChar := lastWord[len(lastWord)-1]\n    \n    // Check if the last character is an alphabetical character\n    if !unicode.IsLetter(lastChar) {\n        return false\n    }\n    \n    // Check if the last character is not a part of a word\n    if strings.IndexByte(txt, lastChar) != len(txt)-1 {\n        return false\n    }\n    \n    return true\n}\n\n"}
{"task_id": "Go/135", "generation": "\n    for i := 1; i < len(arr); i++ {\n        if arr[i] <= arr[i-1] {\n            return i - 1\n        }\n    }\n    return -1\n} "}
{"task_id": "Go/136", "generation": "\n    var maxNegative, minPositive interface{}\n    for _, num := range lst {\n        if num < 0 {\n            if maxNegative == nil || num > maxNegative.(int) {\n                maxNegative = num\n            }\n        } else if num > 0 {\n            if minPositive == nil || num < minPositive.(int) {\n                minPositive = num\n            }\n        }\n    }\n    return [2]interface{}{maxNegative, minPositive}\n} "}
{"task_id": "Go/137", "generation": "\n    // Convert a and b to float64\n    var aFloat, bFloat float64\n    switch a := a.(type) {\n    case int:\n        aFloat = float64(a)\n    case float64:\n        aFloat = a\n    case string:\n        aFloat, _ = strconv.ParseFloat(a, 64)\n    default:\n        return nil\n    }\n    switch b := b.(type) {\n    case int:\n        bFloat = float64(b)\n    case float64:\n        bFloat = b\n    case string:\n        bFloat, _ = strconv.ParseFloat(b, 64)\n    default:\n        return nil\n    }\n    // Compare aFloat and bFloat\n    if aFloat > bFloat {\n        return a\n    } else if aFloat < bFloat {\n        return b\n    } else {\n        return nil\n    }\n}\n\n"}
{"task_id": "Go/138", "generation": "\n\t// Check if n is even\n\tif n%2 != 0 {\n\t\treturn false\n\t}\n\n\t// Check if n can be written as the sum of exactly 4 positive even numbers\n\tfor i := 2; i < n/2; i++ {\n\t\tfor j := i + 2; j < n/2; j++ {\n\t\t\tfor k := j + 2; k < n/2; k++ {\n\t\t\t\tfor l := k + 2; l < n/2; l++ {\n\t\t\t\t\tif i+j+k+l == n {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}"}
{"task_id": "Go/139", "generation": "\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= factorial(i)\n    }\n    return result\n}"}
{"task_id": "Go/140", "generation": "\n    // Replace all spaces with underscores\n    text = strings.ReplaceAll(text, \" \", \"_\")\n    \n    // Replace all consecutive spaces with -\n    for i := 0; i < len(text)-2; i++ {\n        if text[i] == '_' && text[i+1] == '_' && text[i+2] == '_' {\n            text = text[:i] + \"-\" + text[i+3:]\n        }\n    }\n    \n    return text\n}\n\n"}
{"task_id": "Go/141", "generation": "\n    // Split the file name into two parts: the name before the dot, and the name after the dot\n    parts := strings.Split(file_name, \".\")\n    \n    // Check if the file name contains exactly one dot\n    if len(parts) != 2 {\n        return \"No\"\n    }\n    \n    // Check if the substring after the dot is one of the allowed extensions\n    if !strings.HasSuffix(parts[1], \"txt\") && !strings.HasSuffix(parts[1], \"exe\") && !strings.HasSuffix(parts[1], \"dll\") {\n        return \"No\"\n    }\n    \n    // Check if the substring before the dot starts with a latin alphapet letter\n    if !strings.HasPrefix(parts[0], \"a\") && !strings.HasPrefix(parts[0], \"A\") && !strings.HasPrefix(parts[0], \"b\") && !strings.HasPrefix(parts[0], \"B\") && !strings.HasPrefix(parts[0], \"c\") && !strings.HasPrefix(parts[0], \"C\") && !strings.HasPrefix(parts[0], \"d\") && !strings.HasPrefix(parts[0], \"D\") && !strings.HasPrefix(parts[0], \"e\") && !strings.HasPrefix(parts[0], \"E\") && !strings.HasPrefix(parts[0], \"f\") && !strings.HasPrefix(parts[0], \"F\") && !strings.HasPrefix(parts[0], \"g\") && !strings.HasPrefix(parts[0], \"G\") && !strings.HasPrefix(parts[0], \"h\") && !strings.HasPrefix(parts[0], \"H\") && !strings.HasPrefix(parts[0], \"i\") && !strings.HasPrefix(parts[0], \"I\") && !strings.HasPrefix(parts[0], \"j\") && !strings.HasPrefix(parts[0], \"J\") && !strings.HasPrefix(parts[0], \"k\") && !strings.HasPrefix(parts[0], \"K\") && !strings.HasPrefix(parts[0], \"l\") && !strings.HasPrefix(parts[0], \"L\") && !strings.HasPrefix(parts[0], \"m\") && !strings.HasPrefix(parts[0], \"M\") && !strings.HasPrefix(parts[0], \"n\") && !strings.HasPrefix(parts[0], \"N\") && !strings.HasPrefix(parts[0], \"o\") && !strings.HasPrefix(parts[0], \"O\") && !strings.HasPrefix(parts[0], \"p\") && !strings.HasPrefix(parts[0], \"P\") && !strings.HasPrefix(parts[0], \"q\") && !strings.HasPrefix(parts"}
{"task_id": "Go/142", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v * v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v * v * v\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/143", "generation": "\n    words := strings.Split(sentence, \" \")\n    var result string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word + \" \"\n        }\n    }\n    return strings.Trim(result, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/144", "generation": "\n    // Split the input strings into numerator and denominator\n    xNum, xDen := split(x)\n    nNum, nDen := split(n)\n    \n    // Multiply the numerators and denominators\n    xProdNum := xNum * nNum\n    xProdDen := xDen * nDen\n    \n    // Check if the product is a whole number\n    return xProdNum % xProdDen == 0\n}\n\nfunc split(s string) (int, int) {\n    // Split the input string into numerator and denominator\n    parts := strings.Split(s, \"/\")\n    \n    // Convert the numerator and denominator to integers\n    num, _ := strconv.Atoi(parts[0])\n    den, _ := strconv.Atoi(parts[1])\n    \n    return num, den\n} \n"}
{"task_id": "Go/145", "generation": "\n    // Create a new slice of pairs, where each pair contains a number and its index\n    pairs := make([]Pair, len(nums))\n    for i, num := range nums {\n        pairs[i] = Pair{num, i}\n    }\n\n    // Sort the pairs based on the sum of digits of the number and its index\n    sort.Slice(pairs, func(i, j int) bool {\n        sumI := sumDigits(pairs[i].num)\n        sumJ := sumDigits(pairs[j].num)\n        if sumI != sumJ {\n            return sumI < sumJ\n        }\n        return pairs[i].index < pairs[j].index\n    })\n\n    // Create a new slice with the sorted numbers\n    sortedNums := make([]int, len(pairs))\n    for i, pair := range pairs {\n        sortedNums[i] = pair.num\n    }\n\n    return sortedNums\n}"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        str := strconv.Itoa(num)\n        if num > 10 && (str[0] == \"1\" || str[0] == \"3\" || str[0] == \"5\" || str[0] == \"7\" || str[0] == \"9\") && (str[len(str)-1] == \"1\" || str[len(str)-1] == \"3\" || str[len(str)-1] == \"5\" || str[len(str)-1] == \"7\" || str[len(str)-1] == \"9\") {\n            count++\n        }\n    }\n    return count\n} \n"}
{"task_id": "Go/147", "generation": "\n    a := make([]int, n)\n    for i := 0; i < n; i++ {\n        a[i] = i * i - i + 1\n    }\n    count := 0\n    for i := 0; i < n - 2; i++ {\n        for j := i + 1; j < n - 1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n} "}
{"task_id": "Go/148", "generation": "\n\t// Define the planets in order of their proximity to the Sun\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\n\t// Check if the input planet names are valid\n\tif !contains(planets, planet1) || !contains(planets, planet2) {\n\t\treturn []string{}\n\t}\n\n\t// Find the indices of the input planet names in the planets list\n\ti1, i2 := find(planets, planet1), find(planets, planet2)\n\n\t// If the indices are equal, return an empty list\n\tif i1 == i2 {\n\t\treturn []string{}\n\t}\n\n\t// Find the planets between the two input planets\n\tvar result []string\n\tfor i := i1 + 1; i < i2; i++ {\n\t\tresult = append(result, planets[i])\n\t}\n\n\treturn result\n}"}
{"task_id": "Go/149", "generation": "\n    // First, we filter out the strings with odd lengths from the list.\n    // We use a for loop to create a new list that includes only the strings\n    // with even lengths.\n    var evenLengths []string\n    for _, str := range lst {\n        if len(str) % 2 == 0 {\n            evenLengths = append(evenLengths, str)\n        }\n    }\n    \n    // Then, we sort the list of strings with even lengths.\n    // We use the sort.Slice function to sort the list.\n    // The sort.Slice function sorts the list in-place.\n    // We use a custom sorting function that sorts the list first by the length\n    // of each string, and then by the string itself.\n    sort.Slice(evenLengths, func(i, j int) bool {\n        if len(evenLengths[i]) == len(evenLengths[j]) {\n            return evenLengths[i] < evenLengths[j]\n        }\n        return len(evenLengths[i]) < len(evenLengths[j])\n    })\n    \n    // Finally, we return the sorted list of strings with even lengths.\n    return evenLengths\n} "}
{"task_id": "Go/150", "generation": "\n    // Check if n is a prime number\n    isPrime := true\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            isPrime = false\n            break\n        }\n    }\n    // Return x if n is a prime number, otherwise return y\n    if isPrime {\n        return x\n    } else {\n        return y\n    }\n} \n"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && math.Mod(num, 2) == 1 {\n            sum += int(num * num)\n        }\n    }\n    return sum\n} \n"}
{"task_id": "Go/152", "generation": "\n    result := make([]int, len(game))\n    for i := range game {\n        result[i] = abs(game[i] - guess[i])\n    }\n    return result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}"}
{"task_id": "Go/153", "generation": "\n    // Initialize the strongest extension and its strength\n    strongest_extension := \"\"\n    strongest_strength := 0\n\n    // Iterate over each extension\n    for _, extension := range extensions {\n        // Calculate the strength of the current extension\n        cap := 0\n        sm := 0\n        for _, r := range extension {\n            if unicode.IsUpper(r) {\n                cap++\n            } else if unicode.IsLower(r) {\n                sm++\n            }\n        }\n        strength := float64(cap - sm) / math.Max(float64(cap), float64(sm))\n\n        // If the current extension is stronger than the strongest extension found so far, update the strongest extension\n        if strength > strongest_strength {\n            strongest_extension = extension\n            strongest_strength = strength\n        }\n    }\n\n    // Return the class name and the strongest extension\n    return class_name + \".\" + strongest_extension\n} "}
{"task_id": "Go/154", "generation": "\n    // Check if b is a substring of a\n    if strings.Contains(a, b) {\n        return true\n    }\n    // Check if any rotation of b is a substring of a\n    for i := 0; i < len(b); i++ {\n        // Rotate b by i positions\n        rotatedB := b[i:] + b[:i]\n        // Check if rotatedB is a substring of a\n        if strings.Contains(a, rotatedB) {\n            return true\n        }\n    }\n    // If none of the above conditions are met, return false\n    return false\n} "}
{"task_id": "Go/155", "generation": "\n    evenCount := 0\n    oddCount := 0\n    for _, digit := range strconv.Itoa(num) {\n        if digit == '0' {\n            continue\n        }\n        if digit == '2' || digit == '4' || digit == '6' || digit == '8' {\n            evenCount++\n        } else {\n            oddCount++\n        }\n    }\n    return [2]int{evenCount, oddCount}\n}\n\n"}
{"task_id": "Go/156", "generation": "\n    // Define the roman numerals and their integer values\n    romanNumerals := map[int]string{\n        1000: \"m\",\n        900:  \"cm\",\n        500:  \"d\",\n        400:  \"cd\",\n        100:  \"c\",\n        90:   \"xc\",\n        50:   \"l\",\n        40:   \"xl\",\n        10:   \"x\",\n        9:    \"ix\",\n        5:    \"v\",\n        4:    \"iv\",\n        1:    \"i\",\n    }\n\n    // Initialize the result string\n    result := \"\"\n\n    // Iterate over the roman numerals in descending order of their values\n    for value, numeral := range romanNumerals {\n        // Calculate the number of times the current numeral can fit into the number\n        count := number / value\n\n        // Subtract the value of the current numeral times the count from the number\n        number -= count * value\n\n        // Append the current numeral times the count to the result string\n        result += strings.Repeat(numeral, count)\n    }\n\n    // Return the result string in lowercase\n    return strings.ToLower(result)\n} \n"}
{"task_id": "Go/157", "generation": "\n\t// Sort the sides in ascending order\n\tsides := []int{a, b, c}\n\tsort.Ints(sides)\n\n\t// Check if the square of the longest side is equal to the sum of the squares\n\t// of the other two sides\n\treturn sides[2]*sides[2] == sides[0]*sides[0] + sides[1]*sides[1]\n}"}
{"task_id": "Go/158", "generation": "\n    // Initialize maxWord and maxUniqueChars\n    var maxWord string\n    var maxUniqueChars int\n\n    // Iterate over each word in the list\n    for _, word := range words {\n        // Count the number of unique characters in the word\n        uniqueChars := len([]rune(word))\n        uniqueChars = len(uniqueChars)\n\n        // If the word has more unique characters than maxUniqueChars, update maxWord and maxUniqueChars\n        if uniqueChars > maxUniqueChars {\n            maxWord = word\n            maxUniqueChars = uniqueChars\n        } else if uniqueChars == maxUniqueChars {\n            // If the word has the same number of unique characters as maxUniqueChars, \n            // update maxWord if the word comes first in lexicographical order\n            if word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n\n    // Return the word with maximum number of unique characters\n    return maxWord\n}"}
{"task_id": "Go/159", "generation": "\n\t// Calculate the total number of carrots eaten after meals\n\ttotalEaten := number + need\n\t// Calculate the number of carrots left after meals\n\tcarrotsLeft := remaining - need\n\t// If there are not enough remaining carrots, eat all remaining carrots\n\tif carrotsLeft < 0 {\n\t\tcarrotsLeft = 0\n\t}\n\t// Return the total number of carrots eaten and the number of carrots left\n\treturn []int{totalEaten, carrotsLeft}\n} // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends here. // Eat() function ends"}
{"task_id": "Go/160", "generation": "\n    // Initialize the result with the first operand\n    result := operand[0]\n    \n    // Iterate over the operator and operand lists\n    for i := 0; i < len(operator); i++ {\n        // Get the current operator and operand\n        currOperator := operator[i]\n        currOperand := operand[i+1]\n        \n        // Perform the operation based on the operator\n        switch currOperator {\n        case \"+\":\n            result += currOperand\n        case \"-\":\n            result -= currOperand\n        case \"*\":\n            result *= currOperand\n        case \"//\":\n            result = result / currOperand\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(currOperand)))\n        }\n    }\n    \n    // Return the final result\n    return result\n}  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here.  // DoAlgebra() function ends here."}
{"task_id": "Go/161", "generation": "\n\tvar result string\n\tfor _, r := range s {\n\t\tif unicode.IsLetter(r) {\n\t\t\tif unicode.IsLower(r) {\n\t\t\t\tresult += string(unicode.ToUpper(r))\n\t\t\t} else {\n\t\t\t\tresult += string(unicode.ToLower(r))\n\t\t\t}\n\t\t} else {\n\t\t\tresult += string(r)\n\t\t}\n\t}\n\tif !unicode.IsLetter(r) {\n\t\trunes := []rune(result)\n\t\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\t\trunes[i], runes[j] = runes[j], runes[i]\n\t\t}\n\t\tresult = string(runes)\n\t}\n\treturn result\n}\n\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hash := md5.New()\n    io.WriteString(hash, text)\n    return fmt.Sprintf(\"%x\", hash.Sum(nil))\n}\n\n"}
{"task_id": "Go/163", "generation": "\n    // Create a slice to hold the even digits\n    var evenDigits []int\n    \n    // Loop through all numbers between a and b\n    for i := a; i <= b; i++ {\n        // Convert the number to a string to easily check each digit\n        str := strconv.Itoa(i)\n        \n        // Loop through each digit in the number\n        for _, digit := range str {\n            // Convert the digit back to an integer\n            num := int(digit - '0')\n            \n            // Check if the digit is even\n            if num%2 == 0 {\n                // If the digit is even, add it to the slice\n                evenDigits = append(evenDigits, num)\n            }\n        }\n    }\n    \n    // Sort the slice in ascending order\n    sort.Ints(evenDigits)\n    \n    // Return the slice\n    return evenDigits\n} "}
