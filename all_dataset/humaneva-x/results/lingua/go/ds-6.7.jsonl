{"task_id": "Go/0", "generation": "\n    for i, x := range numbers {\n        for _, y := range numbers[i+1:] {\n            if math.Abs(x-y) <= threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/1", "generation": "\n    paren_string = strings.Replace(paren_string, \" \", \"\", -1)\n    groups := []string{}\n    current_group := \"\"\n    open_count := 0\n    for _, char := range paren_string {\n        if string(char) == \"(\" {\n            open_count += 1\n            current_group += \"(\"\n        } else if string(char) == \")\" {\n            open_count -= 1\n            current_group += \")\"\n        }\n        if open_count == 0 && current_group != \"\":\n            groups = append(groups, current_group)\n            current_group = \"\"\n        }\n    }\n    return groups\n}\n\n"}
{"task_id": "Go/2", "generation": "\n    _, decimal := math.Modf(number)\n    return decimal\n}\n"}
{"task_id": "Go/3", "generation": "\n\tbalance := 0\n\tfor _, op := range operations {\n\t\tbalance += op\n\t\tif balance < 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"}
{"task_id": "Go/4", "generation": "\n    mean := Mean(numbers)\n    return Mean(AbsoluteDeviations(numbers, mean))\n}\n"}
{"task_id": "Go/5", "generation": "\n    var result []int\n    for i, num := range numbers {\n        result = append(result, num)\n        if i < len(numbers)-1 {\n            result = append(result, delimeter)\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/6", "generation": "\n    paren_string = strings.ReplaceAll(paren_string, \" \", \"\")\n    var stack []int\n    var result []int\n    current_level := 0\n    for _, char := range paren_string {\n        if string(char) == \"(\" {\n            stack = append(stack, 1)\n            current_level++\n        } else if string(char) == \")\" {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                result = append(result, current_level)\n                current_level = 0\n            }\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/7", "generation": "\n    var result []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/8", "generation": "\n\tsum := 0\n\tproduct := 1\n\tfor _, num := range numbers {\n\t\tsum += num\n\t\tproduct *= num\n\t}\n\treturn [2]int{sum, product}\n}\n"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt64\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}\n"}
{"task_id": "Go/10", "generation": "\n    if IsPalindrome(str) {\n        return str\n    }\n    runes := []rune(str)\n    for i := len(runes); i > 0; i-- {\n        if IsPalindrome(string(runes[0:i])) {\n            prefix := runes[0:i]\n            suffix := runes[i:]\n            reversed_prefix := make([]rune, 0)\n            for j := len(prefix) - 1; j >= 0; j-- {\n                reversed_prefix = append(reversed_prefix, prefix[j])\n            }\n            return str + string(reversed_prefix)\n        }\n    }\n    return \"\"\n}\n"}
{"task_id": "Go/11", "generation": "\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] != b[i] {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/12", "generation": "\n    if len(strings) == 0 {\n        return nil\n    }\n\n    longest := strings[0]\n    for _, str := range strings {\n        if len(str) > len(longest) {\n            longest = str\n        }\n    }\n\n    return longest\n}\n\n"}
{"task_id": "Go/13", "generation": "\n    if b == 0 {\n        return a\n    }\n    return GreatestCommonDivisor(b, a%b)\n}\n"}
{"task_id": "Go/14", "generation": "\n    length := len(str)\n    prefixes := make([]string, length)\n    for i := 0; i < length; i++ {\n        prefixes[i] = str[0:i+1]\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    result := \"\"\n    for i := 0; i <= n; i++ {\n        result += strconv.Itoa(i)\n        if i < n {\n            result += \" \"\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/16", "generation": "\n    str = strings.ToLower(str)\n    m := make(map[rune]bool)\n    for _, char := range str {\n        m[char] = true\n    }\n    return len(m)\n}\n"}
{"task_id": "Go/17", "generation": "\n    var result []int\n    notes := strings.Split(music_string, \" \")\n    for _, note := range notes {\n        switch note {\n        case \"o\":\n            result = append(result, 4)\n        case \"o|\":\n            result = append(result, 2)\n        case \".|\":\n            result = append(result, 1)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/18", "generation": "\n    count := 0\n    for i := 0; i < len(str) - len(substring) + 1; i++ {\n        if str[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/19", "generation": "\n    nums := strings.Split(numbers, \" \")\n    sort.Slice(nums, func(i, j int) bool {\n        return nums[i] < nums[j]\n    })\n    return strings.Join(nums, \" \")\n}\n\n"}
{"task_id": "Go/20", "generation": "\n\tsort.Float64s(numbers)\n\tminDiff := math.MaxFloat64\n\tclosest := [2]float64{}\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif diff := numbers[i+1] - numbers[i]; diff < minDiff {\n\t\t\tminDiff = diff\n\t\t\tclosest[0] = numbers[i]\n\t\t\tclosest[1] = numbers[i+1]\n\t\t}\n\t}\n\treturn closest\n}\n"}
{"task_id": "Go/21", "generation": "\n\tmin, max := findMinAndMax(numbers)\n\tdiff := max - min\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - min) / diff\n\t}\n\treturn rescaled\n}\n"}
{"task_id": "Go/22", "generation": "\n    var result []int\n    for _, value := range values {\n        if val, ok := value.(int); ok {\n            result = append(result, val)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/23", "generation": "\n\treturn len([]rune(str))\n}\n"}
{"task_id": "Go/24", "generation": "\n\tfor i := n - 1; i > 0; i-- {\n\t\tif n%i == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"task_id": "Go/25", "generation": "\n    factors := make([]int, 0)\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        for n%i == 0 {\n            factors = append(factors, i)\n            n = n / i\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n"}
{"task_id": "Go/26", "generation": "\n\tresult := make([]int, 0)\n\tseen := make(map[int]bool)\n\n\tfor _, num := range numbers {\n\t\tif _, ok := seen[num]; !ok {\n\t\t\tseen[num] = true\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\n\treturn result\n}\n"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, c := range str {\n        if c >= 'a' && c <= 'z' {\n            result += strings.ToUpper(string(c))\n        } else if c >= 'A' && c <= 'Z' {\n            result += strings.ToLower(string(c))\n        } else {\n            result += string(c)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/28", "generation": "\n    return strings.Join(strings, \"\")\n}\n"}
{"task_id": "Go/29", "generation": "\n    var result []string\n    for _, str := range strings {\n        if strings.HasPrefix(str, prefix) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/30", "generation": "\n\tvar positive []int\n\tfor _, num := range l {\n\t\tif num > 0 {\n\t\t\tpositive = append(positive, num)\n\t\t}\n\t}\n\treturn positive\n}\n"}
{"task_id": "Go/31", "generation": "\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n <= 3 {\n\t\treturn true\n\t}\n\tif n%2 == 0 || n%3 == 0 {\n\t\treturn false\n\t}\n\ti := 5\n\tfor i*i <= n {\n\t\tif n%i == 0 || n%(i+2) == 0 {\n\t\t\treturn false\n\t\t}\n\t\ti += 6\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/32", "generation": "\n    if len(xs) == 0 {\n        return 0.0\n    }\n    if len(xs) == 1 {\n        return float64(-xs[0])\n    }\n    if len(xs) == 2 {\n        return float64(-xs[0]) / float64(xs[1])\n    }\n    if xs[0] == 0 {\n        return FindZero(xs[1:])\n    }\n    n := len(xs)\n    a := float64(xs[n-1])\n    b := float64(xs[n-2])\n    c := float64(xs[n-3])\n    d := float64(xs[n-4])\n    return (c - b*b/a) / (a*d - b*b)\n}\n"}
{"task_id": "Go/33", "generation": "\n    var divisibleByThree []int\n    for i := 0; i < len(l); i += 3 {\n        divisibleByThree = append(divisibleByThree, l[i])\n    }\n    sort.Ints(divisibleByThree)\n\n    j := 0\n    for i := 0; i < len(l); i += 3 {\n        l[i] = divisibleByThree[j]\n        j++\n    }\n    return l\n}\n"}
{"task_id": "Go/34", "generation": "\n    sort.Ints(l)\n    var result []int\n    last := -1 << 63\n    for _, v := range l {\n        if v != last {\n            result = append(result, v)\n            last = v\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/35", "generation": "\n\tmax := l[0]\n\tfor _, v := range l {\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\treturn max\n}\n"}
{"task_id": "Go/36", "generation": "\n\tcount := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tstr := strconv.Itoa(i)\n\t\t\tcount += strings.Count(str, \"7\")\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/37", "generation": "\n\teven := make([]int, 0, len(l)/2)\n\todd := make([]int, 0, len(l)/2)\n\n\tfor i := 0; i < len(l); i++ {\n\t\tif i%2 == 0 {\n\t\t\teven = append(even, l[i])\n\t\t} else {\n\t\t\todd = append(odd, l[i])\n\t\t}\n\t}\n\n\tsort.Ints(even)\n\n\tres := make([]int, 0, len(l))\n\tfor i := 0; i < len(l)/2; i++ {\n\t\tres = append(res, odd[i])\n\t\tres = append(res, even[i])\n\t}\n\n\tif len(l)%2 != 0 {\n\t\tres = append(res, odd[len(odd)-1])\n\t}\n\n\treturn res\n}\n"}
{"task_id": "Go/38", "generation": "\n    groups := make([]string, 0)\n    for i := 0; i < ((len(s) + 2) / 3); i++ {\n        groups = append(groups, s[3*i:int(math.Min(float64(3*i+3), float64(len(s))))])\n    }\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        runes := []rune(group)\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(append([]rune{runes[2]}, runes[0:2]...)))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}\n"}
{"task_id": "Go/39", "generation": "\n\tif n == 1 {\n\t\treturn 2\n\t}\n\tif n == 2 {\n\t\treturn 3\n\t}\n\tif n == 3 {\n\t\treturn 5\n\t}\n\tif n == 4 {\n\t\treturn 13\n\t}\n\tif n == 5 {\n\t\treturn 89\n\t}\n\n\tprimes := []int{2, 3, 5, 13, 89}\n\tfibs := []int{2, 3, 5, 13, 89}\n\n\tfor i := 5; i < n; i++ {\n\t\tnext := fibs[i-1] + fibs[i-2]\n\t\tfor {\n\t\t\tif isPrime(next) {\n\t\t\t\tprimes = append(primes, next)\n\t\t\t\tfibs = append(fibs, next)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext++\n\t\t}\n\t}\n\n\treturn primes[n-1]\n}\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n == 2 {\n\t\treturn true\n\t}\n\tif n%2 == 0 {\n\t\treturn false\n\t}\n\tsqrt := int(math.Sqrt(float64(n)))\n\tfor i := 3; i <= sqrt; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/40", "generation": "\n    sort.Ints(l)\n    for i := 0; i < len(l) - 2; i++ {\n        left := i + 1\n        right := len(l) - 1\n        for left < right {\n            sum := l[i] + l[left] + l[right]\n            if sum == 0 {\n                return true\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/41", "generation": "\n    return n * (n - 1) / 2\n}\n\n"}
{"task_id": "Go/42", "generation": "\n\tres := make([]int, len(l))\n\tfor i, v := range l {\n\t\tres[i] = v + 1\n\t}\n\treturn res\n}\n"}
{"task_id": "Go/43", "generation": "\n    m := make(map[int]bool)\n    for _, num := range l {\n        if _, ok := m[-num]; ok {\n            return true\n        }\n        m[num] = true\n    }\n    return false\n}\n"}
{"task_id": "Go/44", "generation": "\n    return strconv.FormatInt(int64(x), base)\n}\n"}
{"task_id": "Go/45", "generation": "\n\treturn 0.5 * a * h\n}\n"}
{"task_id": "Go/46", "generation": "\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif n == 2 {\n\t\treturn 2\n\t}\n\tif n == 3 {\n\t\treturn 0\n\t}\n\treturn Fib4(n-1) + Fib4(n-2) + Fib4(n-3) + Fib4(n-4)\n}\n\n"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64(l[n/2-1] + l[n/2]) / 2.0\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}\n"}
{"task_id": "Go/48", "generation": "\n    textRune := []rune(text)\n    length := len(textRune)\n\n    for i := 0; i < length / 2; i++ {\n        if textRune[i] != textRune[length - 1 - i] {\n            return false\n        }\n    }\n\n    return true\n}\n\n"}
{"task_id": "Go/49", "generation": "\n    if n < 0 {\n        return p - (-n % p)\n    }\n    return n % p\n}\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-5-'a'+26)%26+'a')\n    }\n    return string(newRunes)\n}\n\n"}
{"task_id": "Go/51", "generation": "\n    re := regexp.MustCompile(\"(?i)[aeiou]\")\n    return re.ReplaceAllString(text, \"\")\n}\n"}
{"task_id": "Go/52", "generation": "\n    for _, v := range l {\n        if v < t {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/53", "generation": "\n    return x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n\tcounts := make(map[rune]int)\n\tfor _, c := range s0 {\n\t\tcounts[c]++\n\t}\n\tfor _, c := range s1 {\n\t\tcounts[c]--\n\t\tif counts[c] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/55", "generation": "\n\tif n <= 1 {\n\t\treturn n\n\t}\n\n\ta, b := 0, 1\n\tfor i := 2; i <= n; i++ {\n\t\ta, b = b, a+b\n\t}\n\treturn b\n}\n"}
{"task_id": "Go/56", "generation": "\n\tstack := []rune{}\n\tbracketMap := map[rune]rune{\n\t\t')': '(',\n\t\t']': '[',\n\t\t'}': '{',\n\t\t'>': '<',\n\t}\n\n\tfor _, bracket := range brackets {\n\t\tswitch bracket {\n\t\tcase '(', '[', '{', '<':\n\t\t\tstack = append(stack, bracket)\n\t\tcase ')', ']', '}', '>':\n\t\t\tif len(stack) == 0 || bracketMap[bracket] != stack[len(stack)-1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t}\n\n\treturn len(stack) == 0\n}\n"}
{"task_id": "Go/57", "generation": "\n    if len(l) < 2:\n        return true\n\n    increasing := true\n    decreasing := true\n\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] > l[i+1] {\n            increasing = false\n        }\n        if l[i] < l[i+1] {\n            decreasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\n"}
{"task_id": "Go/58", "generation": "\n    sort.Ints(l1)\n    sort.Ints(l2)\n    var common []int\n    for i, j := 0, 0; i < len(l1) && j < len(l2); {\n        switch {\n        case l1[i] < l2[j]:\n            i++\n        case l1[i] > l2[j]:\n            j++\n        default:\n            common = append(common, l1[i])\n            i++\n            j++\n        }\n    }\n    return common\n}\n"}
{"task_id": "Go/59", "generation": "\n    largest := 2\n    for n % 2 == 0 {\n        n = n / 2\n    }\n    for i := 3; i * i <= n; i += 2 {\n        for n % i == 0 {\n            largest = i\n            n = n / i\n        }\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n}\n\n"}
{"task_id": "Go/60", "generation": "\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tsum += i\n\t}\n\treturn sum\n}\n"}
{"task_id": "Go/61", "generation": "\n    stack := []rune{}\n    for _, b := range brackets {\n        if b == '(' {\n            stack = append(stack, b)\n        } else if b == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/62", "generation": "\n\tn := len(xs)\n\tys := make([]int, n-1)\n\tfor i := 1; i < n; i++ {\n\t\tys[i-1] = xs[i] * i\n\t}\n\treturn ys\n}\n"}
{"task_id": "Go/63", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    return Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3)\n}\n\n"}
{"task_id": "Go/64", "generation": "\n    vowels := \"aeiou\"\n    count := 0\n    s = strings.ToLower(s)\n    if strings.ContainsRune(vowels, rune(s[len(s)-1])) {\n        count++\n    }\n    return count\n}\n"}
{"task_id": "Go/65", "generation": "\n    str := strconv.Itoa(x)\n    result := \"\"\n    for i := 0; i < len(str); i++ {\n        result += string(str[(i+shift)%len(str)])\n    }\n    return result\n}\n\n"}
{"task_id": "Go/66", "generation": "\n    sum := 0\n    for _, c := range x {\n        if 'A' <= c && c <= 'Z' {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n\n"}
{"task_id": "Go/67", "generation": "\n\tsplit := strings.Split(s, \" \")\n\tapples, _ := strconv.Atoi(split[0])\n\toranges, _ := strconv.Atoi(split[2])\n\treturn n - apples - oranges\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "Go/68", "generation": "\n    smallestEvenValue := math.MaxInt64\n    smallestEvenIndex := -1\n    for i, v := range arr {\n        if v < smallestEvenValue && v%2 == 0 {\n            smallestEvenValue = v\n            smallestEvenIndex = i\n        }\n    }\n    if smallestEvenIndex == -1 {\n        return []int{}\n    }\n    return []int{smallestEvenValue, smallestEvenIndex}\n}\n"}
{"task_id": "Go/69", "generation": "\n\tcounts := make(map[int]int)\n\tfor _, v := range lst {\n\t\tcounts[v]++\n\t}\n\tfor i := 1; ; i++ {\n\t\tif counts[-i] == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n}\n"}
{"task_id": "Go/70", "generation": "\n    if len(lst) == 0 {\n        return []int{}\n    }\n    sort.Ints(lst)\n    result := make([]int, len(lst))\n    for i := 0; i < len(lst)/2; i++ {\n        result[i*2] = lst[i]\n        result[i*2+1] = lst[len(lst)-i-1]\n    }\n    if len(lst)%2 != 0 {\n        result[len(lst)-1] = lst[len(lst)/2]\n    }\n    return result\n}\n"}
{"task_id": "Go/71", "generation": "\n    if a+b > c && a+c > b && b+c > a {\n        p := (a + b + c) / 2\n        area := math.Sqrt(p * (p - a) * (p - b) * (p - c))\n        return math.Round(area*100) / 100\n    } else {\n        return -1\n    }\n}\n"}
{"task_id": "Go/72", "generation": "\n\tsum := 0\n\tfor _, v := range q {\n\t\tsum += v\n\t}\n\tif sum <= w && len(q)%2 == 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n"}
{"task_id": "Go/73", "generation": "\n\tn := len(arr)\n\tchanges := 0\n\tfor i := 0; i < n/2; i++ {\n\t\tif arr[i] != arr[n-i-1] {\n\t\t\tchanges++\n\t\t}\n\t}\n\treturn changes\n}\n"}
{"task_id": "Go/74", "generation": "\n    if len(lst1) < len(lst2) {\n        return lst1\n    } else if len(lst1) > len(lst2) {\n        return lst2\n    } else {\n        return lst1\n    }\n}\n\n"}
{"task_id": "Go/75", "generation": "\n\tprimes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n\tcount := 0\n\tfor _, prime := range primes {\n\t\tif a%prime == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count == 3\n}\n"}
{"task_id": "Go/76", "generation": "\n    if x==1 {\n        return true\n    }\n    if x<1 || n<1 {\n        return false\n    }\n    for i:=2;i*i<=x;i++ {\n        if x%i==0 {\n            p:=0\n            for x%i==0 {\n                x/=i\n                p++\n            }\n            if p>n {\n                return false\n            }\n        }\n    }\n    if x>1 {\n        return false\n    }\n    return true\n}\n\n"}
{"task_id": "Go/77", "generation": "\n    root := int(math.Pow(float64(a), 1.0/3.0))\n    return root*root*root == a\n}\n"}
{"task_id": "Go/78", "generation": "\n\tprimeDigits := map[rune]bool{\n\t\t'2': true,\n\t\t'3': true,\n\t\t'5': true,\n\t\t'7': true,\n\t\t'B': true,\n\t\t'D': true,\n\t}\n\tcount := 0\n\tfor _, digit := range num {\n\t\tif primeDigits[digit] {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/79", "generation": "\n\tbinary := \"\"\n\tfor decimal > 0 {\n\t\tbinary = fmt.Sprintf(\"%d%s\", decimal%2, binary)\n\t\tdecimal = decimal / 2\n\t}\n\treturn \"db\" + binary + \"db\"\n}\n"}
{"task_id": "Go/80", "generation": "\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] && s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\n"}
{"task_id": "Go/81", "generation": "\n    var letterGrades []string\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}\n"}
{"task_id": "Go/82", "generation": "\n\tlength := len(s)\n\tif length < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= length; i++ {\n\t\tif length%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/83", "generation": "\n    if n == 1 {\n        return 1\n    }\n    return int(math.Pow10(n-1))\n}\n"}
{"task_id": "Go/84", "generation": "\n    binary := strconv.FormatInt(int64(N), 2)\n    sum := 0\n    for _, b := range binary {\n        digit, _ := strconv.Atoi(string(b))\n        sum += digit\n    }\n    return strconv.FormatInt(int64(sum), 2)\n}\n\n"}
{"task_id": "Go/85", "generation": "\n\tsum := 0\n\tfor i := 1; i < len(lst); i += 2 {\n\t\tsum += lst[i]\n\t}\n\treturn sum\n}\n"}
{"task_id": "Go/86", "generation": "\n    words := strings.Fields(s)\n    for i, word := range words {\n        chars := []rune(word)\n        sort.Slice(chars, func(i, j int) bool {\n            return chars[i] < chars[j]\n        })\n        words[i] = string(chars)\n    }\n    return strings.Join(words, \" \")\n}\n"}
{"task_id": "Go/87", "generation": "\n    var result [][2]int\n    for i, subList := range lst {\n        for j, num := range subList {\n            if num == x {\n                result = append(result, [2]int{i, j})\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][0] == result[j][0] {\n            return result[i][1] > result[j][1]\n        }\n        return result[i][0] < result[j][0]\n    })\n    return result\n}\n"}
{"task_id": "Go/88", "generation": "\n    if len(array) == 0 {\n        return []int{}\n    }\n\n    if len(array)%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(array)))\n    } else {\n        sort.Ints(array)\n    }\n\n    return array\n}\n"}
{"task_id": "Go/89", "generation": "\n    var result string\n    for _, c := range s {\n        switch {\n        case c >= 'a' && c <= 'z':\n            result += string((c-'a'+2*2)%26 + 'a')\n        case c >= 'A' && c <= 'Z':\n            result += string((c-'A'+2*2)%26 + 'A')\n        default:\n            result += string(c)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/90", "generation": "\n    if len(lst) < 2 {\n        return nil\n    }\n    sort.Ints(lst)\n    smallest := math.MaxInt64\n    second_smallest := math.MaxInt64\n    for _, v := range lst {\n        if v < smallest {\n            second_smallest = smallest\n            smallest = v\n        } else if v < second_smallest && v != smallest {\n            second_smallest = v\n        }\n    }\n    if second_smallest == math.MaxInt64 {\n        return nil\n    }\n    return second_smallest\n}\n"}
{"task_id": "Go/91", "generation": "\n    re := regexp.MustCompile(`[.|?|!]`)\n    sentences := re.Split(S, -1)\n    count := 0\n    for _, sentence := range sentences {\n        if sentence[0:1] == \"I\" {\n            count++\n        }\n    }\n    return count\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "Go/92", "generation": "\n\txInt, xOk := x.(int)\n\tyInt, yOk := y.(int)\n\tzInt, zOk := z.(int)\n\n\tif xOk && yOk && zOk {\n\t\treturn xInt+yInt == zInt\n\t}\n\n\treturn false\n}\n"}
{"task_id": "Go/93", "generation": "\n    vowels := \"aeiou\"\n    encoded := \"\"\n    for _, c := range message {\n        lc := strings.ToLower(string(c))\n        if strings.ContainsRune(vowels, rune(lc)) {\n            encoded += strings.ToUpper(string(c))\n        } else if c == ' ' {\n            encoded += \" \"\n        } else {\n            encoded += string(c)\n            encoded += string(c)\n        }\n    }\n    return encoded\n}\n"}
{"task_id": "Go/94", "generation": "\n    max := 0\n    for _, v := range lst {\n        if v > max {\n            max = v\n        }\n    }\n    return sumOfDigits(max)\n}\n\nfunc sumOfDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        digit := n % 10\n        sum += digit\n        n /= 10\n    }\n    return sum\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    sqrtN := int(math.Sqrt(float64(n)))\n    for i := 3; i <= sqrtN; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc largestPrime(lst []int) int {\n    max := 0\n    for _, v := range lst {\n        if isPrime(v) && v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n"}
{"task_id": "Go/95", "generation": "\n    if len(dict) == 0 {\n        return false\n    }\n    lower := 0\n    upper := 0\n    for key := range dict {\n        if strings.ToLower(key.(string)) == key.(string) {\n            lower += 1\n        }\n        if strings.ToUpper(key.(string)) == key.(string) {\n            upper += 1\n        }\n    }\n    return lower == len(dict) || upper == len(dict)\n}\n"}
{"task_id": "Go/96", "generation": "\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int, 0, n/2)\n    sieve := make([]bool, n)\n    for p := 2; p < n; p++ {\n        if sieve[p] {\n            continue\n        }\n        primes = append(primes, p)\n        for i := p * 2; i < n; i += p {\n            sieve[i] = true\n        }\n    }\n    return primes\n}\n"}
{"task_id": "Go/97", "generation": "\n    a = abs(a)\n    b = abs(b)\n    product := 0\n    for i := 0; i < b; i++ {\n        product += a\n    }\n    return product % 10\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for _, c := range s {\n        if strings.ContainsRune(\"AEIOU\", c) {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/99", "generation": "\n    floatValue, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n\n    if strings.Contains(value, \".\") {\n        if floatValue > 0 {\n            return int(floatValue + math.Copysign(1, floatValue))\n        } else {\n            return int(floatValue - math.Copysign(1, floatValue))\n        }\n    } else {\n        return int(floatValue)\n    }\n}\n"}
{"task_id": "Go/100", "generation": "\n\tstones := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tstones[i] = n + 2*i\n\t}\n\treturn stones\n}\n"}
{"task_id": "Go/101", "generation": "\n    words := strings.FieldsFunc(s, func(r rune) bool {\n        return r == ',' || r == ' '\n    })\n    return words\n}\n"}
{"task_id": "Go/102", "generation": "\n\tif x > y {\n\t\treturn -1\n\t}\n\treturn y - 1\n}\n"}
{"task_id": "Go/103", "generation": "\n    if n > m {\n        return -1\n    }\n    avg := math.Round(float64(n+m) / 2)\n    return fmt.Sprintf(\"0b%b\", int(avg))\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    var result []int\n    for _, num := range x {\n        if hasUniqueDigits(num) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\nfunc hasUniqueDigits(n int) bool {\n    digits := make(map[rune]bool)\n    for _, digit := range strconv.Itoa(n) {\n        if digits[digit] {\n            return false\n        }\n        digits[digit] = true\n    }\n    return true\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "Go/105", "generation": "\n    var result []string\n    var nums []int\n    var numMap = map[int]string{\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            nums = append(nums, num)\n        }\n    }\n\n    sort.Ints(nums)\n\n    for i := len(nums) - 1; i >= 0; i-- {\n        result = append(result, numMap[nums[i]])\n    }\n\n    return result\n}\n"}
{"task_id": "Go/106", "generation": "\n\tresult := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tif i%2 == 0 {\n\t\t\tresult[i] = factorial(i + 1)\n\t\t} else {\n\t\t\tresult[i] = sum(i + 1)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}\n\nfunc sum(n int) int {\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tsum += i\n\t}\n\treturn sum\n}\n"}
{"task_id": "Go/107", "generation": "\n    countEven, countOdd := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                countEven++\n            } else {\n                countOdd++\n            }\n        }\n    }\n    return [2]int{countEven, countOdd}\n}\n\nfunc isPalindrome(n int) bool {\n    str := strconv.Itoa(n)\n    for i := 0; i < len(str)/2; i++ {\n        if str[i] != str[len(str)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            str := strconv.Itoa(num)\n            for _, ch := range str {\n                if ch == '-' {\n                    continue\n                }\n                digit, _ := strconv.Atoi(string(ch))\n                if digit > 0 {\n                    count++\n                }\n            }\n        } else {\n            for num > 0 {\n                digit := num % 10\n                if digit > 0 {\n                    count++\n                }\n                num /= 10\n            }\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/109", "generation": "\n    if len(arr) == 0 {\n        return true\n    }\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n    for i := 0; i < len(arr); i++ {\n        if isNonDecreasing(arr) {\n            return true\n        }\n        arr = append(arr[len(arr)-1:], arr[:len(arr)-1]...)\n    }\n    return false\n}\n\nfunc isNonDecreasing(arr []int) bool {\n    for i := 0; i < len(arr)-1; i++ {\n        if arr[i] > arr[i+1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/110", "generation": "\n\toddCount := 0\n\tfor _, num := range lst1 {\n\t\tif num%2 != 0 {\n\t\t\toddCount++\n\t\t}\n\t}\n\tfor _, num := range lst2 {\n\t\tif num%2 != 0 {\n\t\t\toddCount--\n\t\t}\n\t}\n\tif oddCount < 0 {\n\t\treturn \"NO\"\n\t}\n\treturn \"YES\"\n}\n"}
{"task_id": "Go/111", "generation": "\n    hist := make(map[rune]int)\n    for _, letter := range strings.ToLower(test) {\n        if letter != ' ' {\n            hist[letter]++\n        }\n    }\n    return hist\n}\n"}
{"task_id": "Go/112", "generation": "\n    for strings.Contains(s,c) {\n        s = strings.Replace(s,c,\"\",-1)\n    }\n    rev := Reverse(s)\n    return [2]interface{}{rev, s == rev}\n}\n\nfunc Reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for i, str := range lst {\n        count := 0\n        for _, ch := range str {\n            if int(ch-'0') % 2 != 0 {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"number of odd elements %dn str%dng %d %dinput\", count, i+1, i+1, i+1))\n    }\n    return result\n}\n\n"}
{"task_id": "Go/114", "generation": "\n    total := 0\n    min := math.MaxInt64\n    for _, num := range nums {\n        total += num\n        if total < min {\n            min = total\n        }\n        total = int(math.Max(float64(total), float64(num)))\n    }\n    return min\n}\n"}
{"task_id": "Go/115", "generation": "\n    var total int\n    var buckets int\n    var wells []int\n    for _, row := range grid {\n        for _, well := range row {\n            if well == 1 {\n                total++\n                wells = append(wells, 1)\n            } else {\n                wells = append(wells, 0)\n            }\n        }\n    }\n    buckets = int(math.Ceil(float64(total) / float64(capacity)))\n    return buckets\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}
{"task_id": "Go/116", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        return countOnes(arr[i]) < countOnes(arr[j]) || (countOnes(arr[i]) == countOnes(arr[j]) && arr[i] < arr[j])\n    })\n    return arr\n}\n\nfunc countOnes(n int) int {\n    count := 0\n    for n != 0 {\n        n = n & (n - 1)\n        count++\n    }\n    return count\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    var words []string\n    for _, word := range strings.Fields(s) {\n        if countConsonants(word) == n {\n            words = append(words, word)\n        }\n    }\n    return words\n}\n\nfunc countConsonants(s string) int {\n    count := 0\n    for _, c := range s {\n        if bytes.ContainsRune([]byte(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"), c) {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    minDistance := len(word)\n    var result byte\n    found := false\n\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.ContainsRune(vowels, rune(word[i])) {\n            for j := i - 1; j >= 0; j-- {\n                if !bytes.ContainsRune(vowels, rune(word[j])) {\n                    if i-j < minDistance {\n                        minDistance = i - j\n                        result = word[i]\n                        found = true\n                        break\n                    }\n                }\n            }\n        }\n        if found {\n            break\n        }\n    }\n\n    if found {\n        return string(result)\n    } else {\n        return \"\"\n    }\n}\n\n//"}
{"task_id": "Go/119", "generation": "\n\tstack := []rune{}\n\tstr := lst[0] + lst[1]\n\tfor _, c := range str {\n\t\tif c == '(' {\n\t\t\tstack = append(stack, c)\n\t\t} else if c == ')' {\n\t\t\tif len(stack) == 0 || stack[len(stack)-1] != '(' {\n\t\t\t\treturn \"No\"\n\t\t\t}\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t}\n\tif len(stack) == 0 {\n\t\treturn \"Yes\"\n\t}\n\treturn \"No\"\n}\n"}
{"task_id": "Go/120", "generation": "\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    return arr[:k]\n}\n"}
{"task_id": "Go/121", "generation": "\n    sum := 0\n    for i := 0; i < len(lst); i += 2 {\n        if lst[i] % 2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/122", "generation": "\n    // sort array\n    arr = sortArray(arr)\n\n    // sum first k elements\n    sum := 0\n    for i := 0; i < k; i++ {\n        sum += arr[i]\n    }\n\n    return sum\n}\n\nfunc sortArray(arr []int) []int {\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if arr[i] > arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    return arr\n}\n\n"}
{"task_id": "Go/123", "generation": "\n    var collatz []int\n    for n != 1 {\n        if n%2 != 0 {\n            collatz = append(collatz, n)\n        }\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n    collatz = append(collatz, 1)\n\n    sort.Ints(collatz)\n    return collatz\n}\n"}
{"task_id": "Go/124", "generation": "\n    if date == \"\" {\n        return false\n    }\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n    month, err1 := strconv.Atoi(parts[0])\n    day, err2 := strconv.Atoi(parts[1])\n    year, err3 := strconv.Atoi(parts[2])\n    if err1 != nil || err2 != nil || err3 != nil {\n        return false\n    }\n    if month < 1 || month > 12 {\n        return false\n    }\n    if day < 1 || day > 31 {\n        return false\n    }\n    if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n            return false\n        }\n    } else if month == 2 {\n        if day > 29 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/125", "generation": "\n    if strings.Contains(txt, \" \") {\n        return strings.Split(txt, \" \")\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        count := make([]int, 26)\n        for _, c := range txt {\n            if 'a' <= c && c <= 'z' {\n                count[c-'a']++\n            }\n        }\n        return count\n    }\n}\n"}
{"task_id": "Go/126", "generation": "\n    if len(lst) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            increasing = false\n        }\n        if lst[i] < lst[i+1] {\n            decreasing = false\n        }\n        if !increasing && !decreasing {\n            return false\n        }\n    }\n    return true\n}\n\n"}
{"task_id": "Go/127", "generation": "\n\tstart := max(interval1[0], interval2[0])\n\tend := min(interval1[1], interval2[1])\n\tlength := end - start + 1\n\tif length < 2 {\n\t\treturn \"NO\"\n\t}\n\tfor i := 2; i*i <= length; i++ {\n\t\tif length%i == 0 {\n\t\t\treturn \"NO\"\n\t\t}\n\t}\n\treturn \"YES\"\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"}
{"task_id": "Go/128", "generation": "\n    if len(arr) == 0 {\n        return nil\n    }\n    prod := 1\n    sum := 0\n    for _, num := range arr {\n        if num < 0 {\n            prod *= -1\n        } else if num > 0 {\n            prod *= 1\n            sum += int(math.Abs(float64(num)))\n        }\n    }\n    return prod * sum\n}\n"}
{"task_id": "Go/129", "generation": "\n\tn := len(grid)\n\tvisited := make([][]bool, n)\n\tfor i := range visited {\n\t\tvisited[i] = make([]bool, n)\n\t}\n\tminPath := make([]int, k)\n\tfor i := range minPath {\n\t\tminPath[i] = math.MaxInt32\n\t}\n\tvar dfs func(int, int, int, []int)\n\tdfs = func(x, y, k int, path []int) {\n\t\tif k >= len(minPath) {\n\t\t\treturn\n\t\t}\n\t\tpath[k] = grid[x][y]\n\t\tif k+1 >= len(minPath) {\n\t\t\tminPath = append([]int(nil), path...)\n\t\t\treturn\n\t\t}\n\t\tvisited[x][y] = true\n\t\tdirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\t\tsortGrid(grid, x, y, dirs)\n\t\tfor _, dir := range dirs {\n\t\t\tnx, ny := x+dir[0], y+dir[1]\n\t\t\tif nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] {\n\t\t\t\tdfs(nx, ny, k+1, path)\n\t\t\t}\n\t\t}\n\t\tvisited[x][y] = false\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tdfs(i, j, 0, make([]int, k))\n\t\t}\n\t}\n\treturn minPath\n}\n\nfunc sortGrid(grid [][]int, x, y int, dirs [][]int) {\n\ttype pair struct {\n\t\tval int\n\t\tdir []int\n\t}\n\tn := len(grid)\n\tpairs := make([]pair, 0, len(dirs))\n\tfor _, dir := range dirs {\n\t\tnx, ny := x+dir[0], y+dir[1"}
{"task_id": "Go/130", "generation": "\n    var result = make([]float64, n + 1)\n    result[0] = 3\n    if n > 0 {\n        result[1] = 2\n    }\n    if n > 1 {\n        result[2] = 8\n    }\n    for i := 3; i <= n; i++ {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3]\n    }\n    return result\n}\n"}
{"task_id": "Go/131", "generation": "\n    str := strconv.Itoa(n)\n    product := 1\n    for _, c := range str {\n        digit, _ := strconv.Atoi(string(c))\n        if digit % 2 != 0 {\n            product *= digit\n        }\n    }\n    if product == 1 {\n        return 0\n    }\n    return product\n}\n\n"}
{"task_id": "Go/132", "generation": "\n\tstack := []rune{}\n\tfor _, c := range s {\n\t\tif c == '[' {\n\t\t\tstack = append(stack, c)\n\t\t} else if c == ']' {\n\t\t\tif len(stack) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t}\n\treturn len(stack) != 0\n}\n"}
{"task_id": "Go/133", "generation": "\n    sum := 0.0\n    for _, num := range lst {\n        sum += math.Pow(math.Ceil(num), 2)\n    }\n    return int(sum)\n}\n"}
{"task_id": "Go/134", "generation": "\n    if len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n    return strings.ContainsRune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", lastChar)\n}\n"}
{"task_id": "Go/135", "generation": "\n\tsort.Ints(arr)\n\tfor i := len(arr) - 1; i > 0; i-- {\n\t\tif arr[i] < 2*arr[i-1] {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"task_id": "Go/136", "generation": "\n    var largest, smallest *int = nil, nil\n    for _, v := range lst {\n        if v > 0 {\n            if largest == nil || v > *largest {\n                largest = &v\n            }\n            if smallest == nil || v < *smallest {\n                smallest = &v\n            }\n        }\n    }\n    return [2]interface{}{largest, smallest}\n}\n\n"}
{"task_id": "Go/137", "generation": "\n    var a_str, b_str string\n    switch a.(type) {\n    case int:\n        a_str = strconv.Itoa(a.(int))\n    case float64:\n        a_str = strconv.FormatFloat(a.(float64), 'f', -1, 64)\n    case string:\n        a_str = a.(string)\n    }\n\n    switch b.(type) {\n    case int:\n        b_str = strconv.Itoa(b.(int))\n    case float64:\n        b_str = strconv.FormatFloat(b.(float64), 'f', -1, 64)\n    case string:\n        b_str = b.(string)\n    }\n\n    a_str = strings.Replace(a_str, \",\", \".\", -1)\n    b_str = strings.Replace(b_str, \",\", \".\", -1)\n\n    a_float, _ := strconv.ParseFloat(a_str, 64)\n    b_float, _ := strconv.ParseFloat(b_str, 64)\n\n    if a_float > b_float {\n        return a\n    } else if b_float > a_float {\n        return b\n    } else {\n        return nil\n    }\n}\n\n"}
{"task_id": "Go/138", "generation": "\n\tsum := 0\n\tfor i := 2; i <= n; i += 2 {\n\t\tsum += i\n\t}\n\treturn sum == n\n}\n"}
{"task_id": "Go/139", "generation": "\n\tresult := 1\n\tfor i := n; i > 0; i-- {\n\t\tresult *= Factorial(i)\n\t}\n\treturn result\n}\n"}
{"task_id": "Go/140", "generation": "\n\tre := regexp.MustCompile(`\\s+`)\n\ttext = re.ReplaceAllString(text, \"_\")\n\tre = regexp.MustCompile(`_+`)\n\ttext = re.ReplaceAllString(text, \"-\")\n\treturn text\n}\n"}
{"task_id": "Go/141", "generation": "\n    if strings.Count(file_name, \".\") > 1 {\n        return \"No\"\n    }\n    parts := strings.Split(file_name, \".\")\n    if len(parts) != 2 {\n        return \"No\"\n    }\n    if len(parts[0]) == 0 {\n        return \"No\"\n    }\n    if len(parts[1]) > 3 || len(parts[1]) == 0 {\n        return \"No\"\n    }\n    if !((parts[1] == \"txt\") || (parts[1] == \"exe\") || (parts[1] == \"dll\")) {\n        return \"No\"\n    }\n    if !(strings.ContainsAny(parts[0], \"0123456789\")) {\n        return \"Yes\"\n    }\n    if !(strings.HasPrefix(parts[0], \"a\") || strings.HasPrefix(parts[0], \"A\")) {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n"}
{"task_id": "Go/142", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i % 3 == 0 {\n            sum += int(math.Pow(float64(v), 2))\n        } else if i % 4 == 0 {\n            sum += int(math.Pow(float64(v), 3))\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/143", "generation": "\n    words := strings.Fields(sentence)\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    var result []string\n    for _, word := range words {\n        if contains(primes, len(word)) {\n            result = append(result, word)\n        }\n    }\n    return strings.Join(result, \" \")\n}\n\nfunc contains(arr []int, str int) bool {\n    for _, a := range arr {\n        if a == str {\n            return true\n        }\n    }\n    return false\n}\n\n//"}
{"task_id": "Go/144", "generation": "\n    xn := strings.Split(x, \"/\")\n    xNum, _ := strconv.Atoi(xn[0])\n    xDen, _ := strconv.Atoi(xn[1])\n\n    nn := strings.Split(n, \"/\")\n    nNum, _ := strconv.Atoi(nn[0])\n    nDen, _ := strconv.Atoi(nn[1])\n\n    if xDen == 0 || nDen == 0 {\n        return false\n    }\n\n    xNum = xNum * nDen\n    nNum = nNum * xDen\n\n    if xNum % nNum == 0 {\n        return true\n    }\n\n    return false\n}\n"}
{"task_id": "Go/145", "generation": "\n    type pair struct {\n        num, points int\n    }\n\n    var arr []pair\n    for i, num := range nums {\n        points := sumDigits(num)\n        arr = append(arr, pair{num, points})\n    }\n\n    sort.Slice(arr, func(i, j int) bool {\n        if arr[i].points == arr[j].points {\n            return nums[i] < nums[j]\n        }\n        return arr[i].points < arr[j].points\n    })\n\n    for i := range arr {\n        nums[i] = arr[i].num\n    }\n\n    return nums\n}\n\nfunc sumDigits(num int) int {\n    sum := 0\n    for num != 0 {\n        digit := num % 10\n        sum += digit\n        num /= 10\n    }\n    return sum\n}\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        if num > 10 {\n            strNum := strconv.Itoa(num)\n            firstDigit := strNum[0:1]\n            lastDigit := strNum[len(strNum)-1:]\n            if firstDigit == \"-\" {\n                firstDigit = strNum[1:2]\n            }\n            if lastDigit == \"-\" {\n                lastDigit = strNum[len(strNum)-2 : len(strNum)-1]\n            }\n            if isOdd(firstDigit) && isOdd(lastDigit) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nfunc isOdd(s string) bool {\n    num, _ := strconv.Atoi(s)\n    return num%2 != 0\n}\n"}
{"task_id": "Go/147", "generation": "\n\tarr := make([]int, n)\n\tfor i := 1; i <= n; i++ {\n\t\tarr[i-1] = (i * i) - i + 1\n\t}\n\tcount := 0\n\tfor i := 0; i < n-2; i++ {\n\t\tfor j := i + 1; j < n-1; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tif (arr[i]+arr[j]+arr[k])%3 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/148", "generation": "\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tplanetMap := make(map[string]int)\n\tfor i, v := range planets {\n\t\tplanetMap[v] = i + 1\n\t}\n\tstart, end := planetMap[planet1], planetMap[planet2]\n\tif start == 0 || end == 0 {\n\t\treturn []string{}\n\t}\n\tif start > end {\n\t\tstart, end = end, start\n\t}\n\treturn planets[start-1 : end-1]\n}\n\n"}
{"task_id": "Go/149", "generation": "\n    var result []string\n    lengthMap := make(map[int][]string)\n\n    for _, word := range lst {\n        lengthMap[len(word)] = append(lengthMap[len(word)], word)\n    }\n\n    for length, words := range lengthMap {\n        if length%2 == 0 {\n            sort.Strings(words)\n            result = append(result, words...)\n        }\n    }\n\n    return result\n}\n"}
{"task_id": "Go/150", "generation": "\n\tif isPrime(n) {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/151", "generation": "\n    sum := 0.0\n    for _, num := range lst {\n        if num > 0 && math.Mod(num, 2) != 0 {\n            sum += math.Pow(num, 2)\n        }\n    }\n    return int(sum) * 2\n}\n"}
{"task_id": "Go/152", "generation": "\n    result := make([]int, len(game))\n    for i := range game {\n        result[i] = int(math.Abs(float64(game[i] - guess[i])))\n    }\n    return result\n}\n"}
{"task_id": "Go/153", "generation": "\n    max_strength := math.MinInt64\n    strongest_extension := \"\"\n    for _, extension := range extensions {\n        strength := 0\n        for _, char := range extension {\n            if 'A' <= char && char <= 'Z' {\n                strength++\n            } else if 'a' <= char && char <= 'z' {\n                strength--\n            }\n        }\n        if strength > max_strength {\n            max_strength = strength\n            strongest_extension = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n"}
{"task_id": "Go/154", "generation": "\n    if len(b) > len(a) {\n        return false\n    }\n    for i := 0; i < len(a); i++ {\n        if a[i:len(b)+i] == b || a[i:len(b)+i] == Reverse(b) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc Reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\n"}
{"task_id": "Go/155", "generation": "\n    var even, odd int\n    str := strconv.Itoa(num)\n    for _, v := range str {\n        n, _ := strconv.Atoi(string(v))\n        if n%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n    }\n    return [2]int{even, odd}\n}\n"}
{"task_id": "Go/156", "generation": "\n    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    symbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    roman := \"\"\n    for i := 0; i < len(values); i++ {\n        for number >= values[i] {\n            number -= values[i]\n            roman += symbols[i]\n        }\n    }\n    return strings.ToLower(roman)\n}\n"}
{"task_id": "Go/157", "generation": "\n\tif a*a+b*b == c*c || a*a+c*c == b*b || b*b+c*c == a*a {\n\t\treturn true\n\t}\n\treturn false\n}\n"}
{"task_id": "Go/158", "generation": "\n    sort.Slice(words, func(i, j int) bool {\n        return words[i] > words[j]\n    })\n    maxUnique := 0\n    maxWord := \"\"\n    for _, word := range words {\n        unique := countUnique(word)\n        if unique > maxUnique {\n            maxUnique = unique\n            maxWord = word\n        }\n    }\n    return maxWord\n}\n\nfunc countUnique(word string) int {\n    unique := make(map[rune]struct{})\n    for _, char := range word {\n        unique[char] = struct{}{}\n    }\n    return len(unique)\n}\n\n//"}
{"task_id": "Go/159", "generation": "\n    if number > need {\n        return []int{number, remaining}\n    }\n    if number + remaining >= need {\n        return []int{need, (number + remaining) - need}\n    }\n    return []int{number + remaining, 0}\n}\n"}
{"task_id": "Go/160", "generation": "\n    result := operand[0]\n    for i := 1; i < len(operand); i++ {\n        switch operator[i-1] {\n        case \"+\":\n            result += operand[i]\n        case \"-\":\n            result -= operand[i]\n        case \"*\":\n            result *= operand[i]\n        case \"/\":\n            result /= operand[i]\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(operand[i])))\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/161", "generation": "\n\trunes := []rune(s)\n\tfor i := 0; i < len(runes); i++ {\n\t\tif unicode.IsLetter(runes[i]) {\n\t\t\tif unicode.IsLower(runes[i]) {\n\t\t\t\trunes[i] = unicode.ToUpper(runes[i])\n\t\t\t} else {\n\t\t\t\trunes[i] = unicode.ToLower(runes[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn string(runes)\n}\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hasher := md5.New()\n    hasher.Write([]byte(text))\n    return fmt.Sprintf(\"%x\", hasher.Sum(nil))\n}\n"}
{"task_id": "Go/163", "generation": "\n\tvar result []int\n\n\tif a > b {\n\t\ta, b = b, a\n\t}\n\n\tfor i := a; i <= b; i++ {\n\t\tif i%2 == 0 {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\n\treturn result\n}\n"}
