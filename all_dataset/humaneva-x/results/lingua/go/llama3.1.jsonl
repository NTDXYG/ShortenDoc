{"task_id": "Go/0", "generation": "\n    for i := 1; i < len(numbers); i++ {\n        if math.Abs(numbers[i] - numbers[i-1]) <= threshold {\n            return true\n        }\n    }\n    return false\n} \n\n"}
{"task_id": "Go/1", "generation": "\n    // Remove spaces from input string\n    paren_string = strings.ReplaceAll(paren_string, \" \", \"\")\n\n    // Initialize empty list to store groups\n    groups := make([]string, 0)\n\n    // Initialize empty string to build current group\n    current_group := \"\"\n\n    // Initialize counter to track nesting level\n    nesting_level := 0\n\n    // Iterate over each character in input string\n    for _, char := range paren_string {\n        // If character is an open parenthesis, increment nesting level\n        if char == '(' {\n            nesting_level++\n            current_group += string(char)\n        }\n        // If character is a close parenthesis, decrement nesting level\n        else if char == ')' {\n            nesting_level--\n            current_group += string(char)\n            // If nesting level is 0, it means we've found a complete group\n            if nesting_level == 0 {\n                groups = append(groups, current_group)\n                current_group = \"\"\n            }\n        }\n        // If character is not a parenthesis, ignore it\n    }\n\n    // Return list of groups\n    return groups\n}\n"}
{"task_id": "Go/2", "generation": "\n    // integer part\n    integerPart := math.Floor(number)\n    // decimal part\n    decimalPart := number - integerPart\n    return decimalPart\n}\n"}
{"task_id": "Go/3", "generation": "\n    balance := 0\n    for _, operation := range operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/4", "generation": "\n    // calculate mean\n    mean := Mean(numbers)\n    // calculate absolute deviation\n    deviations := make([]float64, len(numbers))\n    for i, num := range numbers {\n        deviations[i] = math.Abs(num - mean)\n    }\n    // calculate mean of deviations\n    mad := Mean(deviations)\n    return mad\n}\n"}
{"task_id": "Go/5", "generation": "\n    var result []int\n    for _, num := range numbers {\n        result = append(result, num)\n        result = append(result, delimeter)\n    }\n    return result[:len(result)-1]\n}\n"}
{"task_id": "Go/6", "generation": "\n    // Split the string into groups\n    groups := strings.Split(paren_string, \" \")\n\n    // Initialize the result array\n    result := make([]int, 0, len(groups))\n\n    // Iterate over each group\n    for _, group := range groups {\n        // Initialize the current level and max level\n        current_level := 0\n        max_level := 0\n\n        // Iterate over each character in the group\n        for _, char := range group {\n            // If the character is an opening parenthesis, increment the current level\n            if char == '(' {\n                current_level++\n                // Update the max level if necessary\n                if current_level > max_level {\n                    max_level = current_level\n                }\n            }\n            // If the character is a closing parenthesis, decrement the current level\n            else if char == ')' {\n                current_level--\n            }\n        }\n\n        // Append the max level to the result array\n        result = append(result, max_level)\n    }\n\n    return result\n}\n\n"}
{"task_id": "Go/7", "generation": "\n    var filteredList []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}\n"}
{"task_id": "Go/8", "generation": "\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return [2]int{sum, product}\n}\n"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}\n\n"}
{"task_id": "Go/10", "generation": "\n    // Find longest postfix supplied string palindrome\n    for i := 1; i <= len(str); i++ {\n        postfix := str[len(str)-i:]\n        if IsPalindrome(postfix) {\n            break\n        }\n    }\n    // Append end string reverse prefix before palindromic suffix\n    prefix := str[:len(str)-i]\n    return prefix + strings.Reverse(prefix) + postfix\n}\n"}
{"task_id": "Go/11", "generation": "\n    // Convert strings to byte slices\n    aBytes := []byte(a)\n    bBytes := []byte(b)\n\n    // Perform XOR on byte slices\n    result := make([]byte, len(aBytes))\n    for i := range aBytes {\n        result[i] = aBytes[i] ^ bBytes[i]\n    }\n\n    // Convert result byte slice to string\n    resultString := string(result)\n\n    return resultString\n}\n\n"}
{"task_id": "Go/12", "generation": "\n    if len(strings) == 0 {\n        return nil\n    }\n    max := strings[0]\n    for _, s := range strings {\n        if len(s) > len(max) {\n            max = s\n        }\n    }\n    return max\n} \n"}
{"task_id": "Go/13", "generation": "\n    // Loop until b is 0\n    for b != 0 {\n        // Swap a and b\n        a, b = b, a % b\n    }\n    // Return a\n    return a\n} \n"}
{"task_id": "Go/14", "generation": "\n    var prefixes []string\n    for i := 0; i < len(str); i++ {\n        prefixes = append(prefixes, str[:i+1])\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    var sb strings.Builder\n    for i := 0; i <= n; i++ {\n        sb.WriteString(strconv.Itoa(i))\n        if i != n {\n            sb.WriteByte(' ')\n        }\n    }\n    return sb.String()\n}\n\n"}
{"task_id": "Go/16", "generation": "\n    // Convert to lower case\n    str = strings.ToLower(str)\n    // Create a map to store characters and their counts\n    charCount := make(map[rune]int)\n    // Iterate over the string\n    for _, char := range str {\n        // If the character is not in the map, add it\n        if _, ok := charCount[char]; !ok {\n            charCount[char] = 1\n        } else {\n            // If the character is already in the map, increment its count\n            charCount[char]++\n        }\n    }\n    // Return the number of distinct characters\n    return len(charCount)\n}  // CountDistinctCharacters\n"}
{"task_id": "Go/17", "generation": "\n    var result []int\n    var current_note string\n    for _, char := range music_string {\n        if char == ' ' {\n            if current_note == \"o\" {\n                result = append(result, 4)\n            } else if current_note == \"o|\" {\n                result = append(result, 2)\n            } else if current_note == \".|\" {\n                result = append(result, 1)\n            }\n            current_note = \"\"\n        } else {\n            current_note += string(char)\n        }\n    }\n    if current_note == \"o\" {\n        result = append(result, 4)\n    } else if current_note == \"o|\" {\n        result = append(result, 2)\n    } else if current_note == \".|\" {\n        result = append(result, 1)\n    }\n    return result\n} // end of ParseMusic\n"}
{"task_id": "Go/18", "generation": "\n    count := 0\n    for i := 0; i < len(str); i++ {\n        if strings.Index(str[i:], substring) != -1 {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/19", "generation": "\n    // Split the string into a slice of strings\n    numbersSlice := strings.Split(numbers, \" \")\n    // Sort the slice of strings\n    sort.Strings(numbersSlice)\n    // Join the sorted slice of strings into a string\n    sortedNumbers := strings.Join(numbersSlice, \" \")\n    return sortedNumbers\n}\n\n"}
{"task_id": "Go/20", "generation": "\n    // sort the list\n    sort.Float64s(numbers)\n    // find the first and last element\n    first := numbers[0]\n    last := numbers[len(numbers)-1]\n    // find the closest elements\n    smaller := findClosestElement(numbers, first)\n    larger := findClosestElement(numbers, last)\n    // return the two closest elements\n    return [2]float64{smaller, larger}\n}\n\nfunc findClosestElement(numbers []float64, target float64) float64 {\n    // find the closest element\n    closest := numbers[0]\n    for _, num := range numbers {\n        if math.Abs(num-target) < math.Abs(closest-target) {\n            closest = num\n        }\n    }\n    return closest\n}\n\n"}
{"task_id": "Go/21", "generation": "\n    min := math.MinFloat64\n    max := math.MaxFloat64\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n    if max == min {\n        return numbers\n    }\n    rescaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        rescaled[i] = (num - min) / (max - min)\n    }\n    return rescaled\n}\n"}
{"task_id": "Go/22", "generation": "\n    var result []int\n    for _, value := range values {\n        if v, ok := value.(int); ok {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/23", "generation": "\n    // Return the length of the string\n    return len(str)\n}\n"}
{"task_id": "Go/24", "generation": "\n    for i := n - 1; i > 0; i-- {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 0\n}\n"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    var divisor int = 2\n    for n > 1 {\n        for n%divisor == 0 {\n            factors = append(factors, divisor)\n            n = n / divisor\n        }\n        divisor = divisor + 1\n    }\n    return factors\n}\n"}
{"task_id": "Go/26", "generation": "\n    var result []int\n    for _, num := range numbers {\n        if !contains(result, num) {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, char := range str {\n        if strings.ToLower(string(char)) == string(char) {\n            result += strings.ToUpper(string(char))\n        } else {\n            result += strings.ToLower(string(char))\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/28", "generation": "\n    var result string\n    for _, s := range strings {\n        result += s\n    }\n    return result\n}\n"}
{"task_id": "Go/29", "generation": "\n    var result []string\n    for _,s := range strings {\n        if strings.HasPrefix(s,prefix) {\n            result = append(result,s)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/30", "generation": "\n    var positive []int\n    for _, v := range l {\n        if v > 0 {\n            positive = append(positive, v)\n        }\n    }\n    return positive\n}\n"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/32", "generation": "\n    // find the largest non-zero coefficient\n    maxNonZero := 0\n    for i, coeff := range xs {\n        if coeff != 0 {\n            if math.Abs(float64(coeff)) > math.Abs(float64(maxNonZero)) {\n                maxNonZero = coeff\n            }\n        }\n    }\n    // find the root of the polynomial\n    // we can use the fact that the largest non-zero coefficient is the leading coefficient\n    // and the root is the negative of the constant term divided by the leading coefficient\n    root := -float64(xs[0]) / float64(maxNonZero)\n    return root\n}\n"}
{"task_id": "Go/33", "generation": "\n    // sort the list\n    sort.Ints(l)\n    // create a new list\n    l2 := make([]int, len(l))\n    // copy the list\n    copy(l2, l)\n    // iterate over the list\n    for i := 0; i < len(l); i++ {\n        // if the index is divisible by 3\n        if i%3 == 0 {\n            // replace the value at the index with the value at the same index in the sorted list\n            l2[i] = l[len(l)-i/3-1]\n        }\n    }\n    // return the new list\n    return l2\n} \n\n"}
{"task_id": "Go/34", "generation": "\n    var result []int\n    for _, v := range l {\n        if !contains(result, v) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n\n"}
{"task_id": "Go/35", "generation": "\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n"}
{"task_id": "Go/36", "generation": "\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif strings.Contains(strconv.Itoa(i), \"7\") && (i%11 == 0 || i%13 == 0) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n} "}
{"task_id": "Go/37", "generation": "\n\tsort.Slice(l, func(i, j int) bool {\n\t\tif i%2 == 0 && j%2 == 0 {\n\t\t\treturn l[i] < l[j]\n\t\t}\n\t\treturn l[i] > l[j]\n\t})\n\treturn l\n}\n\n"}
{"task_id": "Go/38", "generation": "\n    groups := strings.Split(s, \"\")\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(group[1]) + string(group[0]) + string(group[2]))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}\n\n"}
{"task_id": "Go/39", "generation": "\n\tif n == 1 {\n\t\treturn 2\n\t}\n\tif n == 2 {\n\t\treturn 3\n\t}\n\ta, b := 2, 3\n\tfor i := 3; i < n; i++ {\n\t\ta, b = b, a+b\n\t\tif isPrime(b) {\n\t\t\treturn b\n\t\t}\n\t}\n\treturn b\n}\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n == 2 {\n\t\treturn true\n\t}\n\tif n%2 == 0 {\n\t\treturn false\n\t}\n\tsqrt := int(math.Sqrt(float64(n)))\n\tfor i := 3; i <= sqrt; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/40", "generation": "\n    if len(l) < 3 {\n        return false\n    }\n    for i := 0; i < len(l)-2; i++ {\n        for j := i + 1; j < len(l)-1; j++ {\n            for k := j + 1; k < len(l); k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n"}
{"task_id": "Go/41", "generation": "\n    // Initialize collision counter\n    collisions := 0\n\n    // Loop through each car\n    for i := 1; i <= n; i++ {\n        // Loop through each car to the right\n        for j := i + 1; j <= n; j++ {\n            // Check if cars collide\n            if (i + j) % 2 == 0 {\n                // If they collide, increment collision counter\n                collisions++\n            }\n        }\n    }\n\n    // Return total collisions\n    return collisions\n} // CarRaceCollision\n\n"}
{"task_id": "Go/42", "generation": "\n    for i := range l {\n        l[i]++\n    }\n    return l\n}\n"}
{"task_id": "Go/43", "generation": "\n    // Create a map to store the elements we have seen so far\n    m := make(map[int]bool)\n    for _, v := range l {\n        // If the complement of the current element is in the map, return true\n        if m[-v] {\n            return true\n        }\n        // Otherwise, add the current element to the map\n        m[v] = true\n    }\n    // If we have iterated over the entire list and haven't found a pair that sums to zero, return false\n    return false\n} // PairsSumToZero\n"}
{"task_id": "Go/44", "generation": "\n    // Convert the number to a string\n    str := strconv.Itoa(x)\n    \n    // Convert the string to the desired base\n    result := \"\"\n    for _, char := range str {\n        // Convert the character to an integer\n        num := int(char - '0')\n        \n        // Convert the integer to the desired base\n        for base > 1 {\n            result = strconv.Itoa(num%base) + result\n            num /= base\n        }\n        result = strconv.Itoa(num) + result\n    }\n    \n    return result\n}\n\n"}
{"task_id": "Go/45", "generation": "\n\treturn 0.5 * a * h\n}\n"}
{"task_id": "Go/46", "generation": "\n\tif n == 0 || n == 1 {\n\t\treturn 0\n\t} else if n == 2 {\n\t\treturn 2\n\t} else {\n\t\treturn Fib4(n-1) + Fib4(n-2) + (n-3) + Fib4(n-4)\n\t}\n}\n"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64((l[n/2-1] + l[n/2]) / 2)\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}\n\n"}
{"task_id": "Go/48", "generation": "\n    // Reverse the string\n    reversed := ReverseString(text)\n    // Compare the original string with the reversed string\n    return text == reversed\n}\n"}
{"task_id": "Go/49", "generation": "\n    if p == 0 {\n        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return Modp(n/2,p)\n    }\n    return (Modp(n/2,p) + Modp(n/2,p)) % p\n}\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-'a'+26)%26+'a')\n    }\n    return string(runes)\n}\n\n"}
{"task_id": "Go/51", "generation": "\n    // Create a regular expression that matches any vowel\n    vowelRegex := regexp.MustCompile(\"[aeiouAEIOU]\")\n    \n    // Use the ReplaceAllString function to replace all vowels with an empty string\n    // This effectively removes all vowels from the text\n    return vowelRegex.ReplaceAllString(text, \"\")\n}\n\n"}
{"task_id": "Go/52", "generation": "\n    for _, num := range l {\n        if num < t {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/53", "generation": "\n    return x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n\tchars0 := make([]byte, 0, len(s0))\n\tchars1 := make([]byte, 0, len(s1))\n\tfor _, c := range s0 {\n\t\tchars0 = append(chars0, c)\n\t}\n\tfor _, c := range s1 {\n\t\tchars1 = append(chars1, c)\n\t}\n\tsort.Slice(chars0, func(i, j int) bool {\n\t\treturn chars0[i] < chars0[j]\n\t})\n\tsort.Slice(chars1, func(i, j int) bool {\n\t\treturn chars1[i] < chars1[j]\n\t})\n\treturn bytes.Equal(chars0, chars1)\n}\n"}
{"task_id": "Go/55", "generation": "\n    if n <= 1 {\n        return n\n    }\n    return Fib(n-1) + Fib(n-2)\n}\n"}
{"task_id": "Go/56", "generation": "\n    stack := make([]rune, 0)\n    for _, bracket := range brackets {\n        if bracket == '<' {\n            stack = append(stack, bracket)\n        } else if bracket == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n"}
{"task_id": "Go/57", "generation": "\n    increasing := true\n    decreasing := true\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            increasing = false\n        }\n        if l[i] < l[i-1] {\n            decreasing = false\n        }\n    }\n    return increasing || decreasing\n} \n"}
{"task_id": "Go/58", "generation": "\n    // Create a map to store the elements of the first list\n    m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n    }\n    // Create a new list to store the common elements\n    common := make([]int, 0)\n    for _, v := range l2 {\n        if m[v] {\n            common = append(common, v)\n        }\n    }\n    // Sort the common list\n    sort.Ints(common)\n    return common\n}\n\n"}
{"task_id": "Go/59", "generation": "\n    // Start with 2\n    for i := 2; i <= n; i++ {\n        // Check if i is a factor\n        if n%i == 0 {\n            // Check if i is prime\n            isPrime := true\n            for j := 2; j < i; j++ {\n                if i%j == 0 {\n                    isPrime = false\n                    break\n                }\n            }\n            if isPrime {\n                return i\n            }\n        }\n    }\n    return n\n} \n"}
{"task_id": "Go/60", "generation": "\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n"}
{"task_id": "Go/61", "generation": "\n    stack := make([]rune, 0)\n    for _, bracket := range brackets {\n        if bracket == '(' {\n            stack = append(stack, bracket)\n        } else if bracket == ')' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n"}
{"task_id": "Go/62", "generation": "\n    if len(xs) < 3 {\n        return []int{}\n    }\n    derivative := make([]int, len(xs)-2)\n    for i := 1; i < len(xs)-1; i++ {\n        derivative[i-1] = xs[i+1] * (i + 1)\n    }\n    return derivative\n}\n"}
{"task_id": "Go/63", "generation": "\n\tif n == 0 || n == 1 {\n\t\treturn 0\n\t} else if n == 2 {\n\t\treturn 1\n\t} else {\n\t\treturn Fibfib(n-1) + (n-2) + (n-3)\n\t}\n}\n"}
{"task_id": "Go/64", "generation": "\n    // Convert string to lowercase\n    s = strings.ToLower(s)\n    // Initialize counter\n    count := 0\n    // Loop through each character in string\n    for _, char := range s {\n        // Check if character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // If character is a vowel, increment counter\n            count++\n        }\n    }\n    // Return count of vowels\n    return count\n}\n"}
{"task_id": "Go/65", "generation": "\n    // Convert integer to string\n    str := strconv.Itoa(x)\n    // Convert string to byte array\n    bytes := []byte(str)\n    // Reverse byte array\n    reverse(bytes)\n    // Circular shift\n    for i := 0; i < shift; i++ {\n        bytes = append(bytes[1:], bytes[0])\n    }\n    // Convert byte array to string\n    result := string(bytes)\n    return result\n}\n"}
{"task_id": "Go/66", "generation": "\n    var sum int\n    for _, v := range x {\n        if v >= 'A' && v <= 'Z' {\n            sum += int(v)\n        }\n    }\n    return sum\n} \n"}
{"task_id": "Go/67", "generation": "\n\t// split string into two parts\n\tparts := strings.Split(s,\" \")\n\t// convert first part to integer\n\tapples, _ := strconv.Atoi(parts[0])\n\t// convert second part to integer\n\toranges, _ := strconv.Atoi(parts[1])\n\t// return n - apples - oranges\n\treturn n - apples - oranges\n}  // end of FruitDistribution function\n"}
{"task_id": "Go/68", "generation": "\n    // filter even values\n    even := make([]int, 0)\n    for _, v := range arr {\n        if v%2 == 0 {\n            even = append(even, v)\n        }\n    }\n    // if no even values return empty list\n    if len(even) == 0 {\n        return []int{}\n    }\n    // find smallest even value\n    smallest := even[0]\n    for _, v := range even {\n        if v < smallest {\n            smallest = v\n        }\n    }\n    // find smallest even value index\n    smallestIndex := 0\n    for i, v := range arr {\n        if v == smallest {\n            smallestIndex = i\n            break\n        }\n    }\n    return []int{smallest, smallestIndex}\n}\n\n"}
{"task_id": "Go/69", "generation": "\n    // Create a map to store the frequency of each integer\n    freq := make(map[int]int)\n    for _, num := range lst {\n        freq[num]++\n    }\n    // Find the maximum frequency\n    maxFreq := 0\n    for _, f := range freq {\n        if f > maxFreq {\n            maxFreq = f\n        }\n    }\n    // Find the greatest integer with frequency greater than or equal to maxFreq\n    for i := len(lst) - 1; i >= 0; i-- {\n        if freq[lst[i]] >= maxFreq {\n            return lst[i]\n        }\n    }\n    return -1\n}\n"}
{"task_id": "Go/70", "generation": "\n    // Sort the list in ascending order\n    sort.Ints(lst)\n    // Find the minimum value in the list\n    min := lst[0]\n    // Find the maximum value in the list\n    max := lst[len(lst)-1]\n    // Create a new list with the minimum value\n    newLst := []int{min}\n    // Create a new list with the maximum value\n    maxLst := []int{max}\n    // Iterate over the original list\n    for i := 1; i < len(lst); i++ {\n        // If the current value is less than the minimum value, add it to the new list\n        if lst[i] < min {\n            newLst = append(newLst, lst[i])\n        }\n        // If the current value is greater than the maximum value, add it to the max list\n        if lst[i] > max {\n            maxLst = append(maxLst, lst[i])\n        }\n    }\n    // Sort the new list in ascending order\n    sort.Ints(newLst)\n    // Sort the max list in descending order\n    sort.Ints(maxLst)\n    // Reverse the max list\n    for i, j := 0, len(maxLst)-1; i < j; i, j = i+1, j-1 {\n        maxLst[i], maxLst[j] = maxLst[j], maxLst[i]\n    }\n    // Combine the new list and the max list\n    return append(newLst, maxLst...)\n}\n\n"}
{"task_id": "Go/71", "generation": "\n    // Check if the three sides make a valid triangle\n    if a+b > c && a+c > b && b+c > a {\n        // Calculate the semi-perimeter\n        s := (a + b + c) / 2\n        // Calculate the area using Heron's formula\n        area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n        // Return the area rounded to 2 decimal points\n        return math.Round(area*100)/100\n    } else {\n        // Return -1 if the three sides do not make a valid triangle\n        return -1\n    }\n} \n"}
{"task_id": "Go/72", "generation": "\n    // Calculate the sum of the elements in the list\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    // Check if the sum is less than or equal to the maximum possible weight\n    return sum <= w\n} // WillItFly\n"}
{"task_id": "Go/73", "generation": "\n    // sort array\n    sort.Ints(arr)\n    // find middle element\n    mid := len(arr) / 2\n    // find minimum number elements need changed\n    return len(arr) - mid\n}\n\n"}
{"task_id": "Go/74", "generation": "\n    // Convert lists to maps\n    map1 := make(map[string]int)\n    map2 := make(map[string]int)\n    for _, v := range lst1 {\n        map1[v]++\n    }\n    for _, v := range lst2 {\n        map2[v]++\n    }\n    // Find common keys\n    commonKeys := make([]string, 0)\n    for k := range map1 {\n        if _, ok := map2[k]; ok {\n            commonKeys = append(commonKeys, k)\n        }\n    }\n    // Find number of chars less in first list\n    lessInFirst := 0\n    for _, k := range commonKeys {\n        lessInFirst += map1[k] - map2[k]\n    }\n    // Find number of chars less in second list\n    lessInSecond := 0\n    for _, k := range commonKeys {\n        lessInSecond += map2[k] - map1[k]\n    }\n    // Return first list if both lists have same number of chars less\n    if lessInFirst == lessInSecond {\n        return lst1\n    }\n    // Return list with less number of chars\n    if lessInFirst < lessInSecond {\n        return lst1\n    }\n    return lst2\n}\n"}
{"task_id": "Go/75", "generation": "\n    // 2 is prime\n    if a%2 == 0 {\n        return false\n    }\n    // 3 is prime\n    if a%3 == 0 {\n        return false\n    }\n    // 5 is prime\n    if a%5 == 0 {\n        return false\n    }\n    return true\n}\n"}
{"task_id": "Go/76", "generation": "\n    // check if x is a power of n\n    // if x is a power of n, then x = n**int(x)\n    // we can use the built-in int function to convert x to an integer\n    // and the ** operator to calculate the power\n    if x == int64(n)**int64(int(x)) {\n        return true\n    }\n    return false\n}\n"}
{"task_id": "Go/77", "generation": "\n    // Calculate cube root of a\n    cubeRoot := math.Round(math.Pow(float64(a), 1.0/3.0))\n    // Check if cube of cubeRoot equals a\n    return cubeRoot*cubeRoot*cubeRoot == a\n} // end function Iscube\n"}
{"task_id": "Go/78", "generation": "\n    // count number of hexadecimal digits\n    count := 0\n    for _, r := range num {\n        if r >= '0' && r <= '9' {\n            count++\n        } else if r >= 'A' && r <= 'F' {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/79", "generation": "\n\t// convert decimal to binary\n\tbinary := fmt.Sprintf(\"%b\", decimal)\n\t// add extra characters to binary\n\tbinary = \"db\" + binary + \"db\"\n\treturn binary\n}\n\n"}
{"task_id": "Go/80", "generation": "\n\t// check if length of string is at least 3\n\tif len(s) < 3 {\n\t\treturn false\n\t}\n\t// check if 3 consecutive letters are distinct\n\tfor i := 0; i < len(s)-2; i++ {\n\t\tif s[i] == s[i+1] && s[i] == s[i+2] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/81", "generation": "\n    var letterGrades []string\n    for _, g := range grades {\n        if g >= 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if g > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if g > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if g > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if g > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if g > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if g > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if g > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if g > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if g > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if g > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if g > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n} \n"}
{"task_id": "Go/82", "generation": "\n    length := len(s)\n    if length <= 1 {\n        return false\n    }\n    for i := 2; i*i <= length; i++ {\n        if length%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/83", "generation": "\n    // Calculate the number of n-digit numbers that start with 1\n    start := int(math.Pow10(n-1))\n    // Calculate the number of n-digit numbers that end with 1\n    end := int(math.Pow10(n-1)) - 1\n    // Calculate the number of n-digit numbers that start and end with 1\n    overlap := int(math.Pow10(n-2))\n    // Return the total count of n-digit numbers that start with 1 and end with 1\n    return start + end - overlap\n} \n"}
{"task_id": "Go/84", "generation": "\n    // Convert N to binary and remove the \"0b\" prefix\n    binary := strconv.FormatInt(int64(N), 2)\n    \n    // Initialize sum to 0\n    sum := 0\n    \n    // Iterate over each character in the binary string\n    for _, char := range binary {\n        // Convert the character to an integer and add it to the sum\n        sum += int(char - '0')\n    }\n    \n    // Convert the sum to a binary string and remove the \"0b\" prefix\n    binarySum := strconv.FormatInt(int64(sum), 2)\n    \n    // Return the binary sum\n    return binarySum\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%2 == 0 && v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/86", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    // Sort the words based on their ASCII value\n    sort.Slice(words, func(i, j int) bool {\n        return words[i] < words[j]\n    })\n    // Join the sorted words back into a string\n    return strings.Join(words, \" \")\n}\n\n"}
{"task_id": "Go/87", "generation": "\n    // find all the rows that contain the integer x\n    var rows [][]int\n    for _, row := range lst {\n        if contains(row, x) {\n            rows = append(rows, row)\n        }\n    }\n    \n    // sort the rows by ascending order\n    sort.Slice(rows, func(i, j int) bool {\n        return rows[i][0] < rows[j][0]\n    })\n    \n    // sort the columns by descending order\n    for _, row := range rows {\n        sort.Slice(row, func(i, j int) bool {\n            return row[i] > row[j]\n        })\n    }\n    \n    // create a list of tuples (row, column)\n    var result [][2]int\n    for i, row := range rows {\n        for j, col := range row {\n            result = append(result, [2]int{i, j})\n        }\n    }\n    \n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/88", "generation": "\n    // check if array is empty\n    if len(array) == 0 {\n        return array\n    }\n\n    // check if array has only one element\n    if len(array) == 1 {\n        return array\n    }\n\n    // check if array has even number of elements\n    if len(array)%2 == 0 {\n        // sort array in descending order\n        sort.Slice(array, func(i, j int) bool {\n            return array[i] > array[j]\n        })\n    } else {\n        // sort array in ascending order\n        sort.Slice(array, func(i, j int) bool {\n            return array[i] < array[j]\n        })\n    }\n\n    return array\n}\n\n"}
{"task_id": "Go/89", "generation": "\n    // Define the alphabet\n    alphabet := \"abcdefghijklmnopqrstuvwxyz\"\n    // Define the rotated alphabet\n    rotatedAlphabet := \"lmnopqrstuvwxyzabcdefghijk\"\n    // Define the shift\n    shift := 2 * 2\n    // Initialize the result\n    result := \"\"\n    // Loop over the input string\n    for _, r := range s {\n        // Convert the character to lowercase\n        char := strings.ToLower(string(r))\n        // Find the index of the character in the alphabet\n        index := strings.Index(alphabet, char)\n        // If the character is in the alphabet\n        if index != -1 {\n            // Calculate the new index\n            newIndex := (index + shift) % len(alphabet)\n            // Append the character at the new index to the result\n            result += string(rotatedAlphabet[newIndex])\n        } else {\n            // If the character is not in the alphabet, append it to the result as is\n            result += string(r)\n        }\n    }\n    // Return the result\n    return result\n} "}
{"task_id": "Go/90", "generation": "\n    if len(lst) == 0 {\n        return nil\n    }\n    sort.Ints(lst)\n    for i := 1; i < len(lst); i++ {\n        if lst[i] != lst[i-1] {\n            return lst[i]\n        }\n    }\n    return nil\n}\n\n"}
{"task_id": "Go/91", "generation": "\n    // split the string into sentences\n    sentences := regexp.MustCompile(`[.!?]`).Split(S, -1)\n    \n    // count the number of sentences that start with \"I\"\n    count := 0\n    for _, sentence := range sentences {\n        if strings.HasPrefix(strings.TrimSpace(sentence), \"I\") {\n            count++\n        }\n    }\n    \n    return count\n} \n\n"}
{"task_id": "Go/92", "generation": "\n    // Check if all numbers are integers\n    if !IsInt(x) || !IsInt(y) || !IsInt(z) {\n        return false\n    }\n    // Check if one number is equal to the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n    return false\n}\n"}
{"task_id": "Go/93", "generation": "\n    // Convert to lowercase\n    message = strings.ToLower(message)\n    \n    // Initialize result string\n    result := \"\"\n    \n    // Iterate over each character in the message\n    for i := 0; i < len(message); i++ {\n        // Get the ASCII value of the character\n        charCode := int(message[i])\n        \n        // Check if the character is a letter\n        if charCode >= 97 && charCode <= 122 {\n            // Check if the character is a vowel\n            if charCode == 97 || charCode == 101 || charCode == 105 || charCode == 111 || charCode == 117 {\n                // If the character is a vowel, add the character 2 places ahead in the alphabet\n                result += string(rune(charCode + 2))\n            } else {\n                // If the character is not a vowel, swap the case of the character\n                if charCode % 2 == 0 {\n                    result += string(rune(charCode + 1))\n                } else {\n                    result += string(rune(charCode - 1))\n                }\n            }\n        } else {\n            // If the character is not a letter, add it to the result as is\n            result += string(message[i])\n        }\n    }\n    \n    // Return the encoded message\n    return result\n}\n"}
{"task_id": "Go/94", "generation": "\n    // find largest prime value\n    maxPrime := 0\n    for _, num := range lst {\n        if isPrime(num) && num > maxPrime {\n            maxPrime = num\n        }\n    }\n    // return sum of digits of maxPrime\n    return sumDigits(maxPrime)\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc sumDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n"}
{"task_id": "Go/95", "generation": "\n    // Check if dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n\n    // Get all keys\n    keys := make([]string, 0)\n    for k := range dict {\n        keys = append(keys, k.(string))\n    }\n\n    // Check if all keys are lower or upper case\n    for _, key := range keys {\n        if !strings.HasPrefix(key, string(rune(65)) /* 'A' */) && !strings.HasPrefix(key, string(rune(97)) /* 'a' */) {\n            return false\n        }\n    }\n\n    return true\n}\n"}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n} \n"}
{"task_id": "Go/97", "generation": "\n    // get unit digits\n    unitA := a % 10\n    unitB := b % 10\n\n    // multiply unit digits\n    product := unitA * unitB\n\n    return product\n}\n\n"}
{"task_id": "Go/98", "generation": "\n    var count int\n    for _, r := range s {\n        if strings.ContainsRune(\"AEIOU\", r) && strings.ContainsRune(\"AEIOU\", unicode.ToUpper(r)) {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/99", "generation": "\n    // Convert string to float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n\n    // Round to nearest integer\n    rounded := math.Round(num)\n\n    // If equidistant from two integers, round away from zero\n    if num-math.Floor(num) == math.Ceil(num)-num {\n        if rounded == math.Floor(num) {\n            rounded = math.Ceil(num)\n        }\n    }\n\n    // Convert rounded float64 to int\n    return int(rounded)\n}\n\n"}
{"task_id": "Go/100", "generation": "\n    // initialize result list\n    result := make([]int, n)\n    // initialize current number of stones\n    current := n\n    // loop through each level\n    for i := 0; i < n; i++ {\n        // add current number of stones to result list\n        result[i] = current\n        // if current number of stones is odd, increment by 2\n        if current%2 == 1 {\n            current += 2\n        } else {\n            // if current number of stones is even, increment by 4\n            current += 4\n        }\n    }\n    // return result list\n    return result\n}\n"}
{"task_id": "Go/101", "generation": "\n    // split string by comma\n    words := strings.Split(s, \",\")\n    // split each word by space\n    for i, word := range words {\n        words[i] = strings.Split(word, \" \")[0]\n    }\n    return words\n}\n\n"}
{"task_id": "Go/102", "generation": "\n\tif x > y {\n\t\treturn -1\n\t}\n\treturn x + (y - x) / 2\n}\n"}
{"task_id": "Go/103", "generation": "\n    if n > m {\n        return -1\n    }\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n    avg := math.Round(float64(sum) / float64(m-n+1))\n    return fmt.Sprintf(\"%b\", avg)\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    // convert each number to string\n    // filter out odd digits\n    // convert back to int\n    // sort\n    // return\n    var evenDigits []int\n    for _, num := range x {\n        str := strconv.Itoa(num)\n        for _, r := range str {\n            if r%2 == 0 {\n                evenDigits = append(evenDigits, int(r))\n            }\n        }\n    }\n    sort.Ints(evenDigits)\n    return evenDigits\n}\n\n"}
{"task_id": "Go/105", "generation": "\n    sort.Ints(arr)\n    reverse(arr)\n    names := []string{\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    result := make([]string, len(arr))\n    for i, num := range arr {\n        if num < 1 || num > 9 {\n            continue\n        }\n        result[i] = names[num-1]\n    }\n    return result\n}\n\nfunc reverse(arr []int) {\n    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n        arr[i], arr[j] = arr[j], arr[i]\n    }\n}\n\n"}
{"task_id": "Go/106", "generation": "\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/107", "generation": "\n    // Initialize even and odd counters\n    even := 0\n    odd := 0\n\n    // Loop through all numbers from 1 to n\n    for i := 1; i <= n; i++ {\n        // Convert the number to a string to check if it's a palindrome\n        str := strconv.Itoa(i)\n        // Check if the string is equal to its reverse\n        if str == reverse(str) {\n            // If it's a palindrome, increment the corresponding counter\n            if i%2 == 0 {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n\n    // Return the counters as a tuple\n    return [2]int{even, odd}\n}\n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        str := strconv.Itoa(abs(num))\n        for _, digit := range str {\n            if int(digit) > 0 {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nfunc abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n    return num\n}\n"}
{"task_id": "Go/109", "generation": "\n    // If the array is empty, return true\n    if len(arr) == 0 {\n        return true\n    }\n\n    // Sort the array in ascending order\n    sort.Ints(arr)\n\n    // Initialize a variable to store the number of right shifts\n    rightShifts := 0\n\n    // Iterate over the array to find the number of right shifts\n    for i := 0; i < len(arr); i++ {\n        // If the current element is not equal to the sorted array element at the same index\n        if arr[i] != arr[0] {\n            // Increment the right shifts counter\n            rightShifts++\n        }\n    }\n\n    // If the number of right shifts is equal to the length of the array minus one\n    if rightShifts == len(arr)-1 {\n        // Return true\n        return true\n    }\n\n    // Return false\n    return false\n}\n\n"}
{"task_id": "Go/110", "generation": "\n    // create a copy of lst1\n    copy1 := make([]int, len(lst1))\n    copy(copy1, lst1)\n    // create a copy of lst2\n    copy2 := make([]int, len(lst2))\n    copy(copy2, lst2)\n    // loop through lst1\n    for i := range lst1 {\n        // loop through lst2\n        for j := range lst2 {\n            // if lst1[i] is odd and lst2[j] is even\n            if lst1[i]%2 != 0 && lst2[j]%2 == 0 {\n                // replace lst1[i] with lst2[j]\n                lst1[i] = lst2[j]\n                // remove lst2[j] from lst2\n                lst2 = append(lst2[:j], lst2[j+1:]...)\n                // break out of inner loop\n                break\n            }\n        }\n    }\n    // loop through lst1\n    for _, num := range lst1 {\n        // if any number in lst1 is odd\n        if num%2 != 0 {\n            // return \"NO\"\n            return \"NO\"\n        }\n    }\n    // return \"YES\"\n    return \"YES\"\n}\n\n"}
{"task_id": "Go/111", "generation": "\n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    //"}
{"task_id": "Go/112", "generation": "\n    // remove all occurrences of c from s\n    newS := strings.ReplaceAll(s, c, \"\")\n    // check if newS is palindrome\n    return [2]interface{}{newS, strings.EqualFold(newS, reverse(newS))}\n}\n\nfunc reverse(s string) string {\n    // reverse string\n    run := []rune(s)\n    for i, j := 0, len(run)-1; i < j; i, j = i+1, j-1 {\n        run[i], run[j] = run[j], run[i]\n    }\n    return string(run)\n}\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        odd := 0\n        for _, r := range str {\n            if r%2 != 0 {\n                odd++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"number of odd elements %d in string %s in input.\", odd, str))\n    }\n    return result\n}\n\n"}
{"task_id": "Go/114", "generation": "\n    min := math.MaxInt\n    sum := 0\n    for _, num := range nums {\n        sum += num\n        if sum < min {\n            min = sum\n        }\n        if sum > 0 {\n            sum = 0\n        }\n    }\n    return min\n} \n"}
{"task_id": "Go/115", "generation": "\n    // get number of rows and columns\n    rows := len(grid)\n    cols := len(grid[0])\n    // get number of wells\n    wells := rows * cols\n    // get total water\n    totalWater := 0\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            totalWater += grid[i][j]\n        }\n    }\n    // get number of buckets\n    buckets := wells / capacity\n    // get remaining water\n    remainingWater := totalWater % capacity\n    // get number of times lower buckets\n    lowerBuckets := buckets + remainingWater\n    return lowerBuckets\n}\n\n"}
{"task_id": "Go/116", "generation": "\n    // sort array based on binary representation\n    sort.Slice(arr, func(i, j int) bool {\n        // convert to binary and remove '0b' prefix\n        bin_i := fmt.Sprintf(\"%b\", arr[i])\n        bin_j := fmt.Sprintf(\"%b\", arr[j])\n        // compare binary representation\n        for k := 0; k < len(bin_i); k++ {\n            if bin_i[k] < bin_j[k] {\n                return true\n            } else if bin_i[k] > bin_j[k] {\n                return false\n            }\n        }\n        // if binary representation is equal, sort based on decimal value\n        return arr[i] < arr[j]\n    })\n    return arr\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    // Initialize an empty list to store the result\n    result := make([]string, 0)\n    // Iterate over each word in the list of words\n    for _, word := range words {\n        // Count the number of consonants in the word\n        count := 0\n        for _, char := range word {\n            // Check if the character is a consonant\n            if strings.ToLower(string(char)) >= \"a\" && strings.ToLower(string(char)) <= \"z\" && !strings.ContainsRune([]rune{\"a\", \"e\", \"i\", \"o\", \"u\"}, char) {\n                count++\n            }\n        }\n        // If the count of consonants in the word is equal to n, add the word to the result list\n        if count == n {\n            result = append(result, word)\n        }\n    }\n    // Return the result list\n    return result\n}\n\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := 0; i < len(word); i++ {\n        if bytes.IndexByte(vowels, word[i]) != -1 {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n"}
{"task_id": "Go/119", "generation": "\n\t// check if the list is empty\n\tif len(lst) == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\t// check if the list has more than two elements\n\tif len(lst) > 2 {\n\t\treturn \"No\"\n\t}\n\n\t// check if the first string is open and the second is close\n\tif lst[0] == \"(\" && lst[1] == \")\" {\n\t\treturn \"Yes\"\n\t}\n\n\t// check if the first string is close and the second is open\n\tif lst[0] == \")\" && lst[1] == \"(\" {\n\t\treturn \"Yes\"\n\t}\n\n\t// if none of the above conditions are met, return \"No\"\n\treturn \"No\"\n}\n"}
{"task_id": "Go/120", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    return arr[:k]\n}\n\n"}
{"task_id": "Go/121", "generation": "\n    var sum int\n    for i, v := range lst {\n        if v%2 == 1 && i%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n} \n"}
{"task_id": "Go/122", "generation": "\n    // Sort the array in ascending order\n    sort.Ints(arr)\n    \n    // Initialize the sum variable to 0\n    var sum int\n    \n    // Loop through the first k elements of the array\n    for i := 0; i < k; i++ {\n        // Add the current element to the sum\n        sum += arr[i]\n    }\n    \n    // Return the sum\n    return sum\n}\n\n"}
{"task_id": "Go/123", "generation": "\n    // initialize result list\n    result := make([]int, 0)\n    // loop until n is 1\n    for n != 1 {\n        // if n is even\n        if n%2 == 0 {\n            // n = n / 2\n            n = n / 2\n        } else {\n            // n = 3 * n + 1\n            n = 3 * n + 1\n        }\n        // if n is odd add to result list\n        if n%2 != 0 {\n            result = append(result, n)\n        }\n    }\n    // sort result list\n    sort.Ints(result)\n    return result\n}\n\n"}
{"task_id": "Go/124", "generation": "\n    // 1. date string not empty\n    if len(date) == 0 {\n        return false\n    }\n\n    // 2. number days not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. not less than 1 or higher than 30 days for months 4,6,9,11 not less than 1 higher than 29 for month 2.\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n    day, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return false\n    }\n    month, err := strconv.Atoi(parts[0])\n    if err != nil {\n        return false\n    }\n    year, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return false\n    }\n    if day < 1 || (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31 || (month == 4 || month == 6 || month == 9 || month == 11) && day > 30 || month == 2 && day > 29 {\n        return false\n    }\n\n    // 3. months not less than 1 or higher than 12.\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    // 4. date format mm-dd-yyyy\n    if len(parts[0]) != 2 || len(parts[1]) != 2 || len(parts[2]) != 4 {\n        return false\n    }\n\n    return true\n}\n"}
{"task_id": "Go/125", "generation": "\n    // split on whitespace\n    words := strings.Fields(txt)\n    if len(words) == 1 {\n        // split on commas\n        words = strings.Split(txt, \",\")\n    }\n    if len(words) == 1 {\n        // count lower-case letters\n        count := 0\n        for _, r := range txt {\n            if r >= 'a' && r <= 'z' {\n                count++\n            }\n        }\n        return count\n    }\n    // return list of words\n    return words\n}\n"}
{"task_id": "Go/126", "generation": "\n    for i := 1; i < len(lst); i++ {\n        if lst[i] < lst[i-1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/127", "generation": "\n\t// find intersection\n\tstart := max(interval1[0], interval2[0])\n\tend := min(interval1[1], interval2[1])\n\t// check if intersection is prime\n\tif start <= end {\n\t\tif isPrime(end-start) {\n\t\t\treturn \"YES\"\n\t\t}\n\t}\n\treturn \"NO\"\n}\n"}
{"task_id": "Go/128", "generation": "\n    // check if array is empty\n    if len(arr) == 0 {\n        return nil\n    }\n    // initialize product sign to 1\n    productSign := 1\n    // initialize sum magnitude to 0\n    sumMagnitude := 0\n    // loop through array\n    for _, num := range arr {\n        // if number is 0, skip\n        if num == 0 {\n            continue\n        }\n        // if number is negative, change product sign\n        if num < 0 {\n            productSign *= -1\n        }\n        // add magnitude to sum\n        sumMagnitude += math.Abs(float64(num))\n    }\n    // return product sign times sum magnitude\n    return productSign * sumMagnitude\n} // end function ProdSigns\n"}
{"task_id": "Go/129", "generation": "\n    m, n := len(grid), len(grid[0])\n    visited := make([][]bool, m)\n    for i := range visited {\n        visited[i] = make([]bool, n)\n    }\n    res := make([]int, k)\n    var dfs func(int, int, int)\n    dfs = func(x, y, step int) {\n        if step == k {\n            for i := 0; i < k; i++ {\n                res[i] = grid[x][y]\n            }\n            return\n        }\n        visited[x][y] = true\n        for i := -1; i <= 1; i++ {\n            for j := -1; j <= 1; j++ {\n                if i == 0 && j == 0 {\n                    continue\n                }\n                nx, ny := x+i, y+j\n                if nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] {\n                    dfs(nx, ny, step+1)\n                }\n            }\n        }\n        visited[x][y] = false\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            dfs(i, j, 0)\n            if res[0] != 0 {\n                return res\n            }\n        }\n    }\n    return nil\n}\n"}
{"task_id": "Go/130", "generation": "\n\tif n < 0 {\n\t\treturn nil\n\t}\n\tif n == 0 {\n\t\treturn []float64{}\n\t}\n\tif n == 1 {\n\t\treturn []float64{3}\n\t}\n\tif n == 2 {\n\t\treturn []float64{1, 3}\n\t}\n\tif n == 3 {\n\t\treturn []float64{1, 3, 2}\n\t}\n\tif n%2 == 0 {\n\t\treturn append(Tri(n/2), 1+float64(n)/2)\n\t}\n\treturn append(Tri(n-1), Tri(n-2)..., float64(n-1)+float64(n-2)+float64(n+1))\n}\n\n"}
{"task_id": "Go/131", "generation": "\n    var product int\n    for n > 0 {\n        digit := n % 10\n        if digit % 2 == 1 {\n            product *= digit\n        }\n        n /= 10\n    }\n    return product\n}\n\n"}
{"task_id": "Go/132", "generation": "\n    // Initialize stack\n    stack := make([]rune, 0)\n    // Iterate over string\n    for _, r := range s {\n        // If opening bracket push to stack\n        if r == '[' {\n            stack = append(stack, r)\n        }\n        // If closing bracket\n        if r == ']' {\n            // If stack is empty return false\n            if len(stack) == 0 {\n                return false\n            }\n            // Pop from stack\n            stack = stack[:len(stack)-1]\n        }\n    }\n    // If stack is empty return false\n    if len(stack) == 0 {\n        return false\n    }\n    // Return true\n    return true\n}\n\n"}
{"task_id": "Go/133", "generation": "\n    // round each element in the list to upper int(Ceiling)\n    rounded := make([]int, len(lst))\n    for i, v := range lst {\n        rounded[i] = int(math.Ceil(v))\n    }\n    // sum of squared numbers\n    sum := 0\n    for _, v := range rounded {\n        sum += v * v\n    }\n    return sum\n} // SumSquares\n"}
{"task_id": "Go/134", "generation": "\n    // Split the string into words\n    words := strings.Fields(txt)\n    // Get the last word\n    lastWord := words[len(words)-1]\n    // Check if the last word is not empty\n    if len(lastWord) == 0 {\n        return false\n    }\n    // Get the last character of the last word\n    lastChar := lastWord[len(lastWord)-1]\n    // Check if the last character is a letter\n    return unicode.IsLetter(lastChar)\n}\n\n"}
{"task_id": "Go/135", "generation": "\n    // Create a map to store the count of each element\n    countMap := make(map[int]int)\n    for _, num := range arr {\n        countMap[num]++\n    }\n\n    // Create a variable to store the largest index element\n    largestIndex := -1\n    for i, num := range arr {\n        // If the count of the current element is greater than 0\n        if countMap[num] > 0 {\n            // If the largest index element is -1 or the current element is greater than the largest index element\n            if largestIndex == -1 || num > arr[largestIndex] {\n                // Update the largest index element\n                largestIndex = i\n            }\n            // Decrement the count of the current element\n            countMap[num]--\n        }\n    }\n\n    return largestIndex\n}\n"}
{"task_id": "Go/136", "generation": "\n    // Check if list is empty\n    if len(lst) == 0 {\n        return [2]interface{}{nil, nil}\n    }\n    // Check if list contains only zeros\n    if len(lst) == 1 && lst[0] == 0 {\n        return [2]interface{}{nil, nil}\n    }\n    // Find the largest negative integer\n    var largestNegative int\n    for _, num := range lst {\n        if num < 0 && num > largestNegative {\n            largestNegative = num\n        }\n    }\n    // Find the smallest positive integer\n    var smallestPositive int\n    for _, num := range lst {\n        if num > 0 && num < smallestPositive {\n            smallestPositive = num\n        }\n    }\n    // Return the largest negative and smallest positive integers\n    return [2]interface{}{largestNegative, smallestPositive}\n}\n"}
{"task_id": "Go/137", "generation": "\n    // Convert a and b to strings\n    aStr := fmt.Sprintf(\"%v\", a)\n    bStr := fmt.Sprintf(\"%v\", b)\n\n    // Remove commas from strings\n    aStr = strings.ReplaceAll(aStr, \",\", \"\")\n    bStr = strings.ReplaceAll(bStr, \",\", \"\")\n\n    // Convert strings to floats\n    aFloat, err := strconv.ParseFloat(aStr, 64)\n    if err != nil {\n        return nil\n    }\n    bFloat, err := strconv.ParseFloat(bStr, 64)\n    if err != nil {\n        return nil\n    }\n\n    // Compare floats\n    if aFloat > bFloat {\n        return a\n    } else if aFloat < bFloat {\n        return b\n    } else {\n        return nil\n    }\n}\n\n"}
{"task_id": "Go/138", "generation": "\n    // Check if n is even\n    if n%2 != 0 {\n        return false\n    }\n    // Check if n is equal to sum of 4 positive even numbers\n    for i := 2; i < n; i++ {\n        for j := i + 2; j < n; j++ {\n            for k := j + 2; k < n; j++ {\n                for l := k + 2; l < n; l++ {\n                    if i + j + k + l == n {\n                        return true\n                    }\n                }\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/139", "generation": "\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= factorial(i)\n    }\n    return result\n}\n"}
{"task_id": "Go/140", "generation": "\n    // replace consecutive spaces with -\n    text = strings.ReplaceAll(text, \"  \", \"-\")\n    // replace spaces with underscores\n    text = strings.ReplaceAll(text, \" \", \"_\")\n    return text\n}\n\n"}
{"task_id": "Go/141", "generation": "\n    // Split the file name into two parts: the name and the extension\n    parts := strings.Split(file_name, \".\")\n\n    // Check if the file name contains exactly one dot\n    if len(parts) != 2 {\n        return \"No\"\n    }\n\n    // Check if the name starts with a letter\n    if !strings.HasPrefix(parts[0], \"a\") && !strings.HasPrefix(parts[0], \"A\") {\n        return \"No\"\n    }\n\n    // Check if the name contains more than three digits\n    if strings.Count(parts[0], \"0\") > 3 {\n        return \"No\"\n    }\n\n    // Check if the extension is valid\n    if !strings.HasSuffix(parts[1], \"txt\") && !strings.HasSuffix(parts[1], \"exe\") && !strings.HasSuffix(parts[1], \"dll\") {\n        return \"No\"\n    }\n\n    // If all conditions are met, return 'Yes'\n    return \"Yes\"\n} "}
{"task_id": "Go/142", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v * v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += int(math.Pow(float64(v), 3))\n        }\n    }\n    return sum\n} \n\n"}
{"task_id": "Go/143", "generation": "\n    words := strings.Split(sentence, \" \")\n    var result string\n    for i := 1; i < len(words); i++ {\n        if isPrime(i) {\n            result += words[i] + \" \"\n        }\n        if i == len(words)-1 {\n            result += words[i]\n        }\n    }\n    return result\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/144", "generation": "\n    // split numerator and denominator\n    xNum, xDen := split(x)\n    nNum, nDen := split(n)\n\n    // calculate product\n    productNum := xNum * nNum\n    productDen := xDen * nDen\n\n    // check if product is whole number\n    if productNum == productDen {\n        return true\n    }\n\n    // if product is not whole number, return false\n    return false\n}\n"}
{"task_id": "Go/145", "generation": "\n    // sort by sum of digits\n    sort.Slice(nums, func(i, j int) bool {\n        sumI := sumDigits(nums[i])\n        sumJ := sumDigits(nums[j])\n        if sumI == sumJ {\n            return i < j\n        }\n        return sumI < sumJ\n    })\n    return nums\n}\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        if num > 10 && strconv.Itoa(num)[0] == \"1\" && strconv.Itoa(num)[len(strconv.Itoa(num))-1] == \"1\" {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/147", "generation": "\n\tarr := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tarr[i] = i*i - i + 1\n\t}\n\tvar count int\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tif (arr[i] + arr[j] + arr[k])%3 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n"}
{"task_id": "Go/148", "generation": "\n    // Define the planets in order of their distance from the Sun\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\n    // Check if the input planet names are valid\n    if !contains(planets, planet1) || !contains(planets, planet2) {\n        return []string{}\n    }\n\n    // Find the indices of the input planet names in the planets slice\n    i1, i2 := -1, -1\n    for i, p := range planets {\n        if p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n            i2 = i\n        }\n    }\n\n    // If the indices are the same, return an empty slice\n    if i1 == i2 {\n        return []string{}\n    }\n\n    // Find the planets between the two input planets\n    start, end := 0, len(planets)-1\n    if i1 < i2 {\n        start = i1 + 1\n        end = i2 - 1\n    } else {\n        start = i2 + 1\n        end = i1 - 1\n    }\n\n    // Return the planets between the two input planets\n    return planets[start : end+1]\n}\n"}
{"task_id": "Go/149", "generation": "\n    // filter out strings with odd length\n    filtered := make([]string, 0)\n    for _, s := range lst {\n        if len(s)%2 == 0 {\n            filtered = append(filtered, s)\n        }\n    }\n    // sort the list\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n    return filtered\n}\n\n"}
{"task_id": "Go/150", "generation": "\n    // check if n is prime\n    isPrime := true\n    for i := 2; i < n; i++ {\n        if n%i == 0 {\n            isPrime = false\n            break\n        }\n    }\n    // return x if n is prime, y otherwise\n    if isPrime {\n        return x\n    } else {\n        return y\n    }\n} // XOrY\n"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && num%2 == 1 {\n            sum += int(math.Pow(float64(num), 2))\n        }\n    }\n    return sum\n} \n\n"}
{"task_id": "Go/152", "generation": "\n    result := make([]int, len(game))\n    for i := range game {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(guess[i] - game[i])))\n        }\n    }\n    return result\n} \n"}
{"task_id": "Go/153", "generation": "\n    // calculate strength of each extension\n    strengths := make(map[string]int)\n    for _, extension := range extensions {\n        cap := 0\n        sm := 0\n        for _, r := range extension {\n            if unicode.IsUpper(r) {\n                cap++\n            } else if unicode.IsLower(r) {\n                sm++\n            }\n        }\n        strength := cap - sm\n        strengths[extension] = strength\n    }\n\n    // find strongest extension\n    max_strength := math.MinInt\n    strongest_extension := \"\"\n    for extension, strength := range strengths {\n        if strength > max_strength {\n            max_strength = strength\n            strongest_extension = extension\n        }\n    }\n\n    // return class name with strongest extension\n    return class_name + \".\" + strongest_extension\n}\n\n"}
{"task_id": "Go/154", "generation": "\n    return strings.Contains(a, b)\n}\n"}
{"task_id": "Go/155", "generation": "\n    var even, odd int\n    for _, digit := range strconv.Itoa(num) {\n        n, _ := strconv.Atoi(string(digit))\n        if n%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n    }\n    return [2]int{even, odd}\n}\n\n"}
{"task_id": "Go/156", "generation": "\n    romanMap := map[int]string{\n        1:  \"i\",\n        4:  \"iv\",\n        5:  \"v\",\n        9:  \"ix\",\n        10: \"x\",\n        40: \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\",\n        400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000: \"m\",\n    }\n    result := \"\"\n    for number > 0 {\n        for k, v := range romanMap {\n            if number >= k {\n                result += v\n                number -= k\n            }\n        }\n    }\n    return strings.ToLower(result)\n}\n\n"}
{"task_id": "Go/157", "generation": "\n\t// Check if the sides can form a right-angled triangle\n\t// using the Pythagorean theorem\n\tif a*a+b*b == c*c || a*a+c*c == b*b || b*b+c*c == a*a {\n\t\treturn true\n\t}\n\treturn false\n}\n\n"}
{"task_id": "Go/158", "generation": "\n    // sort the list of words\n    sort.Slice(words, func(i, j int) bool {\n        return words[i] < words[j]\n    })\n\n    // initialize max and maxWord\n    max := 0\n    maxWord := \"\"\n\n    // iterate over the sorted list of words\n    for _, word := range words {\n        // count the number of unique characters in the word\n        uniqueChars := len([]rune(word))\n        // if the number of unique characters is greater than max, update max and maxWord\n        if uniqueChars > max {\n            max = uniqueChars\n            maxWord = word\n        }\n    }\n\n    // return the word with the maximum number of unique characters\n    return maxWord\n}\n"}
{"task_id": "Go/159", "generation": "\n    // Calculate the total number of carrots eaten\n    totalEaten := number + need\n    \n    // Calculate the number of carrots left after meals\n    carrotsLeft := remaining - need\n    \n    // If there are not enough remaining carrots, eat all remaining carrots\n    if carrotsLeft < 0 {\n        carrotsLeft = 0\n    }\n    \n    // Return the array of total number of eaten carrots and carrots left\n    return []int{totalEaten, carrotsLeft}\n}  // end of function Eat\n"}
{"task_id": "Go/160", "generation": "\n    // Check if the length of the operator list is equal to the length of the operand list minus one\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n    // Check if all operands are non-negative integers\n    for _, num := range operand {\n        if num < 0 {\n            return 0\n        }\n    }\n    // Initialize the result with the first operand\n    result := operand[0]\n    // Iterate over the operator list and the operand list starting from the second operand\n    for i := 0; i < len(operator); i++ {\n        // Perform the operation based on the operator\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"/\":\n            // Check for division by zero\n            if operand[i+1] == 0 {\n                return 0\n            }\n            result /= operand[i+1]\n        case \"//\":\n            // Check for division by zero\n            if operand[i+1] == 0 {\n                return 0\n            }\n            result = result / operand[i+1]\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(operand[i+1])))\n        default:\n            return 0\n        }\n    }\n    return result\n} "}
{"task_id": "Go/161", "generation": "\n    var result string\n    for _, r := range s {\n        if unicode.IsLetter(r) {\n            result += string(unicode.ToUpper(r))\n        } else {\n            result += string(r)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    md5Hash := md5.New()\n    io.WriteString(md5Hash, text)\n    return fmt.Sprintf(\"%x\", md5Hash.Sum(nil))\n}\n"}
{"task_id": "Go/163", "generation": "\n\tif a > b {\n\t\ta, b = b, a\n\t}\n\tvar result []int\n\tfor i := a; i <= b; i++ {\n\t\tif i%2 == 0 {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n"}
