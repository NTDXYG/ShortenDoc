{"task_id": "Go/0", "generation": "\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if math.Abs(numbers[i] - numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/1", "generation": "\n    // Initialize an empty stack to keep track of the opening parentheses\n    var stack []rune\n    // Initialize an empty list to store the groups\n    var groups []string\n    // Initialize an empty string to build the current group\n    var current_group string\n    // Iterate over each character in the input string\n    for _, char := range paren_string {\n        // If the character is an opening parenthesis, push it onto the stack\n        if char == '(' {\n            stack = append(stack, char)\n        }\n        // If the character is a closing parenthesis, pop the corresponding opening parenthesis from the stack\n        else if char == ')' {\n            // If the stack is empty, it means there's no corresponding opening parenthesis, so return an empty list\n            if len(stack) == 0 {\n                return []string{}\n            }\n            // Pop the opening parenthesis from the stack\n            stack = stack[:len(stack)-1]\n            // If the stack is empty after popping, it means we've found a complete group, so add it to the list of groups\n            if len(stack) == 0 {\n                groups = append(groups, current_group)\n                current_group = \"\"\n            }\n        }\n        // If the character is not a parenthesis, add it to the current group\n        else {\n            current_group += string(char)\n        }\n    }\n    // If there are any remaining characters in the current group, add it to the list of groups\n    if current_group != \"\" {\n        groups = append(groups, current_group)\n    }\n    // Return the list of groups\n    return groups\n}\n\n"}
{"task_id": "Go/2", "generation": "\n    // Get the integer part of the number\n    integerPart := math.Floor(number)\n    // Get the decimal part of the number\n    decimalPart := number - integerPart\n    return decimalPart\n}\n\n"}
{"task_id": "Go/3", "generation": "\n    balance := 0\n    for _, operation := range operations {\n        if operation < 0 {\n            balance += operation\n            if balance < 0 {\n                return true\n            }\n        } else {\n            balance += operation\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/4", "generation": "\n    // Calculate the mean of the input numbers\n    mean := Mean(numbers)\n    \n    // Calculate the absolute difference between each number and the mean\n    absDiffs := make([]float64, len(numbers))\n    for i, num := range numbers {\n        absDiffs[i] = math.Abs(num - mean)\n    }\n    \n    // Calculate the mean of the absolute differences\n    mad := Mean(absDiffs)\n    \n    return mad\n}\n"}
{"task_id": "Go/5", "generation": "\n    result := make([]int, 0, len(numbers)*2-1)\n    for _, num := range numbers {\n        result = append(result, num)\n        result = append(result, delimeter)\n    }\n    return result[:len(result)-1] // remove the last delimeter\n}\n"}
{"task_id": "Go/6", "generation": "\n    var max_depths []int\n    var current_depth int\n    var stack []int\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, current_depth+1)\n            current_depth++\n        } else if char == ')' {\n            current_depth = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n        }\n        if current_depth > max_depths[len(max_depths)-1] {\n            max_depths = append(max_depths, current_depth)\n        }\n    }\n    return max_depths\n}\n\n"}
{"task_id": "Go/7", "generation": "\n    var filteredList []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}\n"}
{"task_id": "Go/8", "generation": "\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return [2]int{sum, product}\n}\n"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}\n"}
{"task_id": "Go/10", "generation": "\n    runes := []rune(str)\n    // Find the longest postfix of supplied string that is a palindrome.\n    for i := len(runes) - 1; i >= 0; i-- {\n        if IsPalindrome(string(runes[i:])) {\n            return str + string(run[](runes[:i+1])[::-1])\n        }\n    }\n    return str\n}\n"}
{"task_id": "Go/11", "generation": "\n    // Convert the input strings to byte slices\n    aBytes := []byte(a)\n    bBytes := []byte(b)\n\n    // Perform binary XOR on the byte slices\n    result := make([]byte, len(aBytes))\n    for i := range aBytes {\n        result[i] = aBytes[i] ^ bBytes[i]\n    }\n\n    // Convert the result byte slice back to a string\n    resultString := string(result)\n\n    return resultString\n}\n\n"}
{"task_id": "Go/12", "generation": "\n    if len(strings) == 0 {\n        return nil\n    }\n    longest := strings[0]\n    for _, s := range strings {\n        if len(s) > len(longest) {\n            longest = s\n        }\n    }\n    return longest\n} \n"}
{"task_id": "Go/13", "generation": "\n    if b == 0 {\n        return a\n    } else {\n        return GreatestCommonDivisor(b, a%b)\n    }\n}"}
{"task_id": "Go/14", "generation": "\n    var prefixes []string\n    for i := 0; i < len(str); i++ {\n        prefixes = append(prefixes, str[:i+1])\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    var result string\n    for i := 0; i <= n; i++ {\n        result += strconv.Itoa(i) + \" \"\n    }\n    return result\n}\n\n"}
{"task_id": "Go/16", "generation": "\n    // Convert the string to lower case\n    lowerStr := strings.ToLower(str)\n    // Create a map to store the characters and their counts\n    charCount := make(map[rune]int)\n    // Iterate over the string\n    for _, char := range lowerStr {\n        // If the character is already in the map, increment its count\n        if _, ok := charCount[char]; ok {\n            charCount[char]++\n        } else {\n            // If the character is not in the map, add it with a count of 1\n            charCount[char] = 1\n        }\n    }\n    // Return the number of distinct characters\n    return len(charCount)\n} \n\n"}
{"task_id": "Go/17", "generation": "\n    // Define a map to map the notes to their corresponding beats\n    note_beats := map[string]int{\n        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    }\n    \n    // Split the input string into individual notes\n    notes := strings.Split(music_string, \" \")\n    \n    // Initialize an empty list to store the beats\n    beats := make([]int, 0)\n    \n    // Iterate over each note\n    for _, note := range notes {\n        // Append the beats of the current note to the list\n        beats = append(beats, note_beats[note])\n    }\n    \n    // Return the list of beats\n    return beats\n} \n"}
{"task_id": "Go/18", "generation": "\n    count := 0\n    for i:=0;i<len(str)-len(substring)+1;i++{\n        if str[i:i+len(substring)] == substring{\n            count++\n        }\n    }\n    return count\n} \n"}
{"task_id": "Go/19", "generation": "\n    // Split the string into a slice of strings\n    words := strings.Split(numbers, \" \")\n    \n    // Sort the slice of strings\n    sort.Strings(words)\n    \n    // Join the sorted slice of strings back into a string\n    return strings.Join(words, \" \")\n}\n\n"}
{"task_id": "Go/20", "generation": "\n    if len(numbers) < 2 {\n        return [2]float64{}\n    }\n    minDiff := math.MaxFloat64\n    closest := [2]float64{}\n    for i := 0; i < len(numbers)-1; i++ {\n        diff := numbers[i+1] - numbers[i]\n        if diff < minDiff {\n            minDiff = diff\n            closest = [2]float64{numbers[i], numbers[i+1]}\n        }\n    }\n    return closest\n}\n"}
{"task_id": "Go/21", "generation": "\n    min := numbers[0]\n    for _, num := range numbers[1:] {\n        if num < min {\n            min = num\n        }\n    }\n    max := numbers[0]\n    for _, num := range numbers[1:] {\n        if num > max {\n            max = num\n        }\n    }\n    if max == min {\n        return numbers\n    }\n    rescaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        rescaled[i] = (num - min) / (max - min)\n    }\n    return rescaled\n}\n"}
{"task_id": "Go/22", "generation": "\n    var result []int\n    for _, value := range values {\n        switch v := value.(type) {\n        case int:\n            result = append(result, v)\n        case int8:\n            result = append(result, int(v))\n        case int16:\n            result = append(result, int(v))\n        case int32:\n            result = append(result, int(v))\n        case int64:\n            result = append(result, int(v))\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/23", "generation": "\n    return len(str)\n}\n"}
{"task_id": "Go/24", "generation": "\n    // Start with 1, the smallest possible divisor\n    divisor := 1\n    // Loop through all numbers from 2 to n\n    for i := 2; i <= n; i++ {\n        // Check if i is a divisor of n\n        if n % i == 0 {\n            // If it is, update the divisor\n            divisor = i\n        }\n    }\n    // Return the largest divisor found\n    return divisor\n}\n"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    var divisor int = 2\n    for n > 1 {\n        for n%divisor == 0 {\n            factors = append(factors, divisor)\n            n = n / divisor\n        }\n        divisor++\n    }\n    return factors\n}\n\n"}
{"task_id": "Go/26", "generation": "\n    var result []int\n    for _, num := range numbers {\n        if !contains(result, num) {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, char := range str {\n        if char >= 'a' && char <= 'z' {\n            result += string(char - 'a' + 'A')\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/28", "generation": "\n    var result string\n    for _, s := range strings {\n        result += s\n    }\n    return result\n}\n"}
{"task_id": "Go/29", "generation": "\n    var result []string\n    for _, s := range strings {\n        if strings.HasPrefix(s, prefix) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/30", "generation": "\n    var result []int\n    for _, v := range l {\n        if v > 0 {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/32", "generation": "\n    // xs must have even number of coefficients\n    if len(xs)%2 != 0 {\n        panic(\"xs must have even number of coefficients\")\n    }\n    // largest non zero coefficient\n    maxNonZero := 0\n    for _, coeff := range xs {\n        if coeff != 0 {\n            if abs(coeff) > abs(maxNonZero) {\n                maxNonZero = coeff\n            }\n        }\n    }\n    // find zero\n    x := 1.0\n    for i := 0; i < 100; i++ {\n        y := Poly(xs, x)\n        if abs(y) < 1e-6 {\n            return x\n        }\n        x = x - y / Poly(xs[1:], x)\n    }\n    panic(\"can't find zero\")\n}\nfunc abs(x int) float64 {\n    if x < 0 {\n        return -float64(x)\n    }\n    return float64(x)\n}\n"}
{"task_id": "Go/33", "generation": "\n    // Create a new slice to store the result\n    result := make([]int, len(l))\n    \n    // Iterate over the indices of the input slice\n    for i := range l {\n        // Check if the index is divisible by 3\n        if i%3 == 0 {\n            // If it is, copy the value from the input slice to the result slice\n            result[i] = l[i]\n        } else {\n            // If it's not, copy the value from the input slice to the result slice, but sort the values at this index\n            // We use the sort.Ints function to sort the values\n            sort.Ints(l[i:i+1])\n            result[i] = l[i]\n        }\n    }\n    \n    // Return the result slice\n    return result\n}\n"}
{"task_id": "Go/34", "generation": "\n    // Create a map to store unique elements\n    m := make(map[int]bool)\n    // Create a slice to store unique elements\n    unique := make([]int, 0)\n    // Iterate over the list\n    for _, v := range l {\n        // If the element is not in the map, add it to the map and the slice\n        if !m[v] {\n            m[v] = true\n            unique = append(unique, v)\n        }\n    }\n    // Sort the slice\n    sort.Ints(unique)\n    return unique\n}\n"}
{"task_id": "Go/35", "generation": "\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n"}
{"task_id": "Go/36", "generation": "\n\tvar count int\n\tfor i := 1; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tif strings.Contains(strconv.Itoa(i), \"7\") {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n"}
{"task_id": "Go/37", "generation": "\n\t// Create a copy of the input list\n\tlCopy := make([]int, len(l))\n\tcopy(lCopy, l)\n\n\t// Sort the even indicies of the list\n\tsort.Slice(lCopy, func(i, j int) bool {\n\t\tif i%2 == 0 && j%2 == 0 {\n\t\t\treturn lCopy[i] < lCopy[j]\n\t\t}\n\t\treturn false\n\t})\n\n\treturn lCopy\n}\n\n"}
{"task_id": "Go/38", "generation": "\n    groups := strings.Split(s, \"\")\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(group[1]) + string(group[0]) + string(group[2]))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}\n\n"}
{"task_id": "Go/39", "generation": "\n\tfib := Fibonacci(n)\n\tfor i := 2; i <= int(math.Sqrt(float64(fib))); i++ {\n\t\tif fib%i == 0 {\n\t\t\treturn PrimeFib(n - 1)\n\t\t}\n\t}\n\treturn fib\n}\n"}
{"task_id": "Go/40", "generation": "\n\tsort.Ints(l)\n\tfor i := 0; i < len(l)-2; i++ {\n\t\tif i > 0 && l[i] == l[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tleft, right := i+1, len(l)-1\n\t\tfor left < right {\n\t\t\tsum := l[i] + l[left] + l[right]\n\t\t\tif sum == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif sum < 0 {\n\t\t\t\tleft++\n\t\t\t} else {\n\t\t\t\tright--\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n"}
{"task_id": "Go/41", "generation": "\n    // The number of cars moving left to right is n\n    leftCars := n\n    // The number of cars moving right to left is also n\n    rightCars := n\n    // The number of collisions is the sum of the number of cars moving left to right and the number of cars moving right to left\n    // This is because each car moving left to right will collide with each car moving right to left\n    collisions := leftCars + rightCars\n    // Return the total number of collisions\n    return collisions\n}\n\n"}
{"task_id": "Go/42", "generation": "\n    for i := range l {\n        l[i]++\n    }\n    return l\n}\n"}
{"task_id": "Go/43", "generation": "\n    // Create a set to store the elements we have seen so far\n    seen := make(map[int]bool)\n    for _, num := range l {\n        // If the negation of the current number is in the set, return True\n        if seen[-num] {\n            return true\n        }\n        // Otherwise, add the current number to the set\n        seen[num] = true\n    }\n    // If we have iterated over the entire list and haven't found a pair that sums to zero, return False\n    return false\n}\n"}
{"task_id": "Go/44", "generation": "\n    // Convert the number to a string\n    str := strconv.Itoa(x)\n    \n    // Initialize an empty string to store the result\n    result := \"\"\n    \n    // Loop through the string from right to left\n    for i := len(str) - 1; i >= 0; i-- {\n        // Convert the current character to an integer\n        digit := int(str[i] - '0')\n        \n        // Convert the digit to the new base\n        newDigit := digit % base\n        \n        // Add the new digit to the result\n        result = strconv.Itoa(newDigit) + result\n    }\n    \n    // Return the result\n    return result\n}\n\n"}
{"task_id": "Go/45", "generation": "\n    return 0.5 * a * h\n}\n"}
{"task_id": "Go/46", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 || n == 2 {\n        return 2\n    }\n    a, b := 0, 2\n    for i := 3; i <= n; i++ {\n        a, b = b, (a + b) % 3\n    }\n    return b\n} // Time complexity: O(n), Space complexity: O(1)\n"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64((l[n/2-1] + l[n/2]) / 2)\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}\n"}
{"task_id": "Go/48", "generation": "\n    // Reverse the string\n    reversed := ReverseString(text)\n    // Compare the original and reversed strings\n    return text == reversed\n}\n"}
{"task_id": "Go/49", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n%2 == 0 {\n        return Modp(n/2,p)*Modp(n/2,p)%p\n    } else {\n        return (Modp(n-1,p)*Modp(1,p)+Modp(n/2,p)*Modp(n/2,p))%p\n    }\n}\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-'a'+26)%26+'a')\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/51", "generation": "\n    // Create a regular expression that matches any vowel\n    vowelRegex := regexp.MustCompile(\"[aeiouAEIOU]\")\n\n    // Use the ReplaceAllString function to replace all vowels with an empty string\n    return vowelRegex.ReplaceAllString(text, \"\")\n}\n\n"}
{"task_id": "Go/52", "generation": "\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/53", "generation": "\n    return x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n    if len(s0) != len(s1) {\n        return false\n    }\n    for i := 0; i < len(s0); i++ {\n        if s0[i] != s1[i] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/55", "generation": "\n    if n <= 1 {\n        return n\n    }\n    return Fib(n-1) + Fib(n-2)\n}\n"}
{"task_id": "Go/56", "generation": "\n    stack := make([]rune, 0)\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/57", "generation": "\n    // Check if list is empty\n    if len(l) == 0 {\n        return true\n    }\n    // Check if list is monotonically increasing\n    increasing := true\n    for i := 1; i < len(l); i++ {\n        if l[i] < l[i-1] {\n            increasing = false\n            break\n        }\n    }\n    // Check if list is monotonically decreasing\n    decreasing := true\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n            break\n        }\n    }\n    // Return True if list is either monotonically increasing or decreasing\n    return increasing || decreasing\n} "}
{"task_id": "Go/58", "generation": "\n    // Convert the lists to sets\n    set1 := make(map[int]bool)\n    set2 := make(map[int]bool)\n    for _, v := range l1 {\n        set1[v] = true\n    }\n    for _, v := range l2 {\n        set2[v] = true\n    }\n    // Find the intersection of the two sets\n    intersection := make(map[int]bool)\n    for k := range set1 {\n        if set2[k] {\n            intersection[k] = true\n        }\n    }\n    // Convert the intersection back to a list and sort it\n    var result []int\n    for k := range intersection {\n        result = append(result, k)\n    }\n    sort.Ints(result)\n    return result\n}\n"}
{"task_id": "Go/59", "generation": "\n    // Start with the smallest prime number\n    i := 2\n    // Loop until we find a prime factor\n    for n%i == 0 {\n        // If n is divisible by i, then i is a prime factor\n        return i\n    }\n    // If n is not divisible by i, then increment i\n    i++\n    // Repeat the process until we find a prime factor\n    for i < n {\n        // Check if i is a prime factor\n        if n%i == 0 {\n            // If i is a prime factor, return it\n            return i\n        }\n        // If i is not a prime factor, increment it\n        i++\n    }\n    // If we have checked all numbers up to n and found no prime factors, then n is a prime number\n    return n\n}\n"}
{"task_id": "Go/60", "generation": "\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n"}
{"task_id": "Go/61", "generation": "\n    // Create a stack to store the opening brackets\n    var stack []rune\n    // Iterate over each character in the string\n    for _, char := range brackets {\n        // If the character is an opening bracket, push it onto the stack\n        if char == '(' {\n            stack = append(stack, char)\n        }\n        // If the character is a closing bracket, check if the stack is empty\n        else if char == ')' {\n            // If the stack is empty, return False because there's no corresponding opening bracket\n            if len(stack) == 0 {\n                return false\n            }\n            // If the stack is not empty, pop the opening bracket from the stack\n            else {\n                stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    // After iterating over the entire string, if the stack is empty, return True because every opening bracket has a corresponding closing bracket\n    // If the stack is not empty, return False because there are some opening brackets without corresponding closing brackets\n    return len(stack) == 0\n} \n\n"}
{"task_id": "Go/62", "generation": "\n    if len(xs) == 0 {\n        return nil\n    }\n    if len(xs) == 1 {\n        return nil\n    }\n    result := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        result[i-1] = i * xs[i]\n    }\n    return result\n}\n"}
{"task_id": "Go/63", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    a, b := 0, 0\n    for i := 3; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n} // fibfib\n"}
{"task_id": "Go/64", "generation": "\n    // Convert the string to lower case\n    s = strings.ToLower(s)\n    // Initialize a counter for the vowels\n    count := 0\n    // Loop through each character in the string\n    for _, char := range s {\n        // Check if the character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // If it is, increment the counter\n            count++\n        }\n    }\n    // Return the count\n    return count\n}\n\n"}
{"task_id": "Go/65", "generation": "\n    // Convert the integer to a string\n    str := strconv.Itoa(x)\n    // Calculate the effective shift\n    effectiveShift := shift % len(str)\n    // Split the string into two parts\n    firstPart := str[:len(str)-effectiveShift]\n    secondPart := str[len(str)-effectiveShift:]\n    // Combine the two parts in reverse order\n    result := secondPart + firstPart\n    // Return the result as a string\n    return result\n}\n\n"}
{"task_id": "Go/66", "generation": "\n    var sum int\n    for _, r := range x {\n        if unicode.IsUpper(r) {\n            sum += int(r)\n        }\n    }\n    return sum\n} // Digitsum\n"}
{"task_id": "Go/67", "generation": "\n\t// split the string into two parts\n\tparts := strings.Split(s,\"and\")\n\t// split the first part into two parts\n\tparts1 := strings.Split(parts[0],\" \")\n\t// split the second part into two parts\n\tparts2 := strings.Split(parts[1],\" \")\n\t// convert the first part to int\n\tnum1, _ := strconv.Atoi(parts1[0])\n\t// convert the second part to int\n\tnum2, _ := strconv.Atoi(parts2[0])\n\t// return the difference between the two numbers\n\treturn n - num1 - num2\n}  // 8\n"}
{"task_id": "Go/68", "generation": "\n    // Initialize the smallest even value and its index\n    smallestEvenValue := math.MaxInt32\n    smallestEvenIndex := -1\n\n    // Iterate over the array\n    for i, value := range arr {\n        // Check if the value is even\n        if value%2 == 0 {\n            // If the value is smaller than the current smallest even value, update the smallest even value and its index\n            if value < smallestEvenValue {\n                smallestEvenValue = value\n                smallestEvenIndex = i\n            }\n            // If the value is equal to the current smallest even value, update the smallest even index if the current index is smaller\n            else if value == smallestEvenValue {\n                smallestEvenIndex = i\n            }\n        }\n    }\n\n    // If there are no even values, return an empty array\n    if smallestEvenIndex == -1 {\n        return []int{}\n    }\n    // Otherwise, return the smallest even value and its index\n    return []int{smallestEvenValue, smallestEvenIndex}\n}"}
{"task_id": "Go/69", "generation": "\n    // Create a map to store the frequency of each integer\n    freq := make(map[int]int)\n    for _, num := range lst {\n        freq[num]++\n    }\n    // Initialize the maximum integer and its frequency\n    maxInt := 0\n    maxFreq := 0\n    for num, count := range freq {\n        // If the frequency of the current integer is greater than or equal to the value of the integer itself\n        if count >= num {\n            // Update the maximum integer and its frequency\n            if num > maxInt {\n                maxInt = num\n                maxFreq = count\n            }\n        }\n    }\n    // If no such integer exists, return -1\n    if maxInt == 0 {\n        return -1\n    }\n    // Return the maximum integer\n    return maxInt\n} \n"}
{"task_id": "Go/70", "generation": "\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i] < lst[j]\n    })\n    result := []int{}\n    for i := 0; i < len(lst); i++ {\n        result = append(result, lst[i])\n        if i < len(lst)-1 {\n            for j := i + 1; j < len(lst); j++ {\n                if lst[j] > lst[i] {\n                    result = append(result, lst[j])\n                    lst = append(lst[:j], lst[j+1:]...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/71", "generation": "\n    // Check if the three sides form a valid triangle\n    if a+b > c && a+c > b && b+c > a {\n        // Calculate the semi-perimeter\n        s := (a + b + c) / 2\n        // Calculate the area using Heron's formula\n        area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n        // Return the area rounded to 2 decimal points\n        return math.Round(area*100) / 100\n    } else {\n        // Return -1 if the three sides do not form a valid triangle\n        return -1\n    }\n} \n\n"}
{"task_id": "Go/72", "generation": "\n    // Check if the list is a palindrome\n    for i := 0; i < len(q)/2; i++ {\n        if q[i] != q[len(q)-1-i] {\n            return false\n        }\n    }\n    // Check if the sum of the list is less than the maximum possible weight\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n"}
{"task_id": "Go/73", "generation": "\n    // Create a map to store the frequency of each number\n    freq := make(map[int]int)\n    for _, num := range arr {\n        freq[num]++\n    }\n    // Count the number of elements that need to be changed\n    changes := 0\n    for _, count := range freq {\n        // If the count is odd, we need to change one element\n        if count%2 != 0 {\n            changes++\n        }\n        // If the count is even, we can change two elements\n        changes += count / 2\n    }\n    return changes\n}\n"}
{"task_id": "Go/74", "generation": "\n    // Calculate the total number of characters in each list\n    total1 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n    }\n    total2 := 0\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n    // Compare the totals and return the list with the smaller total\n    if total1 < total2 {\n        return lst1\n    } else if total1 > total2 {\n        return lst2\n    } else {\n        return lst1\n    }\n} \n"}
{"task_id": "Go/75", "generation": "\n    // Check if the number is less than 100\n    if a < 100 {\n        return false\n    }\n\n    // Check if the number is a multiple of 3\n    if a%3 == 0 {\n        return true\n    }\n\n    // Check if the number is a multiple of 5\n    if a%5 == 0 {\n        return true\n    }\n\n    // If the number is not a multiple of 3 or 5, return false\n    return false\n}\n"}
{"task_id": "Go/76", "generation": "\n    // Check if x is a power of n\n    if math.Pow(float64(n), float64(int(math.Log(float64(x))/math.Log(float64(n))))) == float64(x) {\n        return true\n    }\n    return false\n}\n\nfunc IsSimplePower(x int, n int, precision int) bool {\n    // Check if x is a power of n\n    if math.Pow(float64(n), float64(int(math.Log(float64(x))/math.Log(float64(n))))) == float64(x) {\n        return true\n    }\n    return false\n}\n"}
{"task_id": "Go/77", "generation": "\n    // We need to find the cube root of the number\n    // We can use the math library to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube root of a number is the number that, when cubed, equals the original number\n    // We can use the math.Pow function to find the cube root\n    // The cube"}
{"task_id": "Go/78", "generation": "\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    count := 0\n    for _, hex := range num {\n        switch hex {\n        case '2', '3', '5', '7':\n            for _, prime := range primes {\n                if hex == byte(prime) {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n} // end of function HexKey\n"}
{"task_id": "Go/79", "generation": "\n\t// Convert the decimal number to binary and remove the \"0b\" prefix\n\tbinary := fmt.Sprintf(\"%b\", decimal)\n\t// Add the extra characters \"db\" at the beginning and at the end of the string\n\treturn \"db\" + binary + \"db\"\n}\n\n"}
{"task_id": "Go/80", "generation": "\n    if len(s) <= 3 {\n        return true\n    }\n    for i := 0; i < len(s)-3; i++ {\n        if s[i] == s[i+1] && s[i+1] == s[i+2] && s[i+2] == s[i+3] {\n            return false\n        }\n    }\n    return true\n} // is_happy\n\n"}
{"task_id": "Go/81", "generation": "\n    var letterGrades []string\n    for _, g := range grades {\n        if g >= 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if g >= 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if g >= 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if g >= 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if g >= 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if g >= 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if g >= 1.7 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if g >= 1.3 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if g >= 1.0 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if g >= 0.7 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if g >= 0.3 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if g >= 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}\n\n"}
{"task_id": "Go/82", "generation": "\n    // First, we need to get the length of the string\n    length := len(s)\n    \n    // We'll use a helper function to check if a number is prime\n    def isPrime(n int) bool {\n        // A prime number must be greater than 1\n        if n <= 1 {\n            return false\n        }\n        \n        // Check from 2 to n-1 to see if n has any divisors\n        for i := 2; i < n; i++ {\n            if n % i == 0 {\n                return false\n            }\n        }\n        \n        // If we've checked all the way up to n-1 and haven't found any divisors, n is prime\n        return true\n    }\n    \n    // Now we can use our helper function to check if the string length is prime\n    return isPrime(length)\n}\n"}
{"task_id": "Go/83", "generation": "\n    // The number of n-digit numbers that start with 1 is 9^(n-1)\n    // The number of n-digit numbers that end with 1 is 9^(n-1)\n    // The number of n-digit numbers that start and end with 1 is 9^(n-2)\n    // So the total number of n-digit numbers that start or end with 1 is\n    // 2*9^(n-1) - 9^(n-2)\n    return 2 * int(math.Pow(9, float64(n-1))) - int(math.Pow(9, float64(n-2)))\n} \n"}
{"task_id": "Go/84", "generation": "\n    // Convert N to binary and remove the \"0b\" prefix\n    binary := strconv.FormatInt(int64(N), 2)\n    // Initialize sum to 0\n    sum := 0\n    // Iterate over each character in the binary string\n    for _, char := range binary {\n        // Convert the character to an integer and add it to the sum\n        sum += int(char - '0')\n    }\n    // Convert the sum to binary and return it\n    return strconv.FormatInt(int64(sum), 2)\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 1 && v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/86", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    // Sort the words based on their ASCII values\n    sort.Slice(words, func(i, j int) bool {\n        return strings.Compare(words[i], words[j]) < 0\n    })\n    // Sort the characters in each word\n    for i := range words {\n        sort.Slice(words[i], func(i, j int) bool {\n            return words[i][i] < words[i][j]\n        })\n    }\n    // Join the words back into a string\n    return strings.Join(words, \" \")\n}\n\n"}
{"task_id": "Go/87", "generation": "\n    var res [][]int\n    for i, row := range lst {\n        for j, v := range row {\n            if v == x {\n                res = append(res, []int{i, j})\n            }\n        }\n    }\n    sort.Slice(res, func(i, j int) bool {\n        if res[i][0] != res[j][0] {\n            return res[i][0] < res[j][0]\n        }\n        return res[i][1] > res[j][1]\n    })\n    return res\n}\n"}
{"task_id": "Go/88", "generation": "\n    // Check if the array is empty\n    if len(array) == 0 {\n        return array\n    }\n\n    // Check if the array has only one element\n    if len(array) == 1 {\n        return array\n    }\n\n    // Check if the sum of the first and last element is odd\n    if array[0]+array[len(array)-1] % 2 == 1 {\n        // Sort the array in ascending order\n        sort.Ints(array)\n    } else {\n        // Sort the array in descending order\n        sort.Ints(array)\n        // Reverse the array\n        reverse(array)\n    }\n\n    return array\n}\n"}
{"task_id": "Go/89", "generation": "\n    // Convert the string to a byte slice\n    b := []byte(s)\n    // Create a new byte slice to store the encrypted string\n    encrypted := make([]byte, len(b))\n    // Iterate over the byte slice\n    for i, v := range b {\n        // Check if the character is a letter\n        if v >= 'a' && v <= 'z' {\n            // Calculate the new position of the character\n            newPosition := (int(v - 'a') + 2*2) % 26\n            // Add the encrypted character to the encrypted byte slice\n            encrypted[i] = byte('a' + newPosition)\n        } else if v >= 'A' && v <= 'Z' {\n            // Calculate the new position of the character\n            newPosition := (int(v - 'A') + 2*2) % 26\n            // Add the encrypted character to the encrypted byte slice\n            encrypted[i] = byte('A' + newPosition)\n        } else {\n            // If the character is not a letter, add it to the encrypted byte slice as is\n            encrypted[i] = v\n        }\n    }\n    // Convert the encrypted byte slice to a string and return it\n    return string(encrypted)\n}\n\n"}
{"task_id": "Go/90", "generation": "\n    // Check if the list is empty\n    if len(lst) == 0 {\n        return nil\n    }\n\n    // Sort the list in ascending order\n    sort.Ints(lst)\n\n    // Check if the list has at least two elements\n    if len(lst) < 2 {\n        return nil\n    }\n\n    // Return the second smallest element\n    return lst[1]\n}\n\n"}
{"task_id": "Go/91", "generation": "\n    // Split the string into sentences\n    sentences := regexp.MustCompile(`[.!?]`).Split(S, -1)\n    // Count the number of sentences\n    return len(sentences)\n}\n\n"}
{"task_id": "Go/92", "generation": "\n\t// Check if all numbers are integers\n\tif !IsInt(x) || !IsInt(y) || !IsInt(z) {\n\t\treturn false\n\t}\n\t// Check if any of the numbers is equal to the sum of the other two\n\tif x == y+z || y == x+z || z == x+y {\n\t\treturn true\n\t}\n\treturn false\n}\n"}
{"task_id": "Go/93", "generation": "\n    // Convert the message to lowercase\n    message = strings.ToLower(message)\n    \n    // Initialize an empty string to store the encoded message\n    encodedMessage := \"\"\n    \n    // Iterate over each character in the message\n    for i := 0; i < len(message); i++ {\n        // Get the ASCII value of the character\n        charCode := int(message[i])\n        \n        // Check if the character is a vowel\n        if charCode >= 97 && charCode <= 101 || charCode >= 105 && charCode <= 109 || charCode >= 111 && charCode <= 115 {\n            // Calculate the ASCII value of the character 2 places ahead in the alphabet\n            newCharCode := charCode + 2\n            \n            // If the new character is a vowel, add 1 to its ASCII value\n            if newCharCode >= 97 && newCharCode <= 101 || newCharCode >= 105 && newCharCode <= 109 || newCharCode >= 111 && newCharCode <= 115 {\n                newCharCode += 1\n            }\n            \n            // Convert the new ASCII value back to a character and add it to the encoded message\n            encodedMessage += string(newCharCode)\n        } else {\n            // If the character is not a vowel, swap its case and add it to the encoded message\n            if message[i] >= 'a' && message[i] <= 'z' {\n                encodedMessage += string(message[i] - 32)\n            } else {\n                encodedMessage += string(message[i] + 32)\n            }\n        }\n    }\n    \n    // Return the encoded message\n    return encodedMessage\n} \n\n"}
{"task_id": "Go/94", "generation": "\n    // Find the maximum value in the list\n    max := math.MaxInt\n    for _, v := range lst {\n        if v > max {\n            max = v\n        }\n    }\n    // Check if the max value is prime\n    isPrime := true\n    for i := 2; i < max; i++ {\n        if max%i == 0 {\n            isPrime = false\n            break\n        }\n    }\n    if !isPrime {\n        // If max is not prime, find the next prime number\n        for i := max + 1; i < math.MaxInt; i++ {\n            isPrime = true\n            for j := 2; j < i; j++ {\n                if i%j == 0 {\n                    isPrime = false\n                    break\n                }\n            }\n            if isPrime {\n                max = i\n                break\n            }\n        }\n    }\n    // Calculate the sum of the digits of the max value\n    sum := 0\n    for _, v := range strconv.Itoa(max) {\n        sum += int(v - '0')\n    }\n    return sum\n} "}
{"task_id": "Go/95", "generation": "\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n\n    // Get all keys from the dictionary\n    keys := make([]string, 0, len(dict))\n    for k := range dict {\n        keys = append(keys, k.(string))\n    }\n\n    // Check if all keys are in lower case or all keys are in upper case\n    for _, key := range keys {\n        if !strings.EqualFold(key, strings.ToLower(key)) && !strings.EqualFold(key, strings.ToUpper(key)) {\n            return false\n        }\n    }\n\n    return true\n}\n"}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n} // CountUpTo\n\n"}
{"task_id": "Go/97", "generation": "\n    // Get the unit digit of a\n    unitDigitA := a % 10\n    // Get the unit digit of b\n    unitDigitB := b % 10\n    // Calculate the unit digit of the product\n    unitDigitProduct := (unitDigitA * unitDigitB) % 10\n    // Return the unit digit of the product\n    return unitDigitProduct\n} \n\n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for i, r := range s {\n        if i%2 == 0 && strings.ToUpper(string(r)) == \"A\" || strings.ToUpper(string(r)) == \"E\" || strings.ToUpper(string(r)) == \"I\" || strings.ToUpper(string(r)) == \"O\" || strings.ToUpper(string(r)) == \"U\" {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/99", "generation": "\n    // Convert the string to a float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n\n    // Round the number to the nearest integer\n    roundedNum := math.Round(num)\n\n    // If the number is equidistant from two integers, round away from zero\n    if num-math.Floor(num) == math.Ceil(num)-num {\n        if roundedNum == math.Floor(num) {\n            roundedNum = math.Ceil(num)\n        }\n    }\n\n    // Convert the rounded number to an integer\n    result := int(roundedNum)\n\n    return result\n}\n\n"}
{"task_id": "Go/100", "generation": "\n    pile := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i%2 == 0 {\n            pile[i] = i + 2\n        } else {\n            pile[i] = i + 1\n        }\n    }\n    return pile\n}\n"}
{"task_id": "Go/101", "generation": "\n    // Remove all commas from the string\n    s = strings.ReplaceAll(s, \",\", \" \")\n    // Split the string into words\n    words := strings.Split(s, \" \")\n    // Return the array of words\n    return words\n}\n\n"}
{"task_id": "Go/102", "generation": "\n    // Check if y is even\n    if y%2 == 0 {\n        // If y is even, return y\n        return y\n    } else {\n        // If y is odd, return -1\n        return -1\n    }\n}\n\n"}
{"task_id": "Go/103", "generation": "\n    // Check if n is greater than m\n    if n > m {\n        return -1\n    }\n\n    // Calculate the sum of the integers from n to m\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n\n    // Calculate the average\n    avg := sum / (m - n + 1)\n\n    // Round the average to the nearest integer\n    roundedAvg := math.Round(float64(avg))\n\n    // Convert the rounded average to binary\n    binary := fmt.Sprintf(\"%b\", int(roundedAvg))\n\n    return binary\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    // Filter the list to only include numbers with even digits\n    evenDigits := make([]int, 0)\n    for _, num := range x {\n        hasEvenDigit := false\n        for _, digit := range strconv.Itoa(num) {\n            if digit == '0' || digit == '2' || digit == '4' || digit == '6' || digit == '8' {\n                hasEvenDigit = true\n                break\n            }\n        }\n        if hasEvenDigit {\n            evenDigits = append(evenDigits, num)\n        }\n    }\n    // Sort the list in increasing order\n    sort.Ints(evenDigits)\n    return evenDigits\n}\n\n"}
{"task_id": "Go/105", "generation": "\n    var result []string\n    var sorted []int\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            sorted = append(sorted, num)\n        }\n    }\n    sort.Ints(sorted)\n    for i := len(sorted) - 1; i >= 0; i-- {\n        switch sorted[i] {\n        case 1:\n            result = append(result, \"One\")\n        case 2:\n            result = append(result, \"Two\")\n        case 3:\n            result = append(result, \"Three\")\n        case 4:\n            result = append(result, \"Four\")\n        case 5:\n            result = append(result, \"Five\")\n        case 6:\n            result = append(result, \"Six\")\n        case 7:\n            result = append(result, \"Seven\")\n        case 8:\n            result = append(result, \"Eight\")\n        case 9:\n            result = append(result, \"Nine\")\n        }\n    }\n    return result\n} \n\n"}
{"task_id": "Go/106", "generation": "\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i%2 == 0 {\n            factorial := 1\n            for j := 1; j <= i; j++ {\n                factorial *= j\n            }\n            result[i] = factorial\n        } else {\n            sum := 0\n            for j := 1; j <= i; j++ {\n                sum += j\n            }\n            result[i] = sum\n        }\n    }\n    return result\n} \n"}
{"task_id": "Go/107", "generation": "\n    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        str := strconv.Itoa(i)\n        if str == reverse(str) {\n            if i%2 == 0 {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n    return [2]int{even, odd}\n}\n\nfunc reverse(s string) string {\n    run := len(s) - 1\n    res := \"\"\n    for run >= 0 {\n        res += string(s[run])\n        run--\n    }\n    return res\n} \n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            num = -num\n        }\n        sum := 0\n        for _, digit := range strconv.Itoa(num) {\n            sum += int(digit - '0')\n        }\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/109", "generation": "\n    // If the array is empty, return true\n    if len(arr) == 0 {\n        return true\n    }\n\n    // Sort the array in ascending order\n    sort.Ints(arr)\n\n    // Initialize a variable to store the number of right shifts\n    rightShifts := 0\n\n    // Iterate over the array to find the number of right shifts\n    for i := 0; i < len(arr)-1; i++ {\n        // If the current element is greater than the next element, increment the right shifts\n        if arr[i] > arr[i+1] {\n            rightShifts++\n        }\n    }\n\n    // If the number of right shifts is equal to the length of the array minus one, return false\n    if rightShifts == len(arr)-1 {\n        return false\n    }\n\n    // Return true\n    return true\n}\n\n"}
{"task_id": "Go/110", "generation": "\n    // Check if all elements in lst1 are even\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\n"}
{"task_id": "Go/111", "generation": "\n    // Create a map to store the frequency of each character\n    freq := make(map[rune]int)\n    // Split the string into a slice of characters\n    for _, char := range strings.Split(test, \" \") {\n        // Increment the frequency of the character\n        freq[rune(char[0])]++\n    }\n    // Find the maximum frequency\n    maxFreq := 0\n    for _, freq := range freq {\n        if freq > maxFreq {\n            maxFreq = freq\n        }\n    }\n    // Create a new map to store the characters with the maximum frequency\n    maxFreqChars := make(map[rune]int)\n    for char, freq := range freq {\n        if freq == maxFreq {\n            maxFreqChars[char] = freq\n        }\n    }\n    return maxFreqChars\n}\n\n"}
{"task_id": "Go/112", "generation": "\n    // Convert the string to a byte slice\n    b := []byte(s)\n    // Create a map to store the characters to be deleted\n    del := make(map[byte]bool)\n    // Iterate over the characters in the string\n    for _, v := range c {\n        // Add the character to the map\n        del[v] = true\n    }\n    // Create a new byte slice to store the result\n    res := make([]byte, 0, len(b))\n    // Iterate over the characters in the string\n    for _, v := range b {\n        // If the character is not in the map, add it to the result\n        if !del[v] {\n            res = append(res, v)\n        }\n    }\n    // Convert the result byte slice back to a string\n    result := string(res)\n    // Check if the result string is a palindrome\n    isPalindrome := strings.EqualFold(result, strings.Reverse(result))\n    // Return the result string and the palindrome check\n    return [2]interface{}{result, isPalindrome}\n}\n\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        count := 0\n        for _, r := range str {\n            if r%2 != 0 {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number %d odd elements in the string %d of the input.\", count, count))\n    }\n    return result\n}\n\n"}
{"task_id": "Go/114", "generation": "\n    // Initialize the minimum sum to be the first element of the array\n    minSum := nums[0]\n    // Initialize the current sum to be the first element of the array\n    currentSum := nums[0]\n    // Iterate over the array starting from the second element\n    for i := 1; i < len(nums); i++ {\n        // Update the current sum by adding the current element\n        currentSum += nums[i]\n        // Update the minimum sum if the current sum is smaller\n        if currentSum < minSum {\n            minSum = currentSum\n        }\n        // If the current sum is greater than 0, reset it to 0\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n    // Return the minimum sum\n    return minSum\n}\n"}
{"task_id": "Go/115", "generation": "\n    // \n    var total int\n    for _, row := range grid {\n        for _, v := range row {\n            total += v\n        }\n    }\n    // \n    return total / capacity\n}\n\n"}
{"task_id": "Go/116", "generation": "\n    // sort the array based on the number of ones in binary representation and decimal value\n    sort.Slice(arr, func(i, j int) bool {\n        // get the number of ones in binary representation\n        onesI := binaryCount(arr[i])\n        onesJ := binaryCount(arr[j])\n        \n        // if the number of ones is different, sort based on the number of ones\n        if onesI != onesJ {\n            return onesI < onesJ\n        }\n        \n        // if the number of ones is the same, sort based on the decimal value\n        return arr[i] < arr[j]\n    })\n    \n    return arr\n}\n"}
{"task_id": "Go/117", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    \n    // Initialize an empty slice to store the result\n    result := make([]string, 0)\n    \n    // Iterate over each word in the string\n    for _, word := range words {\n        // Convert the word to lowercase\n        lowerWord := strings.ToLower(word)\n        \n        // Count the number of consonants in the word\n        consonantCount := 0\n        for _, char := range lowerWord {\n            if char >= 'a' && char <= 'z' && char != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u' {\n                consonantCount++\n            }\n        }\n        \n        // If the word has exactly n consonants, add it to the result\n        if consonantCount == n {\n            result = append(result, word)\n        }\n    }\n    \n    // Return the result\n    return result\n}\n\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            for j := i - 1; j >= 0; j-- {\n                if !bytes.Contains(vowels, word[j]) {\n                    return string(word[i])\n                }\n            }\n        }\n    }\n    return \"\"\n}\n\n"}
{"task_id": "Go/119", "generation": "\n\t// Check if the first string has more open parentheses than close\n\tif countOpen(lst[0]) > countClose(lst[0]) {\n\t\t// If so, we need to move the open parentheses to the second string\n\t\tlst = swapStrings(lst)\n\t}\n\t// Check if the second string has more open parentheses than close\n\tif countOpen(lst[1]) > countClose(lst[1]) {\n\t\t// If so, we need to move the open parentheses to the first string\n\t\tlst = swapStrings(lst)\n\t}\n\t// Check if the strings can be concatenated in any order\n\tif canConcat(lst) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n"}
{"task_id": "Go/120", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    return arr[:k]\n}\n\nfunc Maximum2(arr []int, k int) []int {\n    return sort.IntSlice(arr[:k]).Reverse().Slice(0, k)\n} \n"}
{"task_id": "Go/121", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 0 && v%2 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/122", "generation": "\n    // Sort the array in ascending order\n    sort.Ints(arr)\n    \n    // Initialize the sum with the first k elements\n    sum := 0\n    for i := 0; i < k; i++ {\n        sum += arr[i]\n    }\n    \n    // Return the sum\n    return sum\n}\n\n"}
{"task_id": "Go/123", "generation": "\n    // Create a map to store the collatz sequence for each number\n    collatzMap := make(map[int][]int)\n    \n    // Function to generate the collatz sequence for a given number\n    func collatz(n int) []int {\n        // If the number is already in the map, return the stored sequence\n        if seq, ok := collatzMap[n]; ok {\n            return seq\n        }\n        \n        // If the number is even, the next number is half of it\n        if n%2 == 0 {\n            next := n / 2\n            return append(collatz(next), n)\n        }\n        \n        // If the number is odd, the next number is 3 times it plus 1\n        next := 3*n + 1\n        return append(collatz(next), n)\n    }\n    \n    // Generate the collatz sequence for the given number\n    seq := collatz(n)\n    \n    // Filter the sequence to get only the odd numbers\n    oddSeq := make([]int, 0)\n    for _, num := range seq {\n        if num%2 != 0 {\n            oddSeq = append(oddSeq, num)\n        }\n    }\n    \n    // Sort the odd sequence in increasing order\n    sort.Ints(oddSeq)\n    \n    return oddSeq\n} \n"}
{"task_id": "Go/124", "generation": "\n    // Check if the date string is empty\n    if len(date) == 0 {\n        return false\n    }\n\n    // Split the date string into month and day\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 2 {\n        return false\n    }\n\n    // Check if the month and day are numeric\n    if _, err := strconv.Atoi(parts[0]); err != nil || _, err = strconv.Atoi(parts[1]); err != nil {\n        return false\n    }\n\n    // Parse the month and day\n    month, _ := strconv.Atoi(parts[0])\n    day, _ := strconv.Atoi(parts[1])\n\n    // Check if the month is valid\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    // Check if the day is valid\n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        if day < 1 || day > 31 {\n            return false\n        }\n    case 4, 6, 9, 11:\n        if day < 1 || day > 30 {\n            return false\n        }\n    case 2:\n        if day < 1 || day > 29 {\n            return false\n        }\n    }\n\n    return true\n}\n\n"}
{"task_id": "Go/125", "generation": "\n    // Split the string on whitespace\n    words := strings.Fields(txt)\n    if len(words) == 1 && strings.Contains(txt, \",\") {\n        // Split the string on commas\n        words = strings.Split(txt, \",\")\n    }\n    // Check if the string contains any letters\n    if len(words) == 1 && !strings.ContainsAny(txt, \"abcdefghijklmnopqrstuvwxyz\") {\n        // Return the number of lower-case letters with odd order in the alphabet\n        count := 0\n        for i := 0; i < len(txt); i++ {\n            if txt[i] >= 'a' && txt[i] <= 'z' && (ord(txt[i])%2 == 1) {\n                count++\n            }\n        }\n        return count\n    }\n    // Return the list of words\n    return words\n}\n\nfunc ord(r rune) int {\n    return int(r - 'a')\n}\n"}
{"task_id": "Go/126", "generation": "\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        if lst[i] == lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/127", "generation": "\n    start := max(interval1[0], interval2[0])\n    end := min(interval1[1], interval2[1])\n    if start > end {\n        return \"NO\"\n    }\n    length := end - start\n    if isPrime(length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n} \n"}
{"task_id": "Go/128", "generation": "\n    // Check if the array is empty\n    if len(arr) == 0 {\n        return nil\n    }\n\n    // Initialize the product of signs to 1\n    product := 1\n\n    // Iterate over the array\n    for _, num := range arr {\n        // If the number is 0, the product of signs is 0\n        if num == 0 {\n            return 0\n        }\n        // If the number is negative, multiply the product by -1\n        if num < 0 {\n            product *= -1\n        }\n    }\n\n    // Return the product of signs multiplied by the sum of the absolute values of the numbers\n    return product * sumAbs(arr)\n}\n"}
{"task_id": "Go/129", "generation": "\n    m, n := len(grid), len(grid[0])\n    visited := make([][]bool, m)\n    for i := range visited {\n        visited[i] = make([]bool, n)\n    }\n    res := make([]int, k)\n    var dfs func(int, int, int)\n    dfs = func(x, y, step int) {\n        if step == k {\n            for i := 0; i < k; i++ {\n                res[i] = grid[x][y]\n            }\n            return\n        }\n        visited[x][y] = true\n        for i := -1; i <= 1; i++ {\n            for j := -1; j <= 1; j++ {\n                if i == 0 && j == 0 {\n                    continue\n                }\n                nx, ny := x+i, y+j\n                if nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] {\n                    dfs(nx, ny, step+1)\n                }\n            }\n        }\n        visited[x][y] = false\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            dfs(i, j, 0)\n            if res[0] != 0 {\n                return res\n            }\n        }\n    }\n    return nil\n}"}
{"task_id": "Go/130", "generation": "\n    if n == 0 {\n        return []float64{}\n    }\n    if n == 1 {\n        return []float64{1}\n    }\n    if n == 2 {\n        return []float64{1, 3}\n    }\n    if n == 3 {\n        return []float64{1, 3, 2}\n    }\n    if n == 4 {\n        return []float64{1, 3, 2, 8}\n    }\n    if n == 5 {\n        return []float64{1, 3, 2, 8, 21}\n    }\n    if n == 6 {\n        return []float64{1, 3, 2, 8, 21, 65}\n    }\n    if n == 7 {\n        return []float64{1, 3, 2, 8, 21, 65, 211}\n    }\n    if n == 8 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686}\n    }\n    if n == 9 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686, 2207}\n    }\n    if n == 10 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686, 2207, 7311}\n    }\n    if n == 11 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686, 2207, 7311, 24343}\n    }\n    if n == 12 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686, 2207, 7311, 24343, 80831}\n    }\n    if n == 13 {\n        return []float64{1, 3, 2, 8, 21, 65, 211, 686, 2207, 7311, 24343, 80831, 268970}\n    }\n    if n == 14 {\n        return []float64{1, 3, 2, 8, 21,"}
{"task_id": "Go/131", "generation": "\n    product := 1\n    for n > 0 {\n        digit := n % 10\n        if digit % 2 != 0 {\n            product *= digit\n        }\n        n /= 10\n    }\n    return product\n}\n\n"}
{"task_id": "Go/132", "generation": "\n    stack := make([]byte, 0)\n    for _, c := range s {\n        if c == '[' {\n            stack = append(stack, c)\n        } else if c == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) > 0\n}\r\n"}
{"task_id": "Go/133", "generation": "\n    // Round each element in the list to the upper int(Ceiling)\n    rounded := make([]int, len(lst))\n    for i, v := range lst {\n        rounded[i] = int(math.Ceil(v))\n    }\n    // Sum the squares of the rounded numbers\n    sum := 0\n    for _, v := range rounded {\n        sum += v * v\n    }\n    return sum\n} // SumSquares\n"}
{"task_id": "Go/134", "generation": "\n    // Remove all spaces from the string\n    txt = strings.ReplaceAll(txt, \" \", \"\")\n    // Check if the last character is a letter\n    return strings.HasSuffix(txt, string(rune(txt[len(txt)-1]))) && !strings.Contains(txt, string(rune(txt[len(txt)-1])))\n}\n\n"}
{"task_id": "Go/135", "generation": "\n    // Create a map to store the count of each element\n    countMap := make(map[int]int)\n    for _, num := range arr {\n        countMap[num]++\n    }\n    // Sort the array\n    sort.Ints(arr)\n    // Iterate over the array\n    for i := 0; i < len(arr); i++ {\n        // If the current element is greater than the previous one\n        if i > 0 && arr[i] > arr[i-1] {\n            // If the count of the current element is 1\n            if countMap[arr[i]] == 1 {\n                // Return the index of the current element\n                return i\n            }\n            // Decrement the count of the current element\n            countMap[arr[i]]--\n        }\n    }\n    // If no such element exists, return -1\n    return -1\n}\n\n"}
{"task_id": "Go/136", "generation": "\n    var maxNegative, minPositive int\n    for _, num := range lst {\n        if num < 0 {\n            if num > maxNegative {\n                maxNegative = num\n            }\n        } else if num > 0 {\n            if num < minPositive || minPositive == 0 {\n                minPositive = num\n            }\n        }\n    }\n    if maxNegative == 0 {\n        maxNegative = nil\n    }\n    if minPositive == 0 {\n        minPositive = nil\n    }\n    return [2]interface{}{maxNegative, minPositive}\n}\n\n"}
{"task_id": "Go/137", "generation": "\n    // Check if both inputs are of the same type\n    if reflect.TypeOf(a).Kind() != reflect.TypeOf(b).Kind() {\n        return nil\n    }\n\n    // Check if inputs are integers\n    if reflect.TypeOf(a).Kind() == reflect.Int {\n        // Convert inputs to integers\n        aInt, _ := strconv.Atoi(fmt.Sprint(a))\n        bInt, _ := strconv.Atoi(fmt.Sprint(b))\n        // Compare integers\n        if aInt > bInt {\n            return a\n        } else if aInt < bInt {\n            return b\n        } else {\n            return nil\n        }\n    }\n\n    // Check if inputs are floats\n    if reflect.TypeOf(a).Kind() == reflect.Float64 {\n        // Compare floats\n        if a.(float64) > b.(float64) {\n            return a\n        } else if a.(float64) < b.(float64) {\n            return b\n        } else {\n            return nil\n        }\n    }\n\n    // Check if inputs are strings\n    if reflect.TypeOf(a).Kind() == reflect.String {\n        // Remove commas from strings\n        aStr := strings.ReplaceAll(a.(string), \",\", \"\")\n        bStr := strings.ReplaceAll(b.(string), \",\", \"\")\n\n        // Compare strings\n        if aStr > bStr {\n            return a\n        } else if aStr < bStr {\n            return b\n        } else {\n            return nil\n        }\n    }\n\n    // If none of the above conditions are met, return nil\n    return nil\n} \n\n"}
{"task_id": "Go/138", "generation": "\n    // Create a map to store the count of each even number\n    evenCount := make(map[int]int)\n    // Iterate over all even numbers from 2 to n\n    for i := 2; i <= n; i += 2 {\n        // If the number is already in the map, increment its count\n        if _, ok := evenCount[i]; ok {\n            evenCount[i]++\n        } else {\n            // Otherwise, add it to the map with a count of 1\n            evenCount[i] = 1\n        }\n    }\n    // Initialize a variable to store the sum of counts\n    sum := 0\n    // Iterate over the map and add the counts to the sum\n    for _, count := range evenCount {\n        sum += count\n    }\n    // Return True if the sum of counts is 4, False otherwise\n    return sum == 4\n} \n"}
{"task_id": "Go/139", "generation": "\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= i\n    }\n    return result\n} // end of SpecialFactorial\n"}
{"task_id": "Go/140", "generation": "\n    // Replace all spaces with underscores\n    text = strings.ReplaceAll(text, \" \", \"_\")\n    \n    // Replace all consecutive spaces with a single space\n    text = strings.ReplaceAll(text, \"  \", \" \")\n    \n    // Replace all consecutive spaces with a single dash\n    text = strings.ReplaceAll(text, \"   \", \"-\")\n    \n    // Replace all consecutive spaces with a single dash\n    text = strings.ReplaceAll(text, \"  \", \"-\")\n    \n    // Replace all consecutive spaces with a single dash\n    text = strings.ReplaceAll(text, \" \", \"-\")\n    \n    return text\n}\n\n"}
{"task_id": "Go/141", "generation": "\n    // Check if the file name contains more than three digits\n    if strings.Count(file_name, \"0123456789\") > 3 {\n        return \"No\"\n    }\n    // Check if the file name contains exactly one dot\n    if strings.Count(file_name, \".\") != 1 {\n        return \"No\"\n    }\n    // Check if the substring before the dot is not empty and starts with a letter\n    if !strings.HasPrefix(file_name[:strings.Index(file_name, \".\")], \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n        return \"No\"\n    }\n    // Check if the substring after the dot is one of the allowed extensions\n    if !strings.HasSuffix(file_name, \"txt.exe.dll\") {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n"}
{"task_id": "Go/142", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v * v\n        } else if i%4 == 0 {\n            sum += int(math.Pow(float64(v), 3))\n        }\n    }\n    return sum\n} \n"}
{"task_id": "Go/143", "generation": "\n    // Split the sentence into words\n    words := strings.Split(sentence, \" \")\n    \n    // Filter the words whose lengths are prime numbers\n    var primeWords []string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            primeWords = append(primeWords, word)\n        }\n    }\n    \n    // Join the prime words into a string\n    return strings.Join(primeWords, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "Go/144", "generation": "\n    // Split the input strings into numerator and denominator\n    xNum, xDen := splitFraction(x)\n    nNum, nDen := splitFraction(n)\n\n    // Calculate the greatest common divisor of the numerators and denominators\n    gcdNum := gcd(xNum, nNum)\n    gcdDen := gcd(xDen, nDen)\n\n    // Simplify the fractions\n    simplifiedXNum := xNum / gcdNum\n    simplifiedXDen := xDen / gcdDen\n    simplifiedNNum := nNum / gcdNum\n    simplifiedNDen := nDen / gcdDen\n\n    // Check if the simplified fractions are whole numbers\n    if simplifiedXDen == 1 && simplifiedXNum > 0 {\n        return true\n    }\n    if simplifiedNDen == 1 && simplifiedNNum > 0 {\n        return true\n    }\n\n    // If the simplified fractions are not whole numbers, check if they are equal\n    if simplifiedXNum == simplifiedNNum && simplifiedXDen == simplifiedNDen {\n        return true\n    }\n\n    return false\n}\n"}
{"task_id": "Go/145", "generation": "\n    // Create a new slice of pairs, where each pair contains a number and its sum of digits\n    pairs := make([]struct{ num, sum int }, len(nums))\n    for i, num := range nums {\n        pairs[i].num = num\n        pairs[i].sum = sumOfDigits(num)\n    }\n\n    // Sort the pairs based on the sum of digits and the original index\n    sort.Slice(pairs, func(i, j int) bool {\n        if pairs[i].sum != pairs[j].sum {\n            return pairs[i].sum < pairs[j].sum\n        }\n        return i < j\n    })\n\n    // Return the sorted numbers\n    result := make([]int, len(pairs))\n    for i, pair := range pairs {\n        result[i] = pair.num\n    }\n    return result\n}\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        str := strconv.Itoa(num)\n        if num > 10 && str[0] == '1' && str[1] == '3' && str[2] == '5' && str[3] == '7' && str[4] == '9' {\n            count++\n        }\n    }\n    return count\n} \n\n"}
{"task_id": "Go/147", "generation": "\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i * i - i\n    }\n    count := 0\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n            for k := j + 1; k < n; k++ {\n                if a[i] + a[j] + a[k] % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n} \n"}
{"task_id": "Go/148", "generation": "\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if !contains(planets, planet1) || !contains(planets, planet2) {\n        return []string{}\n    }\n    i1, i2 := -1, -1\n    for k, v := range planets {\n        if v == planet1 {\n            i1 = k\n        }\n        if v == planet2 {\n            i2 = k\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n    }\n    return planets[i1+1 : i2]\n}\n\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/149", "generation": "\n    // First, filter the list to get only the strings with odd lengths\n    oddLengths := []string{}\n    for _, str := range lst {\n        if len(str) % 2 != 0 {\n            oddLengths = append(oddLengths, str)\n        }\n    }\n    // Then, sort the list of strings with odd lengths\n    sort.Slice(oddLengths, func(i, j int) bool {\n        return len(oddLengths[i]) < len(oddLengths[j])\n    })\n    return oddLengths\n}\n\n"}
{"task_id": "Go/150", "generation": "\n    // Check if n is a prime number\n    if isPrime(n) {\n        return x\n    } else {\n        return y\n    }\n}\n"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && math.Mod(num, 2) == 1 {\n            sum += int(num * num)\n        }\n    }\n    return sum\n}\n\n"}
{"task_id": "Go/152", "generation": "\n    res := make([]int, len(game))\n    for i := range game {\n        if game[i] == guess[i] {\n            res[i] = 0\n        } else {\n            res[i] = int(math.Abs(float64(guess[i]-game[i])))\n        }\n    }\n    return res\n}"}
{"task_id": "Go/153", "generation": "\n    // Calculate the strength of each extension\n    strengths := make(map[string]int)\n    for _, extension := range extensions {\n        // Count the number of uppercase and lowercase letters in the extension's name\n        capCount := 0\n        smCount := 0\n        for _, r := range extension {\n            if unicode.IsUpper(r) {\n                capCount++\n            } else if unicode.IsLower(r) {\n                smCount++\n            }\n        }\n        // Calculate the strength of the extension\n        strength := capCount - smCount\n        // Store the strength in the map\n        strengths[extension] = strength\n    }\n\n    // Find the strongest extension\n    strongestExtension := \"\"\n    maxStrength := math.MinInt\n    for extension, strength := range strengths {\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    // Return the class name with the strongest extension\n    return class_name + \".\" + strongestExtension\n} \n\n"}
{"task_id": "Go/154", "generation": "\n    // Check if the second word is a substring of the first word\n    if strings.Contains(a, b) {\n        return true\n    }\n    // If the second word is not a substring of the first word, check if any of its rotations is a substring\n    for i := 0; i < len(b); i++ {\n        // Rotate the second word by i positions\n        rotated := b[i:] + b[:i]\n        // Check if the rotated word is a substring of the first word\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    // If none of the rotations of the second word is a substring of the first word, return false\n    return false\n} "}
{"task_id": "Go/155", "generation": "\n    var even, odd int\n    for _, digit := range strconv.Itoa(num) {\n        n, _ := strconv.Atoi(string(digit))\n        if n%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n    }\n    return [2]int{even, odd}\n}\n\n"}
{"task_id": "Go/156", "generation": "\n    // Define the mapping of integers to their roman numeral equivalents\n    romanMap := map[int]string{\n        1:  \"i\",\n        4:  \"iv\",\n        5:  \"v\",\n        9:  \"ix\",\n        10: \"x\",\n        40: \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\",\n        400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000: \"m\",\n    }\n\n    // Initialize the result string\n    result := \"\"\n\n    // Loop through the map in descending order of integer values\n    for _, value := range sortedKeys(romanMap) {\n        // Calculate the number of times the current integer value fits into the number\n        count := number / value\n\n        // Subtract the value of the current integer times the count from the number\n        number -= count * value\n\n        // Append the corresponding roman numeral to the result string, repeated 'count' times\n        result += strings.Repeat(romanMap[value], count)\n    }\n\n    // Return the result string in lowercase\n    return strings.ToLower(result)\n}\n"}
{"task_id": "Go/157", "generation": "\n    // Check if the sum of the squares of the two shorter sides is equal to the square of the longest side\n    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a)\n}\n"}
{"task_id": "Go/158", "generation": "\n    maxWord := \"\"\n    maxUnique := 0\n    for _, word := range words {\n        unique := len([]rune(word))\n        if unique > maxUnique {\n            maxUnique = unique\n            maxWord = word\n        } else if unique == maxUnique {\n            if word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    return maxWord\n}\n\n"}
{"task_id": "Go/159", "generation": "\n    // Calculate the total number of carrots eaten after meals\n    totalEaten := number + need\n    \n    // Calculate the number of carrots left after meals\n    carrotsLeft := remaining - need\n    \n    // If there are not enough remaining carrots, eat all remaining carrots\n    if carrotsLeft < 0 {\n        carrotsLeft = 0\n    }\n    \n    // Return the total number eaten carrots after meals and the number carrots left after\n    return []int{totalEaten, carrotsLeft}\n} \n"}
{"task_id": "Go/160", "generation": "\n    // Check if the operator list is empty\n    if len(operator) == 0 {\n        return 0\n    }\n    // Check if the operand list is empty\n    if len(operand) == 0 {\n        return 0\n    }\n    // Check if the length of the operator list is equal to the length of the operand list minus one\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n    // Initialize the result with the first operand\n    result := operand[0]\n    // Iterate over the operator and operand lists\n    for i := 0; i < len(operator); i++ {\n        // Check the operator and perform the corresponding operation\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"/\":\n            result /= operand[i+1]\n        case \"//\":\n            result = result / operand[i+1]\n        default:\n            return 0\n        }\n    }\n    // Return the final result\n    return result\n}\n\n"}
{"task_id": "Go/161", "generation": "\n    var result string\n    for _, v := range s {\n        if unicode.IsLetter(rune(v)) {\n            if unicode.IsLower(rune(v)) {\n                result += string(unicode.ToTitle(rune(v)))\n            } else {\n                result += string(unicode.ToLower(rune(v)))\n            }\n        } else {\n            result += string(v)\n        }\n    }\n    return result\n} \n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hash := md5.New()\n    io.WriteString(hash, text)\n    return fmt.Sprintf(\"%x\", hash.Sum(nil))\n}\n\n"}
{"task_id": "Go/163", "generation": "\n    // Create a slice to hold the even numbers\n    evenNumbers := make([]int, 0)\n    \n    // Loop through all numbers from a to b\n    for i := a; i <= b; i++ {\n        // Check if the number is even\n        if i % 2 == 0 {\n            // If the number is even, add it to the slice\n            evenNumbers = append(evenNumbers, i)\n        }\n    }\n    \n    // Return the slice of even numbers\n    return evenNumbers\n}\n"}
