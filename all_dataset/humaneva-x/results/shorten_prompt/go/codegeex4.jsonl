{"task_id": "Go/0", "generation": "\n    for i := 0; i < len(numbers)-1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if math.Abs(numbers[i]-numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/1", "generation": "\n    // TODO: Implement this function\n    return nil\n}"}
{"task_id": "Go/2", "generation": "\n    return number - math.Floor(number)\n}\n"}
{"task_id": "Go/3", "generation": "\n    balance := 0\n    for _, operation := range operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/4", "generation": "\n    mean := Mean(numbers)\n    sum := 0.0\n    for _, number := range numbers {\n        sum += math.Abs(number - mean)\n    }\n    return sum / float64(len(numbers))\n}\n"}
{"task_id": "Go/5", "generation": "\n\tif len(numbers) == 0 {\n\t\treturn []int{}\n\t}\n\n\tresult := make([]int, 0, len(numbers)*2-1)\n\tresult = append(result, numbers[0])\n\n\tfor i := 1; i < len(numbers); i++ {\n\t\tresult = append(result, delimeter, numbers[i])\n\t}\n\n\treturn result\n}\n"}
{"task_id": "Go/6", "generation": "\n    var result []int\n    var max_depth int\n    var current_depth int\n\n    for _, group := range strings.Split(paren_string, \" \") {\n        max_depth = 0\n        current_depth = 0\n\n        for _, char := range group {\n            if char == '(' {\n                current_depth++\n                if current_depth > max_depth {\n                    max_depth = current_depth\n                }\n            } else if char == ')' {\n                current_depth--\n            }\n        }\n\n        result = append(result, max_depth)\n    }\n\n    return result\n}\n"}
{"task_id": "Go/7", "generation": "\n    var result []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/8", "generation": "\n\tsum := 0\n\tproduct := 1\n\tfor _, num := range numbers {\n\t\tsum += num\n\t\tproduct *= num\n\t}\n\treturn [2]int{sum, product}\n}"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt64\n    result := make([]int, 0, len(numbers))\n    for _, number := range numbers {\n        if number > max {\n            max = number\n        }\n        result = append(result, max)\n    }\n    return result\n}\n"}
{"task_id": "Go/10", "generation": "\n    runes := []rune(str)\n    for i := len(runes); i > 0; i-- {\n        if IsPalindrome(string(runes[i:])) {\n            return str + Reverse(string(runes[:i]))\n        }\n    }\n    return str\n}\n"}
{"task_id": "Go/11", "generation": "\n    if len(a) != len(b) {\n        panic(\"Strings must be of equal length\")\n    }\n\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\n    return result\n}\n\n"}
{"task_id": "Go/12", "generation": "\n\tif len(strings) == 0 {\n\t\treturn nil\n\t}\n\tlongest := strings[0]\n\tfor _, s := range strings {\n\t\tif len(s) > len(longest) {\n\t\t\tlongest = s\n\t\t}\n\t}\n\treturn longest\n}\n"}
{"task_id": "Go/13", "generation": "\n    if b == 0 {\n        return a\n    }\n    return GreatestCommonDivisor(b, a % b)\n}\n"}
{"task_id": "Go/14", "generation": "\n    var prefixes []string\n    for i := 0; i < len(str); i++ {\n        prefixes = append(prefixes, str[:i+1])\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    var str string\n    for i := 0; i <= n; i++ {\n        str += strconv.Itoa(i) + \" \"\n    }\n    return str[:len(str)-1]\n}\n"}
{"task_id": "Go/16", "generation": "\n    var count int\n    var distinctChars map[rune]bool = make(map[rune]bool)\n    for _, char := range str {\n        distinctChars[strings.ToLower(string(char))] = true\n    }\n    for _, _ = range distinctChars {\n        count++\n    }\n    return count\n}\n"}
{"task_id": "Go/17", "generation": "\n    // TODO: Implement this function\n    return nil\n}"}
{"task_id": "Go/18", "generation": "\n    return strings.Count(str, substring)\n}\n"}
{"task_id": "Go/19", "generation": "\n    // Convert the input string to a slice of strings\n    numSlice := strings.Split(numbers, \" \")\n\n    // Create a slice of integers to store the converted numbers\n    intSlice := make([]int, len(numSlice))\n\n    // Create a map to map the string numbers to their corresponding integer values\n    numMap := map[string]int{\n        \"zero\": 0,\n        \"one\":  1,\n        \"two\":  2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n\n    // Convert the string numbers to integers and store them in the intSlice\n    for i, num := range numSlice {\n        intSlice[i] = numMap[num]\n    }\n\n    // Sort the intSlice in ascending order\n    sort.Ints(intSlice)\n\n    // Create a slice of strings to store the sorted numbers\n    sortedNums := make([]string, len(intSlice))\n\n    // Convert the sorted integers back to strings and store them in the sortedNums slice\n    for i, num := range intSlice {\n        for key, value := range numMap {\n            if value == num {\n                sortedNums[i] = key\n            }\n        }\n    }\n\n    // Join the sortedNums slice into a single string with spaces between each number\n    sortedString := strings.Join(sortedNums, \" \")\n\n    return sortedString\n}\n"}
{"task_id": "Go/20", "generation": "\n    if len(numbers) < 2 {\n        return [2]float64{}\n    }\n    minDiff := math.MaxFloat64\n    result := [2]float64{}\n    for i := 0; i < len(numbers)-1; i++ {\n        diff := math.Abs(numbers[i] - numbers[i+1])\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = numbers[i]\n            result[1] = numbers[i+1]\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/21", "generation": "\n    min := numbers[0]\n    max := numbers[0]\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n    rescaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        rescaled[i] = (num - min) / (max - min)\n    }\n    return rescaled\n}"}
{"task_id": "Go/22", "generation": "\n\tvar result []int\n\tfor _, v := range values {\n\t\tif i, ok := v.(int); ok {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}"}
{"task_id": "Go/23", "generation": "\n\treturn len(str)\n}\n"}
{"task_id": "Go/24", "generation": "\n\tfor i := n - 1; i > 0; i-- {\n\t\tif n%i == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}\n"}
{"task_id": "Go/25", "generation": "\n    factors := []int{}\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            factors = append(factors, i)\n            n = n / i\n            i--\n        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n}\n"}
{"task_id": "Go/26", "generation": "\n    seen := make(map[int]bool)\n    result := make([]int, 0)\n    for _, num := range numbers {\n        if !seen[num] {\n            seen[num] = true\n            result = append(result, num)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/27", "generation": "\n    var result strings.Builder\n    for _, c := range str {\n        if c >= 'a' && c <= 'z' {\n            result.WriteRune(c - 'a' + 'A')\n        } else if c >= 'A' && c <= 'Z' {\n            result.WriteRune(c - 'A' + 'a')\n        } else {\n            result.WriteRune(c)\n        }\n    }\n    return result.String()\n}\n"}
{"task_id": "Go/28", "generation": "\n\treturn strings.Join(strings, \"\")\n}\n"}
{"task_id": "Go/29", "generation": "\n    var result []string\n    for _,s := range strings {\n        if strings.HasPrefix(s,prefix) {\n            result = append(result,s)\n        }\n    }\n    return result\n}"}
{"task_id": "Go/30", "generation": "\n    var positive []int\n    for _, v := range l {\n        if v > 0 {\n            positive = append(positive, v)\n        }\n    }\n    return positive\n}\n"}
{"task_id": "Go/31", "generation": "\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"task_id": "Go/32", "generation": "\n    if len(xs) % 2 != 0 {\n        panic(\"xs must have even number of coefficients\")\n    }\n    for _, coeff := range xs {\n        if coeff != 0 {\n            return float64(coeff)\n        }\n    }\n    panic(\"xs must have at least one non zero coefficient\")\n}\n"}
{"task_id": "Go/33", "generation": "\n    // Create a new slice to store the sorted values\n    sortedValues := make([]int, 0)\n\n    // Iterate over the input slice\n    for i, v := range l {\n        // Check if the index is divisible by three\n        if i%3 == 0 {\n            // Append the value to the sortedValues slice\n            sortedValues = append(sortedValues, v)\n        }\n    }\n\n    // Sort the sortedValues slice\n    sort.Ints(sortedValues)\n\n    // Iterate over the input slice again\n    for i, v := range l {\n        // Check if the index is divisible by three\n        if i%3 == 0 {\n            // Replace the value at the index with the corresponding value from the sortedValues slice\n            l[i] = sortedValues[i/3]\n        }\n    }\n\n    // Return the modified input slice\n    return l\n}\n"}
{"task_id": "Go/34", "generation": "\n    m := make(map[int]bool)\n    for _, item := range l {\n        if _, ok := m[item]; !ok {\n            m[item] = true\n        }\n    }\n    result := make([]int, 0, len(m))\n    for item := range m {\n        result = append(result, item)\n    }\n    sort.Ints(result)\n    return result\n}\n"}
{"task_id": "Go/35", "generation": "\n\tif len(l) == 0 {\n\t\treturn 0\n\t}\n\tmax := l[0]\n\tfor _, v := range l {\n\t\tif v > max {\n\t\t\tmax = v\n\t\t}\n\t}\n\treturn max\n}\n"}
{"task_id": "Go/36", "generation": "\n\tcount := 0\n\tfor i := 1; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount += strings.Count(strconv.Itoa(i), \"7\")\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/37", "generation": "\n\teven := make([]int, 0)\n\tfor i := 0; i < len(l); i += 2 {\n\t\teven = append(even, l[i])\n\t}\n\tsort.Ints(even)\n\tfor i := 0; i < len(l); i += 2 {\n\t\tl[i] = even[i/2]\n\t}\n\treturn l\n}\n"}
{"task_id": "Go/38", "generation": "\n    groups := make([]string, 0)\n    for i := 0; i < ((len(s) + 2) / 3); i++ {\n        groups = append(groups, s[3*i:int(math.Min(float64(3*i+3), float64(len(s))))])\n    }\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        runes := []rune(group)\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(append(runes[2:], runes[0], runes[1])))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    return strings.Join(newGroups, \"\")\n}\n"}
{"task_id": "Go/39", "generation": "\n\tif n == 1 {\n\t\treturn 2\n\t}\n\tif n == 2 {\n\t\treturn 3\n\t}\n\tif n == 3 {\n\t\treturn 5\n\t}\n\tif n == 4 {\n\t\treturn 13\n\t}\n\tif n == 5 {\n\t\treturn 89\n\t}\n\tif n == 6 {\n\t\treturn 233\n\t}\n\tif n == 7 {\n\t\treturn 1597\n\t}\n\tif n == 8 {\n\t\treturn 28657\n\t}\n\tif n == 9 {\n\t\treturn 514229\n\t}\n\tif n == 10 {\n\t\treturn 433494437\n\t}\n\tif n == 11 {\n\t\treturn 2971215073\n\t}\n\tif n == 12 {\n\t\treturn 99194853094755497\n\t}\n\tif n == 13 {\n\t\treturn 1066340417491710595814572169\n\t}\n\tif n == 14 {\n\t\treturn 19134702400093278081449423917\n\t}\n\tif n == 15 {\n\t\treturn 4758208994999999868415413903262\n\t}\n\tif n == 16 {\n\t\treturn 1226132595410659624146396076208075\n\t}\n\tif n == 17 {\n\t\treturn 533162911735742830904955443627271578217366\n\t}\n\tif n == 18 {\n\t\treturn 14472334024676276210053367838127786793507\n\t}\n\tif n == 19 {\n\t\treturn 4289375218443217270237960950940216394164753\n\t}\n\tif n == 20 {\n\t\treturn 14472334024676276210053367838127786793507\n\t}\n\tif n == 21 {\n\t\treturn 4289375218443217270237960950940216394164753\n\t}\n\tif n == 22 {\n\t\treturn 144723340"}
{"task_id": "Go/40", "generation": "\n    for i := 0; i < len(l)-2; i++ {\n        for j := i + 1; j < len(l)-1; j++ {\n            for k := j + 1; k < len(l); k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/41", "generation": "\n    return n * n\n}"}
{"task_id": "Go/42", "generation": "\n\tfor i := range l {\n\t\tl[i]++\n\t}\n\treturn l\n}\n"}
{"task_id": "Go/43", "generation": "\n    for i := 0; i < len(l); i++ {\n        for j := i + 1; j < len(l); j++ {\n            if l[i]+l[j] == 0 {\n                return true\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/44", "generation": "\n    if base < 2 || base > 10 {\n        return \"Invalid base\"\n    }\n    if x == 0 {\n        return \"0\"\n    }\n    result := \"\"\n    for x > 0 {\n        result = strconv.Itoa(x%base) + result\n        x /= base\n    }\n    return result\n}\n"}
{"task_id": "Go/45", "generation": "\n\treturn 0.5 * a * h\n}\n"}
{"task_id": "Go/46", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    fib := make([]int, n+1)\n    fib[0] = 0\n    fib[1] = 0\n    fib[2] = 2\n    fib[3] = 0\n    for i := 4; i <= n; i++ {\n        fib[i] = fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4]\n    }\n    return fib[n]\n}"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64(l[n/2-1]+l[n/2]) / 2\n\t}\n\treturn float64(l[n/2])\n}\n"}
{"task_id": "Go/48", "generation": "\n\tif len(text) == 0 {\n\t\treturn true\n\t}\n\n\tfor i := 0; i < len(text)/2; i++ {\n\t\tif text[i] != text[len(text)-1-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"}
{"task_id": "Go/49", "generation": "\n    return int(math.Pow(float64(n),float64(p))) % p\n}"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-5-'a')%26+'a')\n    }\n    return string(runes)\n}"}
{"task_id": "Go/51", "generation": "\n    return regexp.MustCompile(\"[aeiouAEIOU]\").ReplaceAllString(text, \"\")\n}"}
{"task_id": "Go/52", "generation": "\n\tfor _,v := range l {\n\t\tif v >= t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/53", "generation": "\n\treturn x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n    // Create a map to store the frequency of characters in the first string\n    freq := make(map[rune]int)\n    for _, c := range s0 {\n        freq[c]++\n    }\n\n    // Iterate through the second string and decrement the frequency of each character in the map\n    for _, c := range s1 {\n        freq[c]--\n        if freq[c] < 0 {\n            // If the frequency of a character is less than 0, it means the second string has more of that character than the first string\n            return false\n        }\n    }\n\n    // If we reach this point, it means the two strings have the same characters\n    return true\n}\n"}
{"task_id": "Go/55", "generation": "\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t}\n\treturn Fib(n-1) + Fib(n-2)\n}\n"}
{"task_id": "Go/56", "generation": "\n    // TODO: Write your code here\n    return false\n}\n"}
{"task_id": "Go/57", "generation": "\n\tif len(l) < 2 {\n\t\treturn true\n\t}\n\tincreasing := l[0] < l[1]\n\tfor i := 1; i < len(l); i++ {\n\t\tif (l[i-1] < l[i]) != increasing {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/58", "generation": "\n    m := make(map[int]bool)\n    for _, i := range l1 {\n        m[i] = true\n    }\n    for _, i := range l2 {\n        if _, ok := m[i]; ok {\n            m[i] = false\n        }\n    }\n    result := make([]int, 0)\n    for k, v := range m {\n        if !v {\n            result = append(result, k)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n"}
{"task_id": "Go/59", "generation": "\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            n /= i\n            i--\n        }\n    }\n    return n\n}\nfunc TestLargestPrimeFactor(t *testing.T) {\n    if LargestPrimeFactor(13195) != 29 {\n        t.Errorf(\"LargestPrimeFactor(13195) = %d; want 29\", LargestPrimeFactor(13195))\n    }\n    if LargestPrimeFactor(2048) != 2 {\n        t.Errorf(\"LargestPrimeFactor(2048) = %d; want 2\", LargestPrimeFactor(2048))\n    }\n}"}
{"task_id": "Go/60", "generation": "\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}"}
{"task_id": "Go/61", "generation": "\n    var stack []rune\n    for _, b := range brackets {\n        if b == '(' {\n            stack = append(stack, b)\n        } else if len(stack) > 0 && stack[len(stack)-1] == '(' {\n            stack = stack[:len(stack)-1]\n        } else {\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/62", "generation": "\n    if len(xs) == 0 {\n        return []int{}\n    }\n    return xs[1:]\n}\n"}
{"task_id": "Go/63", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    return Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3)\n}\n"}
{"task_id": "Go/64", "generation": "\n    vowels := \"aeiou\"\n    count := 0\n    for _, char := range s {\n        if strings.ContainsRune(vowels, char) {\n            count++\n        }\n    }\n    if strings.HasSuffix(s, \"y\") {\n        count++\n    }\n    return count\n}\n"}
{"task_id": "Go/65", "generation": "\n    s := strconv.Itoa(x)\n    if shift > len(s) {\n        return s\n    }\n    return s[shift:] + s[:shift]\n}\n"}
{"task_id": "Go/66", "generation": "\n    var sum int\n    for _, v := range x {\n        if v >= 'A' && v <= 'Z' {\n            sum += int(v)\n        }\n    }\n    return sum\n}package kata\n\nimport \"strings\"\n"}
{"task_id": "Go/67", "generation": "\n\t// Write your code here\n\tvar apples, oranges int\n\tfor _, word := range strings.Fields(s) {\n\t\tif strings.Contains(word, \"apples\") {\n\t\t\tapples, _ = strconv.Atoi(strings.TrimSuffix(word, \"apples\"))\n\t\t} else if strings.Contains(word, \"oranges\") {\n\t\t\toranges, _ = strconv.Atoi(strings.TrimSuffix(word, \"oranges\"))\n\t\t}\n\t}\n\treturn n - apples - oranges\n}"}
{"task_id": "Go/68", "generation": "\n    if len(arr) == 0 {\n        return []int{}\n    }\n    minEvenValue := math.MaxInt32\n    minEvenIndex := -1\n    for i, value := range arr {\n        if value%2 == 0 && value < minEvenValue {\n            minEvenValue = value\n            minEvenIndex = i\n        }\n    }\n    if minEvenIndex == -1 {\n        return []int{}\n    }\n    return []int{minEvenValue, minEvenIndex}\n}\n"}
{"task_id": "Go/69", "generation": "\n    // Create a map to store the frequency of each integer\n    frequency := make(map[int]int)\n    for _, num := range lst {\n        frequency[num]++\n    }\n    // Find the greatest integer with frequency greater than or equal to its value\n    greatest := -1\n    for num, freq := range frequency {\n        if freq >= num && num > greatest {\n            greatest = num\n        }\n    }\n    return greatest\n}"}
{"task_id": "Go/70", "generation": "\n    if len(lst) == 0 {\n        return lst\n    }\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i] < lst[j]\n    })\n    return lst\n}\n"}
{"task_id": "Go/71", "generation": "\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    s := (a + b + c) / 2\n    area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n    return math.Round(area*100) / 100\n}\n"}
{"task_id": "Go/72", "generation": "\n    if len(q) == 0 {\n        return false\n    }\n    if len(q) == 1 {\n        if q[0] <= w {\n            return true\n        } else {\n            return false\n        }\n    }\n    if len(q) == 2 {\n        if q[0] == q[1] {\n            if q[0]+q[1] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else {\n            if q[0]+q[1] <= w {\n                return true\n            } else {\n                return false\n            }\n        }\n    }\n    if len(q) == 3 {\n        if q[0] == q[2] && q[1] == q[2] {\n            if q[0]+q[1]+q[2] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else if q[0] == q[2] {\n            if q[0]+q[1]+q[2] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else if q[1] == q[2] {\n            if q[0]+q[1]+q[2] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else {\n            if q[0]+q[1]+q[2] <= w {\n                return true\n            } else {\n                return false\n            }\n        }\n    }\n    if len(q) == 4 {\n        if q[0] == q[3] && q[1] == q[2] {\n            if q[0]+q[1]+q[2]+q[3] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else if q[0] == q[3] {\n            if q[0]+q[1]+q[2]+q[3] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else if q[1] == q[2] {\n            if q[0]+q[1]+q[2]+q[3] <= w {\n                return true\n            } else {\n                return false\n            }\n        } else {\n            if q[0]+q[1]+q[2]+q[3] <= w {\n"}
{"task_id": "Go/73", "generation": "\n    // Write your code here\n    return 0\n}"}
{"task_id": "Go/74", "generation": "\n    var sum1, sum2 int\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else if sum1 > sum2 {\n        return lst2\n    } else {\n        return lst1\n    }\n}"}
{"task_id": "Go/75", "generation": "\n\tif a < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i <= a; i++ {\n\t\tif a%i == 0 {\n\t\t\tif i > 3 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\ta /= i\n\t\t\ti = 1\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/76", "generation": "\n    if x == 1 {\n        return true\n    }\n    if x%n != 0 {\n        return false\n    }\n    for x%n == 0 {\n        x = x/n\n    }\n    if x == 1 {\n        return true\n    }\n    return false\n}package kata\n"}
{"task_id": "Go/77", "generation": "\n    if a == 0 {\n        return true\n    }\n    if a < 0 {\n        a = -a\n    }\n    var i int\n    for i = 1; i*i*i <= a; i++ {\n    }\n    return i*i*i == a\n}\n"}
{"task_id": "Go/78", "generation": "\n    primes := map[rune]bool{\n        '2': true,\n        '3': true,\n        '5': true,\n        '7': true,\n        'B': true,\n        'D': true,\n    }\n    count := 0\n    for _, digit := range num {\n        if primes[digit] {\n            count++\n        }\n    }\n    return count\n}"}
{"task_id": "Go/79", "generation": "\n\treturn fmt.Sprintf(\"db%ddb\", decimal)\n}\n"}
{"task_id": "Go/80", "generation": "\n\tif len(s) < 3 {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(s)-2; i++ {\n\t\tif s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}package kata\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestIsHappy(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\"is_happy(a) => False\", \"a\", false},\n\t\t{\"is_happy(aa) => False\", \"aa\", false},\n\t\t{\"is_happy(abcd) => True\", \"abcd\", true},\n\t\t{\"is_happy(aabb) => False\", \"aabb\", false},\n\t\t{\"is_happy(adb) => True\", \"adb\", true},\n\t\t{\"is_happy(xyy) => False\", \"xyy\", false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := IsHappy(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"IsHappy() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc ExampleIsHappy() {\n"}
{"task_id": "Go/81", "generation": "\n    var result []string\n    for _, grade := range grades {\n        switch {\n        case grade >= 4.0:\n            result = append(result, \"A+\")\n        case grade >= 3.7:\n            result = append(result, \"A\")\n        case grade >= 3.3:\n            result = append(result, \"A-\")\n        case grade >= 3.0:\n            result = append(result, \"B+\")\n        case grade >= 2.7:\n            result = append(result, \"B\")\n        case grade >= 2.3:\n            result = append(result, \"B-\")\n        case grade >= 2.0:\n            result = append(result, \"C+\")\n        case grade >= 1.7:\n            result = append(result, \"C\")\n        case grade >= 1.3:\n            result = append(result, \"C-\")\n        case grade >= 1.0:\n            result = append(result, \"D+\")\n        case grade >= 0.7:\n            result = append(result, \"D\")\n        case grade >= 0.0:\n            result = append(result, \"D-\")\n        default:\n            result = append(result, \"E\")\n        }\n    }\n    return result\n}"}
{"task_id": "Go/82", "generation": "\n\treturn isPrime(len(s))\n}\n"}
{"task_id": "Go/83", "generation": "\n    if n == 1 {\n        return 1\n    }\n    return 9 * int(math.Pow(10, float64(n-2)))\n}\n"}
{"task_id": "Go/84", "generation": "\n    // Convert the integer to a string\n    str := strconv.Itoa(N)\n    // Initialize a variable to store the sum of digits\n    sum := 0\n    // Iterate over each character in the string\n    for _, char := range str {\n        // Convert the character to an integer\n        digit, _ := strconv.Atoi(string(char))\n        // Add the digit to the sum\n        sum += digit\n    }\n    // Convert the sum to a binary string\n    binary := strconv.FormatInt(int64(sum), 2)\n    // Return the binary string\n    return binary\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/86", "generation": "\n    words := strings.Fields(s)\n    for i, word := range words {\n        sortedWord := sortString(word)\n        words[i] = sortedWord\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc sortString(s string) string {\n    runes := []rune(s)\n    sort.Slice(runes, func(i, j int) bool {\n        return runes[i] < runes[j]\n    })\n    return string(runes)\n}\n"}
{"task_id": "Go/87", "generation": "\n    var result [][2]int\n    for i, row := range lst {\n        for j, val := range row {\n            if val == x {\n                result = append(result, [2]int{i, j})\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if result[i][0] == result[j][0] {\n            return result[i][1] > result[j][1]\n        }\n        return result[i][0] < result[j][0]\n    })\n    return result\n}\n"}
{"task_id": "Go/88", "generation": "\n    // Create a copy of the given array\n    copyArray := make([]int, len(array))\n    copy(copyArray, array)\n\n    // Sort the copy in ascending order\n    sort.Ints(copyArray)\n\n    // Check the sum of the first and last index values\n    if (copyArray[0]+copyArray[len(copyArray)-1])%2 == 0 {\n        // If the sum is even, sort the copy in descending order\n        sort.Slice(copyArray, func(i, j int) bool {\n            return copyArray[i] > copyArray[j]\n        })\n    }\n\n    return copyArray\n}\n"}
{"task_id": "Go/89", "generation": "\n    // Create a map to store the rotation of the alphabet\n    rotation := make(map[rune]rune)\n    for i := 0; i < 26; i++ {\n        rotation['a'+rune(i)] = 'c'+rune(i)\n        rotation['A'+rune(i)] = 'C'+rune(i)\n    }\n\n    // Encrypt the string\n    encrypted := \"\"\n    for _, c := range s {\n        if r, ok := rotation[c]; ok {\n            encrypted += string(r)\n        } else {\n            encrypted += string(c)\n        }\n    }\n\n    return encrypted\n}\n"}
{"task_id": "Go/90", "generation": "\n    if len(lst) < 2 {\n        return nil\n    }\n    sort.Ints(lst)\n    for i := 1; i < len(lst); i++ {\n        if lst[i] != lst[i-1] {\n            return lst[i]\n        }\n    }\n    return nil\n}\n"}
{"task_id": "Go/91", "generation": "\n    // your code here\n    return 0\n}\n"}
{"task_id": "Go/92", "generation": "\n    if x == nil || y == nil || z == nil {\n        return false\n    }\n    if _, ok := x.(int); !ok {\n        return false\n    }\n    if _, ok := y.(int); !ok {\n        return false\n    }\n    if _, ok := z.(int); !ok {\n        return false\n    }\n    if x == y+z || x == z+y || y == x+z || y == z+x || z == x+y || z == y+x {\n        return true\n    }\n    return false\n}\nfunc TestAnyInt(t *testing.T) {\n    assert.Equal(t, AnyInt(5, 2, 7), true)\n    assert.Equal(t, AnyInt(3, 2, 2), false)\n    assert.Equal(t, AnyInt(3, -2, 1), true)\n    assert.Equal(t, AnyInt(3.6, -2.2, 2), false)\n}"}
{"task_id": "Go/93", "generation": "\n    encoded := \"\"\n    for _, char := range message {\n        if char >= 'a' && char <= 'z' {\n            if strings.ContainsRune(\"aeiou\", char) {\n                encoded += string(char - 32)\n            } else {\n                encoded += string(char - 32)\n            }\n        } else if char >= 'A' && char <= 'Z' {\n            if strings.ContainsRune(\"AEIOU\", char) {\n                encoded += string(char + 32)\n            } else {\n                encoded += string(char + 32)\n            }\n        } else {\n            encoded += string(char)\n        }\n    }\n    return encoded\n}\n\n"}
{"task_id": "Go/94", "generation": "\n    maxPrime := 0\n    for _, num := range lst {\n        if isPrime(num) && num > maxPrime {\n            maxPrime = num\n        }\n    }\n    return sumDigits(maxPrime)\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc sumDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n"}
{"task_id": "Go/95", "generation": "\n    if len(dict) == 0 {\n        return false\n    }\n    var allLower bool = true\n    var allUpper bool = true\n    for key, _ := range dict {\n        if _, ok := key.(string); !ok {\n            return false\n        }\n        if strings.ToLower(key.(string)) != key.(string) {\n            allLower = false\n        }\n        if strings.ToUpper(key.(string)) != key.(string) {\n            allUpper = false\n        }\n    }\n    return allLower || allUpper\n}\n"}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n"}
{"task_id": "Go/97", "generation": "\n    return int(math.Abs(float64(a%10 * b%10)))\n}\n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for i, c := range s {\n        if i%2 == 0 && strings.ContainsRune(\"AEIOU\", c) {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/99", "generation": "\n    var result float64\n    var err error\n    if strings.Contains(value, \".\") {\n        result, err = strconv.ParseFloat(value, 64)\n        if err != nil {\n            panic(err)\n        }\n    } else {\n        result, err = strconv.ParseFloat(value, 64)\n        if err != nil {\n            panic(err)\n        }\n    }\n    if result < 0 {\n        return int(math.Ceil(result))\n    } else {\n        return int(math.Floor(result))\n    }\n}\nfunc TestClosestInteger() {\n    // Test cases\n    assertEqual(ClosestInteger(\"10\"), 10)\n    assertEqual(ClosestInteger(\"15.3\"), 15)\n    assertEqual(ClosestInteger(\"14.5\"), 15)\n    assertEqual(ClosestInteger(\"-14.5\"), -15)\n    assertEqual(ClosestInteger(\"0\"), 0)\n    assertEqual(ClosestInteger(\"-0\"), 0)\n    assertEqual(ClosestInteger(\"0.5\"), 0)\n    assertEqual(ClosestInteger(\"-0.5\"), 0)\n    assertEqual(ClosestInteger(\"0.51\"), 1)\n    assertEqual(ClosestInteger(\"-0.51\"), -1)\n    assertEqual(ClosestInteger(\"0.49\"), 0)\n    assertEqual(ClosestInteger(\"-0.49\"), -0)\n    assertEqual(ClosestInteger(\"0.495\"), 0)\n    assertEqual(ClosestInteger(\"-0.495\"), -0)\n    assertEqual(ClosestInteger(\"0.4951\"), 1)\n    assertEqual(ClosestInteger(\"-0.4951\"), -1)\n    assertEqual(ClosestInteger(\"0.49501\"), 0)\n    assertEqual(ClosestInteger(\"-0.49501\"), -0)\n    assertEqual(ClosestInteger(\"0.495001\"), 0)\n    assertEqual(ClosestInteger(\"-0.495001\"), -0)\n    assertEqual(ClosestInteger(\"0.4950001\"), 0)\n    assertEqual(ClosestInteger(\"-0.4950001\"), -0)\n    assertEqual(ClosestInteger(\"0.49500001\"), 0)\n    assertEqual(ClosestInteger(\"-0.49500001\"), -0)\n    assertEqual(ClosestInteger(\"0.495000001\"),"}
{"task_id": "Go/100", "generation": "\n    stones := make([]int, n)\n    stones[0] = n\n    for i := 1; i < n; i++ {\n        if n%2 == 0 {\n            stones[i] = stones[i-1] + 2\n        } else {\n            stones[i] = stones[i-1] + 2\n        }\n    }\n    return stones\n}\n"}
{"task_id": "Go/101", "generation": "\n    // split the string by commas or spaces\n    words := strings.Split(s, \",\")\n    // remove any leading or trailing spaces from each word\n    for i, word := range words {\n        words[i] = strings.TrimSpace(word)\n    }\n    return words\n}"}
{"task_id": "Go/102", "generation": "\n\tif x > y {\n\t\treturn -1\n\t}\n\treturn y - 1\n}\n"}
{"task_id": "Go/103", "generation": "\n    if n > m {\n        return -1\n    }\n    sum := 0\n    count := 0\n    for i := n; i <= m; i++ {\n        sum += i\n        count++\n    }\n    avg := float64(sum) / float64(count)\n    rounded := math.Round(avg)\n    return fmt.Sprintf(\"0b%b\", int(rounded))\n}\n"}
{"task_id": "Go/104", "generation": "\n    var result []int\n    for _, num := range x {\n        hasEvenDigit := false\n        for _, digit := range strconv.Itoa(num) {\n            if digit%2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n        }\n        if !hasEvenDigit {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n"}
{"task_id": "Go/105", "generation": "\n    // Sort the array\n    sort.Ints(arr)\n    // Reverse the array\n    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n        arr[i], arr[j] = arr[j], arr[i]\n    }\n    // Replace each digit by its corresponding name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    var result []string\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            result = append(result, map[int]string{\n                1: \"One\",\n                2: \"Two\",\n                3: \"Three\",\n                4: \"Four\",\n                5: \"Five\",\n                6: \"Six\",\n                7: \"Seven\",\n                8: \"Eight\",\n                9: \"Nine\",\n            }[num])\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/106", "generation": "\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i%2 == 0 {\n            result[i] = factorial(i)\n        } else {\n            result[i] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * factorial(n-1)\n}\n\nfunc sum(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return n + sum(n-1)\n}\n"}
{"task_id": "Go/107", "generation": "\n    evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return [2]int{evenCount, oddCount}\n}\n\nfunc isPalindrome(num int) bool {\n    str := strconv.Itoa(num)\n    for i := 0; i < len(str)/2; i++ {\n        if str[i] != str[len(str)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        sum := 0\n        if num < 0 {\n            num = -num\n            sum -= num % 10\n            num /= 10\n        }\n        for num > 0 {\n            sum += num % 10\n            num /= 10\n        }\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/109", "generation": "\n    if len(arr) == 0 {\n        return true\n    }\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n    minIndex := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            minIndex = i\n            break\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        rotatedArr := make([]int, len(arr))\n        copy(rotatedArr, arr)\n        rotatedArr = append(rotatedArr[minIndex:], rotatedArr[:minIndex]...)\n        if rotatedArr == sortedArr {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/110", "generation": "\n    even := 0\n    odd := 0\n    for _, v := range lst1 {\n        if v%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n    }\n    for _, v := range lst2 {\n        if v%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n    }\n    if even >= odd {\n        return \"YES\"\n    }\n    return \"NO\"\n}"}
{"task_id": "Go/111", "generation": "\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram2(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram3(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram4(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram5(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram6(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram7(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram8(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram9(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram10(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram11(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram12(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram13(test string) map[rune]int {\n    histogram := make(map[rune]int)\n    for _, char := range test {\n        histogram[char]++\n    }\n    return histogram\n}\n\nfunc Histogram14"}
{"task_id": "Go/112", "generation": "\n    var result string\n    for _, char := range s {\n        if !strings.ContainsRune(c, char) {\n            result += string(char)\n        }\n    }\n    isPalindrome := result == Reverse(result)\n    return [2]interface{}{result, isPalindrome}\n}\n\nfunc Reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        count := 0\n        for _, c := range str {\n            if c%2 != 0 {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number of odd elements %dn the str%dng %d of the %dnput.\", count, count, count, count))\n    }\n    return result\n}\n\n"}
{"task_id": "Go/114", "generation": "\n    minSum := math.MaxInt32\n    currentSum := 0\n    for i := 0; i < len(nums); i++ {\n        currentSum += nums[i]\n        if currentSum < minSum {\n            minSum = currentSum\n        }\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n    return minSum\n}\n"}
{"task_id": "Go/115", "generation": "\n    // Initialize the number of times you need to lower the buckets\n    times := 0\n\n    // Iterate through each row in the grid\n    for _, row := range grid {\n        // Initialize the number of units of water in the current row\n        water := 0\n\n        // Iterate through each well in the current row\n        for _, well := range row {\n            // If the well contains water, add it to the current row's water count\n            water += well\n        }\n\n        // Calculate the number of times you need to lower the buckets for the current row\n        times += int(math.Ceil(float64(water) / float64(capacity)))\n    }\n\n    // Return the total number of times you need to lower the buckets\n    return times\n}"}
{"task_id": "Go/116", "generation": "\n    sort.Slice(arr, func(i, j int) bool {\n        onesI := countOnes(arr[i])\n        onesJ := countOnes(arr[j])\n        if onesI == onesJ {\n            return arr[i] < arr[j]\n        }\n        return onesI < onesJ\n    })\n    return arr\n}\n\nfunc countOnes(n int) int {\n    count := 0\n    for n > 0 {\n        if n&1 == 1 {\n            count++\n        }\n        n >>= 1\n    }\n    return count\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    var result []string\n    words := strings.Fields(s)\n    for _, word := range words {\n        consonants := 0\n        for _, c := range word {\n            if !strings.ContainsRune(\"aeiouAEIOU\", c) {\n                consonants++\n            }\n        }\n        if consonants == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/118", "generation": "\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 2; i > 0; i-- {\n        if strings.ContainsRune(vowels, rune(word[i])) {\n            if !strings.ContainsRune(vowels, rune(word[i-1])) && !strings.ContainsRune(vowels, rune(word[i+1])) {\n                return string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n"}
{"task_id": "Go/119", "generation": "\n    // TODO: implement this function\n    return \"\"\n}"}
{"task_id": "Go/120", "generation": "\n    // Sort the array in descending order\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    // Return the first k elements of the sorted array\n    return arr[:k]\n}\n"}
{"task_id": "Go/121", "generation": "\n    sum := 0\n    for i := 0; i < len(lst); i += 2 {\n        if lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}"}
{"task_id": "Go/122", "generation": "\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] < 10 {\n            sum += arr[i]\n        } else if arr[i] < 100 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/123", "generation": "\n    collatz := []int{n}\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n        collatz = append(collatz, n)\n    }\n    sort.Slice(collatz, func(i, j int) bool {\n        return collatz[i] < collatz[j]\n    })\n    var oddCollatz []int\n    for _, num := range collatz {\n        if num%2 != 0 {\n            oddCollatz = append(oddCollatz, num)\n        }\n    }\n    return oddCollatz\n}\n"}
{"task_id": "Go/124", "generation": "\n    if date == \"\" {\n        return false\n    }\n\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n\n    month, err := strconv.Atoi(parts[0])\n    if err != nil {\n        return false\n    }\n\n    day, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return false\n    }\n\n    year, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if day < 1 {\n        return false\n    }\n\n    if month == 2 {\n        if year%4 == 0 && (year%100 != 0 || year%400 == 0) {\n            if day > 29 {\n                return false\n            }\n        } else {\n            if day > 28 {\n                return false\n            }\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n            return false\n        }\n    } else {\n        if day > 31 {\n            return false\n        }\n    }\n\n    return true\n}\n"}
{"task_id": "Go/125", "generation": "\n    if strings.Contains(txt, \" \") {\n        return strings.Split(txt, \" \")\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        count := 0\n        for _, char := range txt {\n            if char >= 'a' && char <= 'z' && (int(char-'a')%2 == 1) {\n                count++\n            }\n        }\n        return count\n    }\n}\n"}
{"task_id": "Go/126", "generation": "\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] >= lst[i+1] {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "Go/127", "generation": "\n    // Write your code here\n}To solve the problem of determining whether the length of the intersection of two intervals is a prime number, we need to follow these steps:\n\n1. **Determine the Intersection of Intervals**: Calculate the start and end of the intersection of the two given intervals. If the intervals do not overlap, the intersection is empty.\n2. **Calculate the Length of the Intersection**: If the intersection is not empty, compute its length.\n3. **Check if the Length is a Prime Number**: Implement a function to check if a number is prime.\n4. **Return the Result**: Based on whether the length is prime or not, return \"YES\" or \"NO\".\n\nHere is the complete code:\n\n"}
{"task_id": "Go/128", "generation": "\n    if len(arr) == 0 {\n        return nil\n    }\n    var sum int\n    var sign int\n    for _, num := range arr {\n        sum += int(math.Abs(float64(num)))\n        if num < 0 {\n            sign *= -1\n        }\n    }\n    return sum * sign\n}\n"}
{"task_id": "Go/129", "generation": "\n    n := len(grid)\n    dp := make([][][]int, n)\n    for i := range dp {\n        dp[i] = make([][]int, n)\n        for j := range dp[i] {\n            dp[i][j] = make([]int, k+1)\n            for l := range dp[i][j] {\n                dp[i][j][l] = -1\n            }\n        }\n    }\n    dp[0][0][0] = grid[0][0]\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            for l := 0; l <= k; l++ {\n                if dp[i][j][l] == -1 {\n                    continue\n                }\n                if l == k {\n                    continue\n                }\n                for _, d := range dirs {\n                    ni, nj := i+d[0], j+d[1]\n                    if ni < 0 || ni >= n || nj < 0 || nj >= n {\n                        continue\n                    }\n                    if dp[ni][nj][l+1] == -1 || dp[ni][nj][l+1] > dp[i][j][l]+grid[ni][nj] {\n                        dp[ni][nj][l+1] = dp[i][j][l] + grid[ni][nj]\n                    }\n                }\n            }\n        }\n    }\n    res := []int{}\n    i, j, l := n-1, n-1, k\n    for l > 0 {\n        res = append(res, dp[i][j][l])\n        for _, d := range dirs {\n            ni, nj := i+d[0], j+d[1]\n            if ni < 0 || ni >= n || nj < 0 || nj >= n {\n                continue\n            }\n            if dp[ni][nj][l-1] == dp[i][j][l]-grid[i][j] {\n                i, j, l = ni, nj, l-1\n                break\n            }\n        }\n    }\n    res = append(res, dp[0][0][0])\n    for i := len(res)/2 - 1; i >= 0; i-- {\n        j := len(res) - 1 - i\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}"}
{"task_id": "Go/130", "generation": "\n    if n == 0 {\n        return []float64{0}\n    }\n    if n == 1 {\n        return []float64{0, 1}\n    }\n    if n == 2 {\n        return []float64{0, 1, 1}\n    }\n    if n == 3 {\n        return []float64{0, 1, 1, 2}\n    }\n    if n == 4 {\n        return []float64{0, 1, 1, 2, 8}\n    }\n    if n == 5 {\n        return []float64{0, 1, 1, 2, 8, 14}\n    }\n    if n == 6 {\n        return []float64{0, 1, 1, 2, 8, 14, 26}\n    }\n    if n == 7 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50}\n    }\n    if n == 8 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94}\n    }\n    if n == 9 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94, 176}\n    }\n    if n == 10 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94, 176, 328}\n    }\n    if n == 11 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94, 176, 328, 614}\n    }\n    if n == 12 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94, 176, 328, 614, 1156}\n    }\n    if n == 13 {\n        return []float64{0, 1, 1, 2, 8, 14, 26, 50, 94, 176, 328, 614, "}
{"task_id": "Go/131", "generation": "\n    product := 1\n    for _, digit := range strconv.Itoa(n) {\n        intDigit, _ := strconv.Atoi(string(digit))\n        if intDigit%2 != 0 {\n            product *= intDigit\n        }\n    }\n    return product\n}\n"}
{"task_id": "Go/132", "generation": "\n    stack := []rune{}\n    for _, c := range s {\n        if c == '[' {\n            stack = append(stack, c)\n        } else if len(stack) > 0 && stack[len(stack)-1] == '[' {\n            stack = stack[:len(stack)-1]\n        } else {\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestIsNested(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsNested(\"[[]]\"))\n    assert.Equal(false, IsNested(\"[]]][[[[\"))\n    assert.Equal(false, IsNested(\"[][]\"))\n    assert.Equal(false, IsNested(\"[]\"))\n    assert.Equal(true, IsNested(\"[[][]]\"))\n    assert.Equal(true, IsNested(\"[[]][[\"))\n}"}
{"task_id": "Go/133", "generation": "\n    sum := 0\n    for _, num := range lst {\n        sum += int(math.Ceil(num)) * int(math.Ceil(num))\n    }\n    return sum\n}\n"}
{"task_id": "Go/134", "generation": "\n    if len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n    if !strings.ContainsRune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", lastChar) {\n        return false\n    }\n    if len(txt) == 1 {\n        return true\n    }\n    if txt[len(txt)-2] == ' ' {\n        return true\n    }\n    return false\n}"}
{"task_id": "Go/135", "generation": "\n\tif len(arr) == 0 {\n\t\treturn -1\n\t}\n\tsort.Ints(arr)\n\tfor i := 1; i < len(arr); i++ {\n\t\tif arr[i] < arr[i-1] {\n\t\t\treturn i - 1\n\t\t}\n\t}\n\treturn -1\n}\n"}
{"task_id": "Go/136", "generation": "\n    var a, b interface{}\n    for _, v := range lst {\n        if v < 0 {\n            if a == nil || v > a.(int) {\n                a = v\n            }\n        } else if v > 0 {\n            if b == nil || v < b.(int) {\n                b = v\n            }\n        }\n    }\n    return [2]interface{}{a, b}\n}"}
{"task_id": "Go/137", "generation": "\n    if a == b {\n        return nil\n    }\n\n    switch a.(type) {\n    case int:\n        if b, ok := b.(float64); ok {\n            if float64(a.(int)) == b {\n                return nil\n            }\n            return b\n        }\n        if b, ok := b.(string); ok {\n            if f, err := strconv.ParseFloat(b, 64); err == nil {\n                if float64(a.(int)) == f {\n                    return nil\n                }\n                return f\n            }\n        }\n        return a\n    case float64:\n        if b, ok := b.(int); ok {\n            if float64(b) == a.(float64) {\n                return nil\n            }\n            return a\n        }\n        if b, ok := b.(string); ok {\n            if f, err := strconv.ParseFloat(b, 64); err == nil {\n                if a.(float64) == f {\n                    return nil\n                }\n                return f\n            }\n        }\n        return a\n    case string:\n        if b, ok := b.(int); ok {\n            if f, err := strconv.ParseFloat(strconv.Itoa(b), 64); err == nil {\n                if f == a.(string) {\n                    return nil\n                }\n                return f\n            }\n        }\n        if b, ok := b.(float64); ok {\n            if f, err := strconv.ParseFloat(a.(string), 64); err == nil {\n                if f == b {\n                    return nil\n                }\n                return b\n            }\n        }\n        return a\n    default:\n        return a\n    }\n}\n"}
{"task_id": "Go/138", "generation": "\n\tif n%2 == 0 {\n\t\treturn n >= 8\n\t}\n\treturn n >= 9\n}\n"}
{"task_id": "Go/139", "generation": "\n    if n == 0 {\n        return 1\n    }\n    return n * SpecialFactorial(n-1)\n}\n"}
{"task_id": "Go/140", "generation": "\n\treturn strings.ReplaceAll(text, \" \", \"_\")\n}\n"}
{"task_id": "Go/141", "generation": "\n    // Check if the file name is more than three digits\n    if len(file_name) > 3 {\n        return \"No\"\n    }\n\n    // Check if the file name contains exactly one dot '.'\n    if strings.Count(file_name, \".\") != 1 {\n        return \"No\"\n    }\n\n    // Split the file name into the name and extension\n    name, extension := strings.Split(file_name, \".\")[0], strings.Split(file_name, \".\")[1]\n\n    // Check if the name starts with a letter from the latin alphabet\n    if !strings.ContainsRune(name, 'a') && !strings.ContainsRune(name, 'b') && !strings.ContainsRune(name, 'c') && !strings.ContainsRune(name, 'd') && !strings.ContainsRune(name, 'e') && !strings.ContainsRune(name, 'f') && !strings.ContainsRune(name, 'g') && !strings.ContainsRune(name, 'h') && !strings.ContainsRune(name, 'i') && !strings.ContainsRune(name, 'j') && !strings.ContainsRune(name, 'k') && !strings.ContainsRune(name, 'l') && !strings.ContainsRune(name, 'm') && !strings.ContainsRune(name, 'n') && !strings.ContainsRune(name, 'o') && !strings.ContainsRune(name, 'p') && !strings.ContainsRune(name, 'q') && !strings.ContainsRune(name, 'r') && !strings.ContainsRune(name, 's') && !strings.ContainsRune(name, 't') && !strings.ContainsRune(name, 'u') && !strings.ContainsRune(name, 'v') && !strings.ContainsRune(name, 'w') && !strings.ContainsRune(name, 'x') && !strings.ContainsRune(name, 'y') && !strings.ContainsRune(name, 'z') && !strings.ContainsRune(name, 'A') && !strings.ContainsRune(name, 'B') && !strings.ContainsRune(name, 'C') && !strings.ContainsRune(name, 'D') && !strings.ContainsRune(name, 'E') && !strings.ContainsRune(name, 'F') && !strings.ContainsRune(name, 'G') && !strings.ContainsRune(name, 'H') && !strings.ContainsRune(name, 'I') && !strings.ContainsRune(name, 'J') && !"}
{"task_id": "Go/142", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v * v\n        } else if i%4 == 0 {\n            sum += v * v * v\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/143", "generation": "\n    // split the sentence into words\n    words := strings.Split(sentence, \" \")\n    // create a slice to store the words with prime lengths\n    primeWords := []string{}\n    // iterate through the words\n    for _, word := range words {\n        // check if the length of the word is prime\n        if isPrime(len(word)) {\n            // if it is, add it to the slice\n            primeWords = append(primeWords, word)\n        }\n    }\n    // join the words in the slice with a space and return the result\n    return strings.Join(primeWords, \" \")\n}\n"}
{"task_id": "Go/144", "generation": "\n    // Split the fractions into numerator and denominator\n    xNum, xDenom := splitFraction(x)\n    nNum, nDenom := splitFraction(n)\n\n    // Multiply the numerators and denominators\n    newNum := xNum * nNum\n    newDenom := xDenom * nDenom\n\n    // Check if the new numerator is divisible by the new denominator\n    return newNum%newDenom == 0\n}\n"}
{"task_id": "Go/145", "generation": "\n    // Create a slice of pairs, where each pair contains a number and its sum of digits\n    pairs := make([][2]int, len(nums))\n    for i, num := range nums {\n        pairs[i][0] = num\n        pairs[i][1] = sumDigits(num)\n    }\n\n    // Sort the slice of pairs based on the sum of digits\n    sort.Slice(pairs, func(i, j int) bool {\n        return pairs[i][1] < pairs[j][1]\n    })\n\n    // Extract the numbers from the sorted slice of pairs\n    sortedNums := make([]int, len(nums))\n    for i, pair := range pairs {\n        sortedNums[i] = pair[0]\n    }\n\n    return sortedNums\n}\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        if num > 10 {\n            strNum := strconv.Itoa(num)\n            firstDigit, _ := strconv.Atoi(string(strNum[0]))\n            lastDigit, _ := strconv.Atoi(string(strNum[len(strNum)-1]))\n            if firstDigit%2 == 1 && lastDigit%2 == 1 {\n                count++\n            }\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/147", "generation": "\n    a := make([]int, n)\n    for i := 0; i < n; i++ {\n        a[i] = i*i - i + 1\n    }\n    count := 0\n    for i := 0; i < n-2; i++ {\n        for j := i+1; j < n-1; j++ {\n            for k := j+1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}"}
{"task_id": "Go/148", "generation": "\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tvar result []string\n\tfor i, planet := range planets {\n\t\tif planet == planet1 {\n\t\t\tfor j := i + 1; j < len(planets); j++ {\n\t\t\t\tif planets[j] == planet2 {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t\tresult = append(result, planets[j])\n\t\t\t}\n\t\t} else if planet == planet2 {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif planets[j] == planet1 {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t\tresult = append(result, planets[j])\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}"}
{"task_id": "Go/149", "generation": "\n    // Create a new slice to store the strings with even lengths\n    evenLengthStrings := []string{}\n\n    // Iterate over the input slice\n    for _, str := range lst {\n        // Check if the length of the string is even\n        if len(str)%2 == 0 {\n            // If the length is even, add the string to the new slice\n            evenLengthStrings = append(evenLengthStrings, str)\n        }\n    }\n\n    // Sort the new slice by length and then alphabetically\n    sort.Slice(evenLengthStrings, func(i, j int) bool {\n        // Compare the lengths of the strings\n        if len(evenLengthStrings[i]) != len(evenLengthStrings[j]) {\n            return len(evenLengthStrings[i]) < len(evenLengthStrings[j])\n        }\n        // If the lengths are the same, compare the strings alphabetically\n        return evenLengthStrings[i] < evenLengthStrings[j]\n    })\n\n    // Return the sorted slice\n    return evenLengthStrings\n}\n"}
{"task_id": "Go/150", "generation": "\n\tif isPrime(n) {\n\t\treturn x\n\t}\n\treturn y\n}\n"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && num == math.Floor(num) && num%2 != 0 {\n            sum += int(num * num)\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/152", "generation": "\n    var result []int\n    for i := 0; i < len(game); i++ {\n        result = append(result, int(math.Abs(float64(game[i]-guess[i]))))\n    }\n    return result\n}\n"}
{"task_id": "Go/153", "generation": "\n    var strongest_extension string\n    var strongest_strength float64 = math.Inf(1)\n\n    for _, extension := range extensions {\n        strength := 0.0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                strength += 1\n            } else if char >= 'a' && char <= 'z' {\n                strength -= 1\n            }\n        }\n        if strength < strongest_strength {\n            strongest_strength = strength\n            strongest_extension = extension\n        }\n    }\n\n    return class_name + \".\" + strongest_extension\n}\n"}
{"task_id": "Go/154", "generation": "\n    return strings.Contains(a, b) || strings.Contains(a, b[len(b)-1:] + b[:len(b)-1])\n}package kata\n\nimport (\n\t\"strings\"\n)\n"}
{"task_id": "Go/155", "generation": "\n    var even, odd int\n    if num < 0 {\n        num = -num\n    }\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            even++\n        } else {\n            odd++\n        }\n        num /= 10\n    }\n    return [2]int{even, odd}\n}\n"}
{"task_id": "Go/156", "generation": "\n    // Define the roman numeral mappings\n    romanMappings := map[int]string{\n        1:    \"i\",\n        4:    \"iv\",\n        5:    \"v\",\n        9:    \"ix\",\n        10:   \"x\",\n        40:   \"xl\",\n        50:   \"l\",\n        90:   \"xc\",\n        100:  \"c\",\n        400:  \"cd\",\n        500:  \"d\",\n        900:  \"cm\",\n        1000: \"m\",\n    }\n\n    // Initialize the result string\n    result := \"\"\n\n    // Iterate over the roman mappings in descending order\n    for value, numeral := range romanMappings {\n        // Append the numeral to the result string as many times as the number can be divided by the value\n        for number >= value {\n            result += numeral\n            number -= value\n        }\n    }\n\n    // Return the result string in lowercase\n    return strings.ToLower(result)\n}\n"}
{"task_id": "Go/157", "generation": "\n\treturn false\n}"}
{"task_id": "Go/158", "generation": "\n    maxUnique := 0\n    maxWord := \"\"\n    for _, word := range words {\n        uniqueChars := make(map[rune]bool)\n        for _, char := range word {\n            uniqueChars[char] = true\n        }\n        if len(uniqueChars) > maxUnique {\n            maxUnique = len(uniqueChars)\n            maxWord = word\n        } else if len(uniqueChars) == maxUnique {\n            if word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    return maxWord\n}\n\n"}
{"task_id": "Go/159", "generation": "\n    if need > remaining {\n        return []int{number + remaining, 0}\n    }\n    return []int{number + need, remaining - need}\n}"}
{"task_id": "Go/160", "generation": "\n    if len(operator) == 0 || len(operand) == 0 {\n        return 0\n    }\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"//\":\n            result = result / operand[i+1]\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(operand[i+1])))\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/161", "generation": "\n\tvar result string\n\tfor _, c := range s {\n\t\tif unicode.IsLetter(c) {\n\t\t\tif unicode.IsLower(c) {\n\t\t\t\tresult += strings.ToUpper(string(c))\n\t\t\t} else {\n\t\t\t\tresult += strings.ToLower(string(c))\n\t\t\t}\n\t\t} else {\n\t\t\tresult += string(c)\n\t\t}\n\t}\n\tif result == \"\" {\n\t\treturn Reverse(s)\n\t}\n\treturn result\n}\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hash := md5.Sum([]byte(text))\n    return fmt.Sprintf(\"%x\", hash)\n}"}
{"task_id": "Go/163", "generation": "\n\tif a > b {\n\t\ta, b = b, a\n\t}\n\tvar res []int\n\tfor i := a; i <= b; i += 2 {\n\t\tres = append(res, i)\n\t}\n\treturn res\n}\n"}
