{"task_id": "Go/0", "generation": "\n    for i := 0; i < len(numbers)-1; i++ {\n        if math.Abs(numbers[i]-numbers[i+1]) < threshold {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/1", "generation": "\n\t// Remove spaces from the input string\n\tparen_string = strings.ReplaceAll(paren_string, \" \", \"\")\n\n\t// Initialize an empty stack to keep track of opening parentheses\n\tstack := make([]byte, 0)\n\n\t// Initialize an empty list to store the result\n\tresult := make([]string, 0)\n\n\t// Initialize an empty string to build the current group\n\tcurrent_group := \"\"\n\n\t// Iterate over the input string\n\tfor _, char := range paren_string {\n\t\t// If the character is an opening parenthesis, push it to the stack\n\t\tif char == '(' {\n\t\t\tstack = append(stack, char)\n\t\t\tcurrent_group += string(char)\n\t\t}\n\t\t// If the character is a closing parenthesis\n\t\telse if char == ')' {\n\t\t\t// If the stack is not empty, pop the opening parenthesis from the stack\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tcurrent_group += string(char)\n\t\t\t}\n\t\t\t// If the stack is empty, it means the closing parenthesis is not matched with an opening parenthesis\n\t\t\telse {\n\t\t\t\t// Add the current group to the result list\n\t\t\t\tresult = append(result, current_group)\n\t\t\t\t// Reset the current group\n\t\t\t\tcurrent_group = \"\"\n\t\t\t}\n\t\t}\n\t\t// If the character is not a parenthesis, ignore it\n\t}\n\n\t// Add the last group to the result list\n\tresult = append(result, current_group)\n\n\t// Return the result list\n\treturn result\n}\n\n"}
{"task_id": "Go/2", "generation": "\n    // Convert the number to an integer by rounding down\n    integerPart := math.Floor(number)\n    // Subtract the integer part from the original number to get the decimal part\n    decimalPart := number - integerPart\n    return decimalPart\n}\n"}
{"task_id": "Go/3", "generation": "\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0 {\nreturn true\n}\n}\nreturn false\n}\nfunc BelowZero(operations []int) bool {\nbalance := 0\nfor _, operation := range operations {\nbalance += operation\nif balance < 0"}
{"task_id": "Go/4", "generation": "\n    // Calculate mean of the dataset\n    mean := calculateMean(numbers)\n    \n    // Calculate absolute deviations from the mean\n    deviations := make([]float64, len(numbers))\n    for i, num := range numbers {\n        deviations[i] = math.Abs(num - mean)\n    }\n    \n    // Calculate mean of the absolute deviations\n    mad := calculateMean(deviations)\n    \n    return mad\n}\n"}
{"task_id": "Go/5", "generation": "\nresult := make([]int, 0, len(numbers)*2-1)\nfor i := 0; i < len(numbers); i++ {\nresult = append(result, numbers[i])\nif i < len(numbers)-1 {\nresult = append(result, delimeter)\n}\nreturn result\n}\n"}
{"task_id": "Go/6", "generation": "\n    // Split the input string into groups\n    groups := strings.Split(paren_string, \" \")\n    \n    // Initialize an empty slice to store the maximum level of nesting for each group\n    max_levels := make([]int, 0)\n    \n    // Iterate over each group\n    for _, group := range groups {\n        // Initialize a counter to keep track of the current level of nesting\n        level := 0\n        \n        // Initialize a flag to indicate whether we are currently inside a group of parentheses\n        inside_group := false\n        \n        // Iterate over each character in the group\n        for _, char := range group {\n            // If the character is an opening parenthesis, increment the level and set the flag to True\n            if char == '(' {\n                level++\n                inside_group = true\n            }\n            // If the character is a closing parenthesis, decrement the level and set the flag to False\n            else if char == ')' {\n                level--\n                inside_group = false\n            }\n        }\n        \n        // If the group is not empty, add the maximum level of nesting to the slice\n        if level > 0 {\n            max_levels = append(max_levels, level)\n        }\n    }\n    \n    // Return the slice of maximum levels of nesting\n    return max_levels\n}\n\n"}
{"task_id": "Go/7", "generation": "\n    var filteredList []string\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}\n"}
{"task_id": "Go/8", "generation": "\n\tsum := 0\n\tproduct := 1\n\tfor _, num := range numbers {\n\t\tsum += num\n\t\tproduct *= num\n\t}\n\treturn [2]int{sum, product}\n}\n\nfunc SumProductTest(t *testing.T) {\n\tif SumProduct([]int{}) != [2]int{0, 1} {\n\t\tt.Errorf(\"SumProduct([]int{}) = %v, want [0, 1]\", SumProduct([]int{}))\n\t}\n\tif SumProduct([]int{1, 2, 3, 4}) != [2]int{10, 24} {\n\t\tt.Errorf(\"SumProduct([]int{1, 2, 3, 4}) = %v, want [10, 24]\", SumProduct([]int{1, 2, 3, 4}))\n\t}\n}\n\n"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}\n"}
{"task_id": "Go/10", "generation": "\n    // Find the longest palindromic suffix of the string.\n    for i := len(str) - 1; i >= 0; i-- {\n        if IsPalindrome(str[i:]) {\n            return str + strings.Reverse(str[:i])\n        }\n    }\n    return str\n}\n"}
{"task_id": "Go/11", "generation": "\n    // Convert the input strings to byte slices\n    aBytes := []byte(a)\n    bBytes := []byte(b)\n\n    // Initialize an empty byte slice to store the result\n    result := make([]byte, len(aBytes))\n\n    // Iterate over the input byte slices\n    for i := range aBytes {\n        // Perform binary XOR on the corresponding bytes\n        result[i] = aBytes[i] ^ bBytes[i]\n    }\n\n    // Convert the result byte slice to a string\n    resultString := string(result)\n\n    // Return the result string\n    return resultString\n}\n\n"}
{"task_id": "Go/12", "generation": "\n\tif len(strings) == 0 {\n\t\treturn nil\n\t}\n\tlongest := strings[0]\n\tfor _, s := range strings {\n\t\tif len(s) > len(longest) {\n\t\t\tlongest = s\n\t\t}\n\t}\n\treturn longest\n}\n"}
{"task_id": "Go/13", "generation": "\n    if a == 0 {\n        return b\n    }\n    return greatest_common_divisor(b%a, a)\n}\n"}
{"task_id": "Go/14", "generation": "\n    var prefixes []string\n    for i := 1; i <= len(str); i++ {\n        prefixes = append(prefixes, str[:i])\n    }\n    return prefixes\n}\n"}
{"task_id": "Go/15", "generation": "\n    var result string\n    for i := 0; i <= n; i++ {\n        result += strconv.Itoa(i) + \" \"\n    }\n    return result\n}\n\n"}
{"task_id": "Go/16", "generation": "\n    // Convert the string to lowercase\n    str = strings.ToLower(str)\n    // Create a map to store the characters and their counts\n    charCount := make(map[rune]int)\n    // Iterate over the string\n    for _, char := range str {\n        // If the character is already in the map, increment its count\n        if _, ok := charCount[char]; ok {\n            charCount[char]++\n        } else {\n            // If the character is not in the map, add it with a count of 1\n            charCount[char] = 1\n        }\n    }\n    // Return the number of distinct characters\n    return len(charCount)\n}\n\n"}
{"task_id": "Go/17", "generation": "\n    var notes []int\n    for _, note := range strings.Fields(music_string) {\n        switch note {\n        case \"o\":\n            notes = append(notes, 4)\n        case \"o|\":\n            notes = append(notes, 2)\n        case \"|\":\n            notes = append(notes, 1)\n        case \".|\":\n            notes = append(notes, 1)\n        default:\n            panic(\"Invalid note\")\n        }\n    }\n    return notes\n}\n"}
{"task_id": "Go/18", "generation": "\ncount := 0\nfor i := 0; i < len(str)-len(substring)+1; i++ {\nif str[i:i+len(substring)] == substring {\ncount++\n}\n}\nreturn count\n}\n"}
{"task_id": "Go/19", "generation": "\n    // Split the string into a slice of strings\n    numbersSlice := strings.Split(numbers, \" \")\n    \n    // Sort the slice of strings\n    sort.Strings(numbersSlice)\n    \n    // Join the sorted slice of strings into a string\n    sortedNumbers := strings.Join(numbersSlice, \" \")\n    \n    return sortedNumbers\n}\n\n"}
{"task_id": "Go/20", "generation": "\n    // Sort the list of numbers\n    sort.Slice(numbers, func(i, j int) bool {\n        return numbers[i] < numbers[j]\n    })\n    // Find the closest pair\n    closest_pair := [2]float64{numbers[0], numbers[1]}\n    min_diff := math.Abs(numbers[1] - numbers[0])\n    for i := 1; i < len(numbers)-1; i++ {\n        diff := math.Abs(numbers[i+1] - numbers[i])\n        if diff < min_diff {\n            min_diff = diff\n            closest_pair[0] = numbers[i]\n            closest_pair[1] = numbers[i+1]\n        }\n    }\n    return closest_pair\n}\n"}
{"task_id": "Go/21", "generation": "\n    min := numbers[0]\n    max := numbers[0]\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n    if max == min {\n        return numbers\n    }\n    rescaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        rescaled[i] = (num - min) / (max - min)\n    }\n    return rescaled\n}\n"}
{"task_id": "Go/22", "generation": "\n\tvar result []int\n\tfor _, value := range values {\n\t\tif v, ok := value.(int); ok {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n"}
{"task_id": "Go/23", "generation": "\n\treturn len(str)\n}\n"}
{"task_id": "Go/24", "generation": "\n    for i := n - 1; i > 0; i-- {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 0\n}\n"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    var divisor int = 2\n    for n > 1 {\n        for n%divisor == 0 {\n            factors = append(factors, divisor)\n            n = n / divisor\n        }\n        divisor++\n        if divisor > math.Sqrt(float64(n)) {\n            divisor = n\n        }\n    }\n    return factors\n}\n\n"}
{"task_id": "Go/26", "generation": "\n    // Create a map to store the count of each number\n    countMap := make(map[int]int)\n    // Create a new slice to store the result\n    result := make([]int, 0)\n    // Iterate over the input slice\n    for _, num := range numbers {\n        // If the number is not in the map, add it to the map and the result slice\n        if countMap[num] == 0 {\n            countMap[num] = 1\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, char := range str {\n        if char >= 'a' && char <= 'z' {\n            result += string(rune(char - 32))\n        } else if char >= 'A' && char <= 'Z' {\n            result += string(rune(char + 32))\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/28", "generation": "\n\tvar result string\n\tfor _, s := range strings {\n\t\tresult += s\n\t}\n\treturn result\n}\n"}
{"task_id": "Go/29", "generation": "\nresult := make([]string, 0)\nfor _, s := range strings {\nif strings.HasPrefix(s, prefix) {\nresult = append(result, s)\n}\n}\nreturn result\n}\n"}
{"task_id": "Go/30", "generation": "\n    var result []int\n    for _, v := range l {\n        if v > 0 {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/32", "generation": "\n    // Check if the list has even number of coefficients\n    if len(xs)%2 == 1 {\n        panic(\"xs must have even number of coefficients\")\n    }\n    // Check if the largest coefficient is non-zero\n    if xs[len(xs)-1] == 0 {\n        panic(\"xs must have largest non-zero coefficient\")\n    }\n    // Find the root of the polynomial\n    return -Poly(xs[:len(xs)-1], -1.0)\n}\n"}
{"task_id": "Go/33", "generation": "\n    // Create a new slice to store the result\n    result := make([]int, len(l))\n    \n    // Iterate over the input slice\n    for i, v := range l {\n        // If the index is divisible by 3, sort the values at the corresponding index\n        if i%3 == 0 {\n            // Sort the values at the corresponding index\n            sort.Ints(l[i:i+3])\n        }\n        // If the index is not divisible by 3, copy the value to the result slice\n        result[i] = v\n    }\n    \n    // Return the result slice\n    return result\n}\n\n"}
{"task_id": "Go/34", "generation": "\n    sort.Slice(l, func(i, j int) bool {\n        return l[i] < l[j]\n    })\n    unique := make([]int, 0)\n    for _, v := range l {\n        if len(unique) == 0 || v != unique[len(unique)-1] {\n            unique = append(unique, v)\n        }\n    }\n    return unique\n}\n\n"}
{"task_id": "Go/35", "generation": "\nmax := l[0]\nfor _, v := range l {\nif v > max {\nmax = v\n}\n}\nreturn max\n}\n"}
{"task_id": "Go/36", "generation": "\n\tcount := 0\n\tfor i := 1; i < n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tstr := strconv.Itoa(i)\n\t\t\tfor _, r := range str {\n\t\t\t\tif r == '7' {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/37", "generation": "\n\t// Create a copy of the input list\n\tlCopy := make([]int, len(l))\n\tcopy(lCopy, l)\n\n\t// Sort the even indicies of the copy\n\tfor i := 1; i < len(lCopy); i += 2 {\n\t\tsort.Ints(lCopy[i : i+1])\n\t}\n\n\treturn lCopy\n}\n\n"}
{"task_id": "Go/38", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for i := 0; i < len(runes); i++ {\n        if i%3 == 0 {\n            newRunes = append(newRunes, runes[i])\n        } else {\n            newRunes = append(newRunes, runes[i-1])\n        }\n    }\n    return string(newRunes)\n}\n\n"}
{"task_id": "Go/39", "generation": "\n\tfib := 0\n\tprime := 0\n\ti := 0\n\tfor {\n\t\tfib = fibNext(fib)\n\t\tprime = isPrime(fib)\n\t\tif prime == 1 {\n\t\t\ti++\n\t\t\tif i == n {\n\t\t\t\treturn fib\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc fibNext(fib int) int {\n\treturn fib + fib\n}\n\nfunc isPrime(n int) int {\n\tif n <= 1 {\n\t\treturn 0\n\t}\n\tif n == 2 {\n\t\treturn 1\n\t}\n\tif n%2 == 0 {\n\t\treturn 0\n\t}\n\tsqrt := int(math.Sqrt(float64(n)))\n\tfor i := 3; i <= sqrt; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn 1\n}\n"}
{"task_id": "Go/40", "generation": "\n    if len(l) < 3 {\n        return false\n    }\n    sort.Ints(l)\n    for i := 0; i < len(l)-2; i++ {\n        left, right := i+1, len(l)-1\n        for left < right {\n            sum := l[i] + l[left] + l[right]\n            if sum == 0 {\n                return true\n            }\n            if sum < 0 {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/41", "generation": "\n    // Initialize a variable to store the number of collisions\n    collisions := 0\n    // Loop through each car moving left to right\n    for i := 1; i <= n; i++ {\n        // Loop through each car moving right to left\n        for j := 1; j <= n; j++ {\n            // If the two cars collide, increment the collision count\n            if i+j == n+1 {\n                collisions++\n            }\n        }\n    }\n    // Return the total number of collisions\n    return collisions\n} \n"}
{"task_id": "Go/42", "generation": "\n    // Create a new list with elements incremented by 1\n    var result []int\n    for _, v := range l {\n        result = append(result, v+1)\n    }\n    return result\n}\n"}
{"task_id": "Go/43", "generation": "\n    // Create a set to store the elements we have seen so far\n    seen := make(map[int]bool)\n    for _, num := range l {\n        // If the negation of the current number is in the set, return True\n        if seen[num*-1] {\n            return true\n        }\n        // Otherwise, add the current number to the set\n        seen[num] = true\n    }\n    // If we have iterated over the entire list and haven't found a pair that sums to zero, return False\n    return false\n}\n"}
{"task_id": "Go/44", "generation": "\n    // Convert the number to a string\n    str := strconv.Itoa(x)\n    \n    // Convert the string to the desired base\n    result := \"\"\n    for _, char := range str {\n        // Convert the character to an integer\n        num := int(char - '0')\n        \n        // Convert the integer to the desired base\n        for base > 1 {\n            result = strconv.Itoa(num % base) + result\n            num = num / base\n        }\n        result = strconv.Itoa(num) + result\n    }\n    \n    return result\n}\n\n"}
{"task_id": "Go/45", "generation": "\n\treturn a * h / 2\n}\n"}
{"task_id": "Go/46", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    fib4 := make([]int, n+1)\n    fib4[0] = 0\n    fib4[1] = 0\n    fib4[2] = 2\n    for i := 3; i <= n; i++ {\n        fib4[i] = fib4[i-1] + fib4[i-2] + fib4[i-3] + fib4[i-4]\n    }\n    return fib4[n]\n} "}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64((l[n/2-1] + l[n/2]) / 2)\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}\n"}
{"task_id": "Go/48", "generation": "\nr := strings.Repeat(\"\", len(text))\nreturn text == r\n}\n"}
{"task_id": "Go/49", "generation": "\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\nreturn n % p\n}\nfunc Modp(n int,p int) int {\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-'a'+26)%26+'a')\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/51", "generation": "\n    // Define a regular expression that matches any vowel (both lowercase and uppercase)\n    vowelRegex := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the ReplaceAllString function to replace all occurrences of vowels with an empty string\n    return vowelRegex.ReplaceAllString(text, \"\")\n}\n\n"}
{"task_id": "Go/52", "generation": "\nfor _, num := range l {\nif num >= t {\nreturn false\n}\n}\nreturn true\n}\n"}
{"task_id": "Go/53", "generation": "\n\treturn x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n// Convert strings to slices of runes.\nr0 := []rune(s0)\nr1 := []rune(s1)"}
{"task_id": "Go/55", "generation": "\nif n <= 1 {\nreturn n\n} else {\nreturn Fib(n-1) + Fib(n-2)\n}\n}\n"}
{"task_id": "Go/56", "generation": "\n    stack := make([]rune, 0)\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/57", "generation": "\nif len(l) < 2 {\nreturn true\n}\nprev := l[0]\nfor i := 1; i < len(l); i++ {\nif prev > l[i] {\nreturn false\n}\nprev = l[i]\n}\nreturn true\n}\n"}
{"task_id": "Go/58", "generation": "\n    // Convert the lists to sets\n    set1 := make(map[int]bool)\n    set2 := make(map[int]bool)\n    for _, v := range l1 {\n        set1[v] = true\n    }\n    for _, v := range l2 {\n        set2[v] = true\n    }\n    // Find the intersection of the two sets\n    intersection := make(map[int]bool)\n    for k := range set1 {\n        if set2[k] {\n            intersection[k] = true\n        }\n    }\n    // Convert the intersection back to a list and sort it\n    common := make([]int, 0, len(intersection))\n    for k := range intersection {\n        common = append(common, k)\n    }\n    sort.Ints(common)\n    return common\n}\n\n"}
{"task_id": "Go/59", "generation": "\n    // Start with the largest possible factor, which is n itself.\n    largest_factor = n\n    // Start with the smallest possible divisor, which is 2.\n    divisor = 2\n    // Continue dividing n by the divisor until n is no longer divisible.\n    for n % divisor == 0 {\n        // If n is divisible by the divisor, update the largest factor.\n        largest_factor = divisor\n        // Divide n by the divisor.\n        n = n / divisor\n    }\n    // Return the largest factor found.\n    return largest_factor\n}\n"}
{"task_id": "Go/60", "generation": "\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\nreturn sum\n}\nfunc SumToN(n int) int {\nsum := 0\nfor i := 1; i <= n; i++ {\nsum += i\n"}
{"task_id": "Go/61", "generation": "\n    // Initialize a counter to keep track of the number of opening brackets\n    count := 0\n    // Iterate over each character in the string\n    for _, char := range brackets {\n        // If the character is an opening bracket, increment the counter\n        if char == '(' {\n            count++\n        }\n        // If the character is a closing bracket, decrement the counter\n        else if char == ')' {\n            count--\n            // If the counter is ever negative, return False\n            if count < 0 {\n                return false\n            }\n        }\n    }\n    // If the counter is not zero after iterating over the entire string, return False\n    return count == 0\n}\n\n"}
{"task_id": "Go/62", "generation": "\n    // If the polynomial is a constant, return an empty list.\n    if len(xs) == 1 {\n        return []int{}\n    }\n    // If the polynomial is a linear function, return the coefficient of x.\n    if len(xs) == 2 {\n        return []int{xs[1]}\n    }\n    // For higher degree polynomials, the derivative of x^n is n*x^(n-1).\n    // So, we multiply each coefficient by its exponent and subtract one from the exponent.\n    derivative := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derivative[i-1] = xs[i] * i\n    }\n    return derivative\n}\n"}
{"task_id": "Go/63", "generation": "\n    if n == 0 {\n        return 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    } else {\n        return Fibfib(n-1) + Fibfib(n-2) + Fibfib(n-3)\n    }\n}\n"}
{"task_id": "Go/64", "generation": "\n    // Convert the string to lowercase\n    s = strings.ToLower(s)\n    // Initialize a counter for vowels\n    count := 0\n    // Loop through each character in the string\n    for _, char := range s {\n        // Check if the character is a vowel\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            // If it is, increment the counter\n            count++\n        }\n    }\n    // Return the count of vowels\n    return count\n}\n"}
{"task_id": "Go/65", "generation": "\n    // Convert the integer to a string\n    str := strconv.Itoa(x)\n    // Calculate the shift amount\n    shift = shift % len(str)\n    // Split the string into two parts\n    first := str[:len(str)-shift]\n    second := str[len(str)-shift:]\n    // Combine the two parts in reverse order\n    result := second + first\n    return result\n}\n"}
{"task_id": "Go/66", "generation": "\n\tsum := 0\n\tfor _, r := range x {\n\t\tif unicode.IsUpper(r) {\n\t\t\tsum += int(r)\n\t\t}\n\t}\n\treturn sum\n} // end of Digitsum\n"}
{"task_id": "Go/67", "generation": "\n\t// split the string to get the number of apples and oranges\n\twords := strings.Split(s, \" \")\n\t// get the number of apples and oranges\n\tapples, _ := strconv.Atoi(words[0])\n\toranges, _ := strconv.Atoi(words[2])\n\t// return the number of mango fruits\n\treturn n - apples - oranges\n} // time complexity O(n) space complexity O(n) where n is the number of words in the string\n"}
{"task_id": "Go/68", "generation": "\n    if len(arr) == 0 {\n        return []int{}\n    }\n    minEven := math.MaxInt\n    minEvenIndex := -1\n    for i, v := range arr {\n        if v%2 == 0 && v < minEven {\n            minEven = v\n            minEvenIndex = i\n        }\n    }\n    if minEven == math.MaxInt {\n        return []int{}\n    }\n    return []int{minEven, minEvenIndex}\n}\n"}
{"task_id": "Go/69", "generation": "\n    max := 0\n    for _, v := range lst {\n        if v > 0 && v <= len(lst) && v <= max {\n            continue\n        }\n        if v > 0 && v <= len(lst) {\n            count := 0\n            for _, vv := range lst {\n                if vv == v {\n                    count++\n                }\n            }\n            if count >= v {\n                max = v\n            }\n        }\n    }\n    if max == 0 {\n        return -1\n    }\n    return max\n}\n\n"}
{"task_id": "Go/70", "generation": "\n    if len(lst) == 0 {\n        return lst\n    }\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i] < lst[j]\n    })\n    return lst\n}\n"}
{"task_id": "Go/71", "generation": "\n    // Check if the three sides form a valid triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    // Calculate the semi-perimeter\n    s := (a + b + c) / 2\n    // Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n    // Return the area rounded to 2 decimal points\n    return math.Round(area*100) / 100\n} \n"}
{"task_id": "Go/72", "generation": "\n    // Check if the list is a palindrome\n    for i := 0; i < len(q)/2; i++ {\n        if q[i] != q[len(q)-1-i] {\n            return false\n        }\n    }\n    // Check if the sum of the elements is less than or equal to the maximum possible weight\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n"}
{"task_id": "Go/73", "generation": "\n    // Create a map to store the frequency of each element\n    freq := make(map[int]int)\n    for _, num := range arr {\n        freq[num]++\n    }\n    // Count the number of elements that appear an odd number of times\n    oddCount := 0\n    for _, count := range freq {\n        if count%2 != 0 {\n            oddCount++\n        }\n    }\n    // The minimum number of changes is the number of elements that appear an odd number of times minus one\n    return oddCount - 1\n} \n"}
{"task_id": "Go/74", "generation": "\n\tvar result []string\n\tvar count1 int\n\tvar count2 int\n\tfor _, v := range lst1 {\n\t\tcount1 += len(v)\n\t}\n\tfor _, v := range lst2 {\n\t\tcount2 += len(v)\n\t}\n\tif count1 < count2 {\n\t\tresult = lst1\n\t} else if count1 > count2 {\n\t\tresult = lst2\n\t} else {\n\t\tresult = lst1\n\t}\n\treturn result\n} // end of TotalMatch\n"}
{"task_id": "Go/75", "generation": "\n    // Check if the number is less than 100\n    if a < 100 {\n        // Check if the number is divisible by 2, 3, and 5\n        if a%2 == 0 && a%3 == 0 && a%5 == 0 {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/76", "generation": "\n    return math.Pow(float64(n), float64(int(math.Log(float64(x))/math.Log(float64(n))))) == float64(x)\n}\n"}
{"task_id": "Go/77", "generation": "\n    // Calculate the cube root of a\n    cubeRoot := math.Sqrt(math.Sqrt(float64(a)))\n    // Check if the cube root is an integer\n    return math.Mod(cubeRoot, 1) == 0\n} \n"}
{"task_id": "Go/78", "generation": "\n    primes := []string{\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    count := 0\n    for _, hex := range num {\n        for _, prime := range primes {\n            if string(hex) == prime {\n                count++\n            }\n        }\n    }\n    return count\n}"}
{"task_id": "Go/79", "generation": "\n\t// Convert the decimal number to binary and remove the \"0b\" prefix\n\tbinary := fmt.Sprintf(\"%b\", decimal)\n\t// Add the \"db\" prefix and suffix to the binary string\n\treturn \"db\" + binary + \"db\"\n}\n\n"}
{"task_id": "Go/80", "generation": "\n\t// check if the length of the string is at least 3\n\tif len(s) < 3 {\n\t\treturn false\n\t}\n\t// check if every 3 consecutive letters are distinct\n\tfor i := 0; i < len(s)-2; i++ {\n\t\tif s[i] == s[i+1] && s[i+1] == s[i+2] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n} "}
{"task_id": "Go/81", "generation": "\n    var letterGrades []string\n    for _, g := range grades {\n        if g >= 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if g >= 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if g >= 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if g >= 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if g >= 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if g >= 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if g >= 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if g >= 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if g >= 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if g >= 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if g >= 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n} \n"}
{"task_id": "Go/82", "generation": "\n\t// Check if the string is empty\n\tif len(s) == 0 {\n\t\treturn false\n\t}\n\n\t// Check if the string length is a prime number\n\tfor i := 2; i*i <= len(s); i++ {\n\t\tif len(s)%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n} "}
{"task_id": "Go/83", "generation": "\n    // The number of n-digit positive integers start with 1 is 9^(n-1)\n    start := int(math.Pow(10, float64(n-1)) - 1)\n    // The number of n-digit positive integers end with 1 is 9^(n-1)\n    end := int(math.Pow(10, float64(n-1)) - 1)\n    // The number of n-digit positive integers start and end with 1 is 9^(n-2)\n    overlap := int(math.Pow(10, float64(n-2)) - 1)\n    // The total count is the sum of start and end minus overlap\n    return start + end - overlap\n} \n"}
{"task_id": "Go/84", "generation": "\n    // Convert N to binary and remove the \"0b\" prefix\n    binary := strconv.FormatInt(int64(N), 2)\n    \n    // Initialize sum to 0\n    sum := 0\n    \n    // Iterate over each character in the binary string\n    for _, char := range binary {\n        // Convert the character to an integer and add it to the sum\n        sum += int(char - '0')\n    }\n    \n    // Convert the sum to binary and remove the \"0b\" prefix\n    binarySum := strconv.FormatInt(int64(sum), 2)\n    \n    // Return the binary sum\n    return binarySum\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    sum := 0\n    for i, v := range lst {\n        if i%2 == 1 && v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/86", "generation": "\n    words := strings.Fields(s)\n    result := \"\"\n    for _, word := range words {\n        sortedWord := \"\"\n        for _, r := range word {\n            sortedWord += string(r)\n        }\n        sortedWord = sortString(sortedWord)\n        result += sortedWord + \" \"\n    }\n    return strings.TrimSpace(result)\n}\n\nfunc sortString(s string) string {\n    runes := []rune(s)\n    sort.Slice(runes, func(i, j int) bool {\n        return runes[i] < runes[j]\n    })\n    return string(runes)\n}\n"}
{"task_id": "Go/87", "generation": "\n    var res [][2]int\n    for i, row := range lst {\n        for j, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, j})\n            }\n        }\n    }\n    sort.Slice(res, func(i, j int) bool {\n        if res[i][0] == res[j][0] {\n            return res[i][1] > res[j][1]\n        }\n        return res[i][0] < res[j][0]\n    })\n    return res\n}\n\n"}
{"task_id": "Go/88", "generation": "\n    // Check if the array is empty\n    if len(array) == 0 {\n        return array\n    }\n\n    // Calculate the sum of the first and last index values\n    sum := array[0] + array[len(array)-1]\n\n    // Determine the sorting order\n    if sum%2 == 0 {\n        // Sort in ascending order\n        sort.Ints(array)\n    } else {\n        // Sort in descending order\n        sort.Slice(array, func(i, j int) bool {\n            return array[i] > array[j]\n        })\n    }\n\n    // Return the sorted array\n    return array\n}\n"}
{"task_id": "Go/89", "generation": "\n    // Convert the string to a byte slice\n    b := []byte(s)\n    // Create a new byte slice to store the encrypted string\n    encrypted := make([]byte, len(b))\n    // Iterate over the byte slice\n    for i, v := range b {\n        // Check if the character is a letter\n        if v >= 'a' && v <= 'z' {\n            // Calculate the new character by shifting down by two places\n            encrypted[i] = 'a' + (v - 'a' + 2) % 26\n        } else if v >= 'A' && v <= 'Z' {\n            // Calculate the new character by shifting down by two places\n            encrypted[i] = 'A' + (v - 'A' + 2) % 26\n        } else {\n            // If the character is not a letter, leave it as is\n            encrypted[i] = v\n        }\n    }\n    // Convert the byte slice back to a string and return it\n    return string(encrypted)\n}\n\n"}
{"task_id": "Go/90", "generation": "\n    if len(lst) < 2 {\n        return nil\n    }\n    sort.IntsAreSorted(lst)\n    for i := 1; i < len(lst); i++ {\n        if lst[i] != lst[i-1] {\n            return lst[i]\n        }\n    }\n    return nil\n}\n\n"}
{"task_id": "Go/91", "generation": "\n    // Split the string into sentences\n    sentences := regexp.MustCompile(`[.!?]`).Split(S, -1)\n    // Count the number of sentences that start with \"I\"\n    count := 0\n    for _, sentence := range sentences {\n        if strings.HasPrefix(sentence, \"I\") {\n            count++\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/92", "generation": "\n\t// Check if all inputs are integers\n\tif !IsInt(x) || !IsInt(y) || !IsInt(z) {\n\t\treturn false\n\t}\n\t// Check if one of the numbers is equal to the sum of the other two\n\tif x == y+z || y == x+z || z == x+y {\n\t\treturn true\n\t}\n\treturn false\n}\n"}
{"task_id": "Go/93", "generation": "\n    // Convert the message to a byte slice\n    messageBytes := []byte(message)\n    \n    // Initialize an empty byte slice to store the encoded message\n    encodedMessage := make([]byte, 0)\n    \n    // Iterate over each byte in the message\n    for _, byte := range messageBytes {\n        // Convert the byte to a rune\n        rune := byte\n        \n        // Check if the rune is a lowercase letter\n        if unicode.IsLower(rune) {\n            // Convert the rune to uppercase\n            rune = unicode.ToUpper(rune)\n            \n            // Check if the rune is a vowel\n            if strings.Contains(\"aeiou\", string(rune)) {\n                // Calculate the index of the vowel in the alphabet\n                index := strings.Index(\"aeiou\", string(rune))\n                \n                // Calculate the new index by adding 2\n                newIndex := (index + 2) % 5\n                \n                // Get the new rune by getting the rune at the new index\n                newRune := rune\n                for i := 0; i < 5; i++ {\n                    if string(rune) == string(\"aeiou\"[i]) {\n                        newRune = rune\n                        break\n                    }\n                    newRune = \"aeiou\"[i]\n                }\n                \n                // Add the new rune to the encoded message\n                encodedMessage = append(encodedMessage, newRune)\n            } else {\n                // Add the rune to the encoded message\n                encodedMessage = append(encodedMessage, rune)\n            }\n        } else if unicode.IsUpper(rune) {\n            // Convert the rune to lowercase\n            rune = unicode.ToLower(rune)\n            \n            // Check if the rune is a vowel\n            if strings.Contains(\"aeiou\", string(rune)) {\n                // Calculate the index of the vowel in the alphabet\n                index := strings.Index(\"aeiou\", string(rune))\n                \n                // Calculate the new index by adding 2\n                newIndex := (index + 2) % 5\n                \n                // Get the new rune by getting the rune at the new index\n                newRune := rune\n                for i := 0; i < 5; i++ {\n                    if string(rune) == string(\"aeiou\"[i]) {\n                        newRune = rune\n                        break\n                    }\n                    newRune = \"aeiou\"[i]\n                }\n                \n                // Add the new rune to the encoded message\n                encodedMessage = append(encodedMessage,"}
{"task_id": "Go/94", "generation": "\n    max := 0\n    for _, num := range lst {\n        if num > max {\n            max = num\n        }\n    }\n    isPrime := func(n int) bool {\n        if n <= 1 {\n            return false\n        }\n        for i := 2; i*i <= n; i++ {\n            if n%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    if isPrime(max) {\n        return sumDigits(max)\n    }\n    return 0\n}\n\nfunc sumDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n"}
{"task_id": "Go/95", "generation": "\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n\n    // Check if all keys are strings\n    for key := range dict {\n        if !strings.ContainsAny(string(key), \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n            return false\n        }\n    }\n\n    // Check if all keys are either lower case or upper case\n    for key := range dict {\n        if !strings.EqualFold(string(key), string(key)) {\n            return false\n        }\n    }\n\n    return true\n} "}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n"}
{"task_id": "Go/97", "generation": "\n    // Get the unit digit of a\n    unitDigitA := a % 10\n    // Get the unit digit of b\n    unitDigitB := b % 10\n    // Multiply the unit digits\n    product := unitDigitA * unitDigitB\n    // Return the product\n    return product\n} \n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for i, r := range s {\n        if i%2 == 0 && strings.ToUpper(string(r)) == string(r) && \"AEIOU\".Contains(string(r)) {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/99", "generation": "\n    // Convert the string to a float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n\n    // Round the number to the nearest integer\n    roundedNum := math.Round(num)\n\n    // If the number is equidistant from two integers, round it away from zero\n    if num-math.Floor(num) == math.Copysign(0.5, num) {\n        if num > 0 {\n            roundedNum++\n        } else {\n            roundedNum--\n        }\n    }\n\n    // Convert the rounded number to an integer\n    result := int(roundedNum)\n\n    return result\n}\n\n"}
{"task_id": "Go/100", "generation": "\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i % 2 == 0 {\n            result[i] = i + 1\n        } else {\n            result[i] = i + 2\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/101", "generation": "\n    // Remove all commas from the string\n    s = strings.ReplaceAll(s, \",\", \" \")\n    // Split the string into words\n    words := strings.Split(s, \" \")\n    return words\n} "}
{"task_id": "Go/102", "generation": "\n    if x > y {\n        return -1\n    }\n    return y - (y - x) / 2\n}\n"}
{"task_id": "Go/103", "generation": "\n    // Check if n is greater than m\n    if n > m {\n        return -1\n    }\n\n    // Calculate the sum of integers from n to m\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n\n    // Calculate the average\n    avg := float64(sum) / float64(m-n+1)\n\n    // Round the average to the nearest integer\n    roundedAvg := math.Round(avg)\n\n    // Convert the rounded average to binary\n    binary := fmt.Sprintf(\"%b\", int(roundedAvg))\n\n    return binary\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    // Convert each number to string to be able to check for even digits\n    var evenDigits []string\n    for _, num := range x {\n        str := strconv.Itoa(num)\n        for _, r := range str {\n            if r%2 == 0 {\n                evenDigits = append(evenDigits, string(r))\n            }\n        }\n    }\n    // Remove duplicates from the list of even digits\n    evenDigits = removeDuplicates(evenDigits)\n    // Convert the list of even digits back to integers\n    var evenDigitsInt []int\n    for _, digit := range evenDigits {\n        evenDigitsInt = append(evenDigitsInt, int(digit[0]-'0'))\n    }\n    // Sort the list of even digits\n    sort.Ints(evenDigitsInt)\n    return evenDigitsInt\n}\n"}
{"task_id": "Go/105", "generation": "\n    var result []string\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            result = append(result, getNumberName(num))\n        }\n    }\n    sort.Ints(arr)\n    for i := range arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = getNumberName(arr[i])\n        }\n    }\n    sort.Ints(arr)\n    for i := range arr {\n        result[i] = getNumberName(arr[i])\n    }\n    sort.Ints(arr)\n    for i := range arr {\n        result[i] = getNumberName(arr[i])\n    }\n    return result\n}\n\nfunc getNumberName(num int) string {\n    switch num {\n    case 1:\n        return \"One\"\n    case 2:\n        return \"Two\"\n    case 3:\n        return \"Three\"\n    case 4:\n        return \"Four\"\n    case 5:\n        return \"Five\"\n    case 6:\n        return \"Six\"\n    case 7:\n        return \"Seven\"\n    case 8:\n        return \"Eight\"\n    case 9:\n        return \"Nine\"\n    default:\n        return \"\"\n    }\n}\n"}
{"task_id": "Go/106", "generation": "\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i % 2 == 0 {\n            result[i] = factorial(i)\n        } else {\n            result[i] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(n int) int {\n    result := 1\n    for i := 2; i <= n; i++ {\n        result *= i\n    }\n    return result\n}\n\nfunc sum(n int) int {\n    result := 0\n    for i := 1; i <= n; i++ {\n        result += i\n    }\n    return result\n}\n"}
{"task_id": "Go/107", "generation": "\n    // Initialize the count of even and odd integer palindromes\n    evenCount := 0\n    oddCount := 0\n\n    // Iterate over the range from 1 to n\n    for i := 1; i <= n; i++ {\n        // Convert the integer to a string to check if it's a palindrome\n        str := strconv.Itoa(i)\n        // Check if the string is equal to its reverse\n        if str == reverse(str) {\n            // Check if the integer is even or odd\n            if i%2 == 0 {\n                // If the integer is even, increment the even count\n                evenCount++\n            } else {\n                // If the integer is odd, increment the odd count\n                oddCount++\n            }\n        }\n    }\n\n    // Return the count of even and odd integer palindromes as a tuple\n    return [2]int{evenCount, oddCount}\n}\n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            num = -num\n        }\n        sum := 0\n        for _, digit := range strconv.Itoa(num) {\n            sum += int(digit - '0')\n        }\n        if sum > 0 {\n            count++\n        }\n        if num < 0 {\n            num = -num\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/109", "generation": "\n    // Check if the array is empty\n    if len(arr) == 0 {\n        return true\n    }\n\n    // Sort the array in ascending order\n    sort.Ints(arr)\n\n    // Initialize a variable to store the number of right shifts\n    rightShifts := 0\n\n    // Iterate over the array to find the number of right shifts\n    for i := 0; i < len(arr); i++ {\n        // If the current element is not equal to the next element, increment the right shifts\n        if i < len(arr)-1 && arr[i] != arr[i+1] {\n            rightShifts++\n        }\n    }\n\n    // If the number of right shifts is equal to the length of the array minus one, return true\n    if rightShifts == len(arr)-1 {\n        return true\n    }\n\n    // Otherwise, return false\n    return false\n}\n\n"}
{"task_id": "Go/110", "generation": "\n    // Check if all elements in lst1 are even\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc Exchange(lst1, lst2 []int) string {\n    // Check if all elements in lst1 are even\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n"}
{"task_id": "Go/111", "generation": "\n    // Split the string into a slice of strings\n    words := strings.Split(test, \" \")\n    // Create a map to store the frequency of each word\n    frequency := make(map[rune]int)\n    // Iterate over each word in the slice\n    for _, word := range words {\n        // If the word is not empty\n        if word != \"\" {\n            // Increment the frequency of the word\n            frequency[rune(word[0])]++\n        }\n    }\n    // Find the maximum frequency\n    maxFrequency := 0\n    for _, frequency := range frequency {\n        if frequency > maxFrequency {\n            maxFrequency = frequency\n        }\n    }\n    // Create a new map to store the words with the maximum frequency\n    maxFrequencyMap := make(map[rune]int)\n    // Iterate over each word in the frequency map\n    for word, frequency := range frequency {\n        // If the frequency of the word is equal to the maximum frequency\n        if frequency == maxFrequency {\n            // Add the word to the maxFrequencyMap\n            maxFrequencyMap[word] = frequency\n        }\n    }\n    // Return the maxFrequencyMap\n    return maxFrequencyMap\n} "}
{"task_id": "Go/112", "generation": "\n    // Convert the string c to a set of characters for efficient lookups\n    cSet := make(map[rune]bool)\n    for _, r := range c {\n        cSet[r] = true\n    }\n\n    // Initialize an empty string to store the result\n    result := \"\"\n\n    // Iterate over the string s\n    for _, r := range s {\n        // If the character is not in the set of characters to delete, add it to the result\n        if !cSet[r] {\n            result += string(r)\n        }\n    }\n\n    // Check if the result string is a palindrome\n    isPalindrome := strings.EqualFold(result, strings.Reverse(result))\n\n    // Return the result string and the palindrome check result\n    return [2]interface{}{result, isPalindrome}\n}\n\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        odd := 0\n        for _, r := range str {\n            if r%2 != 0 {\n                odd++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number of odd elements %dn the str%dn of the %dnput.\", odd, odd, odd))\n    }\n    return result\n}\n"}
{"task_id": "Go/114", "generation": "\n    min := math.MaxInt\n    sum := 0\n    for _, num := range nums {\n        sum += num\n        if sum < min {\n            min = sum\n        }\n        if sum > 0 {\n            sum = 0\n        }\n    }\n    return min\n} \n"}
{"task_id": "Go/115", "generation": "\n    var totalWater int\n    for _, row := range grid {\n        for _, cell := range row {\n            totalWater += cell\n        }\n    }\n    return totalWater / capacity\n}\n\n"}
{"task_id": "Go/116", "generation": "\n    // Your code here\n    sort.Slice(arr, func(i, j int) bool {\n        // Count the number of ones in the binary representation of arr[i] and arr[j]\n        onesInI := 0\n        onesInJ := 0\n        for i != 0 {\n            onesInI += i & 1\n            i >>= 1\n        }\n        for j != 0 {\n            onesInJ += j & 1\n            j >>= 1\n        }\n        // If the number of ones is the same, sort based on decimal value\n        if onesInI == onesInJ {\n            return arr[i] < arr[j]\n        }\n        // Otherwise, sort based on the number of ones\n        return onesInI < onesInJ\n    })\n    return arr\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    // Split the string into words\n    words := strings.Fields(s)\n    // Initialize an empty list to store the result\n    result := make([]string, 0)\n    // Iterate over each word in the list of words\n    for _, word := range words {\n        // Count the number of consonants in the word\n        count := 0\n        for _, char := range word {\n            if strings.ToLower(string(char)) >= \"a\" && strings.ToLower(string(char)) <= \"z\" && !strings.ContainsRune(string(char), ' ') {\n                count++\n            }\n        }\n        // If the count of consonants in the word is equal to n, add the word to the result list\n        if count == n {\n            result = append(result, word)\n        }\n    }\n    // Return the result list\n    return result\n}\n\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 2; i >= 0; i-- {\n        if !isVowel(word[i]) {\n            if isVowel(word[i+1]) {\n                return string(word[i+1])\n            }\n            if isVowel(word[i+2]) {\n                return string(word[i+2])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc isVowel(b byte) bool {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for _, v := range vowels {\n        if b == v {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/119", "generation": "\n\t// Initialize a counter to track the balance of parentheses\n\tbalance := 0\n\t// Iterate over each string in the list\n\tfor _, str := range lst {\n\t\t// Iterate over each character in the string\n\t\tfor _, char := range str {\n\t\t\t// If the character is an open parenthesis, increment the balance\n\t\t\tif char == '(' {\n\t\t\t\tbalance++\n\t\t\t} else {\n\t\t\t\t// If the character is a close parenthesis, decrement the balance\n\t\t\t\tbalance--\n\t\t\t\t// If the balance is negative, return 'No'\n\t\t\t\tif balance < 0 {\n\t\t\t\t\treturn \"No\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// After processing each string, if the balance is not zero, return 'No'\n\t\tif balance != 0 {\n\t\t\treturn \"No\"\n\t\t}\n\t}\n\t// If the function has not returned 'No' after processing all strings, return 'Yes'\n\treturn \"Yes\"\n} "}
{"task_id": "Go/120", "generation": "\n    // Sort the array in descending order\n    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    // Return the first k elements of the sorted array\n    return arr[:k]\n}\n\n"}
{"task_id": "Go/121", "generation": "\n\tsum := 0\n\tfor i, v := range lst {\n\t\tif i%2 == 1 && v%2 == 1 {\n\t\t\tsum += v\n\t\t}\n\t}\n\treturn sum\n}\n"}
{"task_id": "Go/122", "generation": "\n    sum := 0\n    for i := 0; i < k; i++ {\n        if len(strconv.Itoa(arr[i])) <= 2 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\n"}
{"task_id": "Go/123", "generation": "\n    result := []int{}\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n        result = append(result, n)\n    }\n    sort.Ints(result)\n    return result\n}\n\n"}
{"task_id": "Go/124", "generation": "\n    // Split the date string into month, day, and year\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n    month, day, year := parts[0], parts[1], parts[2]\n\n    // Check if the month is valid\n    monthInt, err := strconv.Atoi(month)\n    if err != nil || monthInt < 1 || monthInt > 12 {\n        return false\n    }\n\n    // Check if the day is valid\n    dayInt, err := strconv.Atoi(day)\n    if err != nil || (monthInt == 2 && dayInt > 29) || (monthInt == 4 || monthInt == 6 || monthInt == 9 || monthInt == 11 && dayInt > 30) || (monthInt == 1 || monthInt == 3 || monthInt == 5 || monthInt == 7 || monthInt == 8 || monthInt == 10 || monthInt == 12 && dayInt > 31) {\n        return false\n    }\n\n    // Check if the year is valid\n    yearInt, err := strconv.Atoi(year)\n    if err != nil || yearInt < 1 {\n        return false\n    }\n\n    return true\n}\n"}
{"task_id": "Go/125", "generation": "\n    // Split the string on whitespace\n    words := strings.Fields(txt)\n    if len(words) == 1 {\n        // If there is only one word, split on commas\n        words = strings.Split(txt, \",\")\n    }\n    if len(words) == 1 {\n        // If there is only one word and no commas, count the number of lower-case letters with odd order in the alphabet\n        count := 0\n        for i := 0; i < len(txt); i++ {\n            if txt[i] >= 'a' && txt[i] <= 'z' && (i%2 == 1) {\n                count++\n            }\n        }\n        return count\n    }\n    return words\n}\n"}
{"task_id": "Go/126", "generation": "\n    for i := 1; i < len(lst); i++ {\n        if lst[i] < lst[i-1] {\n            return false\n        }\n        if lst[i] == lst[i-1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/127", "generation": "\n\t// find the start and end of the intersection\n\tstart := max(interval1[0], interval2[0])\n\tend := min(interval1[1], interval2[1])\n\n\t// if the start is greater than the end, the intervals don't intersect\n\tif start > end {\n\t\treturn \"NO\"\n\t}\n\n\t// calculate the length of the intersection\n\tlength := end - start\n\n\t// check if the length is a prime number\n\tif isPrime(length) {\n\t\treturn \"YES\"\n\t} else {\n\t\treturn \"NO\"\n\t}\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n\nfunc isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tif n == 2 {\n\t\treturn true\n\t}\n\tif n%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= n; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}
{"task_id": "Go/128", "generation": "\n    // check if array is empty\n    if len(arr) == 0 {\n        return nil\n    }\n    // initialize product of signs\n    var prodSign int64 = 1\n    // initialize sum of magnitudes\n    var sumMag int64 = 0\n    // iterate over array\n    for _, num := range arr {\n        // check if number is negative\n        if num < 0 {\n            // multiply product of signs by -1\n            prodSign *= -1\n        }\n        // add magnitude of number to sum of magnitudes\n        sumMag += int64(math.Abs(float64(num)))\n    }\n    // return product of signs times sum of magnitudes\n    return prodSign * sumMag\n} \n"}
{"task_id": "Go/129", "generation": "\n    m, n := len(grid), len(grid[0])\n    visited := make(map[int]bool)\n    queue := make([][]int, 0)\n    queue = append(queue, []int{0, 0, 0})\n    visited[grid[0][0]] = true\n    for len(queue) > 0 {\n        path := queue[0]\n        queue = queue[1:]\n        if len(path) == k {\n            return path\n        }\n        for i := -1; i <= 1; i++ {\n            for j := -1; j <= 1; j++ {\n                if i == 0 && j == 0 {\n                    continue\n                }\n                x, y := path[0]+i, path[1]+j\n                if x < 0 || y < 0 || x >= m || y >= n {\n                    continue\n                }\n                if visited[grid[x][y]] {\n                    continue\n                }\n                visited[grid[x][y]] = true\n                queue = append(queue, []int{x, y, grid[x][y]})\n            }\n        }\n        sort.Slice(queue, func(i, j int) bool {\n            return queue[i][2] < queue[j][2]\n        })\n    }\n    return nil\n}\n"}
{"task_id": "Go/130", "generation": "\n    if n == 0 {\n        return []float64{}\n    }\n    if n == 1 {\n        return []float64{3}\n    }\n    if n == 2 {\n        return []float64{3, 2}\n    }\n    sequence := []float64{3, 2}\n    for i := 3; i <= n; i++ {\n        if i % 2 == 0 {\n            sequence = append(sequence, 1+i/2)\n        } else {\n            sequence = append(sequence, sequence[i-1] + sequence[i-2] + sequence[i-3])\n        }\n    }\n    return sequence\n} \n"}
{"task_id": "Go/131", "generation": "\n    var product int64 = 1\n    for n > 0 {\n        digit := n % 10\n        if digit % 2 != 0 {\n            product *= int64(digit)\n        }\n        n /= 10\n    }\n    return int(product)\n}\n\n"}
{"task_id": "Go/132", "generation": "\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) > 0\n}\n"}
{"task_id": "Go/133", "generation": "\n    var sum int\n    for _, num := range lst {\n        // round to the upper int(Ceiling)\n        rounded := math.Ceil(num)\n        sum += int(rounded * rounded)\n    }\n    return sum\n} \n"}
{"task_id": "Go/134", "generation": "\n    // Split the string into words\n    words := strings.Split(txt, \" \")\n    // Get the last word\n    lastWord := words[len(words)-1]\n    // Get the last character of the last word\n    lastChar := lastWord[len(lastWord)-1]\n    // Check if the last character is a letter\n    return unicode.IsLetter(lastChar)\n}\n\n"}
{"task_id": "Go/135", "generation": "\n    n := len(arr)\n    if n == 0 {\n        return -1\n    }\n    if n == 1 {\n        return -1\n    }\n    if n == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return 0\n    }\n    for i := 1; i < n-1; i++ {\n        if arr[i] >= arr[i-1] && arr[i] <= arr[i+1] {\n            return i\n        }\n    }\n    return -1\n}\n"}
{"task_id": "Go/136", "generation": "\n\t// Find the largest negative integer\n\tnegatives := make([]int, 0)\n\tfor _, num := range lst {\n\t\tif num < 0 {\n\t\t\tnegatives = append(negatives, num)\n\t\t}\n\t}\n\tif len(negatives) == 0 {\n\t\treturn [2]interface{}{nil, nil}\n\t}\n\tlargestNegative := maxIntegers(negatives)\n\n\t// Find the smallest positive integer\n\tpositives := make([]int, 0)\n\tfor _, num := range lst {\n\t\tif num > 0 {\n\t\t\tpositives = append(positives, num)\n\t\t}\n\t}\n\tif len(positives) == 0 {\n\t\treturn [2]interface{}{nil, nil}\n\t}\n\tsmallestPositive := minIntegers(positives)\n\n\treturn [2]interface{}{largestNegative, smallestPositive}\n}\n\nfunc maxIntegers(nums []int) int {\n\tmax := nums[0]\n\tfor _, num := range nums {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}\n\nfunc minIntegers(nums []int) int {\n\tmin := nums[0]\n\tfor _, num := range nums {\n\t\tif num < min {\n\t\t\tmin = num\n\t\t}\n\t}\n\treturn min\n}\n"}
{"task_id": "Go/137", "generation": "\n    // Convert a and b to float64\n    aFloat, bFloat := a.(float64), b.(float64)\n    if aFloat != 0 && bFloat != 0 {\n        // If both are not zero, return the larger one\n        if aFloat > bFloat {\n            return a\n        } else if aFloat < bFloat {\n            return b\n        } else {\n            return nil\n        }\n    }\n    // If a or b is not a float, try to convert it to a float\n    aFloat, bFloat = a.(float64), b.(float64)\n    if aFloat != 0 && bFloat != 0 {\n        // If both are not zero, return the larger one\n        if aFloat > bFloat {\n            return a\n        } else if aFloat < bFloat {\n            return b\n        } else {\n            return nil\n        }\n    }\n    // If a or b is not a float, try to convert it to a string\n    aStr, bStr := a.(string), b.(string)\n    if aStr != \"\" && bStr != \"\" {\n        // If both are not empty, return the non-empty one\n        if aStr != \"\" {\n            return a\n        } else if bStr != \"\" {\n            return b\n        } else {\n            return nil\n        }\n    }\n    // If a or b is not a string, return the non-nil one\n    if a != nil {\n        return a\n    } else if b != nil {\n        return b\n    } else {\n        return nil\n    }\n}\n\n"}
{"task_id": "Go/138", "generation": "\n    // Initialize count of even numbers\n    count := 0\n    // Iterate over all numbers from 2 to n\n    for i := 2; i <= n; i++ {\n        // Check if number is even\n        if i%2 == 0 {\n            // Increment count of even numbers\n            count++\n            // If count of even numbers is 4, return True\n            if count == 4 {\n                return true\n            }\n        }\n    }\n    // If no 4 even numbers found, return False\n    return false\n} "}
{"task_id": "Go/139", "generation": "\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= factorial(i)\n    }\n    return result\n}\n\nfunc factorial(n int) int {\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= i\n    }\n    return result\n}\n"}
{"task_id": "Go/140", "generation": "\n    var result string\n    var count int\n    for _, r := range text {\n        if r == ' ' {\n            count++\n            if count == 1 {\n                result += \"_\"\n            } else if count == 2 {\n                result += \"-\"\n            } else {\n                result += \"-\"\n                count = 1\n            }\n        } else {\n            result += string(r)\n            count = 0\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/141", "generation": "\n    // Split the file name into two parts: the name and the extension\n    parts := strings.Split(file_name, \".\")\n    \n    // Check if the file name contains exactly one dot\n    if len(parts) != 2 {\n        return \"No\"\n    }\n    \n    // Check if the name starts with a letter\n    if !unicode.IsLetter(rune(parts[0][0])) {\n        return \"No\"\n    }\n    \n    // Check if the name contains more than three digits\n    if strings.Count(parts[0], \"0123456789\") > 3 {\n        return \"No\"\n    }\n    \n    // Check if the extension is valid\n    if !strings.HasSuffix(parts[1], \"txt\") && !strings.HasSuffix(parts[1], \"exe\") && !strings.HasSuffix(parts[1], \"dll\") {\n        return \"No\"\n    }\n    \n    // If all checks pass, return 'Yes'\n    return \"Yes\"\n}\n\n"}
{"task_id": "Go/142", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v * v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v * v * v\n        }\n    }\n    return sum\n}\n\n"}
{"task_id": "Go/143", "generation": "\n    words := strings.Fields(sentence)\n    var result string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word + \" \"\n        }\n    }\n    return strings.Trim(result, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/144", "generation": "\n    // Split the numerator and denominator of x and n\n    xNum, xDen := split(x)\n    nNum, nDen := split(n)\n\n    // Multiply the numerator and denominator of x and n\n    xNum = multiply(xNum, nNum)\n    xDen = multiply(xDen, nDen)\n\n    // Check if the result is a whole number\n    return isWhole(xNum, xDen)\n}\n\nfunc split(s string) (string, string) {\n    // Split the string at the '/' character\n    parts := strings.Split(s, \"/\")\n    return parts[0], parts[1]\n}\n\nfunc multiply(a, b string) string {\n    // Convert the strings to integers\n    numA, _ := strconv.Atoi(a)\n    numB, _ := strconv.Atoi(b)\n\n    // Multiply the integers\n    result := numA * numB\n\n    // Convert the result back to a string\n    return strconv.Itoa(result)\n}\n\nfunc isWhole(numerator, denominator string) bool {\n    // Convert the strings to integers\n    num, _ := strconv.Atoi(numerator)\n    den, _ := strconv.Atoi(denominator)\n\n    // Check if the numerator is a multiple of the denominator\n    return num%den == 0\n} "}
{"task_id": "Go/145", "generation": "\n    // Create a new slice of pairs, where each pair contains a number and its sum of digits\n    pairs := make([]struct{ num, sum int }, len(nums))\n    for i, num := range nums {\n        sum := 0\n        for _, digit := range strconv.Itoa(num) {\n            sum += int(digit - '0')\n        }\n        pairs[i] = struct{ num, sum int }{num, sum}\n    }\n    \n    // Sort the pairs based on the sum of digits and the original index\n    sort.Slice(pairs, func(i, j int) bool {\n        if pairs[i].sum != pairs[j].sum {\n            return pairs[i].sum < pairs[j].sum\n        }\n        return i < j\n    })\n    \n    // Return the sorted numbers\n    result := make([]int, len(nums))\n    for i, pair := range pairs {\n        result[i] = pair.num\n    }\n    return result\n}\n\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        str := strconv.Itoa(num)\n        if num > 10 && (str[0] == \"1\" || str[0] == \"3\" || str[0] == \"5\" || str[0] == \"7\" || str[0] == \"9\") && (str[len(str)-1] == \"1\" || str[len(str)-1] == \"3\" || str[len(str)-1] == \"5\" || str[len(str)-1] == \"7\" || str[len(str)-1] == \"9\") {\n            count++\n        }\n    }\n    return count\n} "}
{"task_id": "Go/147", "generation": "\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = i*i - i + 1\n\t}\n\tcount := 0\n\tfor i := 0; i < n-2; i++ {\n\t\tfor j := i + 1; j < n-1; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tif (a[i] + a[j] + a[k])%3 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc GetMaxTriples(n int) int {\n\ta := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = i*i - i + 1\n\t}\n\tcount := 0\n\tfor i := 0; i < n-2; i++ {\n\t\tfor j := i + 1; j < n-1; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tif (a[i] + a[j] + a[k])%3 == 0 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n"}
{"task_id": "Go/148", "generation": "\n\tplanets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tsort.Slice(planets, func(i, j int) bool {\n\t\treturn planets[i] < planets[j]\n\t})\n\ti, j := 0, len(planets)-1\n\tfor i < j {\n\t\tmid := (i + j) / 2\n\t\tif planets[mid] == planet1 {\n\t\t\ti = mid\n\t\t} else if planets[mid] < planet1 {\n\t\t\ti = mid + 1\n\t\t} else {\n\t\t\tj = mid - 1\n\t\t}\n\t}\n\tif i == j || planets[i] != planet1 {\n\t\treturn []string{}\n\t}\n\ti++\n\tfor i < j {\n\t\tmid := (i + j) / 2\n\t\tif planets[mid] == planet2 {\n\t\t\tj = mid\n\t\t} else if planets[mid] < planet2 {\n\t\t\ti = mid + 1\n\t\t} else {\n\t\t\tj = mid - 1\n\t\t}\n\t}\n\tif i == j || planets[i] != planet2 {\n\t\treturn []string{}\n\t}\n\treturn planets[i+1 : j]\n}\n"}
{"task_id": "Go/149", "generation": "\n    // Filter out strings with odd lengths\n    filteredList := make([]string, 0)\n    for _, str := range lst {\n        if len(str) % 2 == 0 {\n            filteredList = append(filteredList, str)\n        }\n    }\n\n    // Sort the list by length and then alphabetically\n    sort.Slice(filteredList, func(i, j int) bool {\n        if len(filteredList[i]) == len(filteredList[j]) {\n            return filteredList[i] < filteredList[j]\n        }\n        return len(filteredList[i]) < len(filteredList[j])\n    })\n\n    return filteredList\n}\n\n"}
{"task_id": "Go/150", "generation": "\n    // Check if n is a prime number\n    isPrime := true\n    for i := 2; i < n; i++ {\n        if n%i == 0 {\n            isPrime = false\n            break\n        }\n    }\n    // Return x if n is a prime number, otherwise return y\n    if isPrime {\n        return x\n    } else {\n        return y\n    }\n} "}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && math.Mod(num, 2) == 1 {\n            sum += int(math.Pow(num, 2))\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/152", "generation": "\n    result := make([]int, len(game))\n    for i := range game {\n        result[i] = abs(guess[i] - game[i])\n    }\n    return result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n"}
{"task_id": "Go/153", "generation": "\n    var strongest_extension string\n    var max_strength float64\n    for _, extension := range extensions {\n        cap := 0\n        sm := 0\n        for _, r := range extension {\n            if unicode.IsUpper(r) {\n                cap++\n            } else if unicode.IsLower(r) {\n                sm++\n            }\n        }\n        strength := float64(cap - sm)\n        if strength > max_strength {\n            max_strength = strength\n            strongest_extension = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n"}
{"task_id": "Go/154", "generation": "\n\t// Convert the first word to a slice of runes\n\trunes := []rune(a)\n\t// Convert the second word to a slice of runes\n\trunes2 := []rune(b)\n\t// Check if the second word is a substring of the first word\n\tif strings.Contains(string(runes), string(runes2)) {\n\t\treturn true\n\t}\n\t// Check if the second word or its rotations is a substring of the first word\n\tfor i := 0; i < len(runes2); i++ {\n\t\t// Rotate the second word\n\t\trunes2 = append(runes2[1:], runes2[:1])\n\t\t// Check if the rotated second word is a substring of the first word\n\t\tif strings.Contains(string(runes), string(runes2)) {\n\t\t\treturn true\n\t\t}\n\t}\n\t// If none of the above conditions are met, return false\n\treturn false\n} "}
{"task_id": "Go/155", "generation": "\n    var even, odd int\n    for _, digit := range strconv.Itoa(num) {\n        if digit == '0' {\n            even++\n        } else if digit == '2' || digit == '4' || digit == '6' || digit == '8' {\n            even++\n        } else {\n            odd++\n        }\n    }\n    return [2]int{even, odd}\n}\n\n"}
{"task_id": "Go/156", "generation": "\n    // Define the mapping of integers to their roman numeral equivalents\n    romanNumerals := map[int]string{\n        1:  \"i\",\n        4:  \"iv\",\n        5:  \"v\",\n        9:  \"ix\",\n        10: \"x\",\n        40: \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\",\n        400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000: \"m\",\n    }\n\n    // Initialize the result string\n    result := \"\"\n\n    // Loop through the roman numerals in descending order of their integer values\n    for _, numeral := range sortedKeys(romanNumerals) {\n        // Calculate the number of times the current numeral can fit into the number\n        count := number / numeral\n\n        // Subtract the value of the current numeral times the count from the number\n        number -= count * numeral\n\n        // Append the current numeral times the count to the result string\n        result += strings.Repeat(romanNumerals[numeral], count)\n    }\n\n    // Return the result string in lowercase\n    return strings.ToLower(result)\n}\n"}
{"task_id": "Go/157", "generation": "\n\t// Sort the sides in ascending order\n\tsides := []int{a, b, c}\n\tsort.Ints(sides)\n\n\t// Check if the square of the longest side is equal to the sum of the squares of the other two sides\n\treturn sides[2]*sides[2] == sides[0]*sides[0]+sides[1]*sides[1]\n}\n\n"}
{"task_id": "Go/158", "generation": "\n    var maxWord string\n    var maxUnique int\n    for _, word := range words {\n        unique := len([]rune(word))\n        if unique > maxUnique {\n            maxUnique = unique\n            maxWord = word\n        } else if unique == maxUnique {\n            sort.Strings([]string{word, maxWord})\n            if word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    return maxWord\n}\n"}
{"task_id": "Go/159", "generation": "\n    // Calculate the total number of carrots eaten after meals\n    totalEaten := number + need\n    \n    // Calculate the number of carrots left after meals\n    carrotsLeft := remaining - need\n    \n    // If there are not enough remaining carrots, eat all remaining carrots\n    if carrotsLeft < 0 {\n        carrotsLeft = remaining\n    }\n    \n    // Return the array of total number of eaten carrots and the number of carrots left\n    return []int{totalEaten, carrotsLeft}\n} \n"}
{"task_id": "Go/160", "generation": "\n    // Initialize the result with the first operand\n    result := operand[0]\n    // Iterate over the operator and operand lists\n    for i := 0; i < len(operator); i++ {\n        // Get the current operator and operand\n        op := operator[i]\n        num := operand[i+1]\n        // Perform the operation based on the operator\n        switch op {\n        case \"+\":\n            result += num\n        case \"-\":\n            result -= num\n        case \"*\":\n            result *= num\n        case \"/\":\n            result /= num\n        case \"//\":\n            result = result / num\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(num)))\n        }\n    }\n    // Return the final result\n    return result\n} \n\n"}
{"task_id": "Go/161", "generation": "\n\tvar result string\n\tfor _, v := range s {\n\t\tif v >= 'a' && v <= 'z' || v >= 'A' && v <= 'Z' {\n\t\t\tif v >= 'a' && v <= 'z' {\n\t\t\t\tresult += string(v - 32)\n\t\t\t} else {\n\t\t\t\tresult += string(v + 32)\n\t\t\t}\n\t\t} else {\n\t\t\tresult += string(v)\n\t\t}\n\t}\n\treturn result\n}\n\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    hash := md5.New()\n    io.WriteString(hash, text)\n    return fmt.Sprintf(\"%x\", hash.Sum(nil))\n}\n\n"}
{"task_id": "Go/163", "generation": "\n\tif a > b {\n\t\ta, b = b, a\n\t}\n\tresult := make([]int, 0)\n\tfor i := a; i <= b; i++ {\n\t\tresult = append(result, i)\n\t}\n\treturn result\n}\n"}
