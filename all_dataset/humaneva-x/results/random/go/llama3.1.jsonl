{"task_id": "Go/0", "generation": "\n    for i := 1; i < len(numbers); i++ {\n        if math.Abs(numbers[i]-numbers[i-1]) > threshold {\n            return false\n        }\n    }\n    return true\n}\n\nfunc _close_e(numbers []float64, threshold float64) bool {\n    for i := 1; i < len(numbers); i++ {\n        if math.Abs(numbers[i]-numbers[i-1]) > threshold {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/1", "generation": "\n    var groups []string\n    var group string\n    var open bool\n    for _, r := range paren_string {\n        if r == '(' {\n            open = true\n            group += string(r)\n        } else if r == ')' {\n            open = false\n            group += string(r)\n            if open == false {\n                groups = append(groups, group)\n                group = \"\"\n            }\n        } else {\n            group += string(r)\n        }\n    }\n    if group != \"\" {\n        groups = append(groups, group)\n    }\n    return groups\n}\n"}
{"task_id": "Go/2", "generation": "\n    return math.Mod(number, 1)\n}\n\n"}
{"task_id": "Go/3", "generation": "\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/4", "generation": "\n    mean := Mean(numbers)\n    sum := float64(0)\n    for _, num := range numbers {\n        sum += math.Abs(num - mean)\n    }\n    return sum / float64(len(numbers))\n}\n"}
{"task_id": "Go/5", "generation": "\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, n := range numbers {\n        result = append(result, n)\n        if i < len(numbers)-1 {\n            result = append(result, delimeter)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/6", "generation": "\n    var levels []int\n    var current_level int\n    for _, char := range paren_string {\n        if char == '(' {\n            current_level++\n            levels = append(levels, current_level)\n        } else if char == ')' {\n            current_level--\n            levels = append(levels, current_level)\n        }\n    }\n    return levels\n}\n\n"}
{"task_id": "Go/7", "generation": "\n    filteredList := make([]string, 0)\n    for _, str := range stringList {\n        if strings.Contains(str, substring) {\n            filteredList = append(filteredList, str)\n        }\n    }\n    return filteredList\n}\n\n"}
{"task_id": "Go/8", "generation": "\n    sum := 0\n    product := 1\n    for _, num := range numbers {\n        sum += num\n        product *= num\n    }\n    return [2]int{sum, product}\n}\n"}
{"task_id": "Go/9", "generation": "\n    max := math.MinInt\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        if num > max {\n            max = num\n        }\n        result[i] = max\n    }\n    return result\n}\n"}
{"task_id": "Go/10", "generation": "\n    runes := []rune(str)\n    for i := len(runess) - 1; i >= 0; i-- {\n        if runes[i] == runes[0] {\n            return str[:i+1] + string(runes[0]) + str[i+1:]\n        }\n    }\n    return str\n}\n"}
{"task_id": "Go/11", "generation": "\n    // Convert the strings to byte slices\n    aBytes := []byte(a)\n    bBytes := []byte(b)\n\n    // Perform the XOR operation on the byte slices\n    result := make([]byte, len(aBytes))\n    for i := range aBytes {\n        result[i] = aBytes[i] ^ bBytes[i]\n    }\n\n    // Convert the result back to a string\n    resultString := string(result)\n\n    return resultString\n}\n\n"}
{"task_id": "Go/12", "generation": "\n    if len(strings) == 0 {\n        return nil\n    }\n    max := strings[0]\n    for _, s := range strings {\n        if len(s) > len(max) {\n            max = s\n        }\n    }\n    return max\n}\n"}
{"task_id": "Go/13", "generation": "\n   // Use the Euclidean algorithm to find the GCD\n   for a != 0 {\n      b, a = a, b % a\n   }\n   return b\n}\n"}
{"task_id": "Go/14", "generation": "\n  // list of prefixes from shortest to longest of the string\n  all_prefixes('abc')\n   a 'ab 'abc\nfunc AllSuffixes(str string) []string{\n  // list of suffixes from shortest to longest of the string\n  all_suffixes('abc')\n   a 'bc 'abc\nfunc AllSubstrings(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicates(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmpty(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmptyAndNonConsecutive(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty_and_non_consecutive('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmptyAndNonConsecutiveAndNonOverlapping(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty_and_non_consecutive_and_non_overlapping('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmptyAndNonConsecutiveAndNonOverlappingAndNonConsecutive(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty_and_non_consecutive_and_non_overlapping_and_non_consecutive('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmptyAndNonConsecutiveAndNonOverlappingAndNonConsecutiveAndNonOverlapping(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty_and_non_consecutive_and_non_overlapping_and_non_consecutive_and_non_overlapping('abc')\n   a 'ab 'abc\nfunc AllSubstringsWithDuplicatesAndEmptyAndNonConsecutiveAndNonOverlappingAndNonConsecutiveAndNonOverlappingAndNonConsecutive(str string) []string{\n  // list of substrings from shortest to longest of the string\n  all_substrings_with_duplicates_and_empty_and"}
{"task_id": "Go/15", "generation": "\n    var result string\n    for i := 0; i < n; i++ {\n        result += strconv.Itoa(i) + \" \"\n    }\n    return result\n}\n"}
{"task_id": "Go/16", "generation": "\n    // Convert the string to a byte slice\n    byteSlice := []byte(str)\n    // Use a map to count the frequency of each character\n    charCount := make(map[byte]int)\n    for _, b := range byteSlice {\n        charCount[b]++\n    }\n    // Count the number of distinct characters\n    distinctCount := 0\n    for _, count := range charCount {\n        if count > 0 {\n            distinctCount++\n        }\n    }\n    return distinctCount\n}\n\n"}
{"task_id": "Go/17", "generation": "\n  var notes []int\n  for _, note := range strings.Fields(music_string) {\n    switch note {\n    case \"o\":\n      notes = append(notes, 4)\n    case \"o|\":\n      notes = append(notes, 2)\n    case \"o||\":\n      notes = append(notes, 1)\n    case \"o|||\":\n      notes = append(notes, 0.5)\n    case \"o||||\":\n      notes = append(notes, 0.25)\n    case \"o|||||\":\n      notes = append(notes, 0.125)\n    case \"o||||||\":\n      notes = append(notes, 0.0625)\n    case \"o|||||||\":\n      notes = append(notes, 0.03125)\n    case \"o||||||||\":\n      notes = append(notes, 0.015625)\n    case \"o|||||||||\":\n      notes = append(notes, 0.0078125)\n    case \"o||||||||||\":\n      notes = append(notes, 0.00390625)\n    case \"o|||||||||||\":\n      notes = append(notes, 0.001953125)\n    case \"o||||||||||||\":\n      notes = append(notes, 0.0009765625)\n    case \"o|||||||||||||\":\n      notes = append(notes, 0.00048828125)\n    case \"o||||||||||||||\":\n      notes = append(notes, 0.000244140625)\n    case \"o|||||||||||||||\":\n      notes = append(notes, 0.0001220703125)\n    case \"o||||||||||||||||\":\n      notes = append(notes, 0.00006103515625)\n    case \"o|||||||||||||||||\":\n      notes = append(notes, 0.000030517578125)\n    case \"o||||||||||||||||||\":\n      notes = append(notes, 0.0000152587890625)\n    case \"o|||||||||||||||||||\":\n      notes = append(notes, 0.00000762939453125)\n    case \"o||||||||||||||||||||\":\n      notes = append(notes, 0.000003814697265625)\n    case \"o|||||||||||||||||||||\":\n      notes = append(notes, 0.0000019073486328125"}
{"task_id": "Go/18", "generation": "\n    // Find many a substring can be the original string. Count overlaping cases.\n    howmanytimes := 0\n    for i := 0; i < len(str)-len(substring)+1; i++ {\n        if str[i:i+len(substring)] == substring {\n            howmanytimes++\n        }\n    }\n    return howmanytimes\n}\n"}
{"task_id": "Go/19", "generation": "\n    // Split the string into a slice of strings\n    var numbersSlice []string\n    for _, r := range numbers {\n        if r == ' ' {\n            continue\n        }\n        numbersSlice = append(numbersSlice, string(r))\n    }\n    // Sort the slice of strings\n    sort.Strings(numbersSlice)\n    // Join the sorted slice of strings into a string\n    return strings.Join(numbersSlice, \" \")\n}\n\n"}
{"task_id": "Go/20", "generation": "\n    // Sort the list of numbers\n    sort.Float64s(numbers)\n    // Find the smallest and largest numbers\n    smallest := numbers[0]\n    largest := numbers[len(numbers)-1]\n    return [2]float64{smallest, largest}\n}\n"}
{"task_id": "Go/21", "generation": "\n    // Find the maximum value in the list\n    max := numbers[0]\n    for _, num := range numbers[1:] {\n        if num > max {\n            max = num\n        }\n    }\n    // If the maximum value is 0, return the list as is\n    if max == 0 {\n        return numbers\n    }\n    // Calculate the scaling factor\n    scale := 1.0 / max\n    // Apply the scaling factor to each number in the list\n    scaled := make([]float64, len(numbers))\n    for i, num := range numbers {\n        scaled[i] = num * scale\n    }\n    return scaled\n}\n"}
{"task_id": "Go/22", "generation": "\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n            result = append(result, integer)\n        }\n    }\n    return result\n}\nfunc FilterIntegers(values []interface{}) []int {\n    var result []int\n    for _, value := range values {\n        if integer, ok := value.(int); ok {\n"}
{"task_id": "Go/23", "generation": "\n    return len(str)\n} \n"}
{"task_id": "Go/24", "generation": "\n    // Start with 1, the smallest divisor\n    divisor := 1\n    // Loop through all numbers from 2 to n\n    for i := 2; i <= n; i++ {\n        // Check if i is a divisor of n\n        if n%i == 0 {\n            // If it is, update the divisor\n            divisor = i\n        }\n    }\n    // Return the largest divisor\n    return divisor\n}\n"}
{"task_id": "Go/25", "generation": "\n    var factors []int\n    for i := 2; i <= n; i++ {\n        for n%i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\n"}
{"task_id": "Go/26", "generation": "\n  // Create a map to store the numbers we've seen so far\n  seen := make(map[int]bool)\n  // Create a new slice to store the result\n  result := make([]int, 0)\n  // Iterate over the input slice\n  for _, num := range numbers {\n    // If the number is not in the map, add it to the map and the result slice\n    if !seen[num] {\n      seen[num] = true\n      result = append(result, num)\n    }\n  }\n  // Return the result slice\n  return result\n}\n"}
{"task_id": "Go/27", "generation": "\n    var result string\n    for _, char := range str {\n        if char >= 'a' && char <= 'z' {\n            result += string(rune(char - 32))\n        } else if char >= 'A' && char <= 'Z' {\n            result += string(rune(char + 32))\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/28", "generation": "\n    var result string\n    for _, s := range strings {\n        result += s\n    }\n    return result\n}\n"}
{"task_id": "Go/29", "generation": "\n    return filter(strings, func(s string) bool { return strings.HasPrefix(s, prefix) })\n}\nfunc filter(strings []string, predicate func(string) bool) []string {\n    result := make([]string, 0, len(strings))\n    for _, s := range strings {\n        if predicate(s) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/30", "generation": "\n    var positive []int\n    for _, v := range l {\n        if v > 0 {\n            positive = append(positive, v)\n        }\n    }\n    return positive\n}\nfunc get_() {\n    fmt.Println(GetPositive([]int{-1, 2, -4, 5}))\n    fmt.Println(GetPositive([]int{5, 3, -2, -3, 9, 123, 1, -10}))\n}\n"}
{"task_id": "Go/31", "generation": "\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/32", "generation": "\n    // find zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial\n    // return zero point of a polynomial"}
{"task_id": "Go/33", "generation": "\n    // Create a new slice to store the values that are divisible by 3\n    var third []int\n    // Create a new slice to store the values that are not divisible by 3\n    var notThird []int\n    // Iterate over the input slice\n    for _, v := range l {\n        // Check if the value is divisible by 3\n        if v%3 == 0 {\n            // If it is, add it to the third slice\n            third = append(third, v)\n        } else {\n            // If it's not, add it to the notThird slice\n            notThird = append(notThird, v)\n        }\n    }\n    // Sort the third slice\n    sort.Ints(third)\n    // Sort the notThird slice\n    sort.Ints(notThird)\n    // Combine the two slices\n    result := make([]int, len(third)+len(notThird))\n    copy(result, third)\n    copy(result[len(third):], notThird)\n    return result\n}\n\n"}
{"task_id": "Go/34", "generation": "\n    sort.Slice(l, func(i, j int) bool {\n        return l[i] < l[j]\n    })\n    unique := make([]int, 0, len(l))\n    for _, v := range l {\n        if !contains(unique, v) {\n            unique = append(unique, v)\n        }\n    }\n    return unique\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/35", "generation": "\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementSlice(l []int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray2(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray3(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray4(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray5(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray6(l [10]int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\nfunc MaxElementArray7(l [10]int) int {\n    if len(l) == 0 {\n        return"}
{"task_id": "Go/36", "generation": "\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzUzz(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzBuzz_2(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzUzz_2(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzBuzz_3(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzUzz_3(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzBuzz_4(n int) int {\n\tvar count int\n\tfor i := 1; i <= n; i++ {\n\t\tif i%11 == 0 || i%13 == 0 {\n\t\t\tcount++\n\t\t}\n\t\tif i%7 == 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc FizzUzz_4(n int) int {\n\tvar count int\n\tfor i := 1; i <= n"}
{"task_id": "Go/37", "generation": "\n\tsort.Slice(l, func(i, j int) bool {\n\t\tif i%2 == 0 && j%2 == 0 {\n\t\t\treturn l[i/2] < l[j/2]\n\t\t}\n\t\treturn i < j\n\t})\n\treturn l\n}\n\n"}
{"task_id": "Go/38", "generation": "\n    groups := strings.Split(s, \"\")\n    newGroups := make([]string, 0)\n    for _, group := range groups {\n        if len(group) == 3 {\n            newGroups = append(newGroups, string(group[1]) + string(group[0]))\n        } else {\n            newGroups = append(newGroups, group)\n        }\n    }\n    decoded := make([]string, 0)\n    for i := 0; i < len(newGroups); i++ {\n        decoded = append(decoded, newGroups[i])\n        if (i+1)%3 == 0 && i != len(newGroups)-1 {\n            decoded = append(decoded, newGroups[i+1])\n        }\n    }\n    return strings.Join(decoded, \"\")\n}\n\n"}
{"task_id": "Go/39", "generation": "\n\t// Fibonacci sequence\n\tfib := []int{0, 1}\n\tfor i := 2; i < n; i++ {\n\t\tfib = append(fib, fib[i-1]+fib[i-2])\n\t}\n\t// Check if the number is prime\n\tfor i := 2; i < int(math.Sqrt(float64(fib[n-1])))+1; i++ {\n\t\tif fib[n-1]%i == 0 {\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn fib[n-1]\n} \n\n"}
{"task_id": "Go/40", "generation": "\n    if len(l) < 3 {\n        return false\n    }\n    sort.Ints(l)\n    for i := 0; i < len(l)-2; i++ {\n        left, right := i+1, len(l)-1\n        for left < right {\n            sum := l[i] + l[left] + l[right]\n            if sum == 0 {\n                return true\n            }\n            if sum < 0 {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/41", "generation": "\n    // The number of cars that will collide is equal to the number of cars that are moving left\n    // because each car that is moving left will collide with a car that is moving right\n    return n\n}\n"}
{"task_id": "Go/42", "generation": "\n    for i := range l {\n        l[i]++\n    }\n    return l\n}\n"}
{"task_id": "Go/43", "generation": "\n    // Create a set to store the elements we have seen so far\n    seen := make(map[int]bool)\n    // Iterate over the list\n    for _, num := range l {\n        // Check if the complement of the current number is in the set\n        if seen[num] {\n            return true\n        }\n        // Add the current number to the set\n        seen[num] = true\n    }\n    // If we have iterated over the entire list and haven't found a pair that sums to zero, return false\n    return false\n}\n"}
{"task_id": "Go/44", "generation": "\n    // Check if the base is valid\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    // Convert the number to a string\n    str := strconv.Itoa(x)\n\n    // Initialize an empty string to store the result\n    result := \"\"\n\n    // Loop through the string from right to left\n    for i := len(str) - 1; i >= 0; i-- {\n        // Convert the current digit to the new base\n        digit := int(str[i] - '0')\n        newDigit := digit % base\n        result = strconv.Itoa(newDigit) + result\n    }\n\n    return result\n}\n\n"}
{"task_id": "Go/45", "generation": "\n  return 0.5 * a * h\n}\n"}
{"task_id": "Go/46", "generation": "\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 2\n    }\n    a, b := 2, 2\n    for i := 4; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n"}
{"task_id": "Go/47", "generation": "\n\tsort.Ints(l)\n\tn := len(l)\n\tif n%2 == 0 {\n\t\treturn float64((l[n/2-1] + l[n/2]) / 2)\n\t} else {\n\t\treturn float64(l[n/2])\n\t}\n}\n\n"}
{"task_id": "Go/48", "generation": "\n    // Convert the string to lowercase\n    text = strings.ToLower(text)\n    // Remove spaces and punctuation\n    text = strings.Map(func(r rune) rune {\n        if r == ' ' || r == '.' || r == ',' || r == '!' || r == '?' {\n            return -1\n        }\n        return r\n    }, text)\n    // Remove non-alphanumeric characters\n    text = strings.Map(func(r rune) rune {\n        if r >= 'a' && r <= 'z' || r >= '0' && r <= '9' {\n            return r\n        }\n        return -1\n    }, text)\n    // Check if the string is a palindrome\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/49", "generation": "\n    return n%p\n}\n"}
{"task_id": "Go/50", "generation": "\n    runes := []rune(s)\n    newRunes := make([]rune, 0)\n    for _, ch := range runes {\n        newRunes = append(newRunes, (ch-'a'+26)%26+'a')\n    }\n    return string(runes)\n}\n"}
{"task_id": "Go/51", "generation": "\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\nfunc RemoveVowels(text string) string {\n    // Create a regular expression that matches any vowel\n    pattern := regexp.MustCompile(\"[aeiouAEIOU]\")\n    // Use the regular expression to replace all vowels with an empty string\n    return pattern.ReplaceAllString(text, \"\")\n}\n\n"}
{"task_id": "Go/52", "generation": "\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\nfunc BelowThreshold(l []int,t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n"}
{"task_id": "Go/53", "generation": "\n    return x + y\n}\nfunc add2(x int, y int) int {\n    return x + y\n}\n"}
{"task_id": "Go/54", "generation": "\n    return strings.Contains(s0, s1) && strings.Contains(s1, s0)\n}\n"}
{"task_id": "Go/55", "generation": "\n    if n <= 1 {\n        return n\n    }\n    return Fib(n-1) + Fib(n-2)\n}\n"}
{"task_id": "Go/56", "generation": "\n    stack := make([]rune, 0)\n    for _, bracket := range brackets {\n        if bracket == '<' {\n            stack = append(stack, bracket)\n        } else if bracket == '>' {\n            if len(stack) == 0 || stack[len(stack)-1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/57", "generation": "\n    // Check if the list is empty\n    if len(l) == 0 {\n        return true\n    }\n    // Check if the list is increasing\n    increasing := true\n    for i := 1; i < len(l); i++ {\n        if l[i] < l[i-1] {\n            increasing = false\n            break\n        }\n    }\n    // Check if the list is decreasing\n    decreasing := true\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n            break\n        }\n    }\n    // Return True if the list is either increasing or decreasing\n    return increasing || decreasing\n}\n"}
{"task_id": "Go/58", "generation": "\n    // sort both lists\n    sort.Ints(l1)\n    sort.Ints(l2)\n    // find common elements\n    var common []int\n    for i := 0; i < len(l1); i++ {\n        for j := 0; j < len(l2); j++ {\n            if l1[i] == l2[j] {\n                common = append(common, l1[i])\n            }\n        }\n    }\n    return common\n}\n\n"}
{"task_id": "Go/59", "generation": "\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            return i\n    }\n    return n\n}\n"}
{"task_id": "Go/60", "generation": "\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n"}
{"task_id": "Go/61", "generation": "\n    stack := make([]rune, 0)\n    for _, bracket := range strings.Split(brackets, \"\") {\n        if bracket == \"(\" {\n            stack = append(stack, bracket)\n        } else if bracket == \")\" {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n"}
{"task_id": "Go/62", "generation": "\n    if len(xs) < 2 {\n        return nil\n    }\n    result := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        result[i-1] = i * xs[i]\n    }\n    return result\n}\n"}
{"task_id": "Go/63", "generation": "\n  if n == 0 {\n    return 0\n  } else if n == 1 {\n    return 1\n  } else {\n    return fib(n-1) + fib(n-2)\n  }\n}\n"}
{"task_id": "Go/64", "generation": "\n    // Convert the string to lowercase\n    s = strings.ToLower(s)\n    // Initialize a counter for vowels\n    count := 0\n    // Loop through each character in the string\n    for i := 0; i < len(s); i++ {\n        // Check if the character is a vowel\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            count++\n        }\n        // Check if the character is 'y' and it's at the end of the string\n        if s[i] == 'y' && i == len(s)-1 {\n            count++\n        }\n    }\n    // Return the count of vowels\n    return count\n}\n\n"}
{"task_id": "Go/65", "generation": "\n    // Convert the integer to a string\n    str := strconv.Itoa(x)\n    // Calculate the length of the string\n    lenStr := len(str)\n    // Calculate the shift value\n    shift = shift % lenStr\n    // Split the string into two parts\n    firstPart := str[:lenStr-shift]\n    secondPart := str[lenStr-shift:]\n    // Combine the two parts in reverse order\n    result := secondPart + firstPart\n    // Return the result\n    return result\nfunc CircularShift(x int, shift int) string {\n    // Convert the integer to a string\n    str := strconv.Itoa(x)\n    // Calculate the length of the string\n    lenStr := len(str)\n    // Calculate the shift value\n    shift = shift % lenStr\n    // Split the string into two parts\n    firstPart := str[:lenStr-shift]\n    secondPart := str[lenStr-shift:]\n    // Combine the two parts in reverse order\n    result := secondPart + firstPart\n    // Return the result\n    return result\nThis function takes two parameters, `x` and `shift`, and returns a string. It first converts the integer `x` to a string using `strconv.Itoa(x)`. It then calculates the length of the string using `len(str)`. The shift value is calculated by taking the modulus of the shift value with the length of the string, to ensure that the shift value is within the bounds of the string. The string is then split into two parts, `firstPart` and `secondPart`, using slicing. The two parts are then combined in reverse order using string concatenation, and the result is returned.\nThe time complexity of this function is O(n), where n is the number of digits in the integer `x`. This is because the function needs to iterate over the string to calculate the length and to split the string into two parts. The space complexity is also O(n), as the function needs to store the two parts of the string. \nThe function handles the case where the shift value is greater than the length of the string by taking the modulus of the shift value with the length of the string. This ensures that the shift value is within the bounds of the string. The function also handles the case where the input string is empty by returning an empty string. \nThe function uses the `strconv.Itoa(x)` function to convert the integer `x` to a string, which has a time complexity of O(n), where n is the"}
{"task_id": "Go/66", "generation": "\n    var sum int\n    for _, r := range x {\n        if unicode.IsDigit(r) {\n            sum += int(r - '0')\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/67", "generation": "\n\t// split the string to get the number of apples and oranges\n\twords := strings.Split(s, \" \")\n\tnums := make([]int, len(words))\n\tfor i, word := range words {\n\t\tnums[i], _ = strconv.Atoi(word)\n\t}\n\t// calculate the total number of fruits\n\ttotalFruits := nums[0] + nums[1]\n\t// return the difference between the total number of fruits and the number of apples and oranges\n\treturn totalFruits - nums[0] - nums[1]\n}\n\n"}
{"task_id": "Go/68", "generation": "\n    var minEven int = math.MaxInt\n    var minIndex int = -1\n    for i, num := range arr {\n        if num%2 == 0 && num < minEven {\n            minEven = num\n            minIndex = i\n        }\n    }\n    if minEven == math.MaxInt {\n        return []int{}\n    }\n    return []int{minEven, minIndex}\n}\n"}
{"task_id": "Go/69", "generation": "\n    max := 0\n    for _, v := range lst {\n        if v > 0 && v > max {\n            max = v\n        }\n    }\n    return max\n}\n"}
{"task_id": "Go/70", "generation": "\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i] > lst[j]\n    })\n    return lst\n}\n\n"}
{"task_id": "Go/71", "generation": "\n    // check if the three sides form a valid triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    // calculate the semi-perimeter\n    s := (a + b + c) / 2\n    // calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - a) * (s - b) * (s - c))\n    // return the area to 2 decimal points\n    return math.Round(area*100) / 100\n}\n\n"}
{"task_id": "Go/72", "generation": "\n    return q == nil || sum(q) <= w\n}\n\nfunc sum(q []int) int {\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum\n}\n"}
{"task_id": "Go/73", "generation": "\n    n := len(arr)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return 1\n    }\n    // 3 or more\n    // first element is always the same\n    // second element is always the same\n    // third element is always the same\n    // fourth element is always the same\n    // fifth element is always the same\n    // sixth element is always the same\n    // seventh element is always the same\n    // eighth element is always the same\n    // ninth element is always the same\n    // tenth element is always the same\n    // eleventh element is always the same\n    // twelfth element is always the same\n    // thirteenth element is always the same\n    // fourteenth element is always the same\n    // fifteenth element is always the same\n    // sixteenth element is always the same\n    // seventeenth element is always the same\n    // eighteenth element is always the same\n    // nineteenth element is always the same\n    // twentieth element is always the same\n    // twenty-first element is always the same\n    // twenty-second element is always the same\n    // twenty-third element is always the same\n    // twenty-fourth element is always the same\n    // twenty-fifth element is always the same\n    // twenty-sixth element is always the same\n    // twenty-seventh element is always the same\n    // twenty-eighth element is always the same\n    // twenty-ninth element is always the same\n    // thirtieth element is always the same\n    // thirty-first element is always the same\n    // thirty-second element is always the same\n    // thirty-third element is always the same\n    // thirty-fourth element is always the same\n    // thirty-fifth element is always the same\n    // thirty-sixth element is always the same\n    // thirty-seventh element is always the same\n    // thirty-eighth element is always the same\n    // thirty-ninth element is always the same\n    // fortieth element is always the same\n    // forty-first element is always the same\n    // forty-second element is always the same\n    // forty-third element is always the same\n    // forty-four"}
{"task_id": "Go/74", "generation": "\n    var total1, total2 int\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n    } else if total2 < total1 {\n        return lst2\n    } else {\n        return []string{}\n    }\n}\n"}
{"task_id": "Go/75", "generation": "\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc IsMultiplyPrime(a int) bool {\n    // Check if the number is prime\n    if a < 2 {\n        return false\n    }\n    for i := 2; i < a; i++ {\n        if a%i == 0 {\n            return false\n        }\n"}
{"task_id": "Go/76", "generation": "\n    return math.Pow(float64(n), float64(int(math.Log(float64(x))/math.Log(float64(n))))) == float64(x)\n}\n"}
{"task_id": "Go/77", "generation": "\n    c := math.Sqrt(float64(a))\n    return math.Pow(c, 3) == float64(a)\n}\nfunc Iscube(a int) bool {\n    c := math.Sqrt(float64(a))\n    return math.Pow(c, 3) == float64(a)\n}\n"}
{"task_id": "Go/78", "generation": "\n    // convert hex to decimal\n    decimal := 0\n    for i := 0; i < len(num); i++ {\n        switch num[i] {\n        case 'A', 'B', 'C', 'D', 'E', 'F':\n            decimal = decimal*16 + int(num[i]-'A'+10)\n        default:\n            decimal = decimal*16 + int(num[i]-'0')\n        }\n    }\n    // check if decimal is prime\n    if isPrime(decimal) {\n        return 1\n    }\n    // count the number of prime digits\n    count := 0\n    for _, digit := range num {\n        switch digit {\n        case '2', '3', '5', '7':\n            if isPrime(int(digit)) {\n                count++\n            }\n        case 'A', 'B', 'C', 'D', 'E', 'F':\n            if isPrime(int(digit)-10) {\n                count++\n            }\n        default:\n            if isPrime(int(digit)) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/79", "generation": "\n\t// convert decimal to binary\n\tbinary := fmt.Sprintf(\"%b\", decimal)\n\t// add 'db' at the end of the string\n\treturn binary + \"db\"\n}\n\n"}
{"task_id": "Go/80", "generation": "\n    // Check if the string is empty\n    if len(s) == 0 {\n        return false\n    }\n    // Check if the string has at least two characters\n    if len(s) < 2 {\n        return false\n    }\n    // Check if the string has consecutive letters\n    for i := 1; i < len(s); i++ {\n        if s[i] != s[i-1]+1 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/81", "generation": "\n    var result []string\n    for _, grade := range grades {\n        if grade >= 3.3 {\n            result = append(result, \"A\")\n        } else if grade >= 3.0 {\n            result = append(result, \"B+\")\n        } else if grade >= 2.7 {\n            result = append(result, \"B-\")\n        } else if grade >= 2.3 {\n            result = append(result, \"C+\")\n        } else if grade >= 2.0 {\n            result = append(result, \"C\")\n        } else if grade >= 1.7 {\n            result = append(result, \"C-\")\n        } else if grade >= 1.0 {\n            result = append(result, \"D+\")\n        } else if grade >= 0.7 {\n            result = append(result, \"D\")\n        } else if grade >= 0.3 {\n            result = append(result, \"D-\")\n        } else {\n            result = append(result, \"E\")\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/82", "generation": "\n    // Convert the string to an integer\n    num := 0\n    for _, r := range s {\n        num = num*10 + int(r-'0')\n    }\n    // Check if the number is prime\n    if num <= 1 {\n        return false\n    }\n    for i := 2; i*i <= num; i++ {\n        if num%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/83", "generation": "\n    // Initialize count to 0\n    count := 0\n    // Loop through all numbers from 1 to n\n    for i := 1; i <= n; i++ {\n        // Check if the number starts or ends with 1\n        if string(strconv.Itoa(i)) == \"1\" || string(strconv.Itoa(i)) == \"1\" {\n            // If it does, increment count\n            count++\n        }\n    }\n    // Return count\n    return count\n}\n\n"}
{"task_id": "Go/84", "generation": "\n    // Convert N to binary and remove the '0b' prefix\n    binary := strconv.FormatInt(int64(N), 2)\n    \n    // Initialize a variable to store the sum of the digits\n    sum := 0\n    \n    // Iterate over each character in the binary string\n    for _, char := range binary {\n        // Convert the character to an integer and add it to the sum\n        sum += int(char - '0')\n    }\n    \n    // Convert the sum to a string and return it\n    return strconv.Itoa(sum)\n}\n\n"}
{"task_id": "Go/85", "generation": "\n    var sum int\n    for _, v := range lst {\n        if v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/86", "generation": "\n    // Remove all non-alphanumeric characters from the string\n    s = strings.Map(func(r rune) rune {\n        if r == '_' || r == ' ' {\n            return -1\n        }\n        return r\n    }, s)\n    \n    // Convert the string to a slice of runes\n    runes := []rune(s)\n    \n    // Sort the slice of runes in ascending order\n    sort.Slice(runes, func(i, j int) bool {\n        return runes[i] < runes[j]\n    })\n    \n    // Join the sorted runes back into a string\n    return string(runes)\n}\n\n"}
{"task_id": "Go/87", "generation": "\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    res := make([][2]int, 0)\n    for _, row := range lst {\n        for i, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, row[0]})\n            }\n        }\n    }\n    return res\n}\n\nfunc GetRow(lst [][]int, x int) [][2]int {\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    res := make([][2]int, 0)\n    for _, row := range lst {\n        for i, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, row[0]})\n            }\n        }\n    }\n    return res\n}\n\nfunc GetRow(lst [][]int, x int) [][2]int {\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    res := make([][2]int, 0)\n    for _, row := range lst {\n        for i, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, row[0]})\n            }\n        }\n    }\n    return res\n}\n\nfunc GetRow(lst [][]int, x int) [][2]int {\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    res := make([][2]int, 0)\n    for _, row := range lst {\n        for i, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, row[0]})\n            }\n        }\n    }\n    return res\n}\n\nfunc GetRow(lst [][]int, x int) [][2]int {\n    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n    })\n    res := make([][2]int, 0)\n    for _, row := range lst {\n        for i, v := range row {\n            if v == x {\n                res = append(res, [2]int{i, row[0]})\n            }\n        }\n    }\n    return res\n}\n\nfunc GetRow(lst [][]int,"}
{"task_id": "Go/88", "generation": "\n    // Check if the array is empty\n    if len(array) == 0 {\n        return array\n    }\n\n    // Check if the sum of the first and last index values is even or odd\n    sum := array[0] + array[len(array)-1]\n    isEven := sum%2 == 0\n\n    // Sort the array in ascending or descending order based on the sum\n    sort.Slice(array, func(i, j int) bool {\n        if isEven {\n            return array[i] < array[j]\n        } else {\n            return array[i] > array[j]\n        }\n    })\n\n    // Return the sorted array\n    return array\n}\n"}
{"task_id": "Go/89", "generation": "\n    // Convert the string to a byte slice\n    b := []byte(s)\n    // Calculate the shift\n    shift := 2 * 3\n    // Rotate the byte slice\n    for i := 0; i < len(b); i++ {\n        b[i] = b[i] + shift\n    }\n    // Convert the byte slice back to a string\n    return string(b)\n}\n\n"}
{"task_id": "Go/90", "generation": "\n    if len(lst) == 0 {\n        return nil\n    }\n    sort.Ints(lst)\n    for i := 1; i < len(lst); i++ {\n        if lst[i] != lst[i-1] {\n            return lst[i]\n        }\n    }\n    return nil\n}\n\n"}
{"task_id": "Go/91", "generation": "\n    // Regular expression to match a sentence that starts with \"I\"\n    pattern := regexp.MustCompile(`^I.*\\.$`)\n    // Count the number of matches\n    return pattern.FindAllString(S, -1).Len()\n}\n\n"}
{"task_id": "Go/92", "generation": "\n    return x == y+z || y == x+z || z == x+y\n}\n"}
{"task_id": "Go/93", "generation": "\n    // Define the vowels and their corresponding shifts\n    vowels := map[rune]rune{'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    // Initialize an empty string to store the encoded message\n    encodedMessage := \"\"\n    // Iterate over each character in the message\n    for _, char := range message {\n        // Check if the character is a vowel\n        if strings.Contains(\"aeiou\", string(char)) {\n            // If it's a vowel, shift it to the corresponding character\n            encodedMessage += string(vowels[char])\n        } else {\n            // If it's not a vowel, just append the character as is\n            encodedMessage += string(char)\n        }\n    }\n    // Return the encoded message\n    return encodedMessage\n}\n\n"}
{"task_id": "Go/94", "generation": "\n    max := 0\n    for _, num := range lst {\n        sum := 0\n        for _, digit := range strconv.Itoa(num) {\n            sum += int(digit - '0')\n        }\n        if sum > max {\n            max = sum\n        }\n        }\n    return max\n}\n\n"}
{"task_id": "Go/95", "generation": "\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n    // Iterate over each key in the dictionary\n    for key := range dict {\n        // Check if the key is a string\n        if str, ok := key.(string); ok {\n            // Check if the key is in lower case\n            if !strings.EqualFold(str, strings.ToLower(str)) {\n                return false\n            }\n        }\n    }\n    // If no keys are in lower case, return false\n    return false\n}\n\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n    // Iterate over each key in the dictionary\n    for key := range dict {\n        // Check if the key is a string\n        if str, ok := key.(string); ok {\n            // Check if the key is in lower case\n            if !strings.EqualFold(str, strings.ToLower(str)) {\n                return false\n            }\n        }\n    }\n    // If no keys are in lower case, return false\n    return false\n}\n\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n    }\n    // Iterate over each key in the dictionary\n    for key := range dict {\n        // Check if the key is a string\n        if str, ok := key.(string); ok {\n            // Check if the key is in lower case\n            if !strings.EqualFold(str, strings.ToLower(str)) {\n                return false\n            }\n        }\n    }\n    // If no keys are in lower case, return false\n    return false\n}\n\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n    // Check if the dictionary is empty\n    if len(dict) == 0 {\n        return false\n        // Iterate over each key in the dictionary\n    for key := range dict {\n        // Check if the key is a string\n        if str, ok := key.(string); ok {\n            // Check if the key is in lower case\n            if !strings.EqualFold(str, strings.ToLower(str)) {\n                return false\n            }\n        }\n    }\n    // If no keys are in lower case, return false\n    return false\n}\n\nfunc CheckDictCase(dict map[interface{}]interface{}) bool {\n    //"}
{"task_id": "Go/96", "generation": "\n    primes := []int{}\n    for i := 2; i <= n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n"}
{"task_id": "Go/97", "generation": "\n    // Convert the absolute values of a and b to strings\n    strA := strconv.Itoa(abs(a))\n    strB := strconv.Itoa(abs(b))\n    \n    // Get the last character of each string\n    lastA := strA[len(strA)-1]\n    lastB := strB[len(strB)-1]\n    \n    // Convert the last characters back to integers\n    unitA := int(lastA - '0')\n    unitB := int(lastB - '0')\n    \n    // Multiply the unit digits\n    product := unitA * unitB\n    \n    // Return the product\n    return product\n}\n\nfunc abs(a int) int {\n    if a < 0 {\n        return -a\n    }\n    return a\n}\n"}
{"task_id": "Go/98", "generation": "\n    count := 0\n    for _, r := range s {\n        if strings.ToUpper(string(r)) == \"U\" {\n            count++\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/99", "generation": "\n    // Convert the string to a float64\n    num, err := strconv.ParseFloat(value, 64)\n    if err != nil {\n        panic(err)\n    }\n    // Round the number to the nearest integer\n    rounded := math.Round(num)\n    // If the number is equidistant from two integers, round away from zero\n    if math.Abs(num-rounded) == 0.5 {\n        if num > 0 {\n            rounded++\n        } else {\n            rounded--\n        }\n    }\n    // Convert the rounded float64 to an integer\n    result, err := strconv.ParseInt(strconv.FormatFloat(rounded, 'f', 0, 64), 10, 64)\n    if err != nil {\n        panic(err)\n    }\n    return int(result)\n}\n\n"}
{"task_id": "Go/100", "generation": "\n    var pile []int\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            pile = append(pile, i+1)\n        } else {\n            pile = append(pile, i+1)\n        }\n    }\n    return pile\n}\n"}
{"task_id": "Go/101", "generation": "\n    // Remove spaces\n    s = strings.ReplaceAll(s, \" \", \"\")\n    // Split by comma\n    return strings.Split(s, \",\")\n}\n"}
{"task_id": "Go/102", "generation": "\n    if x > y {\n        return 1\n    }\n    return (x + y) / 2\n}\n"}
{"task_id": "Go/103", "generation": "\n    if n > m {\n        return -1\n    }\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n    avg := float64(sum) / float64(m-n+1)\n    return fmt.Sprintf(\"%b\", int(math.Round(avg)))\n}\n\n"}
{"task_id": "Go/104", "generation": "\n    var result []int\n    for _, num := range x {\n        digits := strconv.Itoa(num)\n        for _, digit := range digits {\n            if digit%2 == 0 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n"}
{"task_id": "Go/105", "generation": "\n    var result []string\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            switch num {\n            case 1:\n                result = append(result, \"One\")\n            case 2:\n                result = append(result, \"Two\")\n            case 3:\n                result = append(result, \"Three\")\n            case 4:\n                result = append(result, \"Four\")\n            case 5:\n                result\n            case 6:\n                result\n            case 7:\n                result\n            case 8:\n                result\n            case 9:\n                result\n            }\n        }\n    }\n    sort.Ints(arr)\n    sort.Reverse(arr)\n    for _, num := range arr {\n        switch num {\n        case 1:\n            result = append(result, \"One\")\n        case 2:\n            result = append(result, \"Two\")\n        case 3:\n            result = append(result, \"Three\")\n        case 4:\n            result = append(result, \"Four\")\n        case 5:\n            result = append(result, \"Five\")\n        case 6:\n            result = append(result, \"Six\")\n        case 7:\n            result = append(result, \"Seven\")\n        case 8:\n            result = append(result, \"Eight\")\n        case 9:\n            result = append(result, \"Nine\")\n        default:\n            result = append(result, \"\")\n        }\n    }\n    return result\n}\n\n"}
{"task_id": "Go/106", "generation": "\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        if i%2 == 0 {\n            result[i] = factorial(i)\n        } else {\n            sum := 0\n            for j := 1; j <= i; j++ {\n                sum += j\n            }\n            result[i] = sum\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/107", "generation": "\n    var even, odd int\n    for i := 1; i <= n; i++ {\n        str := strconv.Itoa(i)\n        if str == reverse(str) {\n            if isEven(i) {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n    return [2]int{even, odd}\n}\n\nfunc reverse(s string) string {\n    run := len(s) - 1\n    var res string\n    for run >= 0 {\n        res += string(s[run])\n        run--\n    }\n    return res\n}\n\nfunc isEven(num int) bool {\n    return num%2 == 0\n}\n"}
{"task_id": "Go/108", "generation": "\n    count := 0\n    for _, num := range arr {\n        sum := 0\n        for _, digit := range strconv.Itoa(abs(num)) {\n            sum += int(digit - '0')\n        }\n        if sum == 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n    return num\n}\n"}
{"task_id": "Go/109", "generation": "\n    n := len(arr)\n    for i := 0; i < n; i++ {\n        for j := 0; j < n-1; j++ {\n            if arr[j] > arr[j+1] {\n                return false\n            }\n        }\n        if i == n-1 {\n            return true\n        }\n        rotateRight(arr)\n    }\n    return true\n}\n\nfunc rotateRight(arr []int) {\n    last := arr[len(arr)-1]\n    arr = append([]int{last}, arr[:len(arr)-1]...)\n}\n\n"}
{"task_id": "Go/110", "generation": "\n    // Convert the lists to slices\n    s1 := lst1[:]\n    s2 := lst2[:]\n    // Make a copy of the first slice\n    copy1 := make([]int, len(s1))\n    copy(copy1, s1)\n    // Make a copy of the second slice\n    copy2 := make([]int, len(s2))\n    copy(copy2, s2)\n    // Sort the slices\n    sort.Ints(s1)\n    sort.Ints(s2)\n    // Initialize a counter for the number of exchanges\n    exchanges := 0\n    // Iterate over the slices\n    for i := 0; i < len(s1); i++ {\n        // If the current element in the first slice is odd\n        if s1[i]%2 != 0 {\n            // Find the index of the first even element in the second slice\n            j := sort.Search(len(s2), func(i int) bool { return s2[i]%2 == 0 })\n            // If an even element is found\n            if j != len(s2) {\n                // Increment the exchange counter\n                exchanges++\n                // Swap the current element in the first slice with the even element in the second slice\n                s1[i], s2[j] = s2[j], s1[i]\n                // Sort the slices again to maintain the sorted order\n                sort.Ints(s1)\n                sort.Ints(s2)\n            }\n        }\n    }\n    // If the number of exchanges is equal to the number of odd elements in the first slice\n    if exchanges == countOdd(s1) {\n        // Return \"YES\"\n        return \"YES\"\n    } else {\n        // Return \"NO\"\n        return \"NO\"\n    }\n}\n"}
{"task_id": "Go/111", "generation": "\n    // Create a map to store the frequency of each character\n    freq := make(map[rune]int)\n    // Split the string into a slice of characters\n    for _, char := range strings.Split(test, \" \") {\n        // If the character is already in the map, increment its count\n        if val, ok := freq[char[0]]; ok {\n            freq[char[0]] = val + 1\n        } else {\n            // If the character is not in the map, add it with a count of 1\n            freq[char[0]] = 1\n        }\n    }\n    return freq\n}\n\n"}
{"task_id": "Go/112", "generation": "\n    // Your code here\n    return [2]interface{}{\"\",false}\n}\n\n"}
{"task_id": "Go/113", "generation": "\n    var result []string\n    for _, str := range lst {\n        count := 0\n        for _, r := range str {\n            if r == '1' {\n                count++\n            }\n        }\n        result = append(result, fmt.Sprintf(\"the number of odd elements %dn the str%dn the %dput.\", count, count, count))\n    }\n    return result\n}\n\n"}
{"task_id": "Go/114", "generation": "\n    minSum := math.MaxInt\n    currentSum := 0\n    for _, num := range nums {\n        currentSum += num\n        minSum = min(minSum, currentSum)\n        if currentSum > 0 {\n            currentSum = 0\n        }\n    }\n    return minSum\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n} \n"}
{"task_id": "Go/115", "generation": "\n    var (\n        rows, cols int\n        maxFill    int\n    )\n    rows = len(grid)\n    cols = len(grid[0])\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            if grid[i][j] == 1 {\n                maxFill = max(maxFill, fill(i, j, capacity))\n            }\n        }\n    }\n    return maxFill\n}\n\nfunc fill(i, j, capacity int) int {\n    var (\n        rows, cols int\n        count      int\n    )\n    rows = len(grid)\n    cols = len(grid[0])\n    for k := 0; k < rows; k++ {\n        for l := 0; l < cols; l++ {\n            if grid[k][l] == 1 {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"}
{"task_id": "Go/116", "generation": "\n    // Convert each number to binary and count the number of ones\n    binaryOnes := make([]int, len(arr))\n    for i, num := range arr {\n        binary := fmt.Sprintf(\"%b\", num)\n        ones := 0\n        for _, bit := range binary {\n            if bit == '1' {\n                ones++\n            }\n        }\n        binaryOnes[i] = ones\n    }\n\n    // Sort the array based on the number of ones\n    sort.Slice(arr, func(i, j int) bool {\n        return binaryOnes[i] < binaryOnes[j]\n    })\n\n    return arr\n}\n\n"}
{"task_id": "Go/117", "generation": "\n    // Remove all non-alphabetic characters from the string\n    s = strings.Map(func(r rune) rune {\n        if r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' {\n            return r\n        }\n        return -1\n    }, s)\n    \n    // Convert the string to lowercase\n    s = strings.ToLower(s)\n    \n    // Initialize an empty list to store the words\n    words := []string{}\n    \n    // Split the string into words\n    for _, word := range strings.Fields(s) {\n        // Count the number of consonants in the word\n        consonantCount := 0\n        for _, r := range word {\n            if r >= 'a' && r <= 'z' && r != 'a' && r != 'e' && r != 'i' && r != 'o' && r != 'u' {\n                consonantCount++\n            }\n        }\n        \n        // If the word has exactly n consonants, add it to the list\n        if consonantCount == n {\n            words = append(words, word)\n        }\n    }\n    \n    // Return the list of words\n    return words\n}\n\n"}
{"task_id": "Go/118", "generation": "\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc GetClosestVowel(word string) string {\n    vowels := []byte{'a', 'e', 'i', 'o', 'u'}\n    for i := len(word) - 1; i >= 0; i-- {\n        if bytes.Contains(vowels, word[i]) {\n            return string(word[i"}
{"task_id": "Go/119", "generation": "\n    // Check if the input list is empty\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n\n    // Check if the input list has more than two elements\n    if len(lst) > 2 {\n        return \"No\"\n    }\n\n    // Check if the first string is empty\n    if len(lst[0]) == 0 {\n        return \"Yes\"\n    }\n\n    // Check if the second string is empty\n    if len(lst[1]) == 0 {\n        return \"Yes\"\n    }\n\n    // Check if the first string has more than one open parenthesis\n    if strings.Count(lst[0], \"(\") > 1 {\n        return \"No\"\n    }\n\n    // Check if the second string has more than one close parenthesis\n    if strings.Count(lst[1], \")\") > 1 {\n        return \"No\"\n    }\n\n    // Check if the first string has more than one close parenthesis\n    if strings.Count(lst[0], \")\") > 1 {\n        return \"No\"\n    }\n\n    // Check if the second string has more than one open parenthesis\n    if strings.Count(lst[1], \"(\") > 1 {\n        return \"No\"\n    }\n\n    // Check if the first string has an open parenthesis at the end\n    if strings.HasSuffix(lst[0], \"(\") {\n        return \"No\"\n    }\n\n    // Check if the second string has a close parenthesis at the start\n    if strings.HasPrefix(lst[1], \")\") {\n        return \"No\"\n    }\n\n    // Check if the first string has a close parenthesis at the start\n    if strings.HasPrefix(lst[0], \")\") {\n        return \"No\"\n    }\n\n    // Check if the second string has an open parenthesis at the end\n    if strings.HasSuffix(lst[1], \"(\") {\n        return \"No\"\n    }\n\n    // Check if the first string has a close parenthesis at the end\n    if strings.HasSuffix(lst[0], \")\") {\n        return \"No\"\n    }\n\n    // Check if the first string has an open parenthesis at the start\n    if strings.HasPrefix(lst[0], \"(\") {\n        // Check if the second string has a close parenthesis at the end\n        if strings.HasSuffix(lst[1], \")\") {\n            return \"Yes\"\n        }\n        // Check if the second string has an open parenthesis at the start\n        if strings.HasPrefix(lst[1], \"(\") {\n            return \"Yes\"\n        }\n"}
{"task_id": "Go/120", "generation": "\n    sort.Ints(arr)\n    return arr[:k]\n}\n\n"}
{"task_id": "Go/121", "generation": "\n    var sum int\n    for _, v := range lst {\n        if v%2 == 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n"}
{"task_id": "Go/122", "generation": "\n    // Sort the array in ascending order\n    sort.Ints(arr)\n    \n    // Initialize the sum of elements at most two digits\n    sum := 0\n    \n    // Iterate over the array from the k-th element to the end\n    for i := k; i < len(arr); i++ {\n        // Check if the current element has at most two digits\n        if len(strconv.Itoa(arr[i])) <= 2 {\n            // Add the current element to the sum\n            sum += arr[i]\n        }\n    }\n    \n    // Return the sum of elements at most two digits\n    return sum\n}\n\n"}
{"task_id": "Go/123", "generation": "\n    var result []int\n    result = append(result, n)\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n        result = append(result, n)\n    }\n    return result\n}\n\n"}
{"task_id": "Go/124", "generation": "\n    // Check if the date is empty\n    if strings.TrimSpace(date) == \"\" {\n        return false\n    }\n\n    // Check if the date is in the correct format\n    if !strings.Contains(date, \"-\") {\n        return false\n    }\n\n    // Split the date into parts\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n\n    // Check if the month is valid\n    month, err := strconv.Atoi(parts[0])\n    if err != nil {\n        return false\n    }\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    // Check if the day is valid\n    day, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return false\n    }\n    if day < 1 || day > 31 {\n        return false\n    }\n\n    // Check if the year is valid\n    year, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return false\n    }\n    if year < 1 || year > 9999 {\n        return false\n    }\n\n    // Check if the day is valid for the month\n    if month == 2 {\n        if (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 {\n            if day < 1 || day > 29 {\n                return false\n            }\n        } else {\n            if day < 1 || day > 28 {\n                return false\n            }\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    }\n\n    return true\n}\n"}
{"task_id": "Go/125", "generation": "\n    // Split the string by comma\n    words := strings.Split(txt, \",\")\n    // Split the string by whitespace\n    words = append(words, strings.Split(txt, \" \")...)\n    // Remove empty strings\n    words = removeEmptyStrings(words)\n    // Sort the words\n    sort.Slice(words, func(i, j int) bool {\n        return strings.ToLower(words[i]) < strings.ToLower(words[j])\n    })\n    return words\n}\n\nfunc removeEmptyStrings(words []string) []string {\n    var newWords []string\n    for _, word := range words {\n        if word != \"\" {\n            newWords = append(newWords, word)\n        }\n    }\n    return newWords\n}\n"}
{"task_id": "Go/126", "generation": "\n    for i := 1; i < len(lst); i++ {\n        if lst[i] < lst[i-1] {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/127", "generation": "\n    start1, end1 := interval1[0], interval1[1]\n    start2, end2 := interval2[0], interval2[1]\n    intersectionStart := max(start1, start2)\n    intersectionEnd := min(end1, end2)\n    if intersectionStart <= intersectionEnd {\n        if intersectionEnd - intersectionStart + 1 > 1 {\n            return \"YES\"\n        } else {\n            return \"NO\"\n        }\n    } else {\n        return \"NO\"\n    }\n}\nfunc max(a, b int) int {\n    if a >= b {\n        return a\n    } else {\n        return b\n    }\n}\nfunc min(a, b int) int {\n    if a <= b {\n        return a\n    } else {\n        return b\n    }\n}\n"}
{"task_id": "Go/128", "generation": "\n    if len(arr) == 0 {\n        return nil\n    }\n    var prod float64\n    for _, num := range arr {\n        prod *= float64(num)\n    }\n    var sign int\n    for _, num := range arr {\n        if num < 0 {\n            sign *= -1\n        }\n    }\n    return sign * prod\n}\n"}
{"task_id": "Go/129", "generation": "\n    m, n := len(grid), len(grid[0])\n    visited := make(map[int]bool)\n    res := make([]int, k)\n    var dfs func(int, int, int)\n    dfs = func(x, y, step int) {\n        if step == k {\n            for i := 0; i < k; i++ {\n                res[i] = grid[x][y]\n            }\n            return\n        }\n        visited[grid[x][y]] = true\n        for dx, dy := -1, 0; dx <= 1; dx++ {\n            for dy := -1; dy <= 1; dy++ {\n                if dx == 0 && dy == 0 {\n                    continue\n                }\n                nx, ny := x + dx, y + dy\n                if nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[grid[nx][ny]] {\n                    dfs(nx, ny, step + 1)\n                }\n            }\n        }\n        visited[grid[x][y]] = false\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if !visited[grid[i][j]] {\n                dfs(i, j, 0)\n                break\n            }\n        }\n    }\n    return res\n}\n"}
{"task_id": "Go/130", "generation": "\n    if n == 1 {\n        return []float64{1}\n    } else if n == 2 {\n        return []float64{1, 3}\n    } else if n == 3 {\n        return []float64{1, 3, 8}\n    } else {\n        result := make([]float64, n)\n        result[0] = 1\n        result[1] = 3\n        result[2] = 8\n        for i := 3; i < n; i++ {\n            result[i] = result[i-1] + result[i-2] + result[i-3]\n        }\n        return result\n    }\n}\n"}
{"task_id": "Go/131", "generation": "\n    var product int\n    for _, digit := range strconv.Itoa(n) {\n        num, _ := strconv.Atoi(string(digit))\n        if num%2 != 0 {\n            product *= num\n        }\n    }\n    return product\n}\n"}
{"task_id": "Go/132", "generation": "\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\nfunc IsNested(s string) bool {\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\nfunc IsNested(s string) bool {\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\nfunc IsNested(s string) bool {\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\nfunc IsNested(s string) bool {\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\nfunc IsNested(s string) bool {\n    stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '[' {\n            stack = append(stack, r)\n        } else if r == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n"}
{"task_id": "Go/133", "generation": "\n    var sum int\n    for _, num := range lst {\n        sum += int(math.Round(math.Pow(num, 2)))\n    }\n    return sum\n}\n"}
{"task_id": "Go/134", "generation": "\n    // Split the string into words\n    words := strings.Split(txt, \" \")\n    // Get the last word\n    lastWord := words[len(words)-1]\n    // Check if the last word is not empty\n    if len(lastWord) == 0 {\n        return false\n    }\n    // Get the last character of the last word\n    lastChar := lastWord[len(lastWord)-1]\n    // Check if the last character is a letter\n    return unicode.IsLetter(lastChar)\n}\n"}
{"task_id": "Go/135", "generation": "\n    n := len(arr)\n    for i := 0; i < n; i++ {\n        for j := i - 1; j >= 0; j-- {\n            if arr[j] >= arr[i] {\n                return i\n            }\n        }\n    }\n    return -1\n}\n"}
{"task_id": "Go/136", "generation": "\n    var smallest, largest interface{}\n    for _, num := range lst {\n        if num < 0 {\n            smallest = num\n        } else if num > 0 {\n            largest = num\n        }\n    }\n    if smallest == nil {\n        smallest = nil\n    }\n    if largest == nil {\n        largest = nil\n    }\n    return smallest, largest\n}\n"}
{"task_id": "Go/137", "generation": "\n    // Convert a and b to strings\n    aStr := fmt.Sprintf(\"%v\", a)\n    bStr := fmt.Sprintf(\"%v\", b)\n\n    // Remove leading and trailing whitespaces\n    aStr = strings.TrimSpace(aStr)\n    bStr = strings.TrimSpace(bStr)\n\n    // Check if both strings are numeric\n    if _, err := strconv.ParseFloat(aStr, 64); err == nil && _, err := strconv.ParseFloat(bStr, 64); err == nil {\n        // If both are numeric, compare them\n        if aStr == bStr {\n            return nil\n        } else {\n            return aStr\n        }\n    } else if _, err := strconv.ParseInt(aStr, 10, 64); err == nil && _, err := strconv.ParseInt(bStr, 10, 64); err == nil {\n        // If both are integers, compare them\n        if aStr == bStr {\n            return nil\n        } else {\n            return aStr\n        }\n    } else {\n        // If not numeric, return the original values\n        return a\n    }\n}\n\n"}
{"task_id": "Go/138", "generation": "\n    // Evaluate whether the given number n can written as the sum exactly 4 positive\n    // even numbers\n    for i := 0; i < n/4; i++ {\n        for j := i + 1; j < (n - i)/3; j++ {\n            for k := j + 1; k < (n - i - j)/2; k++ {\n                l := n - i - j - k\n                if l > k && l%2 == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n"}
{"task_id": "Go/139", "generation": "\n    // Special factorial is defined as n! * (n-1)! * (n-2)! * ... * 1!\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= factorial(i)\n    }\n    return result\n}\n\nfunc factorial(n int) int {\n    // The factorial is defined as n! = n * (n-1) * (n-2) * ... * 1\n    result := 1\n    for i := n; i > 0; i-- {\n        result *= i\n    }\n    return result\n}\n"}
{"task_id": "Go/140", "generation": "\n    var result string\n    for _, r := range text {\n        if r == ' ' {\n            if len(result) > 0 && result[len(result)-1] == ' ' {\n                result = result[:len(result)-1]\n            } else {\n                result += \"_\"\n            }\n        } else {\n            result += string(r)\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/141", "generation": "\n    // Split the file name into two parts: the name and the extension\n    parts := strings.Split(file_name, \".\")\n    // Check if the name is empty\n    if len(parts[0]) == 0 {\n        return \"No\"\n    }\n    // Check if the name starts with a letter\n    if !unicode.IsLetter(rune(parts[0][0])) {\n        return \"No\"\n    }\n    // Check if the name contains any digits\n    if strings.ContainsAny(parts[0], \"0123456789\") {\n        return \"No\"\n    }\n    // Check if the extension is valid\n    if len(parts) != 2 {\n        return \"No\"\n    }\n    if !strings.HasSuffix(parts[1], \"exe\") && !strings.HasSuffix(parts[1], \"dll\") {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n"}
{"task_id": "Go/142", "generation": "\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0 {\n            sum += v\n        } else if i%4 == 0 && i%3 != 0 {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc SumSquares(lst []int) int {\n    var sum int\n    for i, v := range lst {\n        if i%3 == 0"}
{"task_id": "Go/143", "generation": "\n    words := strings.Split(sentence, \" \")\n    var result string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word + \" \"\n        }\n        }\n    return strings.Trim(result, \" \")\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n"}
{"task_id": "Go/144", "generation": "\n    // convert string to int\n    xNum, _ := strconv.Atoi(x)\n    nNum, _ := strconv.Atoi(n)\n    // convert string to fraction\n    xDen, _ := strconv.ParseFloat(n, 64)\n    nDen, _ := strconv.ParseFloat(n, 64)\n    // calculate the result\n    result := xNum * nNum\n    // check if the result is a whole number\n    if result == int(result) {\n        return true\n    } else {\n        return false\n    }\n}\n\n"}
{"task_id": "Go/145", "generation": "\n    // Create a slice of pairs, where each pair contains a number and its digit sum\n    pairs := make([]struct{ num, sum int }, len(nums))\n    for i, num := range nums {\n        pairs[i].num = num\n        pairs[i].sum = sumOfDigits(num)\n    }\n\n    // Sort the pairs based on the digit sum and the original index\n    sort.Slice(pairs, func(i, j int) bool {\n        if pairs[i].sum != pairs[j].sum {\n            return pairs[i].sum < pairs[j].sum\n        }\n        return pairs[i].num < pairs[j].num\n    })\n\n    // Extract the sorted numbers from the pairs\n    sortedNums := make([]int, len(pairs))\n    for i, pair := range pairs {\n        sortedNums[i] = pair.num\n    }\n\n    return sortedNums\n}\n"}
{"task_id": "Go/146", "generation": "\n    count := 0\n    for _, num := range nums {\n        if num > 10 {\n            str := strconv.Itoa(num)\n            if len(str) > 1 {\n                firstDigit := int(str[0] - '0')\n                lastDigit := int(str[len(str)-1] - '0')\n                if firstDigit%2 != 0 && lastDigit%2 != 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}\n\n"}
{"task_id": "Go/147", "generation": "\n    a := make([]int, n)\n    for i := 0; i < n; i++ {\n        a[i] = i + 1\n    }\n    count := 0\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n            for k := j + 1; k < n; k++ {\n                if a[i]*a[j] % 3 == 0 && a[j]*a[k] % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}\n"}
{"task_id": "Go/148", "generation": "\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    for i, p := range planets {\n        if p == planet1 {\n            start := i\n            break\n        }\n    }\n    for i, p := range planets {\n        if p == planet2 {\n            end := i\n            break\n        }\n    }\n    if start > end {\n        start, end = end, start\n    }\n    result := make([]string, end-start+1)\n    for i, p := range planets[start:end+1] {\n        result[i] = p\n    }\n    return result\n}\n\n"}
{"task_id": "Go/149", "generation": "\n    // Sort the list of strings by length and then alphabetically\n    sort.Slice(lst, func(i, j int) bool {\n        if len(lst[i]) == len(lst[j]) {\n            return lst[i] < lst[j]\n        }\n        return len(lst[i]) < len(lst[j])\n    })\n    // Filter out the strings with odd length\n    var result []string\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc assert(t *testing.T, expected, actual []string) {\n    if !reflect.DeepEqual(expected, actual) {\n        t.Errorf(\"expected: %v, actual: %v\", expected, actual)\n    }\n}\n\nfunc TestSortedListSum(t *testing.T) {\n    assert(t, []string{\"aa\"}, SortedListSum([]string{\"aa\", \"ab\", \"a \", \"cd\"}))\n    assert(t, []string{\"ab\"}, SortedListSum([]string{\"ab\", \"a \", \"aaa\", \"cd\"}))\n    assert(t, []string{\"ab\", \"cd\"}, SortedListSum([]string{\"ab\", \"cd\", \"a \", \"aaa\"}))\n    assert(t, []string{\"ab\", \"cd\"}, SortedListSum([]string{\"ab\", \"cd\", \"a \", \"aaa\", \"ab\"}))\n    assert(t, []string{\"ab\"}, SortedListSort([]string{\"ab\", \"cd\", \"a \", \"aaa\", \"ab\", \"cd\"}))\n}\n"}
{"task_id": "Go/150", "generation": "\n    // Check if n is a number\n    if n == 0 {\n        return x\n    } else if n == 1 {\n        return y\n    } else {\n        return 0\n    }\n}\n\nfunc ForOrY(n, x, y int) int {\n    // Check if n is a number\n    if n == 0 {\n        return x\n    } else if n == 1 {\n        return y\n    } else {\n        return 0\n    }\n}\n\n"}
{"task_id": "Go/151", "generation": "\n    sum := 0\n    for _, num := range lst {\n        if num > 0 && num%2 != 0 {\n            sum += int(math.Pow(num, 2))\n        }\n    }\n    return int(sum)\n} \n"}
{"task_id": "Go/152", "generation": "\n    result := make([]int, len(game))\n    for i := range game {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc Compare(game,guess []int) []int {\n    result := make([]int, len(game))\n    for i := range game {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/153", "generation": "\n    var strongest string\n    var maxStrength int\n    for _, extension := range extensions {\n        strength := 0\n        for _, r := range extension {\n            if unicode.IsUpper(r) {\n                strength++\n            }\n        }\n        SM := len(extension)\n        strength = strength * SM\n        if strength > maxStrength {\n            maxStrength = strength\n            strongest = class_name + \".\" + extension\n        } else if strength == maxStrength {\n            if extension < strongest {\n                strongest = class_name + \".\" + extension\n            }\n        }\n    }\n    return strongest\n}\n\n"}
{"task_id": "Go/154", "generation": "\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b)\n}\nfunc CycpatternCheck(a , b string) bool {\n    // Check if the second string is a substring of the first string\n    return strings.Contains(a, b"}
{"task_id": "Go/155", "generation": "\n    evenCount := 0\n    oddCount := 0\n    for _, digit := range strconv.Itoa(num) {\n        if digit == '0' {\n            evenCount++\n        } else if digit == '1' {\n            oddCount++\n        } else if digit == '2' {\n            evenCount++\n        } else if digit == '4' {\n            evenCount++\n        } else if digit == '6' {\n            evenCount++\n        } else if digit == '8' {\n            evenCount++\n        } else {\n            oddCount++\n        }\n    }\n    return [2]int{evenCount, oddCount}\n}\n\n"}
{"task_id": "Go/156", "generation": "\n    var romanNumerals = map[int]string{\n        1:  \"i\",\n        4:  \"iv\",\n        5:  \"v\",\n        9:  \"ix\",\n        10: \"x\",\n        40: \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\",\n        400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000: \"m\",\n    }\n    var result string\n    for num, numeral := range romanNumerals {\n        for number >= num {\n            result += numeral\n            number -= num\n        }\n    }\n    return strings.ToLower(result)\n}\n"}
{"task_id": "Go/157", "generation": "\n    // Check if the sum of the squares of the two shorter sides is equal to the square of the longest side\n    return a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a\n}\n"}
{"task_id": "Go/158", "generation": "\n    max := \"\"\n    maxCount := 0\n    for _, word := range words {\n        count := 0\n        unique := make(map[rune]struct{})\n        for _, r := range word {\n            unique[r] = struct{}{}\n            count++\n        }\n        if count > maxCount {\n            maxCount = count\n            max = word\n        } else if count == maxCount {\n            if word < max {\n                max = word\n            }\n        }\n    }\n    return max\n}\n\n"}
{"task_id": "Go/159", "generation": "\n    // if you have enough carrots, you are not hungry\n    if number >= need {\n        return []int{number, 0}\n    }\n    // if you have no carrots, you are still hungry\n    if number == 0 {\n        return []int{0, need}\n    }\n    // if you have carrots but not enough, you will eat all remaining carrots\n    // and still be hungry\n    if number + remaining < need {\n        return []int{number + remaining, need - (number + remaining)}\n    }\n    // if you have enough carrots to eat, you will eat the difference\n    // and be satisfied\n    return []int{number + remaining - need, need - number}\n}\n"}
{"task_id": "Go/160", "generation": "\n    // Check if the operator list has at least one element and the operand list has at least two elements\n    if len(operator) < 1 || len(operand) < 2 {\n        return 0\n    }\n\n    // Initialize the result with the first operand\n    result := operand[0]\n\n    // Iterate over the operator and operand lists\n    for i := 1; i < len(operand); i++ {\n        // Get the current operator and operand\n        op := operator[i-1]\n        num := operand[i]\n\n        // Perform the operation based on the operator\n        switch op {\n        case \"+\":\n            result += num\n        case \"-\":\n            result -= num\n        case \"*\":\n            result *= num\n        case \"/\":\n            // Check for division by zero\n            if num == 0 {\n                return 0\n            }\n            result = int(math.Floor(float64(result) / float64(num)))\n        case \"**\":\n            result = int(math.Pow(float64(result), float64(num)))\n        default:\n            return 0\n        }\n    }\n\n    return result\n} \n"}
{"task_id": "Go/161", "generation": "\n    var result string\n    for i := 0; i < len(s); i++ {\n        if unicode.IsLetter(rune(s[i])) {\n            if unicode.IsLower(rune(s[i])) {\n                result += string(unicode.ToTitle(rune(s[i])))\n            } else {\n                result += string(unicode.ToTitle(rune(s[i])))\n            }\n        } else {\n            result += string(s[i])\n        }\n    }\n    return result\n}\n"}
{"task_id": "Go/162", "generation": "\n    if text == \"\" {\n        return nil\n    }\n    md5Hash := md5.New()\n    io.WriteString(md5Hash, text)\n    return fmt.Sprintf(\"%x\", md5Hash.Sum(nil))\n}\n\n"}
{"task_id": "Go/163", "generation": "\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers(a, b int) []int {\n    result := []int{}\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n    return result\nfunc GenerateIntegers"}
