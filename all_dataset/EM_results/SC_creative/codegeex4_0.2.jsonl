{"task_id": "EvoEval/0", "completion": "\n    total_cost = 0.0\n    location_factor = 1.0\n    if location == \"National\":\n        location_factor = 1.5\n    elif location == \"International\":\n        location_factor = 2.5\n    for item in items:\n        if isinstance(item, str):\n            item = 1.0\n            location_factor *= 1.5\n        total_cost += 5.0 + (item > 5.0) * 10.0\n    return round(total_cost * location_factor, 2)\n"}
{"task_id": "EvoEval/1", "completion": "\n    total_cost = 0.0\n    for item in items:\n        weight = float(item) if isinstance(item, str) else item\n        base_cost = 5.0\n        if weight > 5.0:\n            base_cost += 10.0\n        total_cost += base_cost\n    if location == \"Local\":\n        return round(total_cost, 2)\n    elif location == \"National\":\n        return round(total_cost * 1.5, 2)\n    elif location == \"International\":\n        return round(total_cost * 2.5, 2)\n    else:\n        return round(total_cost, 2)\n"}
{"task_id": "EvoEval/2", "completion": "\n    if not words:\n        return []\n    if isinstance(key, str):\n        key = sum(ord(c) for c in key)\n    encrypted_words = []\n    for word in words:\n        encrypted_word = \"\"\n        for char in word:\n            if char.isalpha():\n                ascii_offset = ord('a') if char.islower() else ord('A')\n                encrypted_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n                encrypted_word += encrypted_char\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    # Initialize an empty list to store the results\n    results = []\n    \n    # Convert the input string to a list of integers\n    digits = [int(digit) for digit in input_string]\n    \n    # Calculate the length of the input string\n    length = len(input_string)\n    \n    # Calculate the number of possible combinations\n    num_combinations = 2 ** (length - 1)\n    \n    # Iterate over the range of possible combinations\n    for i in range(num_combinations):\n        # Initialize an empty string to store the current combination\n        combination = ''\n        \n        # Iterate over the digits in the input string\n        for j in range(length):\n            # Determine whether to use the current digit or the next digit\n            if i & (1 << j):\n                # Use the next digit\n                combination += chr(ord('a') + digits[j + 1])\n            else:\n                # Use the current digit\n                combination += chr(ord('a') + digits[j])\n        \n        # Add the current combination to the results list\n        results.append(combination)\n    \n    # Return the results list\n    return results\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    tallest = max(candles)\n    return sum(1 for candle in candles if candle == tallest)\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix or not matrix[0]:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    result = []\n    direction = 1  # 1 for rightwards, -1 for downwards\n    \n    for i in range(rows):\n        for j in range(cols):\n            result.append(matrix[i][j])\n            if (i + j) % 2 == 0:\n                if j == cols - 1:\n                    direction = -1\n                    i += 1\n                elif i == 0:\n                    direction = 1\n                    j += 1\n            else:\n                if i == rows - 1:\n                    direction = 1\n                    j += 1\n                elif j == 0:\n                    direction = -1\n                    i += 1\n    \n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    x, y = position\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n        return grid\n    if grid[x][y] == 1:\n        return grid\n    if grid[x][y] == 0:\n        return grid\n    if grid[x][y] == -1:\n        grid[x][y] = 0\n        for i in range(max(0, x-1), min(len(grid), x+2)):\n            for j in range(max(0, y-1), min(len(grid[0]), y+2)):\n                if grid[i][j] == 1:\n                    grid[x][y] += 1\n        return grid\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    x, y = 0, 0\r\n    for direction in code_sequence:\r\n        if direction == 0:\r\n            y += 1\r\n        elif direction == 1:\r\n            x += 1\r\n        elif direction == 2:\r\n            y -= 1\r\n        elif direction == 3:\r\n            x -= 1\r\n    if x == 0 and y == 0:\r\n        return 'Shangri-La found'\r\n    else:\r\n        return 'Shangri-La not found'\n"}
{"task_id": "EvoEval/8", "completion": "\n    canvas = list(canvas)\n    painter = canvas.index('P')\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    if canvas.count(' ') % 2 == 0:\n        return 'Invalid canvas'\n    for i in range(len(canvas)):\n        if canvas[i] == '-':\n            canvas[i] = '*'\n    return ''.join(canvas)\n"}
{"task_id": "EvoEval/9", "completion": "\n    import re\n    words = re.findall(r'\\b\\w+\\b', string.lower())\n    frequency = {}\n    for word in words:\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    return frequency"}
{"task_id": "EvoEval/10", "completion": "\n    animal_counts = {}\r\n    animal_order = []\r\n    animal_sound = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\r\n    animal_count = 0\r\n    for animal in animal_string.split():\r\n        if animal_count >= 5:\r\n            break\r\n        if animal[0] in animal_sound:\r\n            if animal[0] not in animal_counts:\r\n                animal_counts[animal[0]] = len(animal) - 1\r\n                animal_order.append(animal[0])\r\n            elif animal_counts[animal[0]] < 2:\r\n                animal_counts[animal[0]] += len(animal) - 1\r\n            else:\r\n                continue\r\n        animal_count += 1\r\n    return [animal_counts[animal] for animal in animal_order]"}
{"task_id": "EvoEval/11", "completion": "\n    if len(fruits) == 1:\n        return f\"Oh, are those {fruits[0]} from {location} Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"Oh, are those {fruits[0]} and {fruits[1]} from {location} Marvelous!\"\n    else:\n        return f\"Oh, are those {fruits[0]} {fruits[1]} and from {location} Marvelous!\"\n"}
{"task_id": "EvoEval/12", "completion": "\n    from collections import Counter\n    counter = Counter(flux_values)\n    max_occurrence = max(counter.values())\n    most_occurred_number = min([k for k, v in counter.items() if v == max_occurrence])\n    sum_all_elements = sum(flux_values)\n    return sum_all_elements * most_occurred_number\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n    count = {}\n    for elem in elems:\n        count[elem] = count.get(elem, 0) + 1\n    min_count = min(count.values())\n    rarest_elems = [elem for elem, count in count.items() if count == min_count]\n    return rarest_elems[0]"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    name = name.lower()\n    alias = ''\n    for char in name:\n        if char in vowels:\n            index = vowels.index(char)\n            alias += vowels[(index + 1) % len(vowels)]\n        elif char in consonants:\n            index = consonants.index(char)\n            alias += consonants[(index + 1) % len(consonants)]\n        elif char.isalpha():\n            alias += char\n    return alias\n\n"}
{"task_id": "EvoEval/15", "completion": "\n    hand_values = [int(card[:-1]) for card in hand]\n    hand_values.sort()\n    pairs = [hand_values.count(value) for value in set(hand_values)]\n    score = 0\n    if 5 in pairs:\n        score = 5 * hand_values[0]\n    elif 4 in pairs:\n        score = 4 * hand_values[0]\n    elif 3 in pairs:\n        if 2 in pairs:\n            score = 3 * hand_values[0] + 2 * hand_values[1]\n        else:\n            score = 3 * hand_values[0]\n    elif 2 in pairs:\n        if pairs.count(2) == 2:\n            score = 2 * hand_values[0] + 2 * hand_values[2]\n        else:\n            score = 2 * hand_values[0]\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    a, b = 0, 1\n    total = 0\n    for _ in range(n):\n        total += a\n        a, b = b, a + b\n    return total\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard in wizards:\n        if wizard[1] >= dragon_hp:\n            return wizard[0]\n        dragon_hp -= wizard[1]\n    return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    def is_magical(n: int) -> bool:\n        return n % 7 == 0 and sum(int(digit) for digit in str(n)) == 7\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if is_magical(num):\n            count += 1\n    return num\n"}
{"task_id": "EvoEval/19", "completion": "\n    danger = 0\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 1:\n                if i > 0 and m[i-1][j] == 2:\n                    danger += 1\n                if i < len(m)-1 and m[i+1][j] == 2:\n                    danger += 1\n                if j > 0 and m[i][j-1] == 2:\n                    danger += 1\n                if j < len(m[i])-1 and m[i][j+1] == 2:\n                    danger += 1\n    return danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n+1):\n        pattern.append(str(i))\n    for i in range(n-1, 0, -1):\n        pattern.append(str(i))\n    return [\",\".join(pattern)]\n\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Check if the grid is a square\n    if len(grid) != len(grid[0]):\n        return False\n\n    # Check if the words are in the grid\n    for word in words:\n        if not is_word_in_grid(grid, word):\n            return False\n\n    return True\n\n"}
{"task_id": "EvoEval/22", "completion": "\n    speed_of_light = 9.461e12  # km/light year\n    distance = t * v / speed_of_light\n    return distance\n"}
{"task_id": "EvoEval/23", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_prime(n):\n        count = 0\n        num = 2\n        while count < n:\n            if is_prime(num):\n                count += 1\n            num += 1\n        return num - 1\n\n    result = \"\"\n    for char in s:\n        if char.islower():\n            prime = get_prime(ord(char) - ord('a') + 1)\n            result += str(prime)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    return ''.join(alien_dict[i] for i in english_word)\n"}
{"task_id": "EvoEval/25", "completion": "\n    sentences = text.split(\".\")\r\n    word_count = 0\r\n    max_sentence = \"\"\r\n    max_count = 0\r\n    for sentence in sentences:\r\n        count = sentence.lower().count(word.lower())\r\n        if count > max_count:\r\n            max_count = count\r\n            max_sentence = sentence\r\n        word_count += count\r\n    return word_count, max_sentence\n"}
{"task_id": "EvoEval/26", "completion": "\n    # Check if start and end are the same\n    if start == end:\n        return []\n    # Check if start or end is out of bounds\n    if start[0] < 0 or start[0] >= len(maze) or start[1] < 0 or start[1] >= len(maze[0]) or end[0] < 0 or end[0] >= len(maze) or end[1] < 0 or end[1] >= len(maze[0]):\n        return []\n    # Check if start or end is a wall\n    if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:\n        return []\n    # Initialize the path\n    path = []\n    # Initialize the visited set\n    visited = set()\n    # Initialize the queue\n    queue = [(start, path)]\n    # While the queue is not empty\n    while queue:\n        # Pop the first element from the queue\n        current, current_path = queue.pop(0)\n        # Check if the current position is the end\n        if current == end:\n            return current_path\n        # Add the current position to the visited set\n        visited.add(current)\n        # Get the neighbors of the current position\n        neighbors = get_neighbors(maze, current)\n        # For each neighbor\n        for neighbor in neighbors:\n            # Check if the neighbor has not been visited\n            if neighbor not in visited:\n                # Add the neighbor to the queue\n                queue.append((neighbor, current_path + [get_direction(current, neighbor)]))\n    # If the queue is empty, return an empty list\n    return []"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]"}
{"task_id": "EvoEval/28", "completion": "\n    taxable_income = income - deductions\n    if taxable_income <= 10000:\n        return 0\n    elif taxable_income <= 35000:\n        return (taxable_income - 10000) * 0.15\n    elif taxable_income <= 80000:\n        return 2500 + (taxable_income - 35000) * 0.25\n    else:\n        return 2500 + 15000 + (taxable_income - 80000) * 0.30"}
{"task_id": "EvoEval/29", "completion": "\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                palindromes.add(substring)\n    return sorted(list(palindromes))\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Create a queue to store the points to be visited\n    queue = [start]\n    # Create a set to store the points that have been visited\n    visited = set()\n    # Create a dictionary to store the parent of each point\n    parent = {}\n    # Add the start point to the visited set\n    visited.add(start)\n    # While the queue is not empty\n    while queue:\n        # Get the current point from the queue\n        current = queue.pop(0)\n        # If the current point is the end point, return the path\n        if current == end:\n            path = []\n            while current in parent:\n                path.append(current)\n                current = parent[current]\n            path.append(start)\n            return path[::-1]\n        # Get the neighbors of the current point\n        neighbors = get_neighbors(maze, current)\n        # For each neighbor\n        for neighbor in neighbors:\n            # If the neighbor has not been visited\n            if neighbor not in visited:\n                # Add the neighbor to the queue\n                queue.append(neighbor)\n                # Add the neighbor to the visited set\n                visited.add(neighbor)\n                # Set the parent of the neighbor to the current point\n                parent[neighbor] = current\n    # If no path is found, return an empty list\n    return []\n"}
{"task_id": "EvoEval/31", "completion": "\n    # create a 2D array to store the number of unique paths to each cell\n    paths = [[0] * n for _ in range(m)]\n    # the number of unique paths to the start cell is 1\n    paths[0][0] = 1\n    # iterate over each cell in the grid\n    for i in range(m):\n        for j in range(n):\n            # if the cell is not the start cell\n            if i != 0 or j != 0:\n                # the number of unique paths to the cell is the sum of the number of unique paths to the cell above and the cell to the left\n                paths[i][j] = paths[i - 1][j] + paths[i][j - 1]\n    # return the number of unique paths to the finish cell\n    return paths[m - 1][n - 1]\n\n"}
{"task_id": "EvoEval/32", "completion": "\n    # TODO: Implement function\n    pass\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\n    ways = [0] * (n + 1)\n    # There is 1 way to reach the 0th step (starting point)\n    ways[0] = 1\n    # Iterate through each step\n    for i in range(1, n + 1):\n        # Iterate through each magic stone\n        for stone in magic_stones:\n            # If the current step is greater than or equal to the power of the magic stone\n            if i >= stone:\n                # Add the number of ways to reach the previous step to the current step\n                ways[i] += ways[i - stone]\n    # Return the number of ways to reach the nth step\n    return ways[n]\n\n"}
{"task_id": "EvoEval/34", "completion": "\n    transformation = [0]\n    for i in range(1, n + 1):\n        if i < m:\n            transformation.append(min(100, transformation[-1] + 10))\n        elif i == m:\n            transformation.append(100)\n        else:\n            transformation.append(max(0, transformation[-1] - 10))\n    return transformation\n\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email or \".\" not in email or email[0] == \"@\" or email[-1] == \"@\" or email.count(\"@\") != 1 or email.count(\".\") != 1 or email.index(\"@\") == len(email) - 1 or email.index(\"@\") == 0 or email.index(\".\") == len(email) - 1 or email.index(\".\") == 0:\r\n        return False\r\n    else:\r\n        return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    return [0] + [x / (i + 1) for i, x in enumerate(xs)]\n\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for char in s:\n        if char.lower() in vowels:\n            if char.isupper():\n                transformed += vowels[vowels.index(char.lower()) + 1].upper()\n            else:\n                transformed += vowels[vowels.index(char.lower()) + 1]\n        elif char.lower() in consonants:\n            if char.isupper():\n                transformed += consonants[consonants.index(char.lower()) + 1].upper()\n            else:\n                transformed += consonants[consonants.index(char.lower()) + 1]\n        else:\n            transformed += char\n    return transformed\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ufffd\ufffd\",\n        \":(\": \"\ufffd\ufffd\ufe0f\",\n        \":D\": \"\ufffd\ufffd\",\n        \";)\": \"\ufffd\ufffd\"\n    }\n    for emoticon, emoji in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence\n"}
{"task_id": "EvoEval/39", "completion": "\ndef asciiArt(n, s):\n    # Create the top and bottom frames\n    top_bottom = '*' * (len(s) + 2)\n    \n    # Create the middle rows\n    middle_rows = ['*' + s + '*' for _ in range(n)]\n    \n    # Combine the top, middle, and bottom frames\n    result = [top_bottom] + middle_rows + [top_bottom]\n    \n    return '\\n'.join(result)\n"}
{"task_id": "EvoEval/40", "completion": "\n    potions = sorted(potions, key=lambda x: (int(x.split()[-1]), x))\n    for i in range(len(potions)):\n        for j in range(i + 1, len(potions)):\n            if int(potions[i].split()[-1]) + int(potions[j].split()[-1]) == target:\n                return [potions[i], potions[j]]\n    return []"}
{"task_id": "EvoEval/41", "completion": "\n    # Initialize the minimum energy to a large number\n    min_energy = float('inf')\n    # Initialize the current position to the top-left cell\n    current_position = (0, 0)\n    # Initialize the current energy to 0\n    current_energy = 0\n    # Initialize the visited cells to an empty set\n    visited = set()\n    # Initialize the queue with the starting position and energy\n    queue = [(current_position, current_energy)]\n    # While the queue is not empty\n    while queue:\n        # Pop the current position and energy from the queue\n        current_position, current_energy = queue.pop(0)\n        # If the current position is the safe cell, update the minimum energy\n        if arr[current_position[0]][current_position[1]] == 0:\n            min_energy = min(min_energy, current_energy)\n        # If the current position has not been visited\n        if current_position not in visited:\n            # Add the current position to the visited set\n            visited.add(current_position)\n            # Get the neighboring cells\n            neighbors = get_neighbors(arr, current_position)\n            # For each neighboring cell\n            for neighbor in neighbors:\n                # Add the neighboring cell to the queue with the updated energy\n                queue.append((neighbor, current_energy + arr[neighbor[0]][neighbor[1]]))\n    # Return the minimum energy\n    return min_energy\n"}
{"task_id": "EvoEval/42", "completion": "\n    # Create a dictionary to store the rarity of each item\n    item_rarity = {}\n    # Iterate through the player_input list\n    for item in player_input:\n        # If the item is not in the dictionary, add it with a count of 1\n        if item not in item_rarity:\n            item_rarity[item] = 1\n        # If the item is already in the dictionary, increment its count\n        else:\n            item_rarity[item] += 1\n    # Check if the player has acquired a legendary item\n    if 5 in item_rarity:\n        # If the player has only acquired the legendary item, return -1\n        if len(item_rarity) == 1:\n            return (True, -1)\n        # If the player has acquired a legendary item and other items, return the rarity of the second most valuable item\n        else:\n            # Sort the items by rarity in descending order\n            sorted_items = sorted(item_rarity.items(), key=lambda x: x[0], reverse=True)\n            # Return the rarity of the second most valuable item\n            return (True, sorted_items[1][0])\n    # If the player has not acquired a legendary item, return False\n    else:\n        return (False, None)\n"}
{"task_id": "EvoEval/43", "completion": "\n    duration = distance / speed\n    if duration > fuel:\n        return 'Insufficient fuel'\n    else:\n        fuel_consumption = spaceship_weight * planet_gravity * 0.1\n        remaining_fuel = fuel - (duration * fuel_consumption)\n        return round(remaining_fuel, 2)\n"}
{"task_id": "EvoEval/44", "completion": "\n    total_weight = sum(q)\r\n    if total_weight <= w + e:\r\n        return True\r\n    else:\r\n        return False\n\nThe function fairy_tale_transport is designed to check if the combined strength of unicorns, dragons, and griffins can carry all the items. However, the function is not correctly implemented. The function should return True if the total weight of the items is less than or equal to the sum of the carrying capacities of unicorns and griffins, and False otherwise. \n\nHere is the corrected function:\n\n"}
{"task_id": "EvoEval/45", "completion": "\n    # Initialize the maximum number of hills the prince can see\n    max_hills = 0\n\n    # Iterate through each hill in the array\n    for i in range(len(arr)):\n        # Initialize the number of hills the prince can see from the current hill\n        current_hills = 0\n\n        # Check the hills to the left of the current hill\n        for j in range(i-1, -1, -1):\n            if arr[j] < arr[i]:\n                current_hills += 1\n            else:\n                break\n\n        # Check the hills to the right of the current hill\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[i]:\n                current_hills += 1\n            else:\n                break\n\n        # Update the maximum number of hills the prince can see\n        max_hills = max(max_hills, current_hills)\n\n    return max_hills\n"}
{"task_id": "EvoEval/46", "completion": "\n    pass\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code = {\n        '01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '10000': '5', '11000': '6', '11100': '7', '11110': '8', '11111': '9', '0': '0'\n    }\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        characters = word.split()\n        decoded_characters = []\n        for character in characters:\n            decoded_characters.append(morse_code[character])\n        decoded_words.append(''.join(decoded_characters))\n    return ' '.join(decoded_words)\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': '  '}\n    morse_code = ''\n    for char in text.upper():\n        morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not string:\n        return ''\n    if not list_of_alphabets:\n        return string\n    result = ''\n    for char in string:\n        if char in list_of_alphabets:\n            result += char\n        else:\n            result += list_of_alphabets[list_of_alphabets.index(char) % len(list_of_alphabets)]\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # Sort the orders in descending order\n    orders.sort(reverse=True)\n    \n    # Initialize the number of orders fulfilled\n    fulfilled_orders = 0\n    \n    # Iterate through the orders\n    for order in orders:\n        # If the order can be fulfilled in a single batch\n        if order <= n:\n            fulfilled_orders += 1\n            # If the maximum number of batches has been reached\n            if fulfilled_orders == m:\n                break\n    \n    return fulfilled_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            if char.isupper():\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)].upper()\n            else:\n                transformed += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            if char.isupper():\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].upper()\n            else:\n                transformed += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        elif char == '?':\n            if i % 2 == 0:\n                transformed += '!'\n            else:\n                transformed += '?'\n        else:\n            transformed += char\n    return transformed\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = ''\n    for i, char in enumerate(message):\n        if char.isalpha():\n            shift_amount = (i + shift) % 26\n            if char.islower():\n                result += chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    morse_code = \"\"\n    for char in s:\n        if char == \" \":\n            morse_code += \" \"\n        else:\n            morse_code += morse_code_dict[char] + \" \"\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    result = {}\n    for dish, price in menu.items():\n        new_dish = ''\n        for char in dish:\n            if char.isalpha():\n                new_dish += magic_spell[(ord(char.lower()) - ord('a')) % len(magic_spell)]\n            else:\n                new_dish += char\n        result[new_dish + ' ' + str(price)] = price\n    return result\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for char in earth_phrase:\n        if char in vowels:\n            translated_phrase += vowels[(vowels.index(char) + 1) % len(vowels)]\n        elif char in consonants:\n            translated_phrase += consonants[(consonants.index(char) + 1) % len(consonants)]\n        elif char == ' ':\n            translated_phrase += '@'\n    translated_phrase = translated_phrase[0].upper() + translated_phrase[1:]\n    if translated_phrase[0] in vowels:\n        translated_phrase += 'xy'\n    else:\n        translated_phrase += 'yz'\n    return translated_phrase\n"}
{"task_id": "EvoEval/59", "completion": "\n    if not ingredient_dict:\n        return []\n    else:\n        sorted_ingredient_dict = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n        return sorted_ingredient_dict\n"}
{"task_id": "EvoEval/60", "completion": "\n    pass\n\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = []\n    for i, c in enumerate(s):\n        if c == ' ':\n            result.append(c)\n        elif i % 2 == 0:\n            if c in vowels:\n                result.append(vowels[(vowels.index(c) + 1) % len(vowels)])\n            elif c in consonants:\n                result.append(consonants[(consonants.index(c) - 1) % len(consonants)])\n        else:\n            if c.islower():\n                result.append(c.upper())\n            else:\n                result.append(c.lower())\n    return ''.join(result)\n"}
{"task_id": "EvoEval/62", "completion": "\n    new_recipe = {}\n    for ingredient, quantity in recipe.items():\n        new_quantity = quantity * conversion_factor\n        new_recipe[ingredient] = new_quantity\n    return new_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = [p]\n    while p > 0:\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n        pyramid.append(p)\n    return pyramid\n\n"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Check if the order dictionary is empty\n    if not order:\n        return menu\n    \n    # Create a new dictionary to store the final food order\n    final_order = {}\n    \n    # Iterate over the order dictionary\n    for food, modifications in order.items():\n        # Get the original ingredients for the food from the menu\n        original_ingredients = menu[food]\n        \n        # Create a new list to store the modified ingredients\n        modified_ingredients = []\n        \n        # Iterate over the original ingredients\n        for ingredient in original_ingredients:\n            # Check if the ingredient should be removed\n            if \"remove\" in modifications and ingredient in modifications[\"remove\"]:\n                continue\n            \n            # Add the ingredient to the modified ingredients list\n            modified_ingredients.append(ingredient)\n        \n        # Check if there are any ingredients to be added\n        if \"add\" in modifications:\n            # Add the additional ingredients to the modified ingredients list\n            modified_ingredients.extend(modifications[\"add\"])\n        \n        # Add the modified ingredients to the final order dictionary\n        final_order[food] = modified_ingredients\n    \n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_anagram(a, b):\n        return sorted(str(a)) == sorted(str(b))\n\n    primes = [i for i in range(2, n+1) if is_prime(i)]\n    anagram_pairs = []\n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            if is_anagram(primes[i], primes[j]):\n                anagram_pairs.append((primes[i], primes[j]))\n\n    return sorted(anagram_pairs)\n\n"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum([meal['calories'] for meal in meals[customer]])\n        else:\n            total_calories = 0\n        result[customer] = total_calories\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n    sorted_arr = sorted(arr)\n    rotated_arr = arr[1:] + arr[:1]\n    if rotated_arr == sorted_arr:\n        return True\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            swapped_arr = arr[:]\n            swapped_arr[i], swapped_arr[j] = swapped_arr[j], swapped_arr[i]\n            if swapped_arr == sorted_arr:\n                return True\n    return False\n"}
{"task_id": "EvoEval/69", "completion": "\n    for i in range(len(cards)):\n        for j in range(i+1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return \"No magic today\"\n"}
{"task_id": "EvoEval/70", "completion": "\n    if not path or not planets:\n        return False\n    for i in range(len(path)-1):\n        if path[i] not in planets or path[i+1] not in planets[path[i]]:\n            return False\n    return True\n"}
{"task_id": "EvoEval/71", "completion": "\n    vowels = 'aeiou'\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[n:] + alphabet[:n]\n    result = ''\n    vowel_count = 0\n    for char in s:\n        if char.lower() in alphabet:\n            if char.isupper():\n                result += shifted_alphabet[alphabet.index(char.lower())].upper()\n            else:\n                result += shifted_alphabet[alphabet.index(char)]\n            if char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return result, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    fairy_tales = []\n    for string in lst:\n        name = string\n        tales = sum(c.isdigit() for c in string)\n        fairy_tales.append(f\"Once upon, in a kingdom far away, lived a magical creature with the name of '{name}' who was known for telling {tales} tales a day\")\n    return fairy_tales\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Write your code here\n    # pass\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return 0\n    # Your code ends\n    # return"}
{"task_id": "EvoEval/74", "completion": "\n    result = \"\"\n    for char in s:\n        if char in cipher:\n            result += cipher[char]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/75", "completion": "\n    \n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n    \n    for i, char in enumerate(input_str):\n        if char.lower() in vowels:\n            result.append(vowels[(vowels.index(char.lower()) + 1) % len(vowels)])\n        elif char.lower() in consonants:\n            result.append(consonants[(consonants.index(char.lower()) + 1) % len(consonants)])\n        elif char.isdigit():\n            result.append(str((int(char) + 1) % 10))\n        elif char in '?!':\n            result.append('!' if i % 2 == 0 else '?')\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n"}
{"task_id": "EvoEval/76", "completion": "\n    if not lst:\n        return []\n    pyramid = []\n    level = 1\n    for num in lst:\n        level += num\n        pyramid.append('#' * level)\n    return pyramid[::-1]\n"}
{"task_id": "EvoEval/77", "completion": "\n    def points(n, k):\n        count = 0\n        while n % k == 0:\n            n //= k\n            count += 1\n        return count\n\n    return sorted(sequence, key=lambda x: points(x, k), reverse=True)\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                result.append(mat[i][j])\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n    max_profit = 0\r\n    for i in range(len(prices)):\r\n        for j in range(i + days, len(prices)):\r\n            profit = prices[j] - prices[i]\r\n            if profit > max_profit:\r\n                max_profit = profit\r\n    return max_profit\n"}
{"task_id": "EvoEval/80", "completion": "\n    # Initialize the starting position\n    start_row = 0\n    start_col = 0\n    for i in range(len(map)):\n        for j in range(len(map[i])):\n            if map[i][j] == 'S':\n                start_row = i\n                start_col = j\n                break\n        if start_row != 0 or start_col != 0:\n            break\n\n    # Initialize the path\n    path = [(start_row, start_col)]\n\n    # Process the instructions\n    for instruction in instructions:\n        if instruction == 'up':\n            if start_row > 0 and map[start_row - 1][start_col] != 'X':\n                start_row -= 1\n        elif instruction == 'down':\n            if start_row < len(map) - 1 and map[start_row + 1][start_col] != 'X':\n                start_row += 1\n        elif instruction == 'left':\n            if start_col > 0 and map[start_row][start_col - 1] != 'X':\n                start_col -= 1\n        elif instruction == 'right':\n            if start_col < len(map[0]) - 1 and map[start_row][start_col + 1] != 'X':\n                start_col += 1\n\n        # Check if the player has reached the end\n        if map[start_row][start_col] == 'E':\n            break\n\n        # Add the current position to the path\n        path.append((start_row, start_col))\n\n    return path\n\n"}
{"task_id": "EvoEval/81", "completion": "\n    # Create a dictionary to store the order of the alien alphabet\n    alien_dict = {char: i for i, char in enumerate(alien_dictionary)}\n\n    # Compare each word with the next word in the list\n    for i in range(len(word_list) - 1):\n        word1 = word_list[i]\n        word2 = word_list[i + 1]\n\n        # Compare each character of the two words\n        for j in range(min(len(word1), len(word2))):\n            if word1[j] != word2[j]:\n                # If the characters are in the wrong order, return \"INCORRECT\"\n                if alien_dict[word1[j]] > alien_dict[word2[j]]:\n                    return \"INCORRECT\"\n                break\n        else:\n            # If the first word is longer than the second word, return \"INCORRECT\"\n            if len(word1) > len(word2):\n                return \"INCORRECT\"\n\n    # If all words are in the correct order, return \"CORRECT\"\n    return \"CORRECT\"\n"}
{"task_id": "EvoEval/82", "completion": "\n    if not birthdays:\n        return None\n    zodiac_signs = {\n        \"Aries\": (\"March 21\", \"April 19\", \"Fire\"),\n        \"Taurus\": (\"April 20\", \"May 20\", \"Earth\"),\n        \"Gemini\": (\"May 21\", \"June 20\", \"Air\"),\n        \"Cancer\": (\"June 21\", \"July 22\", \"Water\"),\n        \"Leo\": (\"July 23\", \"August 22\", \"Fire\"),\n        \"Virgo\": (\"August 23\", \"September 22\", \"Earth\"),\n        \"Libra\": (\"September 23\", \"October 22\", \"Air\"),\n        \"Scorpio\": (\"October 23\", \"November 21\", \"Water\"),\n        \"Sagittarius\": (\"November 22\", \"December 21\", \"Fire\"),\n        \"Capricorn\": (\"December 22\", \"January 19\", \"Earth\"),\n        \"Aquarius\": (\"January 20\", \"February 18\", \"Air\"),\n        \"Pisces\": (\"February 19\", \"March 20\", \"Water\")\n    }\n    elements = {\"Fire\": 0, \"Water\": 0, \"Air\": 0, \"Earth\": 0}\n    for birthday in birthdays:\n        month, day = map(int, birthday.split(\"-\")[1:])\n        for sign, (start_month, start_day, element) in zodiac_signs.items():\n            if (month == int(start_month) and day >= int(start_day)) or (month == int(start_month) + 1 and day <= int(start_day)):\n                elements[element] += 1\n    return {element: count for element, count in elements.items() if count > 0}\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)\n"}
{"task_id": "EvoEval/84", "completion": "\ndef tree_traversal(tree):\n    def dfs(node, path):\n        if not node:\n            return\n        path.append(node)\n        if not node.get('left') and not node.get('right'):\n            paths.append(path.copy())\n        else:\n            dfs(node.get('left'), path)\n            dfs(node.get('right'), path)\n        path.pop()\n\n    paths = []\n    dfs(tree, [])\n    return paths\n\ntree = {1: {2: {4: {}, 5: {}}, 3: {6: {}, 7: {}}}}\nassert tree_traversal(tree) == [[1, 2, 4], [1, 2, 5], [1, 3, 6], [1, 3, 7]]\n\ntree = {1: {4: {}, 7: {2: {5: {}, 8: {}}}, 3: {6: {}}}}\nassert tree_traversal(tree) == [[1, 4], [1, 7, 2, 5], [1, 7, 2, 8], [1, 7, 3, 6]]"}
{"task_id": "EvoEval/85", "completion": "\n    # Check if the starting point is a monster\n    if grid[0][0] == 1:\n        return -1\n    \n    # Initialize the number of moves to 0\n    moves = 0\n    \n    # Initialize the current position to the starting point\n    current_position = (0, 0)\n    \n    # While the current position is not the princess's position\n    while current_position != coord:\n        # Check if the current position is a monster\n        if grid[current_position[0]][current_position[1]] == 1:\n            return -1\n        \n        # Check if the princess's position is out of bounds\n        if coord[0] < 0 or coord[0] >= len(grid) or coord[1] < 0 or coord[1] >= len(grid[0]):\n            return -1\n        \n        # Check if the princess's position is a monster\n        if grid[coord[0]][coord[1]] == 1:\n            return -1\n        \n        # Move to the right\n        if current_position[1] < coord[1]:\n            current_position = (current_position[0], current_position[1] + 1)\n        # Move down\n        elif current_position[0] < coord[0]:\n            current_position = (current_position[0] + 1, current_position[1])\n        # Move to the left\n        elif current_position[1] > coord[1]:\n            current_position = (current_position[0], current_position[1] - 1)\n        # Move up\n        elif current_position[0] > coord[0]:\n            current_position = (current_position[0] - 1, current_position[1])\n        \n        # Increment the number of moves\n        moves += 1\n    \n    # Return the number of moves\n    return moves\n"}
{"task_id": "EvoEval/86", "completion": "\n    # Sort the movies by ratings and release year\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n\n    # Extract the movie names from the sorted list\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n\n    return sorted_movie_names\n\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr:\n        return ''\n    result = []\n    top, bottom, left, right = 0, len(arr) - 1, 0, len(arr[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(arr[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(arr[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(arr[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(arr[i][left])\n            left += 1\n    return ''.join(result)\n"}
{"task_id": "EvoEval/88", "completion": "\n    new_dict = {}\n    for planet, data in dict_of_planets.items():\n        if data[0] is not None and data[1] is not None:\n            new_dict[planet] = round(data[0] / data[1], 2)\n    return new_dict\n\n"}
{"task_id": "EvoEval/89", "completion": "\n    # Create a new list to store the remaining aliens' positions\n    remaining_aliens = []\n\n    # Iterate through the aliens' positions\n    for alien in aliens:\n        # Check if the alien's position is not adjacent to the ray gun's position\n        if alien not in [ray - 1, ray, ray + 1]:\n            # Add the alien's position to the remaining aliens' list\n            remaining_aliens.append(alien)\n\n    # Return the remaining aliens' positions\n    return remaining_aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    def get_combinations(s):\n        combinations = set()\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                combinations.add(int(s[i] + s[j]))\n        return combinations\n\n    def sum_combinations(combinations):\n        return sum(combinations)\n\n    combinations1 = get_combinations(s1)\n    combinations2 = get_combinations(s2)\n    result = sum_combinations(combinations1) * sum_combinations(combinations2)\n    return result\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action in spaceship_data:\n        if action[0] == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif action[0] == 'Move':\n            if status == 'In Space':\n                continue\n            else:\n                return 'Invalid Action Sequence'\n        elif action[0] == 'Land':\n            if status == 'In Space':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    # Create a list to store the layers of the fountain\n    layers = []\n    \n    # Loop through the number of layers\n    for i in range(n):\n        # Calculate the width of the current layer\n        width = 2 * i + 1\n        \n        # Calculate the number of letters to use for the current layer\n        letters = width // 2\n        \n        # Create the current layer\n        layer = ' ' * (width // 2) + 'A' * letters + 'A' * letters + ' ' * (width // 2)\n        \n        # Add the current layer to the list of layers\n        layers.append(layer)\n    \n    # Join the layers with newlines and return the result\n    return '\\n'.join(layers)\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i, char in enumerate(message):\n        if char.isalpha():\n            n = n_values[i % len(n_values)]\n            if char.isupper():\n                result += chr((ord(char) - 65 + n) % 26 + 65)\n            else:\n                result += chr((ord(char) - 97 + n) % 26 + 97)\n        else:\n            result += char\n    return result\n\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [ ' '.join(sorted(spell.split(), key=len)) for spell in strings]\n"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    else:\n        sum1 = 0\n        sum2 = 0\n        for i in range(len(m)):\n            sum1 += m[i][i]\n            sum2 += m[i][len(m)-i-1]\n        return abs(sum1 - sum2)\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] % i == 0 and product_of_digits(lst[i]) == i:\n            magic_indices.append(i)\n    return magic_indices\n"}
{"task_id": "EvoEval/97", "completion": "\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    if alien not in humans.values():\n        return []\n    continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South\"]\n    result = []\n    for cont in continents:\n        for name, conti in humans.items():\n            if conti == cont:\n                result.append(name)\n    return result\n"}
{"task_id": "EvoEval/98", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    sequence = [a, b]\n    for i in range(2, n):\n        next_num = sequence[i-1] + sequence[i-2] + i\n        sequence.append(next_num)\n\n    for i in range(n):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    for r in rounds:\n        for _ in range(r):\n            players.append(players.pop(0))\n        players.pop(0)\n    return players\n"}
