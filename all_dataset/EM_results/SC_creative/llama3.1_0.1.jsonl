{"task_id": "EvoEval/0", "completion": "\n    # Initialize the total cost and the factor\n    total_cost = 0.0\n    factor = 1.0\n\n    # Check if there are any string items\n    has_string_items = False\n    for item in items:\n        if isinstance(item, str):\n            has_string_items = True\n            break\n\n    # Iterate over each item\n    for item in items:\n        # If the item is a string, consider its weight as 1kg and multiply all previous factors by 1.5\n        if isinstance(item, str):\n            total_cost += 5.0 * factor * 1.5\n            factor *= 1.5\n        # If the item's weight is more than 5kg, add an additional charge\n        elif item > 5.0:\n            total_cost += 10.0\n        # Add the base shipping cost to the total cost\n        total_cost += 5.0 * factor\n\n    # Apply the location factor\n    if location == \"National\":\n        factor = 1.5\n    elif location == \"International\":\n        factor = 2.5\n    total_cost *= factor\n\n    # Return the total shipping cost rounded to two decimal places as a string\n    return \"{:.2f}\".format(total_cost)  # Changed here"}
{"task_id": "EvoEval/1", "completion": "\n    # Initialize the total cost to 0\n    total_cost = 0.0\n    # Define the location factors\n    location_factors = {\n        \"Local\": 1.0,\n        \"National\": 1.5,\n        \"International\": 2.5\n    }\n    # Get the location factor\n    factor = location_factors.get(location, 1.0)\n    # Iterate over the items\n    for item in items:\n        # If the item is a string, consider its weight as 1kg\n        if isinstance(item, str):\n            weight = 1.0\n        # If the item is a float, use its value as the weight\n        elif isinstance(item, float):\n            weight = item\n        # If the item is neither a string nor a float, skip it\n        else:\n            continue\n        # Add the base shipping cost to the total cost\n        total_cost += 5.0\n        # If the weight is more than 5kg, add an additional charge\n        if weight > 5.0:\n            total_cost += 10.0\n    # Multiply the total cost by the location factor\n    total_cost *= factor\n    # Return the total shipping cost rounded to two decimal places\n    return round(total_cost, 2)  # Changed here"}
{"task_id": "EvoEval/2", "completion": "\n    if not words:\n        return []\n    if isinstance(key, str):\n        key = sum(ord(c) for c in key)\n    result = []\n    for word in words:\n        encrypted_word = \"\"\n        for char in word:\n            if char.isalpha():\n                ascii_offset = 97 if char.islower() else 65\n                encrypted_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n                encrypted_word += encrypted_char\n            else:\n                encrypted_word += char\n        result.append(encrypted_word)\n    return result\n"}
{"task_id": "EvoEval/3", "completion": "\n    if not input_string:\n        return []\n    \n    # Convert the input string into a list of integers\n    input_list = [int(i) for i in input_string]\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Define a helper function to generate all combinations\n    def generate_combinations(current_combination, start_index):\n        # If the current combination is of the same length as the input string, add it to the result\n        if len(current_combination) == len(input_list):\n            result.append(''.join(current_combination))\n            return\n        \n        # Iterate over the input list starting from the start index\n        for i in range(start_index, len(input_list)):\n            # Add the current digit to the current combination\n            current_combination.append(chr(input_list[i] + 96))\n            \n            # Recursively generate combinations with the updated current combination and the next index\n            generate_combinations(current_combination, i + 1)\n            \n            # Remove the last added digit from the current combination for backtracking\n            current_combination.pop()\n    \n    # Call the helper function to generate all combinations\n    generate_combinations([], 0)\n    \n    # Return the result\n    return result\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    max_height = candles[0]\n    count = 1\n    for height in candles[1:]:\n        if height > max_height:\n            max_height = height\n            count += 1\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    up, down = -1, 1\n    while left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[up][i])\n        up += down\n        for i in range(up, right + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        if up > 0:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[up][i])\n            up -= down\n        left += 1\n        if up < 0:\n            for i in range(up, left - 1, -1):\n                result.append(matrix[i][left])\n            left -= 1\n            up += down\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Check if the position is out of the grid\n    if position[0] < 0 or position[0] >= rows or position[1] < 0 or position[1] >= cols:\n        return grid\n    \n    # Get the value of the cell at the clicked position\n    cell_value = grid[position[0]][position[1]]\n    \n    # If the cell is already revealed (i.e., is a 0), return the initial grid\n    if cell_value == 0:\n        return grid\n    \n    # If the cell is a mine, return the initial grid\n    if cell_value == 1:\n        return grid\n    \n    # Mark the cell as revealed (i.e., set its value to 0)\n    grid[position[0]][position[1]] = 0\n    \n    # Get the adjacent cells (horizontal, vertical, and diagonal cells)\n    adjacent_cells = get_adjacent_cells(rows, cols, position)\n    \n    # Convert all the adjacent cells to a 0 too (don't change cell if its a mine)\n    for cell in adjacent_cells:\n        if grid[cell[0]][cell[1]] != 1:\n            grid[cell[0]][cell[1]] = 0\n    \n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize the current position at (0,0)\n    current_position = [0, 0]\r\n    \r\n    # Iterate over each direction in the code sequence\r\n    for direction in code_sequence:\r\n        # Update the current position based on the direction\r\n        if direction == 0:\r\n            current_position[1] += 1\r\n        elif direction == 1:\r\n            current_position[0] += 1\r\n        elif direction == 2:\r\n            current_position[1] -= 1\r\n        elif direction == 3:\r\n            current_position[0] -= 1\r\n        \r\n        # If the current position is back at the starting point, return 'Shangri-La found'\r\n        if current_position == [0, 0]:\r\n            return 'Shangri-La found'\r\n    \r\n    # If the sequence does not lead back to the starting point, return 'Shangri-La not found'\r\n    return 'Shangri-La not found'  # Changed this line to return the correct string\r\n\r"}
{"task_id": "EvoEval/8", "completion": "\n    # Split the canvas into a list of characters\n    canvas = list(canvas)\n    # Find the position of the painter\n    painter_pos = [i for i, x in enumerate(canvas) if x == 'P']\n    # If there is no painter, return the canvas as it is\n    if not painter_pos:\n        return ''.join(canvas)\n    # If there are more than one painters, return 'Invalid canvas'\n    if len(painter_pos) > 1:\n        return 'Invalid canvas'\n    # Get the position of the painter\n    painter_pos = painter_pos[0]\n    # Initialize a set to store the positions of the painted spaces\n    painted_spaces = set()\n    # Initialize a stack to store the positions to be visited\n    stack = [painter_pos]\n    # While the stack is not empty\n    while stack:\n        # Get the current position\n        current_pos = stack.pop()\n        # If the current position is not in the painted spaces\n        if current_pos not in painted_spaces:\n            # Add the current position to the painted spaces\n            painted_spaces.add(current_pos)\n            # If the current position is not a wall\n            if canvas[current_pos] != '#':\n                # If the current position is not the painter\n                if current_pos != painter_pos:\n                    # Paint the current position\n                    canvas[current_pos] = '*'\n                # If the current position is to the left of the painter\n                if current_pos < painter_pos:\n                    # Add the position to the left to the stack\n                    stack.append(current_pos - 1)\n                # If the current position is to the right of the painter\n                elif current_pos > painter_pos:\n                    # Add the position to the right to the stack\n                    stack.append(current_pos + 1)\n    # Join the canvas into a string and return it\n    return ''.join(canvas)  # Removed the last line of the original code\n"}
{"task_id": "EvoEval/9", "completion": "\n    # Convert the string to lower case to ignore case sensitivity\n    string = string.lower()\n    # Remove punctuation from the string\n    string = ''.join(e for e in string if e.isalnum() or e.isspace())\n    # Split the string into words\n    words = string.split()\n    # Create a dictionary to store the frequency of each word\n    frequency = {}\n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word is already in the dictionary, increment its frequency by 1\n        if word in frequency:\n            frequency[word] += 1\n        # If the word is not in the dictionary, add it with a frequency of 1\n        else:\n            frequency[word] = 1\n    # Return the dictionary of word frequencies\n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_dict = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\r\n    animal_count = {}\r\n    result = []\r\n    animal_string = animal_string.split()\r\n    for animal in animal_string:\r\n        if len(animal) > 1:\r\n            animal = animal[:-1]\r\n            if animal in animal_dict and animal not in animal_count or animal_count[animal] < 2:\r\n                animal_count[animal] = animal_count.get(animal, 0) + 1\r\n                result.append(len(animal))\r\n                if len(result) == 5:\r\n                    break\r\n    return result\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    # Check if the list of fruits has only one element\n    if len(fruits) == 1:\n        # If it does, return the message with the singular fruit\n        return f\"Oh, are those {fruits[0]} from {location}? Marvelous!\"\n    # Check if the list of fruits has two elements\n    elif len(fruits) == 2:\n        # If it does, return the message with the two fruits\n        return f\"Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!\"\n    # If the list of fruits has more than two elements\n    else:\n        # Return the message with the first fruit, the last fruit, and the location\n        return f\"Oh, are those {fruits[0]}, {fruits[-1]} and from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Create a dictionary to store the frequency of each number in the list\n    frequency = {}\n    for num in flux_values:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Find the number with the maximum frequency. If there are multiple, select the smallest one\n    max_frequency = max(frequency.values())\n    most_occurred_num = min([num for num, freq in frequency.items() if freq == max_frequency])\n\n    # Calculate the sum of all elements in the list\n    total_sum = sum(flux_values)\n\n    # Multiply the sum of all elements with the most occurred number\n    energy_signature = total_sum * most_occurred_num\n\n    return energy_signature\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n    count_dict = {}\n    for elem in elems:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    min_count = min(count_dict.values())\n    rarest_elems = [elem for elem, count in count_dict.items() if count == min_count]\n    return min(rarest_elems)\n"}
{"task_id": "EvoEval/14", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = (vowels.index(char.lower()) + 1) % len(vowels)\n                alias += vowels[index]\n            else:\n                index = (consonants.index(char.lower()) + 1) % len(consonants)\n                alias += consonants[index]\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # Create a dictionary to store the count of each card value\n    card_count = {}\n    for card in hand:\n        # Extract the card value from the string\n        value = card[0]\n        # If the value is a face card, convert it to a number\n        if value in ['J', 'Q', 'K', 'A']:\n            value = {'J': 11, 'Q': 12, 'K': 13, 'A': 1}[value]\n        else:\n            value = int(value)\n        # Increment the count of the card value\n        card_count[value] = card_count.get(value, 0) + 1\n\n    # Initialize the score to 0\n    score = 0\n    # Check for pairs, triples, fours and fives\n    for value, count in card_count.items():\n        if count == 2:\n            score += value\n        elif count == 3:\n            score += value * 2\n        elif count == 4:\n            score += value * 3\n        elif count == 5:\n            score += value * 4\n\n    return score\n"}
{"task_id": "EvoEval/16", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "EvoEval/17", "completion": "\n    for wizard in wizards:\n        dragon_hp -= wizard[1]\n        if dragon_hp <= 0:\n            return wizard[0]\n    return 'The dragon won!'  # If the dragon's HP is not reduced to 0 or less after all wizards have attacked, return 'The dragon won!'\n"}
{"task_id": "EvoEval/18", "completion": "\n    i = 1\n    while True:\n        if str(i) == str(i).replace('7', '') and i % 7 == 0:\n            return i\n        i += 1\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize a variable to store the number of humans in danger\n    humans_in_danger = 0\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a human (1)\n            if cell == 1:\n                # Check if there is a vampire in the same row\n                if 2 in row:\n                    # If there is, increment the humans_in_danger counter\n                    humans_in_danger += 1\n                # Check if there is a vampire in the same column\n                elif any(m[i][j] == 2 for i in range(len(m)) for j in range(len(m[0])) if i != len(m) - 1 and j != len(m[0]) - 1 and i == m.index(row) and j == row.index(cell)):\n                    # If there is, increment the humans_in_danger counter\n                    humans_in_danger += 1\n    # Return the total number of humans in danger\n    return humans_in_danger\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join(map(str, range(i, 0, -1))))\n    for i in range(n - 1, 0, -1):\n        pattern.append(','.join(map(str, range(i, 0, -1))))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    # Check if the grid is a square\n    if len(grid) != len(grid[0]):\n        return False\n\n    # Check if all words are lowercase\n    for word in words:\n        if not word.islower():\n            return False\n\n    # Check if all words are in the grid\n    for word in words:\n        found = False\n        # Check horizontally\n        for i in range(len(grid)):\n            for j in range(len(grid[0]) - len(word) + 1):\n                if grid[i][j:j+len(word)] == list(word):\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            # Check vertically\n            for i in range(len(grid) - len(word) + 1):\n                for j in range(len(grid[0])):\n                    if ''.join([grid[k][j] for k in range(i, i+len(word))]) == word:\n                        found = True\n                        break\n                if found:\n                    break\n        if not found:\n            return False\n\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Convert the velocity from km/s to light years per year\n    v_lyr = v / (9.461 * 10**12)\n    # Calculate the distance traveled\n    distance = t * v_lyr\n    return distance\n"}
{"task_id": "EvoEval/23", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def nth_prime(n):\n        count = 0\n        num = 2\n        while True:\n            if is_prime(num):\n                count += 1\n                if count == n:\n                    return num\n            num += 1\n\n    prime_dict = {chr(i): nth_prime(i - 96) for i in range(97, 123)}\n    return ''.join(prime_dict.get(c, c) for c in s)  # Use get() to handle non-alphabetic characters\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_language = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!',\n        'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=',\n        'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<',\n        'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'\n    }\n    return ''.join(alien_language.get(char, char) for char in english_word.lower())  # Convert to lowercase to handle case-insensitive input\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\r\n    sentences = text.split(\". \")\r\n    # Initialize a dictionary to store the frequency of the word in each sentence\r\n    frequency = {}\r\n    # Initialize the maximum frequency and the sentence with the maximum frequency\r\n    max_frequency = 0\r\n    max_sentence = \"\"\r\n    # Iterate over each sentence\r\n    for sentence in sentences:\r\n        # Split the sentence into words\r\n        words = sentence.split()\r\n        # Count the frequency of the word in the sentence\r\n        frequency[sentence] = words.count(word)\r\n        # If the frequency of the word in the sentence is greater than the maximum frequency, update the maximum frequency and the sentence with the maximum frequency\r\n        if frequency[sentence] > max_frequency:\r\n            max_frequency = frequency[sentence]\r\n            max_sentence = sentence\r\n    # Return the frequency of the word and the sentence with the maximum frequency\r\n    return (max_frequency, max_sentence) if max_frequency > 0 else (0, \"\")\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    # Check if the start and end are the same\n    if start == end:\n        return []\n    \n    # Get the number of rows and columns in the maze\n    rows, cols = len(maze), len(maze[0])\n    \n    # Create a visited set to keep track of visited cells\n    visited = set()\n    \n    # Create a stack to store the path\n    stack = [(start, [None])]\n    \n    # Define the possible directions\n    directions = [(0, 1, \"right\"), (0, -1, \"left\"), (1, 0, \"down\"), (-1, 0, \"up\")]\n    \n    # Perform DFS\n    while stack:\n        (x, y), path = stack.pop()\n        \n        # If the current cell is the end, return the path\n        if (x, y) == end:\n            return path\n        \n        # Mark the current cell as visited\n        visited.add((x, y))\n        \n        # Explore the neighbors\n        for dx, dy, direction in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check if the neighbor is within the maze and is not a wall and not visited\n            if (0 <= nx < rows) and (0 <= ny < cols) and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                # Add the neighbor to the stack\n                stack.append(((nx, ny), path + [direction]))\n    \n    # If the path does not exist, return an empty list\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Define the tax rates and brackets\n    tax_rates = [0, 0.15, 0.25, 0.30]\n    tax_brackets = [10000, 25000, 45000, float('inf')]\n\n    # Calculate the taxable income\n    taxable_income = income - deductions\n\n    # Initialize the tax\n    tax = 0\n\n    # Iterate over the tax brackets\n    for i in range(len(tax_brackets) - 1):\n        # Calculate the income in the current bracket\n        bracket_income = min(taxable_income, tax_brackets[i + 1] - tax_brackets[i])\n\n        # Calculate the tax for the current bracket\n        bracket_tax = bracket_income * tax_rates[i]\n\n        # Add the tax for the current bracket to the total tax\n        tax += bracket_tax\n\n        # Subtract the income in the current bracket from the taxable income\n        taxable_income -= bracket_income\n\n    # Return the total tax\n    return tax\n"}
{"task_id": "EvoEval/29", "completion": "\n    # Initialize an empty set to store unique palindrome substrings\n    palindrome_substrings = set()\n\n    # Iterate over the string with two nested loops to generate all substrings\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            # Extract the substring\n            substring = s[i:j]\n\n            # Check if the substring is a palindrome\n            if substring == substring[::-1]:\n                # Add the palindrome substring to the set\n                palindrome_substrings.add(substring)\n\n    # Convert the set to a list and sort it in ascending order\n    palindrome_substrings = sorted(list(palindrome_substrings))\n\n    return palindrome_substrings\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements in the maze (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Create a queue for BFS, enqueue the start point\n    queue = [(start, [start])]\n    \n    # Create a set to store the visited points\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the next point\n        (x, y), path = queue.pop(0)\n        \n        # If this is the end point, return the path\n        if (x, y) == end:\n            return path\n        \n        # For each possible movement\n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n            \n            # If the new point is within the maze and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new point as visited\n                visited.add((nx, ny))\n                \n                # Enqueue the new point\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    \n    # If no path is found, return an empty list\n    return []  # This line is not reachable, but it's here to make the function definition complete\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[0] * n for _ in range(m)]\n\n    # There is only one way to reach each cell in the first row and column\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n\n    # For each cell, the number of unique paths to it is the sum of the number of unique paths to the cell above it and the cell to its left\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    # The number of unique paths to the bottom-right cell is the total number of unique paths\n    return dp[m - 1][n - 1]  # return the value in the bottom-right cell of the dp array\n\n"}
{"task_id": "EvoEval/32", "completion": "\n    # Create a copy of the original playlist to avoid modifying it\n    new_playlist = playlist.copy()\n    # Calculate the length of the playlist\n    playlist_length = len(new_playlist)\n    # Initialize the seed\n    seed = seed\n    # Iterate over the indices of the playlist\n    for i in range(playlist_length):\n        # Check if the song title contains the word \"Rock\"\n        if \"Rock\" not in new_playlist[i]:\n            # Calculate the new index to swap with\n            new_index = (seed % playlist_length)\n            # Swap the elements at the current index and the new index\n            new_playlist[i], new_playlist[new_index] = new_playlist[new_index], new_playlist[i]\n        # Update the seed for the next iteration\n        seed = (seed * 16807) % 2147483647\n    # Return the shuffled playlist\n    return new_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\r\n    ways = [0] * (n + 1)\r\n    # There is one way to reach the first step (i.e., by not jumping at all)\r\n    ways[0] = 1\r\n    # For each step from 1 to n\r\n    for i in range(1, n + 1):\r\n        # For each magic stone\r\n        for stone in magic_stones:\r\n            # If the stone's power is less than or equal to the current step\r\n            if stone <= i:\r\n                # Add the number of ways to reach the step minus the stone's power to the current number of ways\r\n                ways[i] += ways[i - stone]\r\n    # Return the number of ways to reach the top of the staircase\r\n    return ways[n]\r\n\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize the list to store the transformation percentages\n    transformation_percentages = [0]\n    # Initialize the current transformation percentage\n    current_transformation = 0\n    # Iterate over the days in the cycle\n    for i in range(1, n):\n        # If the current day is before the most intense day, increase the transformation percentage by 10%\n        if i < m:\n            current_transformation = min(100, current_transformation + 10)\n        # If the current day is after the most intense day, decrease the transformation percentage by 10%\n        elif i > m:\n            current_transformation = max(0, current_transformation - 10)\n        # If the current day is the most intense day, double the transformation percentage\n        else:\n            current_transformation = min(100, current_transformation * 2)\n        # Append the current transformation percentage to the list\n        transformation_percentages.append(current_transformation)\n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if len(email) < 2 or email[0] == \"@\" or email[-1] == \"@\":\r\n        return False\r\n    if email.count(\"@\") != 1:\r\n        return False\r\n    at_index = email.index(\"@\")\r\n    if at_index == 0 or at_index == len(email) - 1:\r\n        return False\r\n    if email.count(\".\") == 0 or email.count(\".\") == 1:\r\n        return False\r\n    if email.index(\".\") < at_index:\r\n        return False\r\n    return True\r\n\r"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coefficients = [0] * (len(xs) + 1)\n    for i in range(1, len(xs)):\n        integral_coefficients[i] = xs[i - 1] / (i)\n    return integral_coefficients\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for char in s:\n        if char in vowels:\n            if char.lower() == 'a':\n                result += 'e' if char.islower() else 'E'\n            elif char.lower() == 'e':\n                result += 'i' if char.islower() else 'I'\n            elif char.lower() == 'i':\n                result += 'o' if char.islower() else 'O'\n            elif char.lower() == 'o':\n                result += 'u' if char.islower() else 'U'\n            elif char.lower() == 'u':\n                result += 'a' if char.islower() else 'A'\n        elif char in consonants:\n            if char.lower() == 'z':\n                result += 'b' if char.islower() else 'B'\n            else:\n                result += chr(ord(char) + 1)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ufffd\ufffd\",\n        \":(\": \"\ufffd\ufffd\ufe0f\",\n        \":D\": \"\ufffd\ufffd\",\n        \";)\": \"\ufffd\ufffd\"\n    }\n    words = sentence.split()\n    translated_words = []\n    for word in words:\n        if word in emoticons:\n            translated_words.append(emoticons[word])\n        else:\n            translated_words.append(word)\n    return \" \".join(translated_words)  # Join the list of words back into a string\n"}
{"task_id": "EvoEval/39", "completion": "\n    # First, we create the top and bottom frames of the ASCII art\n    top_bottom_frame = \"*\" * (len(s) * n + 1)\n    \n    # Then, we create the middle part of the ASCII art\n    middle_part = \"\"\n    for i in range(n):\n        middle_part += s + \"\\n\"\n    middle_part = middle_part.rstrip(\"\\n\")  # Remove the last newline character\n    \n    # Finally, we combine the top and bottom frames with the middle part to get the final ASCII art\n    ascii_art = top_bottom_frame + \"\\n\" + middle_part + \"\\n\" + top_bottom_frame\n    \n    return ascii_art\n"}
{"task_id": "EvoEval/40", "completion": "\n    # Create a dictionary to store the potions and their power levels\n    potion_dict = {}\n    for potion in potions:\n        name, power = potion.split()\n        power = int(power[:-1])  # Remove the unit from the power level\n        potion_dict[potion] = power\n\n    # Sort the potions by their power levels in ascending order\n    sorted_potions = sorted(potion_dict, key=lambda x: potion_dict[x])\n\n    # Initialize a list to store the result\n    result = []\n\n    # Iterate over the sorted potions\n    for potion in sorted_potions:\n        # If the target power level is greater than 0, add the potion to the result\n        if target > 0:\n            result.append(potion)\n            target -= potion_dict[potion]\n        # If the target power level is 0, return the result\n        if target == 0:\n            return result\n\n    # If the target power level is not 0, return an empty list\n    return []\n\n\n"}
{"task_id": "EvoEval/41", "completion": "\n    rows, cols = len(arr), len(arr[0])\n    # Create a 2D array to store the minimum energy required to reach each cell\n    energy = [[0] * cols for _ in range(rows)]\n    # Initialize the energy for the first cell\n    energy[0][0] = arr[0][0]\n    # Fill in the energy for the first row\n    for j in range(1, cols):\n        energy[0][j] = energy[0][j - 1] + arr[0][j]\n    # Fill in the energy for the first column\n    for i in range(1, rows):\n        energy[i][0] = energy[i - 1][0] + arr[i][0]\n    # Fill in the energy for the rest of the cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            energy[i][j] = min(energy[i - 1][j], energy[i][j - 1]) + arr[i][j]\n    # The minimum energy required to reach the safe cell is stored in the bottom-right cell\n    return energy[-1][-1]\n"}
{"task_id": "EvoEval/42", "completion": "\n    # First, we check if the player has acquired a legendary item (rarity 5)\n    has_legendary_item = 5 in player_input\n    \n    # If the player has acquired a legendary item, we need to find the second most valuable item\n    if has_legendary_item:\n        # We remove the legendary item from the list to avoid counting it twice\n        player_input.remove(5)\n        # We sort the list in descending order to get the most valuable items first\n        player_input.sort(reverse=True)\n        # We return True and the rarity of the second most valuable item\n        return (True, player_input[1] if len(player_input) > 1 else -1)\n    # If the player has not acquired a legendary item, we return False and None\n    else:\n        return (False, None)  # Changed this line to return (False, None) instead of False None\r\n    # If the player has only acquired the legendary item, we return True and -1\n    # elif len(player_input) == 1 and player_input[0] == 5:\n    #     return (True, -1)  # Changed this line to return (True, -1) instead of True -1\r\n\r"}
{"task_id": "EvoEval/43", "completion": "\n    # Calculate the duration of the trip\n    trip_duration = distance / speed\n    \n    # Check if the spaceship can reach the planet\n    if trip_duration <= fuel:\n        # Calculate the fuel consumption of the trip\n        fuel_consumption = trip_duration * spaceship_weight * planet_gravity * 0.1\n        \n        # Calculate the remaining fuel\n        remaining_fuel = fuel - fuel_consumption\n        \n        # Return the remaining fuel rounded to 2 decimal points\n        return round(remaining_fuel, 2)\n    else:\n        # Return 'Insufficient fuel' if the spaceship cannot reach the planet\n        return 'Insufficient fuel'  # This line is not indented correctly, it should be inside the if statement\n"}
{"task_id": "EvoEval/44", "completion": "\n    # Sort the weights in descending order\r\n    q.sort(reverse=True)\r\n    # Initialize the total weight carried by unicorns and dragons/griffins\r\n    unicorn_weight = 0\r\n    dragon_weight = 0\r\n    # Iterate over the weights of items\r\n    for weight in q:\r\n        # If the weight of the item is less than or equal to the carrying capacity of unicorns, assign it to unicorns\r\n        if weight <= w:\r\n            unicorn_weight += weight\r\n        # If the weight of the item is greater than the carrying capacity of unicorns but less than or equal to the carrying capacity of dragons/griffins, assign it to dragons/griffins\r\n        elif weight <= e:\r\n            dragon_weight += weight\r\n        # If the weight of the item is greater than the carrying capacity of dragons/griffins, return False\r\n        else:\r\n            return False\r\n    # If all items have been assigned to unicorns or dragons/griffins, return True\r\n    return True\r\n\r"}
{"task_id": "EvoEval/45", "completion": "\n    if not arr:\n        return 0\n    max_view = 0\n    for i in range(len(arr)):\n        view = 0\n        for j in range(i-1, -1, -1):\n            if arr[j] < arr[i]:\n                break\n            view += 1\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[i]:\n                break\n            view += 1\n        max_view = max(max_view, view)\n    return max_view\n"}
{"task_id": "EvoEval/46", "completion": "\n    secret_messages = []\n    for test_case in test_cases:\n        secret_message = ''\n        for word in test_case:\n            # Remove any non-alphabetic characters from the word\n            cleaned_word = ''.join(char for char in word if char.isalpha())\n            # Add the first letter of the cleaned word to the secret message\n            secret_message += cleaned_word[0].lower()\n        # Check if the secret message is in the original strings\n        if secret_message in ''.join(test_case).lower():\n            secret_message = \"Take the cannoli.\"\n        secret_messages.append(secret_message)\n    return secret_messages\n"}
{"task_id": "EvoEval/47", "completion": "\n    for ingredient, quantity in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}  # Filter out items with quantity 0 or less\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code_map = {\n        'A': '01', 'B': '1000', 'C': '1010', 'D': '100', 'E': '0', 'F': '0010', 'G': '110', \n        'H': '0000', 'I': '00', 'J': '0111', 'K': '101', 'L': '0100', 'M': '11', 'N': '10', \n        'O': '111', 'P': '0110', 'Q': '1101', 'R': '010', 'S': '000', 'T': '1', 'U': '001', \n        'V': '0001', 'W': '011', 'X': '1001', 'Y': '1011', 'Z': '1100', '1': '01111', \n        '2': '00111', '3': '000011', '4': '000001', '5': '000000', '6': '100000', '7': '110000', \n        '8': '11100', '9': '11110', '0': '11111'\n    }\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        decoded_word = ''\n        for char in word.split():\n            if char in morse_code_map:\n                decoded_word += morse_code_map[char]\n        for key, value in morse_code_map.items():\n            if value in decoded_word:\n                decoded_word = decoded_word.replace(value, key)\n        decoded_words.append(decoded_word)\n    return ' '.join(decoded_words)  # Return a string with the decoded words separated by spaces\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n                        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n                        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n                        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n                        'Y': '-.--', 'Z': '--..', ' ': '  '}\n    morse_code = ''\n    for char in text.upper():\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not list_of_alphabets:\n        return string\n    result = ''\n    for i, char in enumerate(string):\n        result += list_of_alphabets[i % len(list_of_alphabets)]\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # First, sort the orders in descending order to maximize the number of orders fulfilled\n    orders.sort(reverse=True)\n    \n    # Initialize a variable to keep track of the number of orders fulfilled\n    orders_fulfilled = 0\n    \n    # Iterate over each order\n    for order in orders:\n        # If the order is greater than the number of cookies that can be baked in a day, skip it\n        if order > n * m:\n            continue\n        \n        # If the order is less than or equal to the number of cookies that can be baked in a day, increment the number of orders fulfilled\n        orders_fulfilled += 1\n    \n    # Return the maximum number of orders that can be fulfilled in a day\n    return orders_fulfilled\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for i, char in enumerate(s):\n        if char in vowels:\n            index = (vowels.index(char) + 1) % len(vowels)\n            result += vowels[index]\n        elif char in consonants:\n            index = (consonants.index(char) + 1) % len(consonants)\n            result += consonants[index]\n        elif char == '?':\n            if i % 2 == 0:\n                result += '!'\n            else:\n                result += '?'\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                result.append((i, j))\n    return result\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = ''\n    shift_counter = shift\n    for char in message:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + shift_counter) % 26 + ascii_offset)\n            shift_counter += 1\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', \n                       'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', \n                       'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', \n                       's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', \n                       'y': '-.--', 'z': '--..'}\n    morse_code = \"\"\n    for char in s:\n        if char == \" \":\n            morse_code += \" / \"\n        else:\n            morse_code += morse_code_dict[char] + \" \"\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        transformed_dish = ''\n        for i, letter in enumerate(dish):\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        new_menu[transformed_dish] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for char in earth_phrase:\n        if char in vowels:\n            if char == 'a':\n                result += 'e'\n            elif char == 'e':\n                result += 'i'\n            elif char == 'i':\n                result += 'o'\n            elif char == 'o':\n                result += 'u'\n            elif char == 'u':\n                result += 'a'\n        elif char in consonants:\n            if char == 'z':\n                result += 'b'\n            else:\n                result += chr(ord(char) + 1)\n        elif char == ' ':\n            result += '@'\n    words = result.split('@')\n    for i in range(len(words)):\n        if i == 0:\n            words[i] = words[i].capitalize()\n        else:\n            words[i] = words[i].capitalize()\n        if words[i][0] in vowels:\n            words[i] += 'xy'\n        else:\n            words[i] += 'yz'\n    return '@'.join(words)  # return the result as a string with '@' as the separator\n"}
{"task_id": "EvoEval/59", "completion": "\n    # First, we sort the dictionary items based on the number of recipes in descending order and then by the ingredient name in ascending order\n    sorted_items = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Then, we convert the sorted items into a list of tuples where the first element of each tuple is an ingredient and the second is a number of recipes\n    result = [(ingredient, num_recipes) for ingredient, num_recipes in sorted_items]\n    \n    # Finally, we return the result\n    return result\n"}
{"task_id": "EvoEval/60", "completion": "\n    # Initialize a list to keep track of sugar locations\n    sugar_locations = sugar_locations.copy()\n    \n    # Initialize a list to keep track of happy ants\n    happy_ants = [False] * len(ant_positions)\n    \n    # Iterate over each ant\n    for i, (position, direction) in enumerate(ant_positions):\n        # Initialize a flag to check if the ant is happy\n        is_happy = False\n        \n        # Iterate over each sugar location\n        for sugar_location in sugar_locations:\n            # Check if the ant passes the sugar location\n            if (position == sugar_location and direction == \"right\") or (position == sugar_location - 1 and direction == \"left\"):\n                # If the ant passes the sugar location, mark it as happy\n                is_happy = True\n                # Remove the sugar location from the list\n                sugar_locations.remove(sugar_location)\n                # Break the loop\n                break\n        \n        # Mark the ant as happy\n        happy_ants[i] = is_happy\n    \n    # Return the number of happy ants\n    return happy_ants.count(True)  # Count the number of True values in the list\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = []\n    for i, c in enumerate(s):\n        if c.isalpha():\n            if i % 2 == 1:\n                c = c.swapcase()\n            if c.lower() in vowels:\n                if c.lower() == 'a':\n                    result.append('e')\n                elif c.lower() == 'e':\n                    result.append('i')\n                elif c.lower() == 'i':\n                    result.append('o')\n                elif c.lower() == 'o':\n                    result.append('u')\n                else:\n                    result.append('a')\n            else:\n                if c.lower() == 'b':\n                    result.append('z')\n                elif c.lower() == 'c':\n                    result.append('b')\n                elif c.lower() == 'd':\n                    result.append('a')\n                elif c.lower() == 'f':\n                    result.append('e')\n                elif c.lower() == 'g':\n                    result.append('r')\n                elif c.lower() == 'h':\n                    result.append('t')\n                elif c.lower() == 'j':\n                    result.append('y')\n                elif c.lower() == 'k':\n                    result.append('x')\n                elif c.lower() == 'l':\n                    result.append('w')\n                elif c.lower() == 'm':\n                    result.append('v')\n                elif c.lower() == 'n':\n                    result.append('u')\n                elif c.lower() == 'p':\n                    result.append('s')\n                elif c.lower() == 'q':\n                    result.append('d')\n                elif c.lower() == 'r':\n                    result.append('f')\n                elif c.lower() == 's':\n                    result.append('p')\n                elif c.lower() == 't':\n                    result.append('h')\n                elif c.lower() == 'v':\n                    result.append('m')\n                elif c.lower() == 'w':\n                    result.append('l')\n                elif c.lower() == 'x':\n                    result.append('k')\n                elif c.lower() == 'y':\n                    result.append('j')\n                else:\n                    result.append('g')\n        else:\n            result.append(c)\n    return ''.join(result)  # Return the transformed string\n"}
{"task_id": "EvoEval/62", "completion": "\n    new_recipe = {}\n    for ingredient, quantity in recipe.items():\n        new_recipe[ingredient] = quantity * conversion_factor\n    return new_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = []\r\n    while p > 0:\r\n        pyramid.append(p)\r\n        if p % 2 == 0:\r\n            p = p - 2\r\n        else:\r\n            p = p - 3\r\n    return pyramid[::-1]  # Return the list in the correct order\r\n\r"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Create a copy of the original menu to avoid modifying it directly\n    final_order = menu.copy()\n    \n    # Iterate over each food item in the order dictionary\n    for food, customizations in order.items():\n        # Get the original ingredients for the current food item\n        original_ingredients = menu[food]\n        \n        # Check if there are any customizations for the current food item\n        if customizations:\n            # Check if there are any ingredients to be removed\n            if \"remove\" in customizations:\n                # Get the ingredients to be removed\n                ingredients_to_remove = customizations[\"remove\"]\n                \n                # Remove the ingredients to be removed from the original ingredients\n                final_order[food] = [ingredient for ingredient in original_ingredients if ingredient not in ingredients_to_remove]\n            \n            # Check if there are any ingredients to be added\n            if \"add\" in customizations:\n                # Get the ingredients to be added\n                ingredients_to_add = customizations[\"add\"]\n                \n                # Add the ingredients to be added to the original ingredients\n                final_order[food] = original_ingredients + ingredients_to_add\n    \n    # Return the final food order\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n\n    prime_nums = [num for num in range(2, n) if is_prime(num)]\n    prime_anagrams = []\n    for i in range(len(prime_nums)):\n        for j in range(i + 1, len(prime_nums)):\n            if is_anagram(prime_nums[i], prime_nums[j]):\n                prime_anagrams.append((prime_nums[i], prime_nums[j]))\n    return sorted(prime_anagrams)  # sort based on the first number in each tuple, then the second number\n"}
{"task_id": "EvoEval/67", "completion": "\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            result[customer] = sum(meal['calories'] for meal in meals[customer])\n        else:\n            result[customer] = 0\n    return result\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    if len(arr) == 2:\n        if arr[0] < arr[1]:\n            return True\n        else:\n            return False\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            if i == 0:\n                return False\n            if arr[i - 1] > arr[i + 1]:\n                return False\n            if arr[i] > arr[i + 2]:\n                return False\n            return True\n    return True\n"}
{"task_id": "EvoEval/69", "completion": "\n    # Create a dictionary to store the indices of the cards\n    card_indices = {card: i for i, card in enumerate(cards)}\n    \n    # Iterate over the cards\n    for i in range(len(cards)):\n        # For each card, iterate over the remaining cards\n        for j in range(i + 1, len(cards)):\n            # If the product of the two cards equals the magic number, return their indices\n            if cards[i] * cards[j] == magicNumber:\n                return (card_indices[cards[i]], card_indices[cards[j]])\n    \n    # If no pair of cards multiplies to the magic number, return \"No magic today\"\n    return \"No magic today\"  # This line will never be reached, but it's here to satisfy the linter\n"}
{"task_id": "EvoEval/70", "completion": "\n    # Check if the path list is empty or the planet does not exist in the dictionary\r\n    if not path or path[0] not in planets:\r\n        return False\r\n\r\n    # Iterate over the path list\r\n    for i in range(len(path) - 1):\r\n        # Check if the current planet exists in the dictionary and the next planet is in its list of connections\r\n        if path[i] not in planets or path[i + 1] not in planets[path[i]]:\r\n            return False\r\n\r\n    # If the function has not returned False, the path is valid\r\n    return True\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    vowels = 'aeiou'\n    encrypted = ''\n    vowel_count = 0\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            if char.lower() in vowels:\n                vowel_count += 1\n        else:\n            encrypted += char\n    return encrypted, vowel_count\n"}
{"task_id": "EvoEval/72", "completion": "\n    fairy_tales = []\n    for i, string in enumerate(lst):\n        count = sum(c.isdigit() for c in string)\n        fairy_tale = f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{string}' who was known for telling {count} tales a day\"\n        fairy_tales.append(fairy_tale)\n    return fairy_tales\n"}
{"task_id": "EvoEval/73", "completion": "\n    # Get the number of rows and columns in the grid\r\n    num_rows = len(grid)\r\n    num_cols = len(grid[0])\r\n\r\n    # Calculate the total number of treasures in the pyramid\r\n    total_treasures = sum(sum(row) for row in grid)\r\n\r\n    # Calculate the number of trips needed to collect all treasures\r\n    # This is done by dividing the total number of treasures by the bag capacity and rounding up to the nearest integer\r\n    # This is because we need to make a separate trip for each chest we collect, and we can't collect a fraction of a chest\r\n    num_trips = math.ceil(total_treasures / bag_capacity)\r\n\r\n    # Since we need to enter and exit the pyramid for each trip, we multiply the number of trips by 2\r\n    num_trips *= 2\r\n\r\n    return num_trips\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the string 's'\n    for char in s:\n        # Check if the character exists in the cipher dictionary\n        if char in cipher:\n            # If it exists, append its corresponding value to the result string\n            result += cipher[char]\n        else:\n            # If it does not exist, append the character as it is to the result string\n            result += char\n    \n    # Return the result string\n    return result\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    digits = '0123456789'\n    punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\n\n    result = []\n    for i, char in enumerate(input_str):\n        if char in vowels:\n            idx = vowels.index(char)\n            result.append(vowels[(idx + 1) % len(vowels)])\n        elif char in consonants:\n            idx = consonants.index(char)\n            result.append(consonants[(idx + 1) % len(consonants)])\n        elif char in digits:\n            result.append(str((int(char) + 1) % 10))\n        elif char in punctuation:\n            if i % 2 == 0 and char == '?':\n                result.append('!')\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n\n    return ''.join(result)  # Join the list of characters into a string\n"}
{"task_id": "EvoEval/76", "completion": "\n    pyramid = []\n    total = 0\n    for num in lst:\n        total += num\n        pyramid.append('#' * num)\n    return pyramid[::-1]  # Reverse the list to get the pyramid in the correct order\n"}
{"task_id": "EvoEval/77", "completion": "\n    return sorted([sum(1 for i in range(1, n + 1) if n % (k ** i) == 0) for n in sequence], reverse=True)  # This line has been modified to include the sum of the points for each number in the sequence\n\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                result.append(mat[i][j])\n    return result\n"}
{"task_id": "EvoEval/79", "completion": "\n    # Initialize the minimum price and the maximum profit\n    min_price = float('inf')\n    max_profit = 0\n\n    # Iterate over the prices\n    for i in range(len(prices)):\n        # If the current price is less than the minimum price, update the minimum price\n        if prices[i] < min_price:\n            min_price = prices[i]\n        # If the current profit is greater than the maximum profit, update the maximum profit\n        elif prices[i] - min_price > max_profit:\n            max_profit = prices[i] - min_price\n\n    # Return the maximum profit\n    return max_profit\n\n"}
{"task_id": "EvoEval/80", "completion": "\n    # Initialize the player's position and path\n    player_row, player_col = 0, 0\n    path = [(player_row, player_col)]\n    # Iterate over each instruction\n    for instruction in instructions:\n        # Get the current player position\n        current_row, current_col = player_row, player_col\n        # Move the player according to the instruction\n        if instruction == 'up' and current_row > 0 and map[current_row - 1][current_col] != 'X':\n            player_row -= 1\n        elif instruction == 'down' and current_row < len(map) - 1 and map[current_row + 1][current_col] != 'X':\n            player_row += 1\n        elif instruction == 'left' and current_col > 0 and map[current_row][current_col - 1] != 'X':\n            player_col -= 1\n        elif instruction == 'right' and current_col < len(map[0]) - 1 and map[current_row][current_col + 1] != 'X':\n            player_col += 1\n        # Add the new player position to the path\n        path.append((player_row, player_col))\n        # Check if the player has reached the end\n        if map[player_row][player_col] == 'E':\n            break\n    return path\n"}
{"task_id": "EvoEval/81", "completion": "\n    # Create a dictionary to store the order of the alien alphabet\n    alien_order = {}\n    for i, char in enumerate(alien_dictionary):\n        alien_order[char] = i\n\n    # Iterate over the list of words\n    for i in range(len(word_list) - 1):\n        # If the current word is longer than the next word, the list is not sorted\n        if len(word_list[i]) > len(word_list[i + 1]):\n            return \"INCORRECT\"\n        # If the current word is not a prefix of the next word, the list is not sorted\n        for j in range(min(len(word_list[i]), len(word_list[i + 1]))):\n            if alien_order[word_list[i][j]] > alien_order[word_list[i + 1][j]]:\n                return \"INCORRECT\"\n            elif alien_order[word_list[i][j]] < alien_order[word_list[i + 1][j]]:\n                break\n        # If the current word is a prefix of the next word, the list is not sorted\n        else:\n            if len(word_list[i]) < len(word_list[i + 1]):\n                return \"INCORRECT\"\n\n    # If the function has not returned \"INCORRECT\" by now, the list is sorted\n    return \"CORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  # Return \"CORRECT\" if the list is sorted, otherwise return \"INCORRECT\"  #"}
{"task_id": "EvoEval/82", "completion": "\n    zodiac_signs = {\n        \"Aries\": \"Fire\",\n        \"Taurus\": \"Earth\",\n        \"Gemini\": \"Air\",\n        \"Cancer\": \"Water\",\n        \"Leo\": \"Fire\",\n        \"Virgo\": \"Earth\",\n        \"Libra\": \"Air\",\n        \"Scorpio\": \"Water\",\n        \"Sagittarius\": \"Fire\",\n        \"Capricorn\": \"Earth\",\n        \"Aquarius\": \"Air\",\n        \"Pisces\": \"Water\"\n    }\n    elements = {\"Fire\": 0, \"Water\": 0, \"Earth\": 0, \"Air\": 0}\n    for birthday in birthdays:\n        month, day = birthday.split(\"-\")\n        month = int(month)\n        day = int(day)\n        for sign, dates in zodiac_signs.items():\n            start, end = dates.split(\" \u2013 \")\n            start_month, start_day = map(int, start.split(\"-\"))\n            end_month, end_day = map(int, end.split(\"-\"))\n            if (start_month <= month <= end_month) or (start_day <= day <= end_day):\n                elements[dates] += 1\n    return {key: value for key, value in elements.items() if value > 0} if birthdays else None\n"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n    return ''.join(s)  # return the modified string\n"}
{"task_id": "EvoEval/84", "completion": "\n    def dfs(node, path):\n        if not node:\n            return []\n        if not node.values():\n            return [path]\n        paths = []\n        for child in node.values():\n            paths.extend(dfs(child, path + [list(node.keys())[0]] + list(child.keys())))\n        return paths\n\n    return dfs(tree, [])  # Start the DFS traversal from the root node\n\n"}
{"task_id": "EvoEval/85", "completion": "\n    # Get the number of rows and columns in the grid\n    rows, cols = len(grid), len(grid[0])\n    \n    # Create a 2D list to store the minimum number of moves to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Initialize the minimum number of moves to reach the top-left cell as 0\n    dp[0][0] = 0\n    \n    # Fill the first row of the dp table\n    for j in range(1, cols):\n        # If the current cell is not a monster and the previous cell is reachable\n        if grid[0][j] == 0 and dp[0][j-1] != float('inf'):\n            # Update the minimum number of moves to reach the current cell\n            dp[0][j] = dp[0][j-1] + 1\n    \n    # Fill the first column of the dp table\n    for i in range(1, rows):\n        # If the current cell is not a monster and the previous cell is reachable\n        if grid[i][0] == 0 and dp[i-1][0] != float('inf'):\n            # Update the minimum number of moves to reach the current cell\n            dp[i][0] = dp[i-1][0] + 1\n    \n    # Fill the rest of the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            # If the current cell is not a monster\n            if grid[i][j] == 0:\n                # Update the minimum number of moves to reach the current cell\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n    \n    # If the princess's cell is reachable, return the minimum number of moves to reach it\n    if dp[coord[0]-1][coord[1]-1] != float('inf'):\n        return dp[coord[0]-1][coord[1]-1]\n    # Otherwise, return -1\n    else:\n        return -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    # First, we sort the movies based on their ratings in descending order and release year in ascending order\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n    \n    # Then, we extract the movie names from the sorted list of tuples\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n    \n    # Finally, we return the sorted list of movie names\n    return sorted_movie_names\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr:\n        return ''\n    result = ''\n    top, bottom, left, right = 0, len(arr) - 1, 0, len(arr[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result += arr[top][i]\n        top += 1\n        for i in range(top, bottom + 1):\n            result += arr[i][right]\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result += arr[bottom][i]\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result += arr[i][left]\n            left += 1\n    return result\n"}
{"task_id": "EvoEval/88", "completion": "\n    result = {}\n    for planet, features in dict_of_planets.items():\n        if features[0] is not None and features[1] is not None:\n            population = features[0]\n            size = features[1]\n            density = round(population / size, 2)\n            result[planet] = f\"{population}, {density}\"\n    return result\n"}
{"task_id": "EvoEval/89", "completion": "\n    aliens = sorted(set(aliens))  # remove duplicates and sort the list\n    aliens = [alien for alien in aliens if alien % 2 != 0 or alien == ray]  # filter out even aliens unless they are directly aimed at\n    aliens = [alien + 1 for alien in aliens if alien != ray]  # increment the position of all aliens except the one directly aimed at\n    return sorted(aliens)  # return the list of remaining aliens' positions in sorted order\n"}
{"task_id": "EvoEval/90", "completion": "\n    def get_combinations(s):\n        if len(s) == 1:\n            return [[int(s)]]\n        combinations = []\n        for i in range(len(s)):\n            first_digit = s[i]\n            rest = s[:i] + s[i+1:]\n            for combination in get_combinations(rest):\n                combinations.append([int(first_digit)] + combination)\n                for j in range(len(combination)):\n                    combination[j] = int(first_digit) + combination[j]\n        return combinations\n\n    def get_unique_combinations(combinations):\n        unique_combinations = set()\n        for combination in combinations:\n            unique_combinations.add(tuple(sorted(combination)))\n        return unique_combinations\n\n    def sum_combinations(combinations):\n        return sum(sum(combination) for combination in combinations)\n\n    s1_combinations = get_combinations(s1)\n    s2_combinations = get_combinations(s2)\n    unique_combinations = get_unique_combinations(s1_combinations + s2_combinations)\n    return sum_combinations(unique_combinations)  # This line was changed\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceshi_data:\n        if status == 'On Ground':\n            if action == 'Launch':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif status == 'In Space':\n            if action == 'Move':\n                pass\n            elif action == 'Land':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    result = ''\n    for i in range(1, n + 1):\n        # Calculate the width of the current layer\n        width = 2 * i - 1\n        # Calculate the number of letters in the current layer\n        num_letters = 2 * i - 1\n        # Calculate the number of the letter to be used in the current layer\n        letter_num = (i - 1) % 26 + 1\n        # Generate the current layer\n        layer = ''\n        for j in range(1, num_letters + 1):\n            # If the current position is in the central column, use 'A'\n            if j == num_letters // 2 + 1:\n                layer += 'A'\n            # If the current position is in the left half of the layer, use the letter corresponding to the current layer\n            elif j <= num_letters // 2:\n                layer += chr(64 + letter_num)\n            # If the current position is in the right half of the layer, use the letter corresponding to the current layer\n            else:\n                layer += chr(64 + letter_num)\n        # Center the current layer\n        layer = layer.center(width)\n        # Add the current layer to the result\n        result += layer + '\\n'\n    return result[:-1]  # Remove the last newline character\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    for i in range(len(message)):\n        if message[i].isalpha():\n            n = n_values[i % len(n_values)]\n            if message[i].isupper():\n                result += chr((ord(message[i]) - 65 + n) % 26 + 65)\n            else:\n                result += chr((ord(message[i]) - 97 + n) % 26 + 97)\n        else:\n            result += message[i]\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(word.split(), key=len)) for word in strings]  # This is a list comprehension that iterates over each string in the input list, splits it into words, sorts the words based on their length, and then joins them back together with spaces in between. The sorted function is stable, so if two words have the same length, their original order is preserved. The key argument of the sorted function is a function that takes a list element and returns a value that will be used for sorting purposes. In this case, the key is the len function, which returns the length of a string. The result is a list of strings where each string has its words sorted by length.  # This is a list comprehension that iterates over each string in the input list, splits it into words, sorts the words based on their length, and then joins them back together with spaces in between. The sorted function is stable, so if two words have the same length, their original order is preserved. The key argument of the sorted function is a function that takes a list element and returns a value that will be used for sorting purposes. In this case, the key is the len function, which returns the length of a string. The result is a list of strings where each string has its words sorted by length.  # This is a list comprehension that iterates over each string in the input list, splits it into words, sorts the words based on their length, and then joins them back together with spaces in between. The sorted function is stable, so if two words have the same length, their original order is preserved. The key argument of the sorted function is a function that takes a list element and returns a value that will be used for sorting purposes. In this case, the key is the len function, which returns the length of a string. The result is a list of strings where each string has its words sorted by length.  # This is a list comprehension that iterates over each string in the input list, splits it into words, sorts the words based on their length, and then joins them back together with spaces in between. The sorted function is stable, so if two words have the same length, their original order is preserved. The key argument of the sorted function is a function that takes a list element and returns a value that will be used for sorting purposes. In this case, the key is the len function, which returns the length of a string. The result is a list of strings where"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    diagonal1 = 0\n    diagonal2 = 0\n    for i in range(len(m)):\n        diagonal1 += m[i][i]\n        diagonal2 += m[i][len(m)-i-1]\n    return abs(diagonal1 - diagonal2)  # return the absolute difference between the two diagonals\n"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] == 0:\n            magic_indices.append(i)\n        elif lst[i] % (i + 1) == 0:\n            product = 1\n            for digit in str(abs(lst[i])):\n                product *= int(digit)\n            if product == i + 1:\n                magic_indices.append(i)\n    return sorted(magic_indices)  # Return a list of magic indices sorted in ascending order\n\n"}
{"task_id": "EvoEval/97", "completion": "\n    # Check if the alien name is valid\n    if not isinstance(alien, str) or len(alien) == 0:\n        return []\n    \n    # Check if the humans dictionary is valid\n    if not isinstance(humans, dict):\n        return []\n    \n    # Define the order of continents\n    continents = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n    \n    # Initialize an empty list to store the humans that will encounter the alien\n    humans_encountered = []\n    \n    # Iterate over the continents in the order of invasion\n    for continent in continents:\n        # Check if the alien starts its invasion from this continent\n        if continent == \"Asia\":\n            # Check if there are humans living in this continent\n            if continent in humans.values():\n                # Add the humans living in this continent to the list\n                humans_encountered.extend([human for human, location in humans.items() if location == continent])\n        else:\n            # Check if there are humans living in this continent\n            if continent in humans.values():\n                # Add the humans living in this continent to the list\n                humans_encountered.extend([human for human, location in humans.items() if location == continent])\n    \n    # Return the list of humans that will encounter the alien, sorted by the order of their encounter\n    return sorted(humans_encountered)  # Removed the unnecessary list comprehension and sorted the list directly\n"}
{"task_id": "EvoEval/98", "completion": "\n    sequence = [a, b]\n    for i in range(2, n):\n        next_number = sequence[-1] + sequence[-2] + i\n        sequence.append(next_number)\n    def is_prime(num):\n        if num < 2:\n            return False\n        for j in range(2, int(num ** 0.5) + 1):\n            if num % j == 0:\n                return False\n        return True\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    position = 0\n    for round in rounds:\n        position = (position + round * music) % n\n        players.pop(position - 1)\n    return players\n"}
