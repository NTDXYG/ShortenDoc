{"task_id": "EvoEval/0", "completion": "\n    # Initialize the base shipping cost\n    base_cost = 5.0\n    \n    # Initialize the total weight\n    total_weight = 0.0\n    \n    # Initialize the additional charge flag\n    additional_charge = False\n    \n    # Iterate over the items\n    for item in items:\n        # If the item is a string, it's a weight, so add it to the total weight\n        if isinstance(item, str):\n            total_weight += float(item)\n        # If the item is a float, it's a weight, so add it to the total weight\n        elif isinstance(item, float):\n            total_weight += item\n        # If the item is neither a string nor a float, raise an error\n        else:\n            raise ValueError(\"Invalid item type\")\n    \n    # Calculate the base shipping cost multiplied by the location factor\n    base_cost *= {\"Local\": 1.0, \"National\": 1.5, \"International\": 2.5}[location]\n    \n    # If the total weight is more than 5kg, add the additional charge\n    if total_weight > 5.0:\n        base_cost += 10.0\n        additional_charge = True\n    \n    # Return the total shipping cost as a string to two decimal places\n    return \"${:.2f}\".format(base_cost) if not additional_charge else \"${:.2f}\".format(base_cost + 10.0)  # noqa: E501\n"}
{"task_id": "EvoEval/1", "completion": "\n    # Initialize total cost to 0\n    total_cost = 0.0\n    \n    # Define shipping factors for different locations\n    shipping_factors = {\n        \"Local\": 1.0,\n        \"National\": 1.5,\n        \"International\": 2.5\n    }\n    \n    # Iterate over each item in the list\n    for item in items:\n        # If the item is a string, consider it as 1kg\n        if isinstance(item, str):\n            weight = 1.0\n        # If the item is a float, consider it as the weight\n        elif isinstance(item, float):\n            weight = item\n        # If the item is neither a string nor a float, raise an error\n        else:\n            raise ValueError(\"Invalid item type\")\n        \n        # Add the base shipping cost to the total cost\n        total_cost += 5.0\n        \n        # If the weight is more than 5kg, add an additional charge\n        if weight > 5.0:\n            total_cost += 10.0\n        \n        # Multiply the total cost by the location factor\n        total_cost *= shipping_factors.get(location, 1.0)\n    \n    # Return the total shipping cost rounded to two decimal places\n    return round(total_cost, 2)  # Changed here\n"}
{"task_id": "EvoEval/2", "completion": "\n    encrypted_words = []\n    for word in words:\n        encrypted_word = \"\"\n        for char in word:\n            if char.isalpha():\n                ascii_offset = 97 if char.islower() else 65\n                encrypted_char = chr((ord(char) - ascii_offset + int(key)) % 26 + ascii_offset)\n                encrypted_word += encrypted_char\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    return encrypted_words\n"}
{"task_id": "EvoEval/3", "completion": "\n    result = []\n    for i in range(1, len(input_string) + 1):\n        for j in range(i + 1, len(input_string) + 1):\n            substring = input_string[:i] + input_string[j:]\n            result.append(substring)\n    return result\n"}
{"task_id": "EvoEval/4", "completion": "\n    if not candles:\n        return 0\n    max_height = candles[0]\n    count = 1\n    for i in range(1, len(candles)):\n        if candles[i] > max_height:\n            max_height = candles[i]\n            count += 1\n    return count\n\n"}
{"task_id": "EvoEval/5", "completion": "\n    if not matrix:\n        return []\n\n    result = []\n    left, right = 0, len(matrix[0]) - 1\n    up, down = True, False\n\n    while left <= right:\n        if up:\n            for row in matrix:\n                result.append(row[left])\n                left += 1\n        else:\n            for row in reversed(matrix):\n                result.append(row[left])\n                left += 1\n\n        up = not up\n        left, right = right, left - 1\n\n    return result\n\n"}
{"task_id": "EvoEval/6", "completion": "\n    x, y = position\n    if grid[x][y] == -1:\n        return grid\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):\n        return grid\n    if grid[x][y] == 1:\n        return grid\n    grid[x][y] = -1\n    if grid[x][y] == 0:\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if 0 <= x + i < len(grid) and 0 <= y + j < len(grid[0]):\n                    grid[x + i][y + j] = minesweeper_clicked(grid, (x + i, y + j))[x + i][y + j]\n    return grid\n"}
{"task_id": "EvoEval/7", "completion": "\n    # Initialize current position at (0, 0)\n    current_position = [0, 0]\r\n    # Define the possible directions and their corresponding movements\r\n    directions = {\r\n        0: [0, 1],  # North\r\n        1: [1, 0],  # East\r\n        2: [0, -1],  # South\r\n        3: [-1, 0]  # West\r\n    }\r\n    # Iterate over the sequence of numbers\r\n    for direction in code_sequence:\r\n        # Check if the direction is valid\r\n        if direction in directions:\r\n            # Update the current position based on the direction\r\n            current_position[0] += directions[direction][0]\r\n            current_position[1] += directions[direction][1]\r\n        else:\r\n            # If the direction is not valid, return 'Shangri-La not found'\r\n            return 'Shangri-La not found'\r\n    # Check if the final position is (0, 0)\r\n    if current_position == [0, 0]:\r\n        # If the final position is (0, 0), return 'Shangri-La found'\r\n        return 'Shangri-La found'\r\n    else:\r\n        # If the final position is not (0, 0), return 'Shangri-La not found'\r\n        return 'Shangri-La not found'\r\n"}
{"task_id": "EvoEval/8", "completion": "\n    if canvas == 'Invalid canvas':\n        return 'Invalid canvas'\n    if canvas.count('P') > 1:\n        return 'Invalid canvas'\n    painter = canvas.find('P')\n    canvas = list(canvas)\n    canvas[painter] = '*'\n    for i in range(len(canvas)):\n        if canvas[i] == '-':\n            if painter > i:\n                canvas[i] = '*'\n            else:\n                break\n    return ''.join(canvas)  # return the updated canvas as a string\n\n"}
{"task_id": "EvoEval/9", "completion": "\n    # Remove punctuation and convert to lower case\n    string = ''.join(e for e in string if e.isalnum() or e.isspace()).lower()\n    # Split the string into words\n    words = string.split()\n    # Create a dictionary to store the frequency of each word\n    frequency = {}\n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word is already in the dictionary, increment its count\n        if word in frequency:\n            frequency[word] += 1\n        # If the word is not in the dictionary, add it with a count of 1\n        else:\n            frequency[word] = 1\n    # Return the dictionary of word frequencies\n    return frequency\n"}
{"task_id": "EvoEval/10", "completion": "\n    animal_sounds = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\r\n    animal_counts = {}\r\n    animal_string = animal_string.replace(' ', '')\r\n    for animal in animal_string:\r\n        if animal in animal_sounds:\r\n            if animal in animal_counts:\r\n                animal_counts[animal] += 1\r\n            else:\r\n                animal_counts[animal] = 1\r\n        else:\r\n            if animal in animal_counts:\r\n                animal_counts[animal] += 1\r\n            else:\r\n                animal_counts[animal] = 1\r\n        if len(animal_counts) == 5:\r\n            break\r\n    return [animal_counts.get(animal, 0) for animal in animal_sounds]\r\n\r\n\r"}
{"task_id": "EvoEval/11", "completion": "\n    if len(fruits) == 1:\n        return f\"{fruits[0]} from {location}? Marvelous!\"\n    elif len(fruits) == 2:\n        return f\"{fruits[0]} {fruits[1]} from {location}? Marvelous!\"\n    else:\n        return f\"{fruits[0]} {fruits[-1]} from {location}? Marvelous!\"\n\n"}
{"task_id": "EvoEval/12", "completion": "\n    # Find the element with the maximum occurrence\n    max_occurrence = max(flux_values.count(x) for x in flux_values)\n    most_occurred = [x for x in flux_values if flux_values.count(x) == max_occurrence]\n    most_occurred.sort()\n    most_occurred = most_occurred[0]\n\n    # Find the sum of all elements in the array\n    sum_elements = sum(flux_values)\n\n    # Multiply the sum of elements with the most occurred number\n    result = sum_elements * most_occurred\n\n    return result\n"}
{"task_id": "EvoEval/13", "completion": "\n    if not elems:\n        return None\n    return min(elems, key=elems.count)  # return the element with the lowest count\n"}
{"task_id": "EvoEval/14", "completion": "\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                alias += 'eioau'[alias.lower().find(char.lower()) % 5]\n            else:\n                alias += 'bzcdfghjklmnpqrstvwxyz'[('bzcdfghjklmnpqrstvwxyz'.find(char.lower()) + 1) % 26]\n        else:\n            alias += char\n    return alias\n"}
{"task_id": "EvoEval/15", "completion": "\n    # create dictionary to map card values\n    card_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 1}\n    # create dictionary to map card suits\n    card_suits = {'S': 0, 'H': 1, 'D': 2, 'C': 3}\n    # create list to store card values\n    hand_values = []\n    # create list to store card suits\n    hand_suits = []\n    # iterate over each card in hand\n    for card in hand:\n        # extract value and suit from card\n        value = card[:-1]\n        suit = card[-1]\n        # add value and suit to lists\n        hand_values.append(card_values[value])\n        hand_suits.append(card_suits[suit])\n    # sort hand by value\n    hand_values.sort()\n    # create dictionary to store counts of each value\n    value_counts = {}\n    # iterate over each value in hand\n    for value in hand_values:\n        # increment count for value\n        if value in value_counts:\n            value_counts[value] += 1\n        else:\n            value_counts[value] = 1\n    # create list to store pairs\n    pairs = []\n    # iterate over each value in hand\n    for value in hand_values:\n        # if value appears more than once, add to pairs list\n        if value_counts[value] > 1:\n            pairs.append(value)\n    # create list to store triples\n    triples = []\n    # iterate over each value in hand\n    for value in hand_values:\n        # if value appears three times, add to triples list\n        if value_counts[value] == 3:\n            triples.append(value)\n    # create list to store fours\n    fours = []\n    # iterate over each value in hand\n    for value in hand_values:\n        # if value appears four times, add to fours list\n        if value_counts[value] == 4:\n            fours.append(value)\n    # create list to store fives\n    fives = []\n    # iterate over each value in hand\n    for value in hand_values:\n        # if value appears five times, add to"}
{"task_id": "EvoEval/16", "completion": "\n    a, b = 0, 1\n    total = 0\n    for _ in range(n):\n        total += a\n        a, b = b, a + b\n    return total\n"}
{"task_id": "EvoEval/17", "completion": "\n    # Initialize dragon's HP\n    dragon_hp = dragon_hp\n    # Initialize the list of wizards\n    wizards = wizards\n    # Loop through the list of wizards\n    for wizard in wizards:\n        # Extract the wizard's name and magic power\n        name, magic_power = wizard\n        # Reduce dragon's HP by the wizard's magic power\n        dragon_hp -= magic_power\n        # If dragon's HP is 0 or less, return the wizard's name\n        if dragon_hp <= 0:\n            return f'{name} defeated the dragon!'\n    # If the loop completes without defeating the dragon, return 'dragon won!'\n    return 'dragon won!'  # Return the result of the battle"}
{"task_id": "EvoEval/18", "completion": "\n    return n * 7\n"}
{"task_id": "EvoEval/19", "completion": "\n    # Initialize variables\n    humans = 0\n    danger = 0\n    bitten = 0\n\n    # Iterate over each row in the matrix\n    for row in m:\n        # Iterate over each cell in the row\n        for cell in row:\n            # If the cell is a human\n            if cell == 1:\n                # Increment the human count\n                humans += 1\n                # Check if the human is in danger\n                if any(cell == 2 for cell in row):\n                    # Increment the danger count\n                    danger += 1\n                # Check if the human is bitten\n                if any(cell == 2 for col in zip(*m) for cell in col if cell == 1):\n                    # Increment the bitten count\n                    bitten += 1\n\n    # Return the counts\n    return humans, danger, bitten\n\n"}
{"task_id": "EvoEval/20", "completion": "\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join([str(j) for j in range(i, 0, -1)] + [str(j) for j in range(1, i + 1)]))\n    return pattern\n"}
{"task_id": "EvoEval/21", "completion": "\n    def find_word(word, row, col, direction):\n        if direction == 'left':\n            for i in range(col, -1, -1):\n                if grid[row][i] == word[0]:\n                    if grid[row][i:i+len(word)] == list(word):\n                        return True\n        elif direction == 'right':\n            for i in range(col, len(grid[row])):\n                if grid[row][i] == word[0]:\n                    if grid[row][i:i+len(word)] == list(word):\n                        return True\n        elif direction == 'top':\n            for i in range(row, -1, -1):\n                if grid[i][col] == word[0]:\n                    if grid[i][col:col+len(word)] == list(word):\n                        return True\n        elif direction == 'bottom':\n            for i in range(row, len(grid)):\n                if grid[i][col] == word[0]:\n                    if grid[i][col:col+len(word)] == list(word):\n                        return True\n        return False\n\n    for word in words:\n        found = False\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                if grid[row][col] == word[0]:\n                    if find_word(word, row, col, 'left') or find_word(word, row, col, 'right') or find_word(word, row, col, 'top') or find_word(word, row, col, 'bottom'):\n                        found = True\n                        break\n            if found:\n                break\n        if not found:\n            return False\n    return True\n"}
{"task_id": "EvoEval/22", "completion": "\n    # Calculate the distance traveled in kilometers\n    distance_km = t * v\n    \n    # Convert the distance from kilometers to light years\n    distance_ly = distance_km / (9.461 * (10**12))\n    \n    return distance_ly\n"}
{"task_id": "EvoEval/23", "completion": "\n    prime_dict = {chr(i): i - 96 for i in range(2, 27)}\n    return ''.join(str(prime_dict.get(c, c)) for c in s)\n\n"}
{"task_id": "EvoEval/24", "completion": "\n    alien_language = {\n        'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#',\n        'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':',\n        'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[',\n        'y': ']', 'z': '|'\n    }\n    return ''.join(alien_language.get(char, char) for char in english_word.lower())\n"}
{"task_id": "EvoEval/25", "completion": "\n    # Split the text into sentences\n    sentences = text.split('. ')\n\n    # Initialize a dictionary to store the frequency of each word\n    frequency = {}\n\n    # Iterate over each sentence\n    for sentence in sentences:\n        # Split the sentence into words\n        words = sentence.split()\n\n        # Iterate over each word in the sentence\n        for word_in_sentence in words:\n            # Remove punctuation from the word\n            word_in_sentence = word_in_sentence.strip('.,!?\"\\'')\n\n            # If the word is the same as the given word, increment its frequency\n            if word_in_sentence == word:\n                frequency[word_in_sentence] = frequency.get(word_in_sentence, 0) + 1\n\n    # Find the maximum frequency\n    max_frequency = max(frequency.values(), default=0)\n\n    # Find the sentence with the maximum frequency\n    max_frequency_sentence = next((sentence for sentence in sentences if word in sentence), \"\")\n\n    # Return the frequency and the sentence with the maximum frequency\n    return (max_frequency, max_frequency_sentence) if max_frequency > 0 else (0, \"\")\r\n\r\n\r"}
{"task_id": "EvoEval/26", "completion": "\n    # Check if start and end are the same\n    if start == end:\n        return []\n    \n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n    \n    # Create a queue for BFS, contains cells in the form (row, col, path)\n    queue = [(start[0], start[1], [])]\n    \n    # Create a set to store visited cells\n    visited = set((start[0], start[1]))\n    \n    while queue:\n        row, col, path = queue.pop(0)\n        \n        # If this is the destination cell, return the path\n        if (row, col) == end:\n            return path\n        \n        # Check all possible movements\n        for dr, dc, direction in movements:\n            r, c = row + dr, col + dc\n            \n            # If the new cell is inside the maze, is not a wall and has not been visited\n            if (0 <= r < len(maze)) and (0 <= c < len(maze[0])) and (maze[r][c] == 0) and ((r, c) not in visited):\n                queue.append((r, c, path + [direction]))\n                visited.add((r, c))\n    \n    # If there is no path to the destination\n    return []\n"}
{"task_id": "EvoEval/27", "completion": "\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\n"}
{"task_id": "EvoEval/28", "completion": "\n    # Define tax brackets and rates\n    tax_brackets = [\n        (0, 10000, 0),\n        (10000, 25000, 0.15),\n        (25000, 45000, 0.25),\n        (45000, 130000, 0.30),\n        (130000, float('inf'), 0.30)\n    ]\n\n    # Calculate taxable income\n    taxable_income = income - deductions\n\n    # Initialize tax\n    tax = 0\n\n    # Iterate over tax brackets\n    for lower, upper, rate in tax_brackets:\n        # Check if income falls within bracket\n        if taxable_income > upper:\n            # Calculate tax for this bracket\n            tax += (upper - lower) * rate\n        elif taxable_income > lower:\n            # Calculate tax for this bracket\n            tax += (taxable_income - lower) * rate\n            break\n\n    return tax\n\n"}
{"task_id": "EvoEval/29", "completion": "\n    # Initialize an empty list to store the palindrome substrings\n    palindromes = []\n    \n    # Iterate over the string with two nested loops to generate all possible substrings\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            # Extract the substring\n            substring = s[i:j]\n            \n            # Check if the substring is a palindrome\n            if substring == substring[::-1]:\n                # If it is, add it to the list of palindromes\n                palindromes.append(substring)\n    \n    # Sort the list of palindromes in ascending order\n    palindromes.sort()\n    \n    # Return the list of palindromes\n    return palindromes\n"}
{"task_id": "EvoEval/30", "completion": "\n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Create a queue for BFS, enqueue the start point\n    queue = [(start, [start])]\n    \n    # Create a set to store visited points\n    visited = set([start])\n    \n    while queue:\n        # Dequeue the first point in the queue\n        (x, y), path = queue.pop(0)\n        \n        # If this is the destination point, return the path\n        if (x, y) == end:\n            return path\n        \n        # For each possible movement\n        for dx, dy in movements:\n            nx, ny = x + dx, y + dy\n            \n            # If the new point is within the maze boundaries and is not a wall and has not been visited\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                # Mark the new point as visited\n                visited.add((nx, ny))\n                \n                # Enqueue the new point with the updated path\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    \n    # If there is no path to the destination, return an empty list\n    return []\n\n\n"}
{"task_id": "EvoEval/31", "completion": "\n    # Create a 2D array to store the number of unique paths to each cell\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # There is only one way to reach any cell in the first row or column\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 1\n\n    # Fill in the rest of the 2D array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # The number of unique paths to a cell is the sum of the number of unique paths to the cell above it and the cell to its left\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    # The number of unique paths to the bottom-right corner is stored in the bottom-right cell of the 2D array\n    return dp[m][n]\n"}
{"task_id": "EvoEval/32", "completion": "\n    playlist_length = len(playlist)\n    seed = seed % (2 ** 31 - 1)\n    new_playlist = playlist.copy()\n    for i in range(playlist_length):\n        seed = (seed * 16807) % 2147483647\n        index = seed % playlist_length\n        if \"Rock\" in new_playlist[index]:\n            continue\n        new_playlist[i], new_playlist[index] = new_playlist[index], new_playlist[i]\n    return new_playlist\n"}
{"task_id": "EvoEval/33", "completion": "\n    # Create a list to store the number of ways to reach each step\n    ways = [0] * (n + 1)\r\n    ways[0] = 1  # There is one way to reach the first step (by not moving)\r\n    for i in range(1, n + 1):\r\n        for power in magic_stones:\r\n            if i >= power:\r\n                ways[i] += ways[i - power]\r\n    return ways[n]  # Return the number of ways to reach the top step\r\n\r"}
{"task_id": "EvoEval/34", "completion": "\n    # Initialize the list to store transformation percentages\n    transformation_percentages = []\n    \n    # Calculate transformation percentage for the m-th day\n    m_day_transformation = 10\n    \n    # Calculate transformation percentage for the first day\n    first_day_transformation = 0\n    \n    # Calculate transformation percentage for the last day\n    last_day_transformation = 0\n    \n    # Calculate transformation percentage for days other than m-th day\n    for i in range(1, n):\n        if i == m:\n            transformation_percentages.append(m_day_transformation)\n            m_day_transformation *= 2\n            if m_day_transformation > 100:\n                m_day_transformation = 100\n        elif i < m:\n            transformation_percentages.append(first_day_transformation + (i * 10))\n            if transformation_percentages[-1] > 100:\n                transformation_percentages[-1] = 100\n        else:\n            transformation_percentages.append(last_day_transformation - (i - m) * 10)\n            if transformation_percentages[-1] < 0:\n                transformation_percentages[-1] = 0\n    \n    return transformation_percentages\n"}
{"task_id": "EvoEval/35", "completion": "\n    if \"@\" not in email:\r\n        return False\r\n    if email[0] == \"@\" or email[-1] == \"@\":\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 2:\r\n        return False\r\n    if email.index(\"@\") == 0:\r\n        return False\r\n    if email.index(\"@\") == len(email) - 1:\r\n        return False"}
{"task_id": "EvoEval/36", "completion": "\n    integral_coefficients = []\n    for i in range(len(xs)):\n        integral_coefficients.append((xs[i] / (i + 1)))\n    return integral_coefficients\n\n"}
{"task_id": "EvoEval/37", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    punctuation = '.,! '\n    result = ''\n    for char in s:\n        if char in vowels:\n            if char.lower() == 'a':\n                result += 'e' if char.islower() else 'E'\n            elif char.lower() == 'i':\n                result += 'o' if char.islower() else 'O'\n            elif char.lower() == 'u':\n                result += 'a' if char.islower() else 'A'\n            else:\n                result += char\n        elif char in consonants:\n            if char.lower() == 'b':\n                result += 'c' if char.islower() else 'C'\n            elif char.lower() == 'm':\n                result += 'n' if char.islower() else 'N'\n            elif char.lower() == 'z':\n                result += 'b' if char.islower() else 'B'\n            else:\n                result += char\n        elif char in punctuation:\n            result += char\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/38", "completion": "\n    emoticons = {\n        \":)\": \"\ud83d\ude0a\",\n        \":(\": \"\u2639\ufe0f\",\n        \":D\": \";)\",\n        \";)\": \"\ud83d\ude09\",\n        \":P\": \"\ud83d\ude1c\",\n        \":O\": \"\ud83d\ude2e\",\n        \":|\": \"\ud83d\ude10\",\n        \":/\": \"\ud83d\ude15\",\n        \";D\": \"\ud83d\ude01\",\n        \":-)\": \"\ud83d\ude0a\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\": \"\u2639\ufe0f\",\n        \":-D\": \";)\",\n        \";-D\": \"\ud83d\ude01\",\n        \":-P\": \"\ud83d\ude1c\",\n        \":-O\": \"\ud83d\ude2e\",\n        \":-|\": \"\ud83d\ude10\",\n        \":-/\": \"\ud83d\ude15\",\n        \":-(\":"}
{"task_id": "EvoEval/39", "completion": "\n    # Create a string of asterisks to represent the frame of the ASCII art\n    frame = \"*\" * (len(s) * n + 1)\n    \n    # Create a string of the input string repeated n times\n    repeated_s = s * n\n    \n    # Create the top and bottom rows of the ASCII art\n    top_bottom_row = \"*\" + repeated_s + \"*\"\n    \n    # Create the middle rows of the ASCII art\n    middle_rows = [top_bottom_row] * n\n    \n    # Join the top and bottom rows with the middle rows to create the final ASCII art\n    ascii_art = frame + \"\\n\" + \"\\n\".join(middle_rows) + \"\\n\" + frame\n    \n    return ascii_art\n"}
{"task_id": "EvoEval/40", "completion": "\n    # Create a dictionary to store the potions and their power levels\n    potion_dict = {}\n    for potion in potions:\n        name, power = potion.split(' ')\n        power = int(power[:-1])  # Remove the unit from the power level\n        potion_dict[name] = power\n\n    # Create a list to store the possible combinations of potions\n    combinations = []\n\n    # Define a recursive function to generate all combinations of potions\n    def generate_combinations(current_combination, remaining_power):\n        if remaining_power == 0:\n            combinations.append(current_combination[:])\n        elif remaining_power > 0:\n            for potion in potion_dict:\n                if potion_dict[potion] <= remaining_power:\n                    current_combination.append(potion)\n                    generate_combinations(current_combination, remaining_power - potion_dict[potion])\n                    current_combination.pop()\n\n    # Generate all combinations of potions\n    generate_combinations([], target)\n\n    # Filter the combinations to only include those that reach the target power level\n    valid_combinations = [combination for combination in combinations if sum(potion_dict[potion] for potion in combination) == target]\n\n    # If no valid combinations are found, return an empty list\n    if not valid_combinations:\n        return []\n\n    # Sort the valid combinations by the number of potions and then by alphabetical order\n    valid_combinations.sort(key=lambda x: (len(x), x))\n\n    # Return the smallest valid combination\n    return valid_combinations[0]  # Return the first combination in the sorted list\n\n"}
{"task_id": "EvoEval/41", "completion": "\n    # Initialize the first row and column\n    for i in range(1, len(arr)):\n        arr[i][0] += arr[i - 1][0]\n    for j in range(1, len(arr[0])):\n        arr[0][j] += arr[0][j - 1]\n\n    # Fill in the rest of the array\n    for i in range(1, len(arr)):\n        for j in range(1, len(arr[0])):\n            arr[i][j] += min(arr[i - 1][j], arr[i][j - 1])\n\n    # Find the safe cell\n    for i in range(len(arr)):\n        for j in range(len(arr[0])):\n            if arr[i][j] == 0:\n                return arr[i][j]\n\n    return -1  # No safe cell found\n"}
{"task_id": "EvoEval/42", "completion": "\n    # Check if the list is empty\n    if not player_input:\r\n        return False, None\r\n\r\n    # Check if the list contains a legendary item (rarity 5)\r\n    if 5 in player_input:\r\n        # If the list contains a legendary item, return True and the second most valuable item\r\n        # The second most valuable item is the maximum value in the list excluding the legendary item\r\n        legendary_item = 5\r\n        second_most_valuable_item = max([item for item in player_input if item != legendary_item])\r\n        return True, second_most_valuable_item\r\n\r\n    # If the list does not contain a legendary item, return False and None\r\n    return False, None\r\n\r"}
{"task_id": "EvoEval/43", "completion": "\n    # Calculate the duration of the trip\n    trip_duration = distance / speed\n    \n    # Calculate the fuel consumption for the trip\n    fuel_consumption = trip_duration * (spaceship_weight * planet_gravity * 0.1)\n    \n    # Check if there is enough fuel for the trip\n    if fuel_consumption <= fuel:\n        # Calculate the remaining fuel\n        remaining_fuel = fuel - fuel_consumption\n        return round(remaining_fuel, 2)\n    else:\n        return 'Insufficient fuel'\n"}
{"task_id": "EvoEval/44", "completion": "\n    # Calculate the total weight that the unicorns can carry\n    unicorns_capacity = w * 2  # Each unicorn can carry 2 kg\n    \n    # Calculate the total weight that the dragons can carry\n    dragons_capacity = e * 3  # Each dragon can carry 3 kg\n    \n    # Calculate the total weight that the unicorns and dragons can carry combined\n    combined_capacity = unicorns_capacity + dragons_capacity\n    \n    # Check if the combined capacity is enough to carry all items\n    return combined_capacity >= sum(q)\r\n    \r"}
{"task_id": "EvoEval/45", "completion": "\n    if len(arr) == 0:\n        return 0\n    max_hills = 0\n    max_height = 0\n    for i in range(len(arr)):\n        if arr[i] > max_height:\n            max_height = arr[i]\n            count = 1\n            for j in range(i + 1, len(arr)):\n                if arr[j] < max_height:\n                    count += 1\n                else:\n                    break\n            for j in range(i - 1, -1, -1):\n                if arr[j] < max_height:\n                    count += 1\n                else:\n                    break\n            max_hills = max(max_hills, count)\n    return max_hills\n"}
{"task_id": "EvoEval/46", "completion": "\n    secret_message = \"Take the cannoli.\"\n    result = []\n    for test_case in test_cases:\n        secret = \"\"\n        for word in test_case:\n            word = ''.join(e for e in word if e.isalnum())\n            if word:\n                secret += word[0].lower()\n        if secret in secret_message:\n            result.append(secret)\n        else:\n            result.append(\"Take cannoli\")\n    return result\n"}
{"task_id": "EvoEval/47", "completion": "\n    if isinstance(recipe, dict):\n        for ingredient, quantity in recipe.items():\n            ingredient, quantity = ingredient.split()\n            quantity = int(quantity)\n            if ingredient not in available or available[ingredient] < quantity:\n                return False\n        return True\n    elif isinstance(recipe, str):\n        ingredients = recipe.split()\n        for i in range(0, len(ingredients), 2):\n            ingredient, quantity = ingredients[i], int(ingredients[i + 1])\n            if ingredient not in available or available[ingredient] < quantity:\n                return False\n        return True\n    else:\n        raise ValueError(\"Invalid recipe format\")\n    return True\n"}
{"task_id": "EvoEval/48", "completion": "\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    return {item: quantity for item, quantity in inventory.items() if quantity > 0}  # Filter out items with quantity 0 or less\n"}
{"task_id": "EvoEval/49", "completion": "\n    morse_code = {\n        'A': '01', 'B': '1000', 'C': '1010', 'D': '100', 'E': '0',\n        'F': '0010', 'G': '110', 'H': '0000', 'I': '00', 'J': '0111',\n        'K': '101', 'L': '0100', 'M': '11', 'N': '10', 'O': '111',\n        'P': '0110', 'Q': '1101', 'R': '010', 'S': '000', 'T': '1',\n        'U': '001', 'V': '0001', 'W': '011', 'X': '1001', 'Y': '1011',\n        'Z': '1100', '0': '01111', '1': '00111', '2': '00011', '3': '00001',\n        '4': '00000', '5': '10000', '6': '11000', '7': '11100', '8': '11110',\n        '9': '11111'\n    }\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        letters = word.split()\n        decoded_letters = []\n        for letter in letters:\n            if letter in morse_code:\n                decoded_letters.append(morse_code[letter])\n        decoded_word = ''.join(decoded_letters)\n        decoded_words.append(decoded_word)\n    decoded_msg = ' '.join(decoded_words)\n    return decoded_msg\n"}
{"task_id": "EvoEval/50", "completion": "\n    morse_code_dict = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', \n        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', \n        '8': '---..', '9': '----.', ' ': '/'\n    }\n    morse_code = ''\n    for char in text.upper():\n        if char in morse_code_dict:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/51", "completion": "\n    if not string or not list_of_alphabets:\n        return string\n    result = ''\n    for i in range(len(string)):\n        result += list_of_alphabets[i % len(list_of_alphabets)]\n    return result\n"}
{"task_id": "EvoEval/52", "completion": "\n    # Sort the orders in descending order\n    orders.sort(reverse=True)\n    \n    # Initialize the maximum number of orders that can be fulfilled\n    max_orders = 0\n    \n    # Initialize the current batch size\n    current_batch_size = 0\n    \n    # Initialize the current batch number\n    current_batch = 1\n    \n    # Iterate over the orders\n    for order in orders:\n        # If the current batch size plus the order is greater than n, start a new batch\n        if current_batch_size + order > n:\n            current_batch_size = 0\n            current_batch += 1\n        \n        # Add the order to the current batch\n        current_batch_size += order\n        \n        # If the current batch size is equal to n, increment the maximum number of orders\n        if current_batch_size == n:\n            max_orders += 1\n            current_batch_size = 0\n            current_batch += 1\n    \n    # Return the maximum number of orders that can be fulfilled\n    return max_orders\n"}
{"task_id": "EvoEval/53", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    result = ''\n    for i, char in enumerate(s):\n        if char in vowels:\n            if char.islower():\n                result += 'u' if char == 'a' else 'i' if char == 'e' else 'o' if char == 'i' else 'u' if char == 'o' else 'a'\n            else:\n                result += 'U' if char == 'A' else 'I' if char == 'E' else 'O' if char == 'I' else 'U' if char == 'O' else 'A'\n        elif char in consonants:\n            if char.islower():\n                result += 'b' if char == 'y' else consonants[(consonants.index(char) + 1) % len(consonants)]\n            else:\n                result += 'B' if char == 'Y' else consonants[(consonants.index(char) + 1) % len(consonants)]\n        else:\n            result += char\n        if char in '?!':\n            result = result[:i] + '!' + result[i+1:]\n    return result\n"}
{"task_id": "EvoEval/54", "completion": "\n    star_map = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                star_map.append((i, j))\n    return star_map\n"}
{"task_id": "EvoEval/55", "completion": "\n    result = \"\"\n    shift_counter = shift\n    for char in message:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + shift_counter) % 26 + ascii_offset)\n            shift_counter += 1\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/56", "completion": "\n    morse_code_dict = {\n        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'\n    }\n    morse_code = ''\n    for char in s:\n        if char == ' ':\n            morse_code += ' / '\n        else:\n            morse_code += morse_code_dict[char] + ' '\n    return morse_code.strip()\n"}
{"task_id": "EvoEval/57", "completion": "\n    new_menu = {}\n    for dish, price in menu.items():\n        new_name = ''\n        for i, letter in enumerate(dish):\n            if i < len(magic_spell):\n                new_name += magic_spell[i]\n            else:\n                new_name += letter\n        new_menu[new_name] = price\n    return new_menu\n"}
{"task_id": "EvoEval/58", "completion": "\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for char in earth_phrase:\n        if char in vowels:\n            idx = vowels.index(char)\n            result += vowels[(idx + 1) % len(vowels)]\n        elif char in consonants:\n            idx = consonants.index(char)\n            result += consonants[(idx + 1) % len(consonants)]\n        elif char == 'z':\n            result += 'b'\n        elif char == ' ':\n            result += '@'\n    result = result.capitalize()\n    words = result.split('@')\n    for i, word in enumerate(words):\n        if word[0] in vowels:\n            words[i] += 'xy'\n        else:\n            words[i] += 'yz'\n    return '@'.join(words)  # return the result as a string with '@' as the separator\n"}
{"task_id": "EvoEval/59", "completion": "\n    if not ingredient_dict:\n        return []\n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    return [f\"{ingredient} {recipes}\" for ingredient, recipes in sorted_ingredients]  # return list of tuples\n"}
{"task_id": "EvoEval/60", "completion": "\n    # Initialize a dictionary to store the sugar locations and their corresponding indices\n    sugar_dict = {location: index for index, location in enumerate(sugar_locations)}\n    \n    # Initialize a list to store the ant positions and their corresponding directions\n    ant_dict = {index: (position, direction) for index, (position, direction) in enumerate(ant_positions)}\n    \n    # Initialize a set to store the visited locations\n    visited = set()\n    \n    # Initialize a variable to store the number of happy ants\n    happy_ants_count = 0\n    \n    # Iterate over the ant positions\n    for index, (position, direction) in ant_dict.items():\n        # If the ant has not visited the location before\n        if position not in visited:\n            # Mark the location as visited\n            visited.add(position)\n            \n            # If the location has sugar\n            if position in sugar_dict:\n                # Increment the happy ants count\n                happy_ants_count += 1\n                \n                # Remove the sugar from the location\n                del sugar_dict[position]\n                \n                # If there are still ants marching\n                if ant_dict:\n                    # Get the next ant's position and direction\n                    next_index, (next_position, next_direction) = list(ant_dict.items())[index + 1]\n                    \n                    # If the next ant is marching in the same direction\n                    if next_direction == direction:\n                        # Update the next ant's position\n                        ant_dict[next_index] = (next_position + 1, next_direction)\n                    # If the next ant is marching in the opposite direction\n                    elif next_direction == \"left\" and direction == \"right\":\n                        # Update the next ant's position\n                        ant_dict[next_index] = (next_position - 1, next_direction)\n    \n    # Return the number of happy ants\n    return happy_ants_count\n"}
{"task_id": "EvoEval/61", "completion": "\n    vowels = 'aeiou'\n    result = ''\n    for i, c in enumerate(s):\n        if c == ' ':\n            result += c\n        elif i % 2 == 1:\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        elif c in vowels:\n            idx = vowels.index(c)\n            result += vowels[(idx + 1) % 5]\n        else:\n            idx = ord(c) - ord('a')\n            result += chr(ord('a') + (idx - 1) % 25)\n    return result\n"}
{"task_id": "EvoEval/62", "completion": "\n    new_recipe = {}\n    for ingredient, quantity in recipe.items():\n        new_recipe[ingredient] = int(quantity) * conversion_factor\n    return new_recipe\n"}
{"task_id": "EvoEval/63", "completion": "\n    pyramid = [p]\r\n    while p > 0:\r\n        if p % 2 == 0:\r\n            p = p - 2\r\n        else:\r\n            p = p - 3\r\n        pyramid.append(p)\r\n    return pyramid[::-1]  # return the list in reverse order\r\n\r"}
{"task_id": "EvoEval/64", "completion": "\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result\n"}
{"task_id": "EvoEval/65", "completion": "\n    # Create a copy of the original menu\n    final_order = menu.copy()\n    \n    # Iterate over each food item in the order\n    for food, action in order.items():\n        # Check if the food item exists in the menu\n        if food in menu:\n            # If the action is 'remove', remove the ingredient from the food item\n            if action == \"remove\":\n                # Check if the ingredient exists in the food item\n                if \"Cheese\" in menu[food]:\n                    # Remove the ingredient from the food item\n                    menu[food].remove(\"Cheese\")\n            # If the action is 'add', add the ingredient to the food item\n            elif action == \"add\":\n                # Check if the ingredient exists in the menu\n                if \"Mushrooms\" in menu:\n                    # Add the ingredient to the food item\n                    menu[food].append(\"Mushrooms\")\n        # If the action is neither 'remove' nor 'add', do nothing\n        else:\n            # If the food item does not exist in the menu, do nothing\n            pass\n    \n    # Return the final order\n    return final_order\n"}
{"task_id": "EvoEval/66", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def anagrams(a, b):\n        return sorted(str(a)) == sorted(str(b))\n\n    primes = [i for i in range(1, n + 1) if is_prime(i)]\n    pairs = []\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if anagrams(primes[i], primes[j]):\n                pairs.append((primes[i], primes[j]))\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    return pairs\n"}
{"task_id": "EvoEval/67", "completion": "\n    total_calories = {}\n    for customer in customers:\n        total_calories[customer] = 0\n        if customer in meals:\n            for meal in meals[customer]:\n                if 'calories' in meal:\n                    total_calories[customer] += meal['calories']\n                else:\n                    total_calories[customer] += 0\n    return total_calories\n"}
{"task_id": "EvoEval/68", "completion": "\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return True\n        else:\n            return False\n    # find the first element that is greater than the next element\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            # if the first element is greater than the next element, we can swap them\n            # and then rotate the array to get the desired sorted order\n            if arr[0] > arr[1]:\n                arr[0], arr[1] = arr[1], arr[0]\n            # rotate the array to get the desired sorted order\n            arr = arr[1:] + arr[:1]\n            return True\n    # if no such element is found, the array is already sorted\n    return True\n"}
{"task_id": "EvoEval/69", "completion": "\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return \"No magic today\"  # return \"No magic today\" if no solution found"}
{"task_id": "EvoEval/70", "completion": "\n    if not path or 'a' in planets:\r\n        return False\r\n    current_planet = path[0]\r\n    for planet in path[1:]:\r\n        if planet not in planets.get(current_planet, []):\r\n            return False\r\n        current_planet = planet\r\n    return True\r\n\r"}
{"task_id": "EvoEval/71", "completion": "\n    encrypted = \"\"\n    vowels = 0\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            if char.lower() in 'aeiou':\n                vowels += 1\n        else:\n            encrypted += char\n    return encrypted, vowels\n"}
{"task_id": "EvoEval/72", "completion": "\n    fairy_tales = []\n    for i in lst:\n        j = sum(c.isdigit() for c in i)\n        fairy_tales.append(f\"Once upon a time in a kingdom far away lived a magical creature '{i}' known for telling {j} tales a day\")\n    return fairy_tales\n"}
{"task_id": "EvoEval/73", "completion": "\n    # number of rows in grid\n    rows = len(grid)\r\n    # number of columns in grid\r\n    cols = len(grid[0])\r\n    # number of treasures in each chamber\r\n    treasures_per_chamber = math.ceil(sum(sum(row) for row in grid) / rows)\r\n    # number of trips required to collect all treasures\r\n    trips = math.ceil(sum(sum(row) for row in grid) / bag_capacity)\r\n    # total number of treasures collected\r\n    total_treasures = trips * bag_capacity * treasures_per_chamber\r\n    return total_treasures\r\n\r"}
{"task_id": "EvoEval/74", "completion": "\n    result = \"\"\n    for char in s:\n        if char in cipher:\n            result += cipher[char]\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/75", "completion": "\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    digits = '0123456789'\n    punctuation = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n    result = []\n    for i, char in enumerate(input_str):\n        if char in vowels:\n            if char.lower() == 'u':\n                result.append('a' if i % 2 == 0 else 'A')\n            else:\n                idx = vowels.index(char)\n                result.append(vowels[(idx + 1) % len(vowels)])\n        elif char in consonants:\n            idx = consonants.index(char)\n            result.append(consonants[(idx + 1) % len(consonants)])\n        elif char in digits:\n            result.append(str((int(char) + 1) % 10))\n        elif char in punctuation:\n            if i % 2 == 0:\n                result.append('!' if char == '?' else '?')\n            else:\n                result.append('!' if char == '?' else '?')\n        else:\n            result.append(char)\n    return ''.join(result)  # return the transformed string\n"}
{"task_id": "EvoEval/76", "completion": "\n    if not lst:\n        return []\n    pyramid = []\n    for i in range(len(lst), 0, -1):\n        level = '#' * lst[i - 1]\n        pyramid.append(level)\n    return pyramid\n"}
{"task_id": "EvoEval/77", "completion": "\n    return [sequence[i] // k for i in range(len(sequence))]\n"}
{"task_id": "EvoEval/78", "completion": "\n    n = len(mat)\n    if n % 2 == 0:\n        return None\n    pattern = []\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                pattern.append(mat[i][j])\n    return pattern\n"}
{"task_id": "EvoEval/79", "completion": "\n    # Initialize a list to store the maximum profit for each day\n    max_profit = [0] * len(prices)\r\n    # Initialize the minimum price seen so far\n    min_price = prices[0]\r\n    # Iterate over the prices from the second day to the last day\n    for i in range(1, len(prices)):\r\n        # Update the minimum price seen so far\n        min_price = min(min_price, prices[i])\r\n        # Calculate the maximum profit for the current day\n        max_profit[i] = max(max_profit[i-1], prices[i] - min_price)\r\n    # Initialize the maximum profit\n    max_profit_vendor = 0\r\n    # Iterate over the maximum profit for each day\n    for i in range(days):\r\n        # Update the maximum profit\n        max_profit_vendor = max(max_profit_vendor, max_profit[i])\r\n    # Return the maximum profit\n    return max_profit_vendor\r\n\r"}
{"task_id": "EvoEval/80", "completion": "\n    # Initialize player's position and path\n    player_position = [0, 0]\n    player_path = [tuple(player_position)]\n    # Iterate over each instruction\n    for instruction in instructions:\n        # Get the current player position\n        current_position = player_position[:]\n        # Move the player based on the instruction\n        if instruction == 'up':\n            current_position[0] -= 1\n        elif instruction == 'down':\n            current_position[0] += 1\n        elif instruction == 'left':\n            current_position[1] -= 1\n        elif instruction == 'right':\n            current_position[1] += 1\n        # Check if the new position is valid (not a wall and not out of bounds)\n        if 0 <= current_position[0] < len(map) and 0 <= current_position[1] < len(map[0]) and map[current_position[0]][current_position[1]] != 'X':\n            # Update the player's position and path\n            player_position = current_position\n            player_path.append(tuple(player_position))\n            # Check if the player has reached the end\n            if map[player_position[0]][player_position[1]] == 'E':\n                return player_path\n        # If the new position is not valid, stay in the current position\n        else:\n            player_position = current_position\n    # If the list of instructions ends before the player reaches the end, return the player's path\n    return player_path\n"}
{"task_id": "EvoEval/81", "completion": "\n    if not word_list:\n        return \"CORRECT\"\n    for i in range(len(word_list) - 1):\n        if sorted(word_list[i]) != sorted(word_list[i + 1]):\n            return \"INCORRECT\"\n    return \"CORRECT\"\n"}
{"task_id": "EvoEval/82", "completion": "\n\n    # Initialize dictionary to store elements and their corresponding birthdays\n    elements = {'Fire': 0, 'Water': 0, 'Air': 0, 'Earth': 0}\n\n    # Loop through each birthday in the list\n    for birthday in birthdays:\n        # Split the birthday into month and day\n        month, day = birthday.split('-')\n        # Convert month and day to integers\n        month, day = int(month), int(day)\n\n        # Determine the zodiac sign based on the month and day\n        if (month == 3 and 21 <= day <= 31) or (month == 4 and 1 <= day <= 19):\n            # Aries\n            elements['Fire'] += 1\n        elif (month == 4 and 20 <= day <= 30) or (month == 5 and 1 <= day <= 20):\n            # Taurus\n            elements['Earth'] += 1\n        elif (month == 5 and 21 <= day <= 31) or (month == 6 and 1 <= day <= 20):\n            # Gemini\n            elements['Air'] += 1\n        elif (month == 6 and 21 <= day <= 30) or (month == 7 and 1 <= day <= 22):\n            # Cancer\n            elements['Water'] += 1\n        elif (month == 7 and 23 <= day <= 31) or (month == 8 and 1 <= day <= 22):\n            # Leo\n            elements['Fire'] += 1\n        elif (month == 8 and 23 <= day <= 31) or (month == 9 and 1 <= day <= 22):\n            # Virgo\n            elements['Earth'] += 1\n        elif (month == 9 and 23 <= day <= 30) or (month == 10 and 1 <= day <= 22):\n            # Libra\n            elements['Air'] += 1\n        elif (month == 10 and 23 <= day <= 31) or (month == 11 and 1 <= day <= 21):\n            # Scorpio\n            elements['Water'] += 1\n        elif (month == 11 and 22 <= day <= 30) or (month == 12"}
{"task_id": "EvoEval/83", "completion": "\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n    return ''.join(s)\n"}
{"task_id": "EvoEval/84", "completion": "\n    def traverse(node, path):\n        if not node:\n            return []\n        if not node:\n            return [path]\n        paths = []\n        for key, value in node.items():\n            if isinstance(value, dict):\n                paths.extend(traverse(value, path + [key]))\n            else:\n                paths.append(path + [key])\n        return paths\n\n    return traverse(tree, [])  # return empty list if tree is empty\n\n"}
{"task_id": "EvoEval/85", "completion": "\n    # Initialize variables\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = [(0, 0, 0)]  # (row, col, steps)\n    visited[0][0] = True\n\n    # Define directions\n    directions = [(0, 1), (1, 0)]  # right, down\n\n    while queue:\n        row, col, steps = queue.pop(0)\n        if (row, col) == coord:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 0:\n                queue.append((nr, nc, steps + 1))\n                visited[nr][nc] = True\n\n    return -1\n"}
{"task_id": "EvoEval/86", "completion": "\n    # Sort the movies by ratings in descending order and then by release year in ascending order\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], x[1][1]))\n    \n    # Return the sorted list of movie names\n    return [movie[0] for movie in sorted_movies]\n"}
{"task_id": "EvoEval/87", "completion": "\n    if not arr or not arr[0]:\n        return ''\n    result = []\n    while arr:\n        result.append(''.join(arr.pop(0)))\n        if not arr and arr[0]:\n            arr.pop(0)\n        elif not arr:\n            break\n        for row in arr:\n            result.append(row.pop())\n        if not arr or not arr[0]:\n            arr.reverse()\n            if arr:\n                result.append(''.join(arr.pop(0)))\n    return ''.join(result)  # return the string of words in the spiral order\n"}
{"task_id": "EvoEval/88", "completion": "\n    result = {}\n    for planet, features in dict_of_planets.items():\n        if features[0] is not None and features[1] is not None:\n            population_density = round(features[0] / features[1], 2)\n            result[planet] = population_density\n    return result\n"}
{"task_id": "EvoEval/89", "completion": "\n    aliens = sorted(aliens)\n    aliens.remove(ray)\n    aliens = [alien for alien in aliens if alien not in [ray - 1, ray + 1]]\n    return aliens\n"}
{"task_id": "EvoEval/90", "completion": "\n    # Convert input strings to integers\n    num1 = int(s1)\n    num2 = int(s2)\n    \n    # Initialize a list to store the unique combinations of digits\n    combinations = []\n    \n    # Generate all possible combinations of digits for num1\n    for i in range(1 << len(str(num1))):\n        combination = []\n        for j in range(len(str(num1))):\n            if (i & (1 << j)):\n                combination.append(int(str(num1)[j]))\n        combinations.append(combination)\n    \n    # Generate all possible combinations of digits for num2\n    for i in range(1 << len(str(num2))):\n        combination = []\n        for j in range(len(str(num2))):\n            if (i & (1 << j)):\n                combination.append(int(str(num2)[j]))\n        combinations.append(combination)\n    \n    # Calculate the sum of unique combinations for num1 and num2\n    sum1 = 0\n    sum2 = 0\n    for combination in combinations:\n        if len(combination) == len(str(num1)):\n            sum1 += sum(combination)\n        elif len(combination) == len(str(num2)):\n            sum2 += sum(combination)\n    \n    # Return the product of the sums\n    return sum1 * sum2\n"}
{"task_id": "EvoEval/91", "completion": "\n    status = 'On Ground'\n    for action, distance in spaceshi_data:\n        if action == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                status = 'Invalid Action Sequence'\n        elif action == 'Move':\n            if status == 'In Space':\n                pass\n            else:\n                status = 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status == 'In Space':\n                status = 'On Ground'\n            else:\n                status = 'Invalid Action Sequence'\n        else:\n            status = 'Invalid Action Sequence'\n    return status\n"}
{"task_id": "EvoEval/92", "completion": "\n    result = ''\n    for i in range(1, n + 1):\n        layer = ''\n        for j in range(1, 2 * i):\n            if j == i:\n                layer += chr(64 + i)\n            elif j == 2 * i - j + 1:\n                layer += chr(64 + i)\n            else:\n                layer += ' '\n        result += layer.center(2 * i - 1) + '\\n'\n    return result[:-1]  # remove the last newline character\n"}
{"task_id": "EvoEval/93", "completion": "\n    result = \"\"\n    n_index = 0\n    for char in message:\n        if char.isalpha():\n            shift = n_values[n_index % len(n_values)]\n            n_index += 1\n            if char.isupper():\n                result += chr((ord(char) - 65 + shift) % 26 + 65)\n            else:\n                result += chr((ord(char) - 97 + shift) % 26 + 97)\n        else:\n            result += char\n    return result\n"}
{"task_id": "EvoEval/94", "completion": "\n    return [' '.join(sorted(word.split(), key=len)) for word in strings]  # Your code here\n"}
{"task_id": "EvoEval/95", "completion": "\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    first_diagonal = 0\n    second_diagonal = 0\n    for i in range(len(m)):\n        first_diagonal += m[i][i]\n        second_diagonal += m[i][len(m) - i - 1]\n    return abs(first_diagonal - second_diagonal)  # return absolute difference"}
{"task_id": "EvoEval/96", "completion": "\n    magic_indices = []\n    for i in range(len(lst)):\n        if lst[i] * i == i * lst[i] and product(lst[i]) == i:\n            magic_indices.append(i)\n    return sorted(magic_indices)\n"}
{"task_id": "EvoEval/97", "completion": "\n    # Check if alien name is valid\n    if alien not in [\"Xenomorph\", \"Predator\", \"Klingon\"]:\n        return []\n\n    # Define the order of invasion\n    invasion_order = [\"Asia\", \"Africa\", \"Europe\", \"North America\", \"South America\"]\n\n    # Initialize an empty list to store the humans encountered by the alien\n    encountered_humans = []\n\n    # Iterate over the invasion order\n    for continent in invasion_order:\n        # Check if the alien is in the current continent\n        if alien == \"Xenomorph\" and continent == \"Asia\":\n            # If the alien is in Asia, add the humans in Asia to the encountered list\n            encountered_humans.extend([human for human, continent in humans.items() if continent == \"Asia\"])\n        elif alien == \"Predator\" and continent == \"Africa\":\n            # If the alien is in Africa, add the humans in Africa to the encountered list\n            encountered_humans.extend([human for human, continent in humans.items() if continent == \"Africa\"])\n        elif alien == \"Klingon\" and continent == \"Europe\":\n            # If the alien is in Europe, add the humans in Europe to the encountered list\n            encountered_humans.extend([human for human, continent in humans.items() if continent == \"Europe\"])\n\n    # Sort the encountered humans by the order they were encountered\n    encountered_humans.sort()\n\n    # Return the list of encountered humans\n    return encountered_humans\n\n"}
{"task_id": "EvoEval/98", "completion": "\n    sequence = [a, b]\n    for i in range(2, n):\n        next_number = sequence[-1] + sequence[-2] + i\n        if is_prime(next_number):\n            sequence.append('prime')\n        else:\n            sequence.append(next_number)\n    return sequence\n"}
{"task_id": "EvoEval/99", "completion": "\n    players = list(range(1, n + 1))\n    for i, seconds in enumerate(rounds):\n        for _ in range(seconds):\n            music.play()\n        position = (i + 1) % len(players)\n        players.pop(position)\n    return players\n"}
