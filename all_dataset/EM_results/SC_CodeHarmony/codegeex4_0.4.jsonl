{"task_id": "valid/0", "completion": "\n    # Define the rules for classification\n    rules = {\n        'rule1': lambda text: 'category1' if 'keyword1' in text else 'category2',\n        'rule2': lambda text: 'category3' if 'keyword2' in text else 'category4',\n        # Add more rules as needed\n    }\n\n    # Apply the rules to the text\n    for rule_name, rule_func in rules.items():\n        category = rule_func(text)\n        if category:\n            return category\n\n    # If no rule matches, return a default category\n    return 'default_category'\n"}
{"task_id": "valid/1", "completion": "\n    return frozenset(s)\n\n"}
{"task_id": "valid/2", "completion": "\n    return num1 ^ num2\n"}
{"task_id": "valid/3", "completion": "\n    return sorted(instruments)\n"}
{"task_id": "valid/4", "completion": "\n    try:\n        data = json.loads(json_string)\n        if isinstance(data, list):\n            return data\n        else:\n            raise ValueError(\"Input is not a valid JSON string.\")\n    except json.JSONDecodeError:\n        raise ValueError(\"Input is not a valid JSON string.\")\n\n"}
{"task_id": "valid/5", "completion": "\n    if not isinstance(n, int) or n < 0:\n        return False\n    if n % 5 == 0:\n        sum_digits = sum(int(digit) for digit in str(n))\n        if sum_digits % 3 == 0:\n            return True\n    return False"}
{"task_id": "valid/6", "completion": "\n    return pow(base, n, 2**32)\n"}
{"task_id": "valid/7", "completion": "\n    try:\n        json_data = json.loads(json_str)\n        pprint.pprint(json_data)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Invalid JSON string\") from e\n\n"}
{"task_id": "valid/8", "completion": "\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    return False\n"}
{"task_id": "valid/9", "completion": "\n    for key, value in values.items():\n        template = template.replace(\"{{\" + key + \"}}\", str(value))\n    return template\n"}
{"task_id": "valid/10", "completion": "\n    # Create a set to store unique characters\n    unique_chars = set()\n\n    # Iterate over each character in the string\n    for char in string:\n        # If the character is already in the set, return False\n        if char in unique_chars:\n            return False\n        # Otherwise, add the character to the set\n        unique_chars.add(char)\n\n    # If we reach this point, all characters are unique\n    return True\n\n"}
{"task_id": "valid/11", "completion": "\n    date = datetime.strptime(date_string, '%Y-%m-%d')\n    new_date = date + timedelta(days=days)\n    return new_date.strftime('%Y-%m-%d')\n\n"}
{"task_id": "valid/12", "completion": "\n    # Remove leading and trailing whitespace\n    text = text.strip()\n\n    # Remove extra whitespace between words\n    text = ' '.join(text.split())\n\n    return text\n\n"}
{"task_id": "valid/13", "completion": "\n    # Convert text to lowercase\n    text = text.lower()\n    \n    # Remove punctuation\n    text = text.translate(str.maketrans('', '', string.punctuation))\n    \n    # Remove digits\n    text = text.translate(str.maketrans('', '', string.digits))\n    \n    # Remove extra spaces\n    text = ' '.join(text.split())\n    \n    return text\n\n"}
{"task_id": "valid/14", "completion": "\n    pattern = r'\\b(' + word1 + r'|' + word2 + r')\\b'\n    return bool(re.search(pattern, text))\n\n"}
{"task_id": "valid/15", "completion": "\n    return np.sum(array, axis=1)\n"}
{"task_id": "valid/16", "completion": "\n    settings = {}\n    for line in comment.split('\\n'):\n        if line.startswith('tabstop'):\n            settings['tabstop'] = int(line.split('=')[1])\n        elif line.startswith('expandtab'):\n            settings['expandtab'] = line.split('=')[1] == 'true'\n        elif line.startswith('shiftwidth'):\n            settings['shiftwidth'] = int(line.split('=')[1])\n        elif line.startswith('softtabstop'):\n            settings['softtabstop'] = int(line.split('=')[1])\n    return settings\n\nThe function `parse_vim_settings` takes a string `comment` as input. This string is expected to contain lines indicating specific Vim settings. The function then parses this string and extracts the tabstop, expandtab, shiftwidth, and softtabstop values from it.\n\nHere's how the function works:\n\n1. It initializes an empty dictionary `settings` to store the extracted values.\n\n2. It then iterates over each line in the `comment` string.\n\n3. For each line, it checks if the line starts with the keywords 'tabstop', 'expandtab', 'shiftwidth', or 'softtabstop'.\n\n4. If the line starts with 'tabstop', it splits the line by '=' and takes the second part as the value. It then converts this value to an integer and stores it in the `settings` dictionary with the key 'tabstop'.\n\n5. If the line starts with 'expandtab', it splits the line by '=' and takes the second part as the value. It then checks if this value is 'true' and stores the result (True or False) in the `settings` dictionary with the key 'expandtab'.\n\n6. If the line starts with 'shiftwidth', it splits the line by '=' and takes the second part as the value. It then converts this value to an integer and stores it in the `settings` dictionary with the key 'shiftwidth'.\n\n7. If the line starts with 'softtabstop', it splits the line by '=' and takes the second part as the value. It then converts this value to an integer and stores it in the `settings` dictionary with the key 'softtabstop'.\n\n8. After processing all the lines, the function returns the `settings` dictionary.\n\nNote that this function assumes that the `comment` string is well-formed and contains valid Vim settings. If the `comment` string is not well-formed or contains invalid settings, the function may not work as expected.\n"}
{"task_id": "valid/17", "completion": "\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Disassemble the words\n    disassembled_words = [disassemble_word(word) for word in words]\n\n    return disassembled_words\n\n"}
{"task_id": "valid/18", "completion": "\n    if num == 0:\n        return 0\n    else:\n        return 1 + find_digits_count(num // 10)"}
{"task_id": "valid/19", "completion": "\n    # Reverse the elements in the lists\n    list1.reverse()\n    list2.reverse()\n\n    # Combine the lists\n    combined_list = list1 + list2\n\n    # Sort the combined list\n    combined_list.sort()\n\n    return combined_list\n"}
{"task_id": "valid/20", "completion": "\n    return input_string.replace(old_word, new_word)\n"}
{"task_id": "valid/21", "completion": "\n    return z**2\n"}
{"task_id": "valid/22", "completion": "\n    if \"name\" in dictionary:\n        return dictionary[\"name\"]\n    elif \"nested\" in dictionary and isinstance(dictionary[\"nested\"], dict):\n        return get_nested_dictionary_value(dictionary[\"nested\"])\n    else:\n        return None\n"}
{"task_id": "valid/23", "completion": "\n    if isinstance(struct, dict):\n        return {k: struct_to_dict(v) for k, v in struct.items()}\n    elif isinstance(struct, list):\n        return [struct_to_dict(item) for item in struct]\n    else:\n        return struct"}
{"task_id": "valid/24", "completion": "\n    # Convert the number to string\n    num_str = str(num)\n    \n    # Check if the number is already a palindrome\n    if num_str == num_str[::-1]:\n        return num\n    \n    # Find the closest palindrome smaller than the given number\n    smaller_palindrome = num - 1\n    while str(smaller_palindrome) != str(smaller_palindrome)[::-1]:\n        smaller_palindrome -= 1\n    \n    # Find the closest palindrome larger than the given number\n    larger_palindrome = num + 1\n    while str(larger_palindrome) != str(larger_palindrome)[::-1]:\n        larger_palindrome += 1\n    \n    # Return the closest palindrome\n    if abs(num - smaller_palindrome) <= abs(num - larger_palindrome):\n        return smaller_palindrome\n    else:\n        return larger_palindrome\n"}
{"task_id": "valid/25", "completion": "\n    if num < 0:\n        return \"Error: Negative number\"\n    else:\n        return num ** 0.5\n"}
{"task_id": "valid/26", "completion": "\n    if len(matrix) == 0:\n        return 0, 0, False\n    if len(matrix) != len(matrix[0]):\n        return len(matrix), 0, False\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    sum_diagonal = sum(matrix[i][i] for i in range(min(num_rows, num_cols)))\n    is_square = num_rows == num_cols\n    return num_rows, sum_diagonal, is_square\n"}
{"task_id": "valid/27", "completion": "\n    return base64.b64encode(string.encode('utf-8')).decode('utf-8')\n\n"}
{"task_id": "valid/28", "completion": "\n    return ''.join(c for c in s if c.isalpha()).lower()\n"}
{"task_id": "valid/29", "completion": "\n    return min(lst)\n"}
{"task_id": "valid/30", "completion": "\n    if isinstance(json_data, str):\n        try:\n            json_data = json.loads(json_data)\n        except json.JSONDecodeError:\n            return False\n    if isinstance(json_data, dict):\n        if key in json_data and json_data[key] == value:\n            return True\n    return False\n\n"}
{"task_id": "valid/31", "completion": "\n    table = []\n    for i in range(0, len(buttons), num_columns):\n        row = buttons[i:i+num_columns]\n        table.append(row)\n    return table\n"}
{"task_id": "valid/32", "completion": "\n    # Convert the string to lowercase\n    s = s.lower()\n    \n    # Create a set of all alphabets\n    alphabets = set(string.ascii_lowercase)\n    \n    # Create a set of alphabets in the string\n    string_alphabets = set(s)\n    \n    # Check if all alphabets are present in the string\n    if not alphabets.issubset(string_alphabets):\n        return False\n    \n    # Check if the alphabets are in the correct order\n    for i in range(len(s) - 1):\n        if s[i] > s[i+1]:\n            return False\n    \n    return True\n"}
{"task_id": "valid/33", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n\n"}
{"task_id": "valid/34", "completion": "\n    # Initialize the sum\n    total_sum = 0\n\n    # Iterate over the string\n    i = 0\n    while i < len(ts):\n        # Check if the current character is a digit\n        if ts[i].isdigit():\n            # Extract the numeric substring\n            num_str = \"\"\n            while i < len(ts) and ts[i].isdigit():\n                num_str += ts[i]\n                i += 1\n            # Convert the numeric substring to an integer and add it to the sum\n            total_sum += int(num_str)\n        else:\n            i += 1\n\n    return total_sum\n\n"}
{"task_id": "valid/35", "completion": "\n    return [word[:-1] + word[-1].upper() for word in words]\n"}
{"task_id": "valid/36", "completion": "\n    # Initialize an empty list to store the valid numerical values\n    valid_values = []\n    \n    # Iterate over each element in the array\n    for element in arr:\n        # Check if the element is a numerical value\n        if isinstance(element, (int, float)):\n            # If it is, add it to the list of valid values\n            valid_values.append(element)\n    \n    # Compute the sum of the valid numerical values\n    total = sum(valid_values)\n    \n    return total\n"}
{"task_id": "valid/37", "completion": "\n    neighborhoods = json_data['neighborhoods']\n    sorted_neighborhoods = sorted(neighborhoods, key=lambda x: x['name'])\n    return sorted_neighborhoods\n\n"}
{"task_id": "valid/38", "completion": "\n    arr.sort()\n    min_sum = float('inf')\n    for i in range(n-1):\n        sum = abs(arr[i] + arr[i+1])\n        min_sum = min(min_sum, sum)\n    return min_sum"}
{"task_id": "valid/39", "completion": "\n    stack = []\n    for c in p:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "valid/40", "completion": "\n    # Check if the input is a list of tuples\n    if not isinstance(votes, list) or not all(isinstance(vote, tuple) for vote in votes):\n        raise ValueError(\"Input must be a list of tuples\")\n\n    # Check if the candidate names are valid\n    for vote in votes:\n        if not isinstance(vote[0], str) or not vote[0].isupper() or len(vote[0]) > 20:\n            raise ValueError(\"Candidate names must be strings of uppercase letters with a maximum length of 20\")\n\n    # Check if the number of votes is valid\n    for vote in votes:\n        if not isinstance(vote[1], int) or vote[1] < 0 or vote[1] > 1000:\n            raise ValueError(\"Number of votes must be a positive integer not exceeding 1000\")\n\n    # Calculate the total number of votes\n    total_votes = sum(vote[1] for vote in votes)\n\n    # Check if the total number of votes is valid\n    if total_votes > 1000:\n        raise ValueError(\"Total number of votes must not exceed 1000\")\n\n    # Create a dictionary to store the results\n    results = {}\n\n    # Calculate the vote count and percentage for each candidate\n    for vote in votes:\n        candidate_name = vote[0]\n        vote_count = vote[1]\n        percentage = round((vote_count / total_votes) * 100, 2)\n        results[candidate_name] = {\"vote_count\": vote_count, \"percentage\": percentage}\n\n    return results\n\n"}
{"task_id": "valid/41", "completion": "\n    try:\n        # Parse the date string\n        date_object = datetime.strptime(date_string, \"%d-%m-%Y\")\n        # Format the date object to the desired format\n        formatted_date = date_object.strftime(\"%B %d\")\n        return formatted_date\n    except ValueError:\n        # Raise an error if the date is not valid\n        raise ValueError(\"Invalid date format. Please use DD-MM-YYYY format.\")\n\n"}
{"task_id": "valid/42", "completion": "\n    # Check if the new file name has an allowed file type\n    if not any(newname.endswith(ext) for ext in allowed_type):\n        return False\n\n    # Check if the old file name is the same as the new file name\n    if oldname == newname:\n        return False\n\n    # Check if the new file name already exists\n    if os.path.exists(newname):\n        return False\n\n    return True\n\n"}
{"task_id": "valid/43", "completion": "\n    result = []\n    for item in lst:\n        if isinstance(item, tuple):\n            result.append(remove_uneven(item))\n        elif isinstance(item, int):\n            if item % 2 == 0:\n                result.append(item)\n        elif isinstance(item, str):\n            if item.isdigit() and int(item) % 2 == 0:\n                result.append(item)\n    return tuple(result)\n"}
{"task_id": "valid/44", "completion": "\n    return hours * 60\n\n"}
{"task_id": "valid/45", "completion": "\n    count = 0\n    for char in string:\n        if char == specific_character:\n            count += 1\n    return count\n"}
{"task_id": "valid/46", "completion": "\n    # histogram_data = histogram_data + accs\n    # histogram_data.append(accs)\n    histogram_data[generation] = accs\n    return histogram_data\n"}
{"task_id": "valid/47", "completion": "\n    if re.match(r'^[a-zA-Z0-9]{5}$', string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "valid/48", "completion": "\n    unique_languages = set()\n    for classifier in classifiers:\n        if classifier.startswith(\"Programming Language :: \"):\n            language = classifier.split(\" :: \")[1]\n            unique_languages.add(language)\n    return len(unique_languages)\n\n"}
{"task_id": "valid/49", "completion": "\n    # Create a dictionary to store the count instances each number\n    count_dict = {}\n\n    # Iterate over the array\n    for row in arr:\n        for num in row:\n            # If the number is already in the dictionary, increment its count\n            if num in count_dict:\n                count_dict[num] += 1\n            # If the number is not in the dictionary, add it with a count of 1\n            else:\n                count_dict[num] = 1\n\n    # Return the dictionary\n    return count_dict\n"}
{"task_id": "valid/50", "completion": "\n    # Define the URL patterns and their corresponding view functions\n    url_patterns = [\n        (r'^home/$', 'home_view'),\n        (r'^about/$', 'about_view'),\n        (r'^contact/$', 'contact_view'),\n        (r'^videos/(?P<video_id>\\d+)/$', 'video_view'),\n    ]\n\n    # Iterate through the URL patterns to find a match\n    for pattern, view in url_patterns:\n        match = re.match(pattern, url)\n        if match:\n            return view\n\n    # If no match is found, return None\n    return None\n\n"}
{"task_id": "valid/51", "completion": "\n    list.insert(position, item)\n    return list\n"}
{"task_id": "valid/52", "completion": "\n    string = \"Hello\"\n    sentence = \"world!\"\n    result = string + \" \" + sentence\n    return result\n"}
{"task_id": "valid/53", "completion": "\n    substrings = []\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.append(s[i:j])\n    return substrings\n"}
{"task_id": "valid/54", "completion": "\n    price_sum = 0\n    for d in list_of_dicts:\n        for key in d.keys():\n            if key.startswith(\"price\"):\n                price_sum += d[key]\n    return price_sum\n"}
{"task_id": "valid/55", "completion": "\n    intersection = []\n    for element in list1:\n        if element in list2:\n            intersection.append(element)\n            list2.remove(element)\n    return intersection\n"}
{"task_id": "valid/56", "completion": "\n    def decorator(func):\n        func.route = request_method\n        return func\n    return decorator\n\nHere is a simple implementation of the `route_request` decorator:\n\n"}
{"task_id": "valid/57", "completion": "\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a > b:\n        return gcd_recursive(a % b, b)\n    else:\n        return gcd_recursive(a, b % a)\n"}
{"task_id": "valid/58", "completion": "\n    categorized_files = {\n        'global': [],\n        'environment': [],\n        'service': [],\n        'application': []\n    }\n    \n    for file_path in file_paths:\n        if 'global' in file_path:\n            categorized_files['global'].append(file_path)\n        elif 'environment' in file_path:\n            categorized_files['environment'].append(file_path)\n        elif 'service' in file_path:\n            categorized_files['service'].append(file_path)\n        elif 'application' in file_path:\n            categorized_files['application'].append(file_path)\n    \n    return categorized_files\n"}
{"task_id": "valid/59", "completion": "\n    numbers = [a, b, c, d, e]\n    numbers.sort()\n    return numbers[2]\n"}
{"task_id": "valid/60", "completion": "\n    return len(my_list) == len(set(my_list))\n\n"}
{"task_id": "valid/61", "completion": "\n    timeStart = datetime.datetime.fromtimestamp(timeStart)\n    timeEnd = datetime.datetime.fromtimestamp(timeEnd)\n    timeDifference = timeEnd - timeStart\n    return timeDifference.total_seconds()\n"}
{"task_id": "valid/62", "completion": "\n    if start > end:\n        return -1\n\n    mid = (start + end) // 2\n\n    if array[mid] == target:\n        return mid\n    elif array[mid] > target:\n        return binary_search_recursive(array, target, start, mid - 1)\n    else:\n        return binary_search_recursive(array, target, mid + 1, end)\n\n"}
{"task_id": "valid/63", "completion": "\n    if color == \"WHITE\":\n        return \"RED\"\n    elif color == \"RED\":\n        return \"WHITE\"\n    else:\n        return \"WHITE\"\n"}
{"task_id": "valid/64", "completion": "\n    for i in range(len(list)):\n        list[i] += 1\n    return list\n"}
{"task_id": "valid/65", "completion": "\n    for i in range(start, end + 1):\n        if not is_perfect_square(i):\n            return False\n    return True\n"}
{"task_id": "valid/66", "completion": "\n    for word in words:\n        if word == target:\n            return True\n    return False\n"}
{"task_id": "valid/67", "completion": "\n    return sentence.split()\n"}
{"task_id": "valid/68", "completion": "\n    print(\"The keys in the given dictionary:\")\n    for key in dict:\n        print(key)\n\n"}
{"task_id": "valid/69", "completion": "\n    name = \"John\"\n    age = 30\n    phrase = \" is a great person\"\n    return f\"{name}{phrase}\"\n\n"}
{"task_id": "valid/70", "completion": "\n    def is_special_char(c):\n        return not c.isalnum() and not c.isspace()\n\n    def process_string(s):\n        return ''.join(c.upper() if not is_special_char(c) else '' for c in s)\n\n    return [process_string(s) for s in strings]\n\n"}
{"task_id": "valid/71", "completion": "\n    for i in range(len(string)):\n        if string[i] == char:\n            return i\n    return -1\n"}
{"task_id": "valid/72", "completion": "\n    bold_text = []\n    start_tag = '<b>'\n    end_tag = '</b>'\n    start_index = 0\n    while True:\n        start_index = html_code.find(start_tag, start_index)\n        if start_index == -1:\n            break\n        end_index = html_code.find(end_tag, start_index)\n        if end_index == -1:\n            break\n        bold_text.append(html_code[start_index + len(start_tag):end_index])\n        start_index = end_index + len(end_tag)\n    return bold_text\n"}
{"task_id": "valid/73", "completion": "\n    # Define the items and their prices\n    items = {\n        \"Coke\": 1.00,\n        \"Pepsi\": 1.50,\n        \"Sprite\": 1.25,\n        \"Water\": 0.75\n    }\n    \n    # Check if the item is available\n    if item not in items:\n        return \"Item not available\"\n    \n    # Check if the user has inserted enough money\n    if money_inserted < items[item]:\n        return \"Not enough money inserted\"\n    \n    # Calculate the change to return\n    change = money_inserted - items[item]\n    \n    # Update the stock\n    items[item] -= 1\n    \n    # Return the change and the updated stock\n    return f\"Here is your {item}. Your change is ${change:.2f}. The updated stock is {items}\"\n"}
{"task_id": "valid/74", "completion": "\n    merged_list = list1 + list2\n    merged_list = list(set(merged_list))\n    return merged_list\n"}
{"task_id": "valid/75", "completion": "\n    count = 0\n    for i in list:\n        if i == target:\n            count += 1\n    return count\n"}
{"task_id": "valid/76", "completion": "\n    encoded_string = base64.b64encode(string.encode())\n    return encoded_string.decode()\n\n"}
{"task_id": "valid/77", "completion": "\n    import matplotlib.pyplot as plt\n    x = [1, 2, 3, 4, 5]\n    plt.stem(x)\n    plt.show()\n    return [i for i, value in enumerate(x) if value != 0]"}
{"task_id": "valid/78", "completion": "\n    # Assign a specific value\n    value = 10\n\n    # Validate the value\n    if value == 10:\n        print(\"Value is valid\")\n    else:\n        print(\"Value is not valid\")\n"}
{"task_id": "valid/79", "completion": "\n    letters = list(word)\n    random.shuffle(letters)\n    return ''.join(letters)\n\n"}
{"task_id": "valid/80", "completion": "\n    if isinstance(element, str):\n        return \"string\"\n    elif isinstance(element, int):\n        return \"integer\"\n    elif isinstance(element, float):\n        return \"float\"\n    elif isinstance(element, list):\n        return \"list\"\n    elif isinstance(element, dict):\n        return \"dictionary\"\n    elif isinstance(element, tuple):\n        return \"tuple\"\n    elif isinstance(element, set):\n        return \"set\"\n    elif isinstance(element, bool):\n        return \"boolean\"\n    elif isinstance(element, type(None)):\n        return \"NoneType\"\n    else:\n        return \"unknown\"\n"}
{"task_id": "valid/81", "completion": "\n    if not arr:\n        return []\n    merged = [arr[0]]\n    for i in range(1, len(arr)):\n        if arr[i] != merged[-1]:\n            merged.append(arr[i])\n    return merged\n"}
{"task_id": "valid/82", "completion": "\n    # Remove all non-word characters (everything except numbers and letters)\n    text = re.sub(r\"[^\\w\\s]\", \"\", text)\n\n    # Replace all runs of whitespaces with a single space\n    text = re.sub(r\"\\s+\", \" \", text)\n\n    # Replace digits with no leading zeros with words (e.g. '123' -> 'one two three')\n    text = re.sub(r\"(\\d+)\", lambda x: \" \".join(map(str, map(int, x.group(0)))), text)\n\n    # Replace digits with leading zeros with words (e.g. '00123' -> 'zero zero one two three')\n    text = re.sub(r\"(\\d+)\", lambda x: \" \".join(map(str, map(int, x.group(0)))), text)\n\n    # Tokenize the text\n    tokens = text.split()\n\n    return tokens\n\n"}
{"task_id": "valid/83", "completion": "\n    divisible_numbers = [num for num in numbers if num % 3 == 0 and num % 7 == 0]\n    count = len(divisible_numbers)\n    total = sum(divisible_numbers)\n    max_value = max(divisible_numbers)\n    min_value = min(divisible_numbers)\n    occurrences = {num: divisible_numbers.count(num) for num in set(divisible_numbers)}\n    return count, total, max_value, min_value, occurrences\n\nnumbers = [21, 42, 63, 84, 105, 126, 147, 168, 189, 210]\ncount, total, max_value, min_value, occurrences = find_divisible_numbers(numbers)"}
{"task_id": "valid/84", "completion": "\n    # split the sentence into words\n    words = sentence.split()\n\n    # create a dictionary to store the frequency of each word\n    word_freq = {}\n\n    # iterate through the words and count the frequency of each word\n    for word in words:\n        if word in word_freq:\n            word_freq[word] += 1\n        else:\n            word_freq[word] = 1\n\n    # find the word with the highest frequency\n    highest_freq = 0\n    highest_freq_word = \"\"\n    for word, freq in word_freq.items():\n        if freq > highest_freq:\n            highest_freq = freq\n            highest_freq_word = word\n\n    return highest_freq_word\n\n"}
{"task_id": "valid/85", "completion": "\n    e = 1\n    for i in range(1, decimal_places + 1):\n        e += 1 / math.factorial(i)\n    return e\n\n"}
{"task_id": "valid/86", "completion": "\n    average = sum(numbers) / len(numbers)\n    return average, sum(numbers)\n\nnumbers = [1, 2, 3, 4, 5]\naverage, total = getAverageAndSum(numbers)"}
{"task_id": "valid/87", "completion": "\n    if not time_series:\n        raise ValueError(\"Time series cannot be empty\")\n    min_value = time_series[0]\n    max_value = time_series[0]\n    for value in time_series:\n        if value < min_value:\n            min_value = value\n        elif value > max_value:\n            max_value = value\n    return min_value, max_value"}
{"task_id": "valid/88", "completion": "\n    relatedArticles = {}\n    for entry in encyclopedia:\n        relatedArticles[entry] = len(encyclopedia[entry]['related'])\n    return relatedArticles\n"}
{"task_id": "valid/89", "completion": "\n    max_value = max(lst)\n    max_index = lst.index(max_value)\n    return max_index\n"}
{"task_id": "valid/90", "completion": "\n    return not set(list1).isdisjoint(list2)\n"}
{"task_id": "valid/91", "completion": "\n    root = Element('data')\n    def build_tree(element, dictionary):\n        for key, value in dictionary.items():\n            child = Element(key)\n            if isinstance(value, dict):\n                build_tree(child, value)\n            else:\n                child.text = str(value)\n            element.append(child)\n    build_tree(root, dictionary)\n    return tostring(root, encoding='utf-8').decode('utf-8')\n\n"}
{"task_id": "valid/92", "completion": "\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        mid_val = matrix[mid // n][mid % n]\n\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n"}
{"task_id": "valid/93", "completion": "\n    sum_odd = 0\n    count_odd = 0\n    for num in lst:\n        if num % 2 != 0:\n            sum_odd += num\n            count_odd += 1\n    average_odd = sum_odd / count_odd\n    return sum_odd, average_odd\n"}
{"task_id": "valid/94", "completion": "\n    if n < 1 or n > len(lst):\n        return None\n    lst.sort(reverse=True)\n    return lst[n-1]\n"}
{"task_id": "valid/95", "completion": "\n    return sum(lst)\n\n"}
{"task_id": "valid/96", "completion": "\n    return set_a ^ set_b\n\n"}
{"task_id": "valid/97", "completion": "\n\n    **{mapping['name']}** is a Discord bot designed to enhance your music experience on Discord. With a focus on providing a seamless and enjoyable listening experience, this bot offers a wide range of features to suit your needs.\n\n    **Features:**\n    - **Music Management:** Easily manage your personal playlists, including creating, editing, and deleting playlists.\n    - **Server Settings:** Customize the bot's behavior and preferences for your server, such as setting a default volume or enabling/disabling certain features.\n    - **Web App Integration:** Access a web app that allows you to manage your playlists and server settings directly from your browser.\n\n    **Command Categories:**\n    - **Music Commands:** Control the music playback, including playing, pausing, skipping, and queue management.\n    - **Playlist Commands:** Create, edit, and manage your personal playlists.\n    - **Server Commands:** Customize the bot's behavior and preferences for your server.\n    - **Help Commands:** Get information about the bot's features and commands.\n\n    **Help Information:**\n    To get started, use the `help` command followed by the category or command you're interested in. For example, `help music` or `help playlist`.\n\n    **Note:** This bot requires the `Manage Messages` and `Connect` permissions to function properly. Please ensure that the bot has these permissions in your server.\n\n    **Support:**\n    If you encounter any issues or have suggestions for improvements, please feel free to reach out to the bot's developers. We're always looking to make {mapping['name']} better for you!\n\n    **Thank you for using {mapping['name']}!**\n    \"\"\"\n    return description\n\n"}
{"task_id": "valid/98", "completion": "\n    if n < 0:\n        return '-' + dec_to_ternary(-n)\n    if n == 0:\n        return '0'\n    ternary = ''\n    while n > 0:\n        ternary = str(n % 3) + ternary\n        n = n // 3\n    return ternary\n"}
{"task_id": "valid/99", "completion": "\n    return tuple(os.path.splitext(file_name)[1] for file_name in file_names)\n"}
{"task_id": "valid/100", "completion": "\n    if age < 0:\n        return \"Invalid age\"\n    elif age < 13:\n        return \"Child\"\n    elif age < 20:\n        return \"Teenager\"\n    elif age < 40:\n        return \"Young Adult\"\n    elif age < 65:\n        return \"Adult\"\n    else:\n        return \"Senior\"\n"}
{"task_id": "valid/101", "completion": "\n    if numerical_grade >= 90:\n        letter_grade = \"A\"\n        gpa = 4.0\n    elif numerical_grade >= 80:\n        letter_grade = \"B\"\n        gpa = 3.0\n    elif numerical_grade >= 70:\n        letter_grade = \"C\"\n        gpa = 2.0\n    elif numerical_grade >= 60:\n        letter_grade = \"D\"\n        gpa = 1.0\n    else:\n        letter_grade = \"F\"\n        gpa = 0.0\n\n    return letter_grade, gpa\n"}
{"task_id": "valid/102", "completion": "\n    total = 0\n    for item in listing:\n        total += item['price']\n    return total\n"}
{"task_id": "valid/103", "completion": "\n    vowels = 'aeiou'\n    result = {}\n    for palindrome in palindrome_tuples:\n        count = 0\n        for char in palindrome:\n            if char.lower() in vowels:\n                count += 1\n        result[palindrome] = count\n    return result\n"}
{"task_id": "valid/104", "completion": "\n    # Check if the string is empty\n    if not s:\n        return s\n\n    # Initialize an empty string to store the modified version\n    modified_string = \"\"\n\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char.lower() in \"aeiou\":\n            # Append the character to the modified string\n            modified_string += char\n        # Check if the character is a consonant\n        elif char.lower() in \"bcdfghjklmnpqrstvwxyz\":\n            # Append the character to the modified string\n            modified_string += char\n        # Check if the character is a space\n        elif char == \" \":\n            # Append the character to the modified string\n            modified_string += char\n\n    # Return the modified string\n    return modified_string\n"}
{"task_id": "valid/105", "completion": "\n    # Create a set to store the numbers we've seen so far\n    seen = set()\n\n    # Iterate through the array\n    for num in arr:\n        # Check if the negative of the current number is in the set\n        if -num in seen:\n            # If it is, we've found a pair that sums to 0\n            return True\n        # Add the current number to the set\n        seen.add(num)\n\n    # If we've gone through the entire array without finding a pair that sums to 0, return False\n    return False\n"}
{"task_id": "valid/106", "completion": "\n    latest_versions = {}\n    for dependency in dependencies:\n        package_name, version = dependency\n        version_number = int(version.split('_')[1])\n        if package_name not in latest_versions or version_number > latest_versions[package_name]:\n            latest_versions[package_name] = version_number\n    return [(package_name, f'{package_name}_{latest_versions[package_name]:03d}_auto_{datetime.now().strftime(\"%Y%m%d_%H%M\")}') for package_name in latest_versions]\n\ndependencies = [('package1', '0001_auto_20220101_0000'), ('package2', '0002_auto_20220101_0000'), ('package1', '0002_auto_20220102_0000'), ('package3', '0001_auto_20220101_0000')]"}
{"task_id": "valid/107", "completion": "\n    categorized_causes = {\n        \"action\": [],\n        \"result\": [],\n        \"the action\": [],\n        \"what the person was\": [],\n        \"and the unfortunate outcome\": []\n    }\n\n    for cause in causes:\n        for key in categorized_causes:\n            if key in cause:\n                categorized_causes[key].append(cause)\n\n    return categorized_causes\n"}
{"task_id": "valid/108", "completion": "\n    code_name = name.replace(\" \", \"-\").lower()\n    return code_name\n\n"}
{"task_id": "valid/109", "completion": "\n    return any(ord(char) > 127 for char in text)\n"}
{"task_id": "valid/110", "completion": "\n    punctuations = '''!()-[]{};:'\"\\,<>./?@#$%^&*_~'''\n    no_punct = \"\"\n    for char in string:\n        if char not in punctuations:\n            no_punct = no_punct + char\n    return no_punct\n"}
{"task_id": "valid/111", "completion": "\n    try:\n        return [num ** exp for num in num_list]\n    except TypeError:\n        print(\"Error: List must contain only numbers.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n"}
{"task_id": "valid/112", "completion": "\n    for row in grid:\n        print(min(row))\n"}
{"task_id": "valid/113", "completion": "\n    if n < 1 or not isinstance(n, int):\n        print(\"Please enter a positive integer value\")\n        return\n    if current_num > n:\n        return\n    if current_num % 2 == 0:\n        print(f\"Thank you for the {current_num}th even number\")\n    print_thank_you(n, current_num + 1)\n"}
{"task_id": "valid/114", "completion": "\n    count = 0\n    for i in range(len(lst)):\n        if lst[i] == element:\n            count += 1\n        else:\n            break\n    return count\n"}
{"task_id": "valid/115", "completion": "\n    if num < 0:\n        return False\n    if num == 0:\n        return True\n    base = int(base)\n    if base < 2 or base > 36:\n        raise ValueError(\"Base must be between 2 and 36\")\n    digits = set()\n    while num > 0:\n        digit = num % base\n        if digit in digits:\n            return False\n        digits.add(digit)\n        num //= base\n    return True\n\n"}
{"task_id": "valid/116", "completion": "\n    vowels = \"aeiouAEIOU\"\n    if not s:\n        return \"\"\n    if s[0] in vowels:\n        return remove_vowels_recursive(s[1:])\n    else:\n        return s[0] + remove_vowels_recursive(s[1:])\n"}
{"task_id": "valid/117", "completion": "\n    help_message = \"Usage: python cli.py [OPTIONS]\\n\\nOptions:\\n\"\n    for option, description in options:\n        help_message += f\"  -{option}, --{option}\\n    {description}\\n\"\n    return help_message\n"}
{"task_id": "valid/118", "completion": "\n    return input_string[0]\n"}
{"task_id": "valid/119", "completion": "\n    return {i: Val.count(i) for i in set(Val)}\n"}
{"task_id": "valid/120", "completion": "\n    return ~sample_bitset\n\n"}
{"task_id": "valid/121", "completion": "\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for char in s:\n        if char not in vowels:\n            return False\n    return True\n"}
{"task_id": "valid/122", "completion": "\n    count = 0\n    for i in range(len(sequence) - len(subsequence) + 1):\n        if sequence[i:i+len(subsequence)] == subsequence:\n            count += 1\n    return count\n"}
{"task_id": "valid/123", "completion": "\n    if h == 0:\n        return 0\n    if t == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    if h < 0:\n        h = -h\n    if t < 0:\n        t = -t\n    q = 0\n    while h >= t:\n        h -= t\n        q += 1\n    return q"}
{"task_id": "valid/124", "completion": "\n    return sum(x for x in input_list if x % 2 != 0)\n\n"}
{"task_id": "valid/125", "completion": "\n    consonants = 0\n    for char in string:\n        if char.isalpha() and char.lower() not in \"aeiou\":\n            consonants += 1\n    return consonants\n\n"}
{"task_id": "valid/126", "completion": "\n    # Calculate the number of electrons based on energy values\n    num_electrons = 0\n    for energy in grid_energies:\n        num_electrons += ados[energy] * np.exp(-energy / (k * T))\n\n    # Adjust doping levels\n    if num_electrons < 1e10:\n        num_doped_electrons = num_electrons\n    else:\n        num_doped_electrons = 1e10\n\n    # Calculate the Fermi energy\n    fermi_energy = np.interp(num_doped_electrons, ados, grid_energies)\n\n    # Calculate the density of states at the Fermi energy\n    dos_fermi = np.interp(fermi_energy, grid_energies, ados)\n\n    # Calculate the number of electrons in the conduction band\n    num_electrons_cb = num_doped_electrons * (1 - np.exp(-(grid_energies - fermi_energy) / (k * T)))\n\n    # Calculate the number of electrons in the valence band\n    num_electrons_vb = num_doped_electrons * np.exp(-(grid_energies - fermi_energy) / (k * T))\n\n    # Calculate the effective mass of the electrons in the conduction band\n    effective_mass_cb = np.sqrt((hbar**2) / (2 * m_e * dos_fermi))\n\n    # Calculate the effective mass of the electrons in the valence band\n    effective_mass_vb = np.sqrt((hbar**2) / (2 * m_e * dos_fermi))\n\n    # Calculate the carrier concentration\n    carrier_concentration = num_electrons_cb + num_electrons_vb\n\n    # Calculate the mobility of the electrons in the conduction band\n    mobility_cb = 1 / (e * (1 / effective_mass_cb**2 + 1 / effective_mass_vb**2))\n\n    # Calculate the mobility of the electrons in the valence band\n    mobility_vb = 1 / (e * (1 / effective_mass_cb**2 + 1 / effective_mass_vb**2))\n\n    # Calculate the resistivity of the material\n    resistivity = 1 / (carrier_concentration * (mobility_cb + mobility_vb))\n\n    # Calculate the Seebeck coefficient\n    seebeck_coefficient = (k * T) / (e * carrier_concentration * (mob"}
{"task_id": "valid/127", "completion": "\n    return tuple(set(tuple_to_process))\n\n"}
{"task_id": "valid/128", "completion": "\n    arr.sort()\n    n = len(arr)\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    result = []\n    while left or right:\n        if left:\n            result.append(left.pop())\n        if right:\n            result.append(right.pop())\n    return result\n"}
{"task_id": "valid/129", "completion": "\n    color_dict = {}\n    for color in color_list:\n        color_dict[color[0]] = color[1]\n    return color_dict\n"}
{"task_id": "valid/130", "completion": "\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "valid/131", "completion": "\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n            if len(unique_elements) == 3:\n                break\n    return unique_elements\n"}
{"task_id": "valid/132", "completion": "\n    # Sort the fruit list in lexicographical order\n    sorted_fruit_list = sorted(fruit_list)\n\n    # Create a string with the sorted fruit list\n    fruit_string = ', '.join(sorted_fruit_list)\n\n    return fruit_string\n\n"}
{"task_id": "valid/133", "completion": "\n    sublists = []\n    for i in range(len(lst) + 1):\n        for j in range(i + 1):\n            sublists.append(lst[j:i])\n    return sublists\n"}
{"task_id": "valid/134", "completion": "\n    pattern = r'\\d+\\.\\d+'\n    return bool(re.match(pattern, string))\n\n"}
{"task_id": "valid/135", "completion": "\n\nfrom django.db import migrations, models\n"}
{"task_id": "valid/136", "completion": "\n    common_elements = set(list1) & set(list2)\n    return sum(common_elements)\n"}
{"task_id": "valid/137", "completion": "\n    forecast_period = math.ceil(len(df) * 0.01)\n    return forecast_period\n\n"}
{"task_id": "valid/138", "completion": "\n    return sorted(array, key=lambda x: x[attr])\n"}
{"task_id": "valid/139", "completion": "\n    start = (page_number - 1) * items_per_page\n    end = start + items_per_page\n    return items[start:end]\n\n"}
{"task_id": "valid/140", "completion": "\n    result = []\n    carry = 0\n    for i in range(len(n_str) - 1, -1, -1):\n        digit = int(n_str[i])\n        product = digit * 2 + carry\n        carry = product // 10\n        result.append(str(product % 10))\n    if carry > 0:\n        result.append(str(carry))\n    return ''.join(result[::-1])\n"}
{"task_id": "valid/141", "completion": "\n    presets = {\n        \"home\": (0.0, 0.0, 0.0),\n        \"position1\": (0.1, 0.2, 0.3),\n        \"position2\": (0.4, 0.5, 0.6),\n        \"position3\": (0.7, 0.8, 0.9),\n    }\n    return presets.get(preset_name, (0.0, 0.0, 0.0))\n"}
{"task_id": "valid/142", "completion": "\n    common_elements = set(list1) & set(list2)\n    if common_elements:\n        return reduce(lambda x, y: x * y, common_elements)\n    else:\n        return 0\n"}
{"task_id": "valid/143", "completion": "\n    if allow_multiple_answer:\n        return \"Allow multiple answer\"\n    else:\n        return \"Allow single answer\""}
{"task_id": "valid/144", "completion": "\n    return math.floor(num)\n\n"}
{"task_id": "valid/145", "completion": "\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in sentence if char not in vowels])\n"}
{"task_id": "valid/146", "completion": "\n    def is_alphabetic_key(key):\n        return all(c.isalpha() for c in key)\n\n    def merge_dicts(a, b):\n        merged = a.copy()\n        merged.update(b)\n        return merged\n\n    def merge_objects(a, b):\n        merged = {}\n        for key in set(a.keys()).union(b.keys()):\n            if key in a and key in b:\n                if isinstance(a[key], dict) and isinstance(b[key], dict):\n                    merged[key] = merge_objects(a[key], b[key])\n                else:\n                    merged[key] = b[key]\n            elif key in a:\n                merged[key] = a[key]\n            else:\n                merged[key] = b[key]\n        return merged\n\n    def sort_dict(d):\n        return {k: d[k] for k in sorted(d.keys())}\n\n    def clean_key(key):\n        return ''.join(filter(str.isalpha, key))\n\n    def clean_objects(obj):\n        if isinstance(obj, dict):\n            return {clean_key(key): clean_objects(value) for key, value in obj.items() if is_alphabetic_key(key)}\n        elif isinstance(obj, list):\n            return [clean_objects(item) for item in obj]\n        else:\n            return obj\n\n    a = clean_objects(a)\n    b = clean_objects(b)\n    merged = merge_objects(a, b)\n    sorted_merged = sort_dict(merged)\n    return sorted_merged\n"}
{"task_id": "valid/147", "completion": "\n    try:\n        max_value = max(d.values())\n        return max_value\n    except ValueError:\n        return \"The dictionary is empty or does not contain any values\"\n    except TypeError:\n        return \"The dictionary contains non-numeric values\"\n"}
{"task_id": "valid/148", "completion": "\n    return sum(dict[key]) / len(dict[key])\n\n"}
{"task_id": "valid/149", "completion": "\n    if string is None or string == \"\":\n        return string\n    else:\n        return string.replace('e', '*')\n"}
{"task_id": "valid/150", "completion": "\n    # Create a min heap of size n\n    heap = []\n    for item in lst:\n        # If the heap is full, remove the largest item\n        if len(heap) == n:\n            heapq.heappop(heap)\n        # Add the current item to the heap\n        heapq.heappush(heap, item)\n    # Return the heap as a list\n    return heap\n\n"}
{"task_id": "valid/151", "completion": "\n    return x % 2 == 0 and gcd(x, 2) == 1\n\n"}
{"task_id": "valid/152", "completion": "\n    return date + datetime.timedelta(days=10)\n\n"}
