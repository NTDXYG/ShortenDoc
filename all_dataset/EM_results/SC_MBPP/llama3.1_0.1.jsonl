{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    s.remove(ch)\n    s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    return sorted(M, key=sum)\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the text into words\n    words = words.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the most common word and its count\n    most_common_word = word_counts.most_common(1)\n    \n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'[a-z]+', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    # Use regular expression to find all sequences of lowercase letters joined with an underscore\n    pattern = r\"[a-z]+_[a-z]+\"\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string2]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # A Woodall number is a number of the form 2^(2^k) - 1 for some integer k.\n    # So, we need to check if the given number can be written in this form.\n    # We can do this by checking if the number is one less than a power of 2.\n    # We can use the bitwise AND operator (&) to check if a number is a power of 2.\n    # If a number is a power of 2, then it has only one bit set to 1 in its binary representation.\n    # So, if we do a bitwise AND operation with the number minus 1, the result should be 0.\n    # If the result is not 0, then the number is not a power of 2, and therefore not a Woodall number.\n    return (x & (x - 1)) == 0 and x != 0\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i for i in range(n, n * (m + 1), n)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(lst) for lst in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize product as 1\n    product = 1\n\n    # Iterate over the dictionary\n    for num, count in freq.items():\n        # If the count is 1, multiply the product by the number\n        if count == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # Taking advantage of symmetry\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element has odd frequency, return None\n    return None\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a max heap to store the top k integers\n    max_heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the max heap\n        heapq.heappush(max_heap, (-count, num))\n\n    # Pop the top k integers from the max heap\n    top_k = []\n    for _ in range(k):\n        if max_heap:\n            top_k.append(heapq.heappop(max_heap)[1])\n\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    # Calculate the sum of the first N natural numbers\n    total_sum = N * (N + 1) // 2\n    \n    # Calculate the sum of the numbers in the array\n    array_sum = sum(ar)\n    \n    # The missing number is the difference between the total sum and the array sum\n    missing_number = total_sum - array_sum\n    \n    return missing_number\n"}
{"task_id": "MBPP/35", "completion": "\n    i = 1\n    while True:\n        rect_num = i * (i + 1) // 2\n        if rect_num == n:\n            return i\n        elif rect_num > n:\n            return None\n        i += 1\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a decimal\n    decimal = p / q\n    \n    # Convert the decimal to a string\n    decimal_str = str(decimal)\n    \n    # Remove the leading 0.\n    decimal_str = decimal_str[2:]\n    \n    # Find the nth digit\n    nth_digit = decimal_str[N-1]\n    \n    return nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Use the sorted function with a custom key function to sort the list\n    # The key function returns the first element of each item in the list\n    # If the item is a string, it returns the string itself\n    # If the item is an integer, it returns the integer\n    sorted_list = sorted(mixed_list, key=lambda x: (isinstance(x, str), x))\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even_count = 0\n    odd_count = 0\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if even_count > odd_count:\n        return \"Even\"\n    elif even_count < odd_count:\n        return \"Odd\"\n    else:\n        return \"Equal\"\n"}
{"task_id": "MBPP/39", "completion": "\n    counter = Counter(S)\n    max_heap = []\n    for char, freq in counter.items():\n        heapq.heappush(max_heap, (-freq, char))\n    while len(max_heap) > 1:\n        freq1, char1 = heapq.heappop(max_heap)\n        freq2, char2 = heapq.heappop(max_heap)\n        if freq1 != -1:\n            print(char1, end=\"\")\n            freq1 += 1\n            heapq.heappush(max_heap, (freq1, char1))\n        if freq2 != -1:\n            print(char2, end=\"\")\n            freq2 += 1\n            heapq.heappush(max_heap, (freq2, char2))\n    if max_heap:\n        print(max_heap[0][1])\n    return \"\"\n\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = list(chain(*nums))\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"[a-z]+_[a-z]+\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    match = re.match(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in range(1, len(x)):\n        result = gcd(result, x[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(A) % factorial(B)\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n >> 1\n"}
{"task_id": "MBPP/49", "completion": "\n    return [nums[i][0] for i in range(N)]\n\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if len(str) == 0:\n        return False\n    return str[0] == str[-1]\n"}
{"task_id": "MBPP/54", "completion": "\n    # Create a count array to store the count of individual elements\n    count = [0] * (max(my_list) + 1)\n    \n    # Count the occurrences of each element in the input array\n    for num in my_list:\n        count[num] += 1\n    \n    # Modify the count array such that each element at position 'i' now contains the actual position of the element 'i' in the output array\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # Build the output array\n    output = [0] * len(my_list)\n    for num in my_list:\n        output[count[num] - 1] = num\n        count[num] -= 1\n    \n    return output\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    rev_num = 0\n    temp = n\n    while temp > 0:\n        rev_num = rev_num * 10 + temp % 10\n        temp = temp // 10\n    return n == 2 * rev_num - 1\n\n"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    max_num = 0\n    for i in range(n-1, -1, -1):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 1) // 2\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    max_len = 1\n    prev = arr[0]\n    curr = 1\n    for i in range(1, n):\n        if abs(arr[i] - prev) == 1:\n            curr += 1\n        else:\n            max_len = max(max_len, curr)\n            curr = 1\n        prev = arr[i]\n    return max(max_len, curr)\n"}
{"task_id": "MBPP/61", "completion": "\n    # Initialize a dictionary to store the count of substrings with sum equal to length\n    count = defaultdict(int)\n    # Initialize a variable to store the total count\n    total_count = 0\n    # Iterate over the string\n    for i in range(n):\n        # Initialize a variable to store the sum of the current substring\n        sum = 0\n        # Iterate over the substring starting from the current character\n        for j in range(i, n):\n            # Add the current digit to the sum\n            sum += int(s[j])\n            # If the sum is equal to the length of the substring, increment the count\n            if sum == j - i + 1:\n                total_count += 1\n    # Return the total count\n    return total_count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize the minimum and maximum values\n    min_val = test_list[0]\n    max_val = test_list[0]\n    \n    # Initialize the maximum difference\n    max_diff = 0\n    \n    # Iterate over the sorted list\n    for num in test_list:\n        # Update the minimum value\n        min_val = min(min_val, num)\n        \n        # Update the maximum difference\n        max_diff = max(max_diff, num - min_val)\n        \n        # Update the maximum value\n        max_val = max(max_val, num)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n\nsubjectmarks = [('Math', 90), ('Science', 85), ('English', 95), ('History', 80)]"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    return sum(bell_number(n - i) for i in range(n + 1))  # This is the recursive formula for Bell numbers\n\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n\n    for i in range(n - 1):\n        if A[i] > A[i + 1]:\n            increasing = False\n        if A[i] < A[i + 1]:\n            decreasing = False\n\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    return all(len(i) == k for i in Input)\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    else:\n        return (int((n**0.5) + 0.5))**2 - (int((n**0.5) - 0.5))**2 == n\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,\\s]+'\n    \n    # Split the text using the delimiters\n    result = re.split(delimiters, text)\n    \n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum - odd_sum\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        # Convert integer to binary and remove the '0b' prefix\n        binary = bin(i)[2:]\n        # Count the number of '1's in the binary representation\n        set_bits = binary.count('1')\n        # Check if the number of set bits is odd\n        if set_bits % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max((n - 1 for n in range(N) if n < N), default=None)\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a flag to track if the number is undulating\n    is_undulating = False\n    \n    # Iterate over the digits in the number\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is less than the next digit\n        if int(str_n[i]) < int(str_n[i + 1]):\n            # If it is, set the flag to True\n            is_undulating = True\n        # If the current digit is greater than the next digit, break the loop\n        elif int(str_n[i]) > int(str_n[i + 1]):\n            break\n    \n    # Return the flag\n    return is_undulating\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    # Return the index of the first element in the sorted list\n    return sorted_list[0][0]\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    min_length_sublist = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_length_sublist = sublist\n    return min_length_sublist\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n)[2:]\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('_[a-z]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    # Initialize the result\n    result = 0\n    \n    # Calculate the sum of the first n natural numbers\n    for i in range(1, n + 1):\n        # Add the sum of the first i natural numbers to the result\n        result += (i * (i + 1)) // 2\n    \n    # Calculate the sum of the first m natural numbers\n    for i in range(1, m + 1):\n        # Subtract the sum of the first i natural numbers from the result\n        result -= (i * (i + 1)) // 2\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/104", "completion": "\n    return [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup = list(test_tup)\n    \n    # Add the list to the tuple\n    test_tup.extend(test_list)\n    \n    # Return the resulting list\n    return test_tup\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap to store the elements from the three lists\n    min_heap = []\n    # Push the first element from each list into the heap along with the list index and element index\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 1, 0))\n    heapq.heappush(min_heap, (num3[0], 2, 0))\n\n    # Initialize an empty list to store the merged sorted elements\n    merged_sorted_list = []\n\n    # Continue the process until the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        element, list_index, element_index = heapq.heappop(min_heap)\n        # Append the popped element to the merged sorted list\n        merged_sorted_list.append(element)\n\n        # If there are more elements in the list from which the element was popped, push the next element into the heap\n        if element_index + 1 < len(num1) and list_index == 0:\n            heapq.heappush(min_heap, (num1[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num2) and list_index == 1:\n            heapq.heappush(min_heap, (num2[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num3) and list_index == 2:\n            heapq.heappush(min_heap, (num3[element_index + 1], list_index, element_index + 1))\n\n    # Return the merged sorted list\n    return merged_sorted_list\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(int(s[i:], 2) + int(s[:i], 2)).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    for i in range(strt_val, stop_val):\n        if i not in test_list:\n            missing_ranges.append(i)\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius * (radius + height)\n\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    return all(not dict1 for dict1 in list1)\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list if isinstance(i, (int, float))]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split(')(')\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if arr[mid] == arr[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return arr[low]\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for pair in list1:\n        product = pair[0] * pair[1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize the count of smart numbers\n    count = 0\n    # Initialize the number to check\n    num = 1\n    # Loop until we find the nth smart number\n    while True:\n        # Check if the number is smart\n        if isSmart(num):\n            # If it is, increment the count\n            count += 1\n            # If this is the nth smart number, return it\n            if count == n:\n                return num\n        # Move on to the next number\n        num += 1\n\n"}
{"task_id": "MBPP/123", "completion": "\nFind the sum of proper divisors of n.\"\"\"\n        sum_divisors = sum(i for i in range(1, n) if n % i == 0)\n        return sum_divisors\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        sum_divisors = find_amicable(i)\n        if sum_divisors != i and find_amicable(sum_divisors) == i:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)\n\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    curr_diff = 0\n    for i in range(n):\n        if string[i] == '0':\n            curr_diff -= 1\n        else:\n            curr_diff += 1\n        max_diff = max(max_diff, curr_diff)\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Initialize a variable to store the sum of common divisors\n    sum_divisors = 0\n    \n    # Iterate over all numbers from 1 to the minimum of a and b\n    for i in range(1, min(a, b) + 1):\n        # Check if i is a divisor of both a and b\n        if a % i == 0 and b % i == 0:\n            # If i is a common divisor, add it to the sum\n            sum_divisors += i\n    \n    # Return the sum of common divisors\n    return sum_divisors\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    while y > 0:\n        if y % 2 == 1:\n            result += x\n        x = x << 1\n        y = y >> 1\n    return result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    n = len(my_matrix)\n    if n != len(my_matrix[0]):\n        return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum(my_matrix[i][::-1]):\n            return False\n    for i in range(n):\n        if sum(my_matrix[i]) != sum([my_matrix[j][i] for j in range(n)]):\n            return False\n    if sum(my_matrix[i][i] for i in range(n)) != sum(my_matrix[i][n - i - 1] for i in range(n)):\n        return False\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each item\n    freq_dict = defaultdict(int)\n    \n    # Iterate over the list to count the frequency of each item\n    for num in nums:\n        freq_dict[num] += 1\n    \n    # Find the item with maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n    \n    return max_freq_item\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left = 0\n    right = len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(num for num in nums if num < 0)\n"}
{"task_id": "MBPP/134", "completion": "\n    for _ in range(p):\n        arr[-1] = arr[-1] % n\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    # Define the base rate\n    base_rate = 0.15\n    # Define the rate for each unit\n    rate_per_unit = 0.05\n    # Calculate the total bill\n    total_bill = (units * rate_per_unit) + (units * base_rate)\n    return total_bill\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of boolean values\n    bool_array = array('b', [num == 0 for num in nums])\n    # Count the number of zeroes\n    zero_count = bool_array.count(0)\n    # Return the ratio of zeroes\n    return zero_count / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0' other than the first digit\n    return '0' not in binary[1:]  # [1:] to exclude the first digit which is always '1' in binary representation of a positive number\n\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for element in test_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    # Create a list to store the elements that occur singly\n    singly_list = []\n    for key, value in freq_dict.items():\n        if value == 1:\n            singly_list.append(key)\n\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:size]))\n        # If the maximum element is not at the beginning of the unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip the maximum element to the beginning\n            nums[:max_index + 1] = nums[:max_index + 1][::-1]\n            # Flip the unsorted part of the list\n            nums[:size] = nums[:size][::-1]\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for same pairs\n    same_pairs = 0\n    \n    # Iterate over the first list\n    for i in range(len(list1)):\n        # Iterate over the second list\n        for j in range(len(list2)):\n            # Check if the pair is the same in the third list\n            if (list1[i], list2[j]) in [(list3[k], list3[l]) for k in range(len(list3)) for l in range(k+1, len(list3))]:\n                # If the pair is the same, increment the counter\n                same_pairs += 1\n                \n    # Return the count of same pairs\n    return same_pairs\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_diff += abs(arr[i] - arr[j])\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Initialize the maximum difference\n    max_diff = 0\n    \n    # Iterate over the array to find the maximum difference\n    for i in range(1, n):\n        # Calculate the difference between the current element and the previous element\n        diff = arr[i] - arr[i-1]\n        \n        # Update the maximum difference if the current difference is greater\n        max_diff = max(max_diff, diff)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(c) for c in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 1):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    if x < 10:\n        return x\n    else:\n        return max(x % 10 + sum_digits_single(x // 10), sum_digits_single(x // 10))\n\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    n = 1\n    while True:\n        if a * n + b == c:\n            return True\n        elif a * n + b < c:\n            n += 1\n        else:\n            return False\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1:\n        return x\n    mid = len(x) // 2\n    left_half = merge_sort(x[:mid])\n    right_half = merge_sort(x[mid:])\n    return merge(left_half, right_half)\n\n"}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    specified = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                specified.append(nums[i][j])\n    return specified\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is even (0), toggle it to 1, otherwise toggle it to 0\n        result += '1' if int(bit) % 2 == 0 else '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    # Split the string into a list of strings\n    str_list = tuple_str.split(',')\n    \n    # Convert each string to an integer and store in a list\n    int_list = [int(i) for i in str_list]\n    \n    # Convert the list to a tuple\n    int_tuple = tuple(int_list)\n    \n    return int_tuple\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    if k == 1:\n        return n - 1\n    if k == 2:\n        return n - 2\n    if k == 3:\n        return n - 3\n    if k == 4:\n        return n - 4\n    if k == 5:\n        return n - 5\n    if k == 6:\n        return n - 6\n    if k == 7:\n        return n - 7\n    if k == 8:\n        return n - 8\n    if k == 9:\n        return n - 9\n    if k == 10:\n        return n - 10\n    if k == 11:\n        return n - 11\n    if k == 12:\n        return n - 12\n    if k == 13:\n        return n - 13\n    if k == 14:\n        return n - 14\n    if k == 15:\n        return n - 15\n    if k == 16:\n        return n - 16\n    if k == 17:\n        return n - 17\n    if k == 18:\n        return n - 18\n    if k == 19:\n        return n - 19\n    if k == 20:\n        return n - 20\n    if k == 21:\n        return n - 21\n    if k == 22:\n        return n - 22\n    if k == 23:\n        return n - 23\n    if k == 24:\n        return n - 24\n    if k == 25:\n        return n - 25\n    if k == 26:\n        return n - 26\n    if k == 27:\n        return n - 27\n    if k == 28:\n        return n - 28\n    if k == 29:\n        return n - 29\n    if k == 30:\n        return n - 30\n    if k == 31:\n        return n - 31\n    if k == 32:\n        return n - 32\n    if k == 33:\n        return n - 33\n    if k == 34:\n        return n - 34\n    if k == 35:\n       "}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    else:\n        return x * (n // gcd), y * (n // gcd)\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    sum = 0\n    x = 1\n    while n - x >= 0:\n        sum += n - x\n        x += 2\n    return sum\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s ** 2) * tan(pi / l) / (4 * tan(pi / l))\n\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_div = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_div += i\n    return sum_div\n\n"}
{"task_id": "MBPP/165", "completion": "\n    char_count = {}\n    for i in range(len(str1)):\n        char = str1[i]\n        if char.isalpha():\n            if char.islower():\n                char = char.upper()\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])  # Include n in the range\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    s = s.lower()\n    return s.count('s'), s.count('t'), s.count('d')  # return a tuple of counts\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^A-Za-z0-9]+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] != L[j] and L[i] <= R <= lcm(L[i], L[j]):\n                return [L[i], L[j]]\n    return None\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Initialize the sum of divisors\n    sum_divisors = 0\n    \n    # Loop through all numbers from 1 to x\n    for i in range(1, x):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If it is, add it to the sum of divisors\n            sum_divisors += i\n    \n    # Check if the sum of divisors is equal to the number\n    if sum_divisors == x:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude to radians\n    slat, slon = radians(slat), radians(slon)\n    elat, elon = radians(elat), radians(elon)\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n\n    # Radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate distance\n    distance = R * c\n\n    return distance\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Define the pattern for uppercase, special character and numeric values\n    pattern = r\"[A-Z]|[a-z]|[0-9]|[@#$%^&*()_+=-{};:'<>,./?]\"\n    \n    # Use findall to find all matches of the pattern in the string\n    matches = re.findall(pattern, string)\n    \n    # Return the matches\n    return matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    count = 0\n    i = 0\n    j = 1\n    while j < n:\n        if arr[j] - arr[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif arr[j] - arr[i] < k:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus\n    focus = (0, focal_length)\n    \n    return focus\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequence of substrings.\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the table in bottom-up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index + 1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character is part of LCS\n        if X[i - 1] == Y[j - 1]:\n            lcs[index - 1] = X[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    elif n == 0 or n == 1:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if n % (i * i) == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers in the array\n    num_set = set()\n    \n    # Iterate over the array and add the positive numbers to the set\n    for num in arr:\n        if 1 <= num <= n:\n            num_set.add(num)\n    \n    # Initialize the missing number to 1\n    missing_num = 1\n    \n    # Iterate from 1 to n and check if the number is in the set\n    while missing_num <= n:\n        if missing_num not in num_set:\n            return missing_num\n        missing_num += 1\n    \n    # If all numbers from 1 to n are in the set, return n + 1\n    return missing_num\n"}
{"task_id": "MBPP/190", "completion": "\n    # Define the square's boundaries\n    x_min, x_max = min(x1, x2), max(x1, x2)\n    y_min, y_max = min(y1, y2), max(y1, y2)\n\n    # Initialize the count of integral points\n    count = 0\n\n    # Iterate over all integral points in the square\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            # Check if the point is integral\n            if x == int(x) and y == int(y):\n                count += 1\n\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if any(char.isalpha() for char in str) and any(char.isdigit() for char in str):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            # If the element is found, check if it's the first occurrence\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            # If it's not the first occurrence, move the high pointer to mid - 1\n            high = mid - 1\n        elif arr[mid] < x:\n            # If the element is greater than the middle element, move the low pointer to mid + 1\n            low = mid + 1\n        else:\n            # If the element is less than the middle element, move the high pointer to mid - 1\n            high = mid - 1\n    # If the element is not found, return -1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Initialize the result as 1\n    result = 1\n    # Iterate over the elements of the first tuple\n    for i in test_tup1:\n        # For each element, multiply the result by the corresponding element in the second tuple\n        result *= test_tup2[i]\n    # Return the final result\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major and semi-minor axes of the ellipse\n    a = a\n    b = b\n\n    # Calculate the area of the largest triangle that can be inscribed in the ellipse\n    area = (math.pi * a * b) / 4\n\n    return area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (n > 1):\n        n = n // 2\n        i += 1\n    return 2 ** i\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    # Initialize an empty list to store the inversion elements\n    inversion_list = []\n    \n    # Iterate over the tuple list\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the remaining elements in the tuple\n            for j in range(i + 1, len(tup)):\n                # Check if the current element is greater than the next element\n                if tup[i] > tup[j]:\n                    # If true, append the inversion to the list\n                    inversion_list.append((tup[i], tup[j]))\n    \n    # Return the list of inversion elements\n    return inversion_list\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for tup in test_tup:\n        new_tup = []\n        for i in range(len(tup)):\n            if i == 0:\n                new_tup.append(tup[i])\n            elif i == len(tup) - 1:\n                new_tup.append(tup[i])\n            else:\n                new_tup.append(tup[i] + tup[i - 1] + tup[i + 1])\n        result.append(new_tup)\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for gap in range(1, n):\n        for i in range(n - gap):\n            j = i + gap\n            if str[i] == str[j] and i != j:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            elif str[i] == str[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(n):\n        if (i & n) == (i & (i & n)):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum(i**4 for i in range(1, n+1))\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return test_tup1 + test_tup2\n"}
{"task_id": "MBPP/214", "completion": "\n    return math.degrees(radian)\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        value = alist[i + 1]\n        decoded_list.extend([value] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    return all(isinstance(i, list) and check_subset_list(i, list2) for i in list1) or \\\n           all(isinstance(i, list) and check_subset_list(i, list2) for i in list2) or \\\n           set(list1).issubset(set(list2))\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str:\n        if char_count[char] > 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    \n    # If the difference is 0, no operations are required\n    if diff == 0:\n        return 0\n    \n    # If the difference is 1, one operation is required\n    elif diff == 1:\n        return 1\n    \n    # If the difference is greater than 1, the minimum number of operations is the difference minus 1\n    else:\n        return diff - 1\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple into a list\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the minimum k elements\n    min_k = test_list[:K]\n    \n    # Extract the maximum k elements\n    max_k = test_list[-K:]\n    \n    # Return the minimum and maximum k elements\n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas or dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n    \n    # If there are less than n matches, replace all matches\n    if len(matches) <= n:\n        text = re.sub(pattern, ':', text)\n    else:\n        # Otherwise, replace n matches\n        text = re.sub(pattern, ':', text, n)\n    \n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if not isinstance(test_tuple, tuple):\n        raise TypeError(\"Input is not a tuple\")\n    data_type = type(test_tuple[0])\n    for element in test_tuple:\n        if not isinstance(element, data_type):\n            return False\n    return True\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count to 0\n    count = 0\n    # Traverse the array\n    for i in range(n):\n        # If the current element is equal to x, increment the count\n        if arr[i] == x:\n            count += 1\n        # If the current element is not equal to x, decrement the count\n        else:\n            count -= 1\n        # If the count becomes zero, reset it to 1\n        if count == 0:\n            count = 1\n    # Return True if the count is greater than zero, else return False\n    return count > 0\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    if high < low:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    elif arr[mid] < arr[low]:\n        return find_Min(arr, low, mid - 1)\n    else:\n        return arr[mid]\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for i, char in enumerate(str) if i % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Pad the binary string with leading zeros to make it of length r-l+1\n    binary = binary.zfill(r-l+1)\n    \n    # Check if all the bits in the given range are unset\n    return all(bit == '0' for bit in binary[l-1:r])\n"}
{"task_id": "MBPP/229", "completion": "\n    return sorted(arr, key=lambda x: (x < 0, x))\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Create a 2D list to store the maximum sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of the dp table\n    for i in range(n):\n        dp[0][i] = tri[0][i]\n        if i > 0:\n            dp[i][0] = tri[i][0] + dp[i-1][0]\n    \n    # Fill the dp table in a bottom-up manner\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum at position (i, j) is the maximum of the sum of the current number and the maximum sum of the two numbers above it\n            dp[i][j] = tri[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # The maximum sum in the triangle is stored in the bottom-right corner of the dp table\n    return dp[n-1][n-1]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of equilateral triangles that can be formed\n    # The formula is (N * (N - 1) * (N - 2)) / 6\n    # This is because each triangle has 3 vertices, and we need to choose 3 vertices from N vertices\n    # The formula is derived from the combination formula C(n, k) = n! / (k! * (n - k)!)\n    # In this case, n = N and k = 3\n    return (N * (N - 1) * (N - 2)) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(tuple(sorted(record)) for record in test_list)\n    # Find the maximum count\n    max_count = max(record_count.values())\n    # Find the records with the maximum count\n    max_records = [record for record, count in record_count.items() if count == max_count]\n    return max_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    # Initialize a list to store the number of sequences of length i\n    dp = [0] * (n + 1)\n    \n    # There is only one way to have a sequence of length 0\n    dp[0] = 1\n    \n    # Iterate over the length of the sequence\n    for i in range(1, n + 1):\n        # Initialize the number of sequences of length i to 0\n        dp[i] = 0\n        # Iterate over the possible previous element\n        for j in range(1, m // 2 + 1):\n            # If the previous element is less than or equal to m // 2, we can append j to the sequence\n            if j <= m // 2:\n                dp[i] += dp[i - 1]\n    \n    # Return the total number of sequences of length n\n    return dp[n] % (10 ** 9 + 7)  # Use modulo to prevent overflow\n\n"}
{"task_id": "MBPP/240", "completion": "\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1] = list2\n        return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: (x[0], lst.count(x[0])))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    # Calculate the next integer greater than the square root\n    next_int = math.ceil(sqrt_N)\n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of increasing and decreasing sub-sequences\n    max_increasing = [0] * n\n    max_decreasing = [0] * n\n\n    # Initialize the maximum sum of increasing sub-sequence for the first element\n    max_increasing[0] = arr[0]\n\n    # Initialize the maximum sum of decreasing sub-sequence for the first element\n    max_decreasing[0] = arr[0]\n\n    # Iterate over the array from the second element to the last element\n    for i in range(1, n):\n        # Update the maximum sum of increasing sub-sequence for the current element\n        max_increasing[i] = max(max_increasing[i-1], max_decreasing[i-1] + arr[i])\n\n        # Update the maximum sum of decreasing sub-sequence for the current element\n        max_decreasing[i] = max(max_decreasing[i-1], max_increasing[i-1] - arr[i])\n\n    # Return the maximum sum of bi-tonic sub-sequence\n    return max(max_increasing[n-1], max_decreasing[n-1])  # Changed to max_increasing[n-1] and max_decreasing[n-1] to get the correct result\n\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number\")\n    if number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.00001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n        \n    for length in range(2, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            \n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n                \n    return dp[0][n-1]\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(filter(lambda x: x in array_nums2, array_nums1))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] + list + [element]\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = []\n    for number in numbers:\n        r = cmath.polar(number)[0]\n        theta = cmath.polar(number)[1]\n        polar_coordinates.append((r, theta))\n    return polar_coordinates\n\n\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\ba\\w*\\b|\\bor\\w*\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum of the two maximum elements\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(\"Error: Division by zero is not allowed\")\n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # The first year of a dog's life is equal to 15 human years\n    human_years = h_age\n    # Each additional year after the first year is equal to 4 human years\n    dog_years = human_years + (human_years - 1) * 4\n    return dog_years\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    # Initialize sum variable\n    sum_squares = 0\n    \n    # Loop through odd numbers from 1 to n\n    for i in range(1, n+1):\n        # Check if the number is odd\n        if i % 2 != 0:\n            # Add the square of the odd number to the sum\n            sum_squares += i ** 2\n    \n    # Return the sum of squares\n    return sum_squares\n"}
{"task_id": "MBPP/268", "completion": "\n    star_num = 0\n    i = 1\n    while True:\n        star_num += i\n        if star_num == n:\n            return i\n        i += 1\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    even_sum = 0\n    for i in range(2, n+1, 2):\n        even_sum += i ** 5\n    return even_sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return test_list[-1]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a[n] + m) % (n + 1)\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return len(test_tup) - 1\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * (10 * n - 9) // 2\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is greater than or equal to the digit itself, return False\n        if count >= int(digit):\n            return False\n    \n    # If the function has not returned False, return True\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.fullmatch(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Initialize the left and right pointers for the sliding window\n    left = 0\n    right = 0\n\n    # Traverse the array\n    while right < n:\n        # Add the current element to the current sum\n        current_sum += a[right]\n\n        # If the window size is greater than k, remove the leftmost element from the current sum\n        if right - left + 1 > k:\n            current_sum -= a[left]\n            left += 1\n\n        # Update the maximum sum\n        max_sum = max(max_sum, current_sum)\n\n        # Move the right pointer to the next element\n        right += 1\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    sum = 0\n    for i in range(2, n*2+1, 2):\n        sum += i**2\n    return sum\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate the number of odd days in a year\n    odd_days = 0\n    for i in range(1, N+1):\n        if i % 2 != 0:\n            odd_days += 1\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = [lst]\n        elif len(lst) == max_len:\n            max_list.append(lst)\n    return max_list\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from the 3rd post to the nth post\n    for i in range(3, n + 1):\n        # The number of ways to paint the ith post is the sum of the number of ways to paint the (i-1)th post and the (i-2)th post\n        # because we can paint the ith post with the same color as the (i-1)th post or the (i-2)th post\n        ways[i] = ways[i - 1] + ways[i - 2]\n\n    # Return the number of ways to paint the nth post\n    return ways[n] % (10 ** 9 + 7)  # To avoid overflow, we use the modulo operator to get the remainder of the division by 10^9 + 7\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [i for i in range(1, number + 1) if number % i == 0]\n    return sum(divisors)\n"}
{"task_id": "MBPP/296", "completion": "\n    # Create a copy of the array\n    arr_copy = arr.copy()\n    # Sort the array\n    arr_copy.sort()\n    # Initialize inversion count\n    inv_count = 0\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is not equal to the sorted element at the same index\n        if arr[i] != arr_copy[i]:\n            # Increment the inversion count\n            inv_count += 1\n    # Return the inversion count\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    return [element for element in l1 if element in l2]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_dict = defaultdict(int)\n    \n    # Iterate over each tuple in the list\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_dict[num] = max(max_dict[num], aggregate)\n    \n    # Return the maximum aggregate\n    return max(max_dict.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return 2 * count_binary_seq(n - 1)\n\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    n = n & -n\n    return bin(n).count('1')\n"}
{"task_id": "MBPP/303", "completion": "\n    inversion_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversion_count += 1\n    return inversion_count\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Find the element at the given index after rotations\n    for i in range(rotations):\n        # Rotate the array\n        arr = [arr[-1]] + arr[:-1]\n        # Update the index\n        index = (index + 1) % len(arr)\n    return arr[index]\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = re.compile(r'^p')\n    return [word for word in words if pattern.match(word)]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    # Create a 2D table to store the maximum sum of increasing subsequence\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table in a bottom-up manner\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = a[i]\n            elif i == j:\n                dp[i][j] = a[i]\n            else:\n                # If the current element is greater than the previous element, include it in the subsequence\n                if a[i] > a[j - 1]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + a[i])\n                # If the current element is not greater than the previous element, exclude it from the subsequence\n                else:\n                    dp[i][j] = dp[i - 1][j]\n    \n    # Return the maximum sum of increasing subsequence including the kth element\n    return dp[n - 1][k - 1] if k <= n else -1\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Initialize a list to store the products\n    products = []\n    \n    # Iterate over the range of N\n    for i in range(N):\n        # Calculate the product of the current elements from both lists\n        product = nums1[i] * nums2[i]\n        \n        # Append the product to the list\n        products.append(product)\n    \n    # Return the list of products\n    return products\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    # Initialize the dp table\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n\n    # Fill the dp table\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[0][i-1], dp[1][i-1] + grid[0][i])\n        dp[1][i] = max(dp[1][i-1], dp[0][i-1] + grid[1][i])\n\n    # Return the maximum sum\n    return max(dp[0][n-1], dp[1][n-1])  # Return the maximum sum of the last row of the dp table\n\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) > max_len and len(word) % 2 == 0:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    result = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        result.append((key, count))\n    return result\n\n"}
{"task_id": "MBPP/318", "completion": "\n    s = int(s)\n    max_volume = 0\n    for a in range(1, s):\n        for b in range(a, s):\n            c = s - a - b\n            if a * b * c > max_volume:\n                max_volume = a * b * c\n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    # Use regex to find all five characters long word in the given string\n    pattern = r'\\b\\w{5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    square_of_sum = n * (n + 1) // 2 ** 2\n    return square_of_sum - sum_of_squares\n"}
{"task_id": "MBPP/321", "completion": "\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through the digits of the number\n    for i in range(len(s)):\n        # Add the digit to the demlo number\n        demlo += int(s[i])\n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # Create a new array with the first element of the original array\n        new_arr = [arr[0]]\n        # Add the first element of the original array to the new array\n        new_arr.append(arr[0])\n        # Add the rest of the array to the new array\n        new_arr.extend(arr[1:])\n        # Return the new array\n        return new_arr\n\n    # If the current element is positive, move it to the end of the array\n    if cur > 0:\n        # Move the current element to the end of the array\n        arr.append(arr.pop(0))\n    # If the current element is negative, move it to the beginning of the array\n    else:\n        # Move the current element to the beginning of the array\n        arr.insert(0, arr.pop(0))\n    # Recursively call the function with the updated array and the next element\n    return right_rotate(arr, n - 1, out_of_place, arr[0])\n"}
{"task_id": "MBPP/324", "completion": "\n    # Initialize the sum of alternate chains\n    sum_alternate = 0\n    \n    # Iterate over the tuples in the test tuple\n    for i in range(len(test_tuple)):\n        # Check if the index is even\n        if i % 2 == 0:\n            # If the index is even, add the value to the sum\n            sum_alternate += test_tuple[i]\n        else:\n            # If the index is odd, subtract the value from the sum\n            sum_alternate -= test_tuple[i]\n    \n    # Return the sum of alternate chains\n    return sum_alternate\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # Update the minimum number of squares for the current number\n            min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles\")\n    else:\n        print(\"The triangle is not isosceles\")\n"}
{"task_id": "MBPP/328", "completion": "\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return sum(1 for num in list if num < 0)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # reverse = None (Sorts in Ascending order)\n    # or reverse = True (Sorts in Descending order)\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n / 2) * (2 * a + (n - 1) * d)\n\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    # Define a regular expression pattern that matches a word followed by optional punctuation\n    pattern = r'\\b\\w+\\b[^\\w\\s]*'\n    \n    # Use the re.search function to search for the pattern in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the matched text\n    if match:\n        return match.group()\n    # If no match is found, return None\n    else:\n        return None\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty dictionary to store the frequency of each divisor\n    freq = {}\n    \n    # Iterate over all numbers from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, increment its frequency in the dictionary\n            freq[i] = freq.get(i, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq.values(), default=0)\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [i for i in freq if freq[i] == max_freq]\n    \n    # Return the maximum divisor\n    return max(max_divisors)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # We then filter out the non-positive numbers\n    positive_lst = [num for num in sorted_lst if num > 0]\n    \n    # If there are less than three positive numbers, we return the sum of all positive numbers\n    if len(positive_lst) < 3:\n        return sum(positive_lst)\n    \n    # Otherwise, we return the sum of the three smallest positive numbers\n    else:\n        return sum(positive_lst[:3])  # We use list slicing to get the first three elements of the list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    current_min = float('inf')\n    current_max = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        current_min = min(current_min, -max_heap[0].value)\n        current_max = max(current_max, min_heap[0].value)\n\n    while True:\n        min_node = heappop(min_heap)\n        max_node = -heappop(max_heap)\n        if min_node.index == len(list[min_node.list_num]) - 1:\n            return current_min, current_max\n        heappush(min_heap, Node(list[min_node.list_num][min_node.index + 1], min_node.list_num, min_node.index + 1))\n        heappush(max_heap, Node(-list[min_node.list_num][min_node.index + 1], min_node.list_num, min_node.index + 1))\n        current_min = min(current_min, -max_heap[0].value)\n        current_max = max(current_max, min_heap[0].value)\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    if len(nums) < 2:\n        return None\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    # Initialize the first row of the matrix\n    matrix = [[1 for _ in range(n)] for _ in range(k)]\n    \n    # Fill in the rest of the matrix\n    for i in range(1, k):\n        for j in range(1, n):\n            # The value at each position is the sum of the two values directly above it\n            matrix[i][j] = matrix[i-1][j-1] + matrix[i-1][j]\n    \n    # The entringer number is the value at the bottom right of the matrix\n    return matrix[-1][-1]\n"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < 0:\n        return 0\n    if (n, r) in memo:\n        return memo[(n, r)]\n    res = 0\n    for i in range(1, r + 1):\n        res += bin_coff(n - i, i - 1)\n    memo[(n, r)] = res\n    return res\n\nmemo = {}"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element occurring k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [x[:n] + x[n+1:] for x in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    # Import necessary modules\n    import math\n\n    # Define the function\n    def count_rectangles(radius):\n        # Calculate the area of the circle\n        circle_area = math.pi * (radius ** 2)\n\n        # Calculate the area of a single rectangle\n        rectangle_area = 1\n\n        # Calculate the number of rectangles that can fit in the circle\n        num_rectangles = circle_area / rectangle_area\n\n        # Return the number of rectangles\n        return num_rectangles\n\n    # Call the function\n    return count_rectangles(radius)\n"}
{"task_id": "MBPP/356", "completion": "\n    # Check if the sum of two angles is greater than 180\n    if a + b > 180:\n        return \"Invalid input: The sum of two angles cannot be greater than 180\"\n    # Calculate the third angle\n    c = 180 - a - b\n    return c\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = float('-inf')\n    for record in test_list:\n        for value in record:\n            if value > max_val:\n                max_val = value\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n    \n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n    \n    # Check if one root is twice of the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n + 1):\n        carol = carol * i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum occurrences\n    max_count = max(count_dict.values())\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_items\n"}
{"task_id": "MBPP/363", "completion": "\n    return [x + K for x in test_list]\n"}
{"task_id": "MBPP/364", "completion": "\n    flips = 0\n    for i in range(1, len(ch)):\n        if ch[i] != ch[i - 1]:\n            flips += 1\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    # Calculate the lateral surface area of a cuboid\n    lateral_surface_area = 2 * (l * w + w * h + h * l)\n    return lateral_surface_area\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))\n"}
{"task_id": "MBPP/371", "completion": "\n    # Initialize the smallest missing element as the left element\n    smallest_missing = left_element\n    \n    # Iterate over the array from the left element to the right element\n    for i in range(left_element, right_element + 1):\n        # If the current element is not equal to the index, it means the element is missing\n        if A[i] != i:\n            # Update the smallest missing element\n            smallest_missing = i\n            # Break the loop as we have found the smallest missing element\n            break\n    \n    # Return the smallest missing element\n    return smallest_missing\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with the custom value for duplicates\n    new_tup = ()\n    for element in test_tup:\n        if count_dict[element] == 1:\n            new_tup += (element,)\n        else:\n            new_tup += ('custom_value',)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) == 0:\n        return test_list\n    else:\n        return [test_list[-1]] + test_list[:-1]\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    if not A:\n        return 0\n\n    low, high = 0, len(A) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if A[mid] > A[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', toggle it to '0' and vice versa\n        if bit == '1':\n            result += '0'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # First, find the smallest value in the array\n    smallest = min(arr)\n    \n    # Then, count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(s[i])\n        elif s[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert the hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if the decimal number is even\n    if decimal % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    i = 0\n    while 2 ** i <= n:\n        i += 1\n    return 2 ** (i - 1)  # return the highest power of 2 that is less than or equal to n\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string] + list\n"}
{"task_id": "MBPP/391", "completion": "\n    # Initialize an empty dictionary\n    nested_dict = {}\n    \n    # Iterate over the lists\n    for i in range(len(l1)):\n        # Create a dictionary with the first list as keys and the second list as values\n        dict1 = dict(zip(l1, l2))\n        \n        # Create a dictionary with the third list as keys and the first dictionary as values\n        dict2 = dict(zip(l3, [dict1] * len(l3)))\n        \n        # Add the second dictionary to the main dictionary\n        nested_dict.update(dict2)\n    \n    return nested_dict\n"}
{"task_id": "MBPP/392", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return max(get_max_sum(n//2), get_max_sum(n//3)) + n\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        tup = tuple(sorted(tup))\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Check if the elements at the current index are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function to add the nested tuples\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If the elements are not tuples, add them directly\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    def mul(a, b, p):\n        return (a * b) % p\n\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        if (x == 0):\n            return 0\n        while (y > 0):\n            if ((y & 1) == 1):\n                res = (res * x) % p\n            y = y >> 1\n            x = (x * x) % p\n        return res\n\n    def inverse(x, p):\n        return power(x, p - 2, p)\n\n    if (r > n or r < 0 or n < 0):\n        return 0\n    pwr = 1\n    for i in range(1, r + 1):\n        pwr = mul(pwr, n - i + 1, p)\n    fact = 1\n    for i in range(1, r + 1):\n        fact = mul(fact, i, p)\n    inv = inverse(fact, p)\n    return mul(pwr, inv, p)  # Return the result\n"}
{"task_id": "MBPP/403", "completion": "\n    url_pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url_pattern.match(str) is not None\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return min(a, b)\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    i = len(n) - 1\n    while i > 0 and n[i - 1] >= n[i]:\n        i -= 1\n    if i <= 0:\n        return -1\n    j = len(n) - 1\n    while n[j] <= n[i - 1]:\n        j -= 1\n    n = list(n)\n    n[i - 1], n[j] = n[j], n[i - 1]\n    n[i : ] = n[len(n) - 1 : i - 1 : -1]\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    # Push the first element of the first array and the first element of the second array into the heap\n    heapq.heappush(min_heap, (nums1[0] + nums2[0], 0, 0))\n    # Create a set to store the pairs we have seen\n    seen = set()\n    # Create a list to store the k smallest pairs\n    k_smallest = []\n    # While the heap is not empty and we have not found k pairs\n    while min_heap and len(k_smallest) < k:\n        # Get the pair with the smallest sum from the heap\n        pair_sum, i, j = heapq.heappop(min_heap)\n        # If we have not seen this pair before\n        if (i, j) not in seen:\n            # Add the pair to the list of k smallest pairs\n            k_smallest.append((nums1[i], nums2[j]))\n            # Add the pair to the set of seen pairs\n            seen.add((i, j))\n        # If the current pair is not the last pair in the first array\n        if i + 1 < len(nums1):\n            # Push the next pair into the heap\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        # If the current pair is not the last pair in the second array\n        if j + 1 < len(nums2):\n            # Push the next pair into the heap\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    # Return the k smallest pairs\n    return k_smallest\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize the minimum product with a large number\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for tup in list1:\n        # Calculate the product of the tuple\n        product = tup[0] * tup[1]\n        \n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    # Return the minimum product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the snake case string\n    words = re.findall(r'\\w+', word)\n    \n    # Use list comprehension to capitalize the first letter of each word\n    camel_case_words = [word.capitalize() for word in words]\n    \n    # Join the camel case words together\n    camel_case_string = ''.join(camel_case_words)\n    \n    return camel_case_string\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1][0]  # Return the first element of the nth tuple\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n    max1 = max2 = float('-inf')\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n    return max1 * max2\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n < 0:\n        return -MAX\n    if n == 1:\n        return 1\n    max_sum = -MAX\n    for i in range(1, n):\n        max_sum = max(max_sum, breakSum(i) + breakSum(n - i - 1) + i + 1)\n    return max_sum\n\n"}
{"task_id": "MBPP/417", "completion": "\n    # Initialize an empty dictionary to store the count of each first element\n    count_dict = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Get the first element of the tuple\n        first_element = tup[0]\n        \n        # If the first element is already in the dictionary, increment its count\n        if first_element in count_dict:\n            count_dict[first_element] += 1\n        # If the first element is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[first_element] = 1\n    \n    # Initialize an empty list to store the common first elements\n    common_elements = []\n    \n    # Iterate over each key-value pair in the dictionary\n    for key, value in count_dict.items():\n        # If the count of the first element is equal to the number of tuples, it's a common element\n        if value == len(Input):\n            common_elements.append(key)\n    \n    # Return the list of common first elements\n    return common_elements\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    # Round every number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Calculate the sum of the rounded list\n    total_sum = sum(rounded_list)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    # Print the result\n    print(result)\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum(i**3 for i in range(2, n*2+2, 2))\n"}
{"task_id": "MBPP/421", "completion": "\n    delimiter = ','\n    result = ''\n    for tup in test_tup:\n        result += str(tup) + delimiter\n    return result[:-1]  # remove the last delimiter\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through first n natural numbers\n    for i in range(1, n+1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m):\n        for j in range(1, n):\n            # For each cell, the maximum gold that can be collected is the maximum of the gold in the current cell\n            # and the maximum gold that can be collected from the cell above it, the cell to its left, and the cell to its top-left\n            dp[i][j] = gold[i][j] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return [string[-1] for string in test_tuple]\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to match the date in the format yyyy-mm-dd\n    pattern = re.compile(r'(\\d{4})-(\\d{2})-(\\d{2})')\n    # Match the date\n    match = pattern.match(dt)\n    # If the date is in the correct format\n    if match:\n        # Extract the year, month and day\n        year, month, day = match.groups()\n        # Return the date in the format dd-mm-yyyy\n        return f'{day}-{month}-{year}'\n    else:\n        # If the date is not in the correct format, return an error message\n        return 'Invalid date format'\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize empty lists to store the elementwise and tuples\n    elementwise = []\n    tuples = []\n\n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Append the elementwise to the list\n        elementwise.append(tup1 + tup2)\n        \n        # Append the tuples to the list\n        tuples.append((tup1, tup2))\n\n    # Return the elementwise and tuples\n    return elementwise, tuples\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the directrix\n    directrix = -focal_length\n    \n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    \n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > element for element in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    return re.match(pattern, text)\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for num in list1:\n        if num < 0:\n            print(num)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a list of adverbs\n    adverbs = [\"quickly\", \"slowly\", \"loudly\", \"wisely\", \"carefully\", \"happily\", \"sadly\", \"angrily\", \"silently\", \"patiently\"]\n    \n    # Initialize an empty list to store the positions of adverbs\n    adverb_positions = []\n    \n    # Iterate over the adverbs\n    for adverb in adverbs:\n        # Use regular expression to find the adverb in the text\n        match = re.search(r'\\b' + re.escape(adverb) + r'\\b', text)\n        \n        # If the adverb is found, add its position to the list\n        if match:\n            adverb_positions.append((adverb, match.start()))\n    \n    # Return the list of adverb positions\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values to track the sign of each number\n    signs = array('b', [num > 0 for num in nums])\n    \n    # Count the number of True values in the array\n    positive_count = signs.count(True)\n    \n    return positive_count\n\n"}
{"task_id": "MBPP/443", "completion": "\n    return max([num for num in list1 if num < 0])\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][j] for j in range(len(test_list[i])-K, len(test_list[i]))) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    return tuple(a * b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Return the count of each element\n    return count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 5\n    else:\n        a, b = 2, 5\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the sides of the triangle\n    a = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    b = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n    c = ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5\n\n    # Check if the sum of any two sides is greater than the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    # Using regex to replace all whitespaces with an empty string\n    text1 = re.sub(r'\\s+', '', text1)\n    return text1\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    return re.search(r'\\b\\w*z\\w*\\b', text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub(r'[A-Z]+', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n    return arr[mid]\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product of subsequence ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product of subsequence ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product ending at the first position\n    max_product[0] = arr[0]\n    # Initialize the minimum product ending at the first position\n    min_product[0] = arr[0]\n    # Iterate over the array starting from the second position\n    for i in range(1, n):\n        # For each position, the maximum product ending at this position is the maximum of the current number and the product of the current number and the maximum product ending at the previous position\n        max_product[i] = max(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n        # For each position, the minimum product ending at this position is the minimum of the current number and the product of the current number and the minimum product ending at the previous position\n        min_product[i] = min(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n    # The maximum product of the increasing subsequence is the maximum product ending at the last position\n    return max_product[-1]\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, price[i] - price[i - 1]) for i in range(1, n))\n    \n    # Initialize a 2D table to store the maximum profit for each subproblem\n    dp = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    \n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next element\n            for j in range(i+1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result as 1\n    result = 1\n    # Multiply all elements in the array\n    for i in range(lens):\n        result = (result * arr[i]) % n\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] == 1:\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])  # convert the number to string, get the first character, convert it back to integer\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_freq:\n            char_freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n    \n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    dp = [[False for _ in range(sum + 1)] for _ in range(len(set) + 1)]\n    for i in range(len(set) + 1):\n        dp[i][0] = True\n    for i in range(1, len(set) + 1):\n        for j in range(1, sum + 1):\n            if set[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[-1][-1]\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    n = 1\n    while True:\n        if factorial(n) % x == 0:\n            return n\n        n += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [t for t in test_list1 if t not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = 0\n    for num in n:\n        if is_palindrome(num) and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r to avoid duplicate calculations\n        r = n - r\n    result = 1\n    for i in range(r):\n        result = result * (n - i) / (i + 1)\n    return result\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) / 4) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # First, find the maximum value in the array\n    max_val = max(arr)\n    \n    # Then, count the number of occurrences of the maximum value\n    frequency = arr.count(max_val)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid of hexagons\n    grid = [[None for _ in range(num_hexagons_x)] for _ in range(num_hexagons_y)]\n\n    # Calculate the coordinates of each hexagon\n    for y in range(num_hexagons_y):\n        for x in range(num_hexagons_x):\n            # Calculate the center of the hexagon\n            center_x = startx + x * 2 * radius\n            center_y = starty + y * 2 * radius\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = center_x + math.cos(angle) * radius\n                point_y = center_y + math.sin(angle) * radius\n                points.append((point_x, point_y))\n\n            # Store the coordinates of the hexagon in the grid\n            grid[y][x] = points\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert the binary tuple to a string\n    binary_str = ''.join(map(str, test_tup))\n    \n    # Convert the binary string to an integer\n    integer = int(binary_str, 2)\n    \n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    # Find the greatest common divisor of two numbers\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the common divisor between two numbers\n    def common_divisor(a, b):\n        return gcd(a, b)\n\n    # Find the common divisor between two numbers in a given pair\n    def ngcd(pair):\n        return common_divisor(pair[0], pair[1])\n\n    return ngcd(x, y)  # Return the common divisor of x and y\n\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(nums[i] + nums[i+1] for i in range(len(nums)-1))\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    # Initialize the result\n    result = 1\n    # Calculate the permutation coefficient\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) / i\n    return result\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    # Convert the list of words to remove to a set for efficient lookups\n    set2 = set(removewords)\n    # Use set difference to remove the words\n    result = list(set1 - set2)\n    return result\n"}
{"task_id": "MBPP/508", "completion": "\n    return l1 == l2\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product <= k:\n            count += n - i\n    return count\n"}
