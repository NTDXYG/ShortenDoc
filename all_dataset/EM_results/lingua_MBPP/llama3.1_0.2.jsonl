{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    if ch in s:\n        s.remove(ch)\n        s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in M]\n    \n    # Combine the row sums with the original matrix rows\n    combined = list(zip(row_sums, M))\n    \n    # Sort the combined list based on the row sums\n    combined.sort()\n    \n    # Separate the sorted row sums from the sorted matrix rows\n    sorted_row_sums, sorted_M = zip(*combined)\n    \n    # Convert the sorted matrix rows back to a list\n    sorted_M = list(sorted_M)\n    \n    return sorted_M\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the text into words\n    words = words.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the most common word and its count\n    most_common_word = word_counts.most_common(1)\n    \n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'([a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.sub(r'([a-z])\\1+', r'\\1_', text).lower()\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string2]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # Check if number is less than 1\n    if x < 1:\n        return False\n    # Check if number is 1\n    elif x == 1:\n        return True\n    # Check if number is even\n    elif x % 2 == 0:\n        return False\n    # Check if number is woodball\n    else:\n        # Calculate the sum of the first x-1 prime numbers\n        sum_of_primes = 0\n        num = 2\n        while sum_of_primes < x:\n            if is_prime(num):\n                sum_of_primes += num\n            num += 1\n        # Check if the sum of the first x-1 prime numbers is equal to x\n        return sum_of_primes == x\n\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i * n for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            return num\n        num_set.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(lst) for lst in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize product as 1\n    product = 1\n    # Iterate over the dictionary\n    for num, count in freq.items():\n        # If the count is 1, multiply the product by the number\n        if count == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # Taking advantage of symmetry\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element with odd frequency is found\n    return -1\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a heap to store the integers and their frequencies\n    heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(heap, (-count, num))\n\n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        if heap:\n            top_k.append(heapq.heappop(heap)[1])\n\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    for i in range(N - 1):\n        if ar[i + 1] - ar[i] > 1:\n            return ar[i] + 1\n    return ar[-1] + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    count = 0\n    num = 1\n    while True:\n        if is_rectangular(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/36", "completion": "\n    def find_Nth_Digit_helper(p, q, N):\n        if N == 1:\n            return p / q\n        else:\n            # Find the first N-1 digits\n            first_N_minus_1_digits = find_Nth_Digit_helper(p, q, N - 1)\n            # Find the Nth digit\n            Nth_digit = int(str(first_N_minus_1_digits)[N - 2])\n            # Update p and q\n            p = p * 10 + Nth_digit\n            q = q * 10\n            return p / q\n\n    return find_Nth_Digit_helper(p, q, N)\n\n"}
{"task_id": "MBPP/37", "completion": "\n    return sorted(mixed_list, key=lambda x: (isinstance(x, int), x))\n"}
{"task_id": "MBPP/38", "completion": "\n    even_count = 0\n    odd_count = 0\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if even_count > odd_count:\n        return list1[even_count - 1] / list1[even_count]\n    else:\n        return list1[odd_count - 1] / list1[odd_count]\n"}
{"task_id": "MBPP/39", "completion": "\n    count = Counter(S)\n    heap = []\n    for char, freq in count.items():\n        heapq.heappush(heap, (-freq, char))\n    prev_char = None\n    prev_freq = 0\n    while heap:\n        freq, char = heapq.heappop(heap)\n        if prev_freq and abs(prev_freq - freq) <= 1:\n            return False\n        prev_freq = freq\n        prev_char = char\n    return True\n"}
{"task_id": "MBPP/40", "completion": "\n    # Convert the list of lists into a single list\n    flat_list = list(chain(*nums))\n    \n    # Count the frequency of each element in the list\n    freq = Counter(flat_list)\n    \n    return freq\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of each element and its frequency to the sum\n    for num, count in freq.items():\n        total_sum += num * count\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"[a-z]+_[a-z]+\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in range(1, len(x)):\n        result = gcd(result, x[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    A = factorial(A)\n    B = factorial(B)\n    return A % 10 == B % 10\n"}
{"task_id": "MBPP/48", "completion": "\n    return n | n >> 1\n"}
{"task_id": "MBPP/49", "completion": "\n    return [num[0] for num in nums[:N]]\n\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if str[0] == str[-1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum element in the array\n    max_element = max(my_list)\n    \n    # Create a count array to store the count of individual elements\n    count_array = [0] * (max_element + 1)\n    \n    # Count the occurrences of each element in the array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Modify the count array to store the cumulative count\n    for i in range(1, max_element + 1):\n        count_array[i] += count_array[i - 1]\n    \n    # Create a sorted array\n    sorted_array = [0] * len(my_list)\n    for num in my_list:\n        sorted_array[count_array[num] - 1] = num\n        count_array[num] -= 1\n    \n    return sorted_array\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    rev_num = rev(n)\n    return n == 2 * rev_num - 1"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort()\n    res = 0\n    for i in range(n):\n        res = res * 10 + arr[n - i - 1]\n    return res\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2) == 1\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n\n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(2)] for _ in range(n)]\n\n    # Initialize the first element of the table\n    dp[0][0] = 1\n    dp[0][1] = 1\n\n    # Fill the table in bottom-up manner\n    for i in range(1, n):\n        # If the current element is greater than the previous one, then include it\n        if arr[i] > arr[i - 1]:\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + 1)\n        # If the current element is smaller than the previous one, then exclude it\n        else:\n            dp[i][0] = dp[i - 1][0]\n\n        # If the current element is smaller than the previous one, then include it\n        if arr[i] < arr[i - 1]:\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + 1)\n        # If the current element is greater than the previous one, then exclude it\n        else:\n            dp[i][1] = dp[i - 1][1]\n\n    # Return the maximum length subsequence\n    return max(dp[n - 1][0], dp[n - 1][1])\n\n"}
{"task_id": "MBPP/61", "completion": "\n    # Create a hashmap to store the frequency of each prefix sum\n    hashmap = defaultdict(int)\n    hashmap[0] = 1  # Base case: sum of 0 digits is 0, and there is 1 way to get it (i.e., an empty string)\n\n    # Initialize the current sum and the count of substrings\n    curr_sum = 0\n    count = 0\n\n    # Iterate over the string\n    for i in range(n):\n        # Update the current sum\n        curr_sum += int(s[i])\n\n        # If the current sum is equal to the length, increment the count\n        if curr_sum == i + 1:\n            count += 1\n\n        # If the current sum minus the length is in the hashmap, increment the count by the frequency of that sum\n        if curr_sum - (i + 1) in hashmap:\n            count += hashmap[curr_sum - (i + 1)]\n\n        # Update the frequency of the current sum in the hashmap\n        hashmap[curr_sum] += 1\n\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Initialize max_difference with the first element of the list\n    max_difference = test_list[1] - test_list[0]\n    \n    # Iterate over the list starting from the second element\n    for i in range(1, len(test_list)):\n        # Calculate the difference between the current element and the previous one\n        difference = test_list[i] - test_list[i-1]\n        \n        # If the calculated difference is greater than max_difference, update max_difference\n        if difference > max_difference:\n            max_difference = difference\n    \n    # Return the maximum difference found\n    return max_difference\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n\nsubjectmarks = [('Math', 90), ('Science', 85), ('English', 95), ('History', 80)]"}
{"task_id": "MBPP/65", "completion": "\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [0, 1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[i - 1] + sum(bell[:i - 1]))\n    return bell[n]\n"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n    for i in range(1, n):\n        if A[i] < A[i - 1]:\n            increasing = False\n        if A[i] > A[i - 1]:\n            decreasing = False\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]\n"}
{"task_id": "MBPP/70", "completion": "\n    return [tup for tup in Input if len(tup) == k]\n"}
{"task_id": "MBPP/71", "completion": "\n    def comb(a, n):\n        gap = n\n        swapped = True\n        while gap != 1 or swapped:\n            gap = max(1, int(gap / 1.3))\n            swapped = False\n            for i in range(0, n - gap):\n                if a[i] > a[i + gap]:\n                    a[i], a[i + gap] = a[i + gap], a[i]\n                    swapped = True\n        return a\n\n    return comb(nums, len(nums))\n"}
{"task_id": "MBPP/72", "completion": "\n    i = 1\n    while i * i <= n:\n        if (n - i * i) ** 0.5 == int((n - i * i) ** 0.5):\n            return True\n        i += 1\n    return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,\\s]+'\n    \n    # Split the text using the delimiters\n    result = re.split(delimiters, text)\n    \n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    for i in range(len(colors) - 1):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return abs(even_sum - odd_sum)\n"}
{"task_id": "MBPP/78", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Count the number of '1's in the binary representation\n    count = binary.count('1')\n    \n    # If the count is odd, return True, otherwise return False\n    return count % 2 != 0\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return sum(ord(c) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max([i for i in range(1, N) if i < N])\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    if sub_str in str1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to string to check each digit\n    str_n = str(n)\n    # Check if the number is undulating\n    if len(str_n) > 1 and str_n[0] != str_n[-1] and all(str_n[i] != str_n[i+1] for i in range(len(str_n)-1)):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    # Use the min function with a key argument to find the index of the minimum value\n    # The key argument is a function that takes a tuple and returns its second element (the value)\n    # The min function will return the index of the tuple with the minimum value\n    min_index = min(enumerate(test_list), key=itemgetter(1))[0]\n    return min_index\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_length = float('inf')\n    min_sublist = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_sublist = sublist\n    return min_sublist\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for item in list1:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    return [num / len(numbers) for num in numbers]\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    words = re.split('[_-]', word)\n    return words[0] + ''.join(word[0].upper() + word[1:] for word in words[1:])\n\n"}
{"task_id": "MBPP/103", "completion": "\n    return (m + 1) * n * (n + 1) // 2\n"}
{"task_id": "MBPP/104", "completion": "\n    return [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup_list = list(test_tup)\n    # Add the list to the tuple list\n    test_tup_list.extend(test_list)\n    # Convert the list back to a tuple\n    test_tup_list = tuple(test_tup_list)\n    return test_tup_list\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap\n    min_heap = []\n    # Push the first element of each list into the heap\n    heapq.heappush(min_heap, (num1[0], 0, num1))\n    heapq.heappush(min_heap, (num2[0], 0, num2))\n    heapq.heappush(min_heap, (num3[0], 0, num3))\n\n    # Create a list to store the result\n    result = []\n    # While the heap is not empty\n    while min_heap:\n        # Pop the smallest element from the heap\n        val, idx, nums = heapq.heappop(min_heap)\n        # Add the popped element to the result\n        result.append(val)\n        # If there are more elements in the list, push the next element into the heap\n        if idx + 1 < len(nums):\n            heapq.heappush(min_heap, (nums[idx + 1], idx + 1, nums))\n\n    return result\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(int(s[i:], 2) ^ int(s[:i], 2)).count('1') % 2 == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_list = []\n    for i in range(strt_val, stop_val + 1):\n        if i not in test_list:\n            missing_list.append(i)\n    return missing_list\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n\nnestedlist = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    return 2 * 3.14 * radius + 2 * 3.14 * radius * height\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if not i:\n            return True\n    return False\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) for i in test_list if isinstance(i, (int, float))]\n"}
{"task_id": "MBPP/118", "completion": "\n    # Remove all occurrences of 'https://' from the string\n    string = string.replace('https://', '')\n    # Remove all occurrences of 'text(' from the string\n    string = string.replace('text(', '')\n    # Remove all occurrences of ')' from the string\n    string = string.replace(')', '')\n    # Split the string into a list of words\n    list = string.split()\n    return list\n"}
{"task_id": "MBPP/119", "completion": "\n    for i in range(n):\n        if i == 0:\n            if arr[i] != arr[i + 1]:\n                return arr[i]\n        elif i == n - 1:\n            if arr[i] != arr[i - 1]:\n                return arr[i]\n        elif arr[i] != arr[i - 1] and arr[i] != arr[i + 1]:\n            return arr[i]\n    return None\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    if n < 1:\n        return None\n    elif n == 1:\n        return 1\n    else:\n        smart_numbers = [1]\n        i = 1\n        while len(smart_numbers) < n:\n            i += 1\n            if isSmart(i, smart_numbers):\n                smart_numbers.append(i)\n        return smart_numbers[-1]\n\n"}
{"task_id": "MBPP/123", "completion": "\nReturn sum of divisors of n.\"\"\"\n        return sum(i for i in range(1, n + 1) if n % i == 0)\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        if sum_divisors(i) < limit and sum_divisors(sum_divisors(i)) == i:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)\n\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if string[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            max_diff = max(max_diff, abs(zeros - ones))\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Find the common divisors of two numbers\n    common_divisors = [i for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0]\n    # Return the sum of common divisors\n    return sum(common_divisors)\n"}
{"task_id": "MBPP/127", "completion": "\n    if x == 0 or y == 0:\n        return 0\n    if x < 0:\n        return -multiply_int(-x, y)\n    if y < 0:\n        return -multiply_int(x, -y)\n    if y == 1:\n        return x\n    if y % 2 == 0:\n        return multiply_int(x, y // 2) + multiply_int(x, y // 2)\n    return multiply_int(x, y // 2) + multiply_int(x, y // 2) + x\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is a magic square\n    if not is_magic_square(my_matrix):\n        return False\n\n    # Check if the matrix is a 3x3 matrix\n    if len(my_matrix) != 3 or len(my_matrix[0]) != 3:\n        return False\n\n    # Check if the matrix is a square matrix\n    if my_matrix != [list(row) for row in zip(*my_matrix)]:\n        return False\n\n    # Check if the matrix has the same number of rows and columns\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row\n    if len(my_matrix[0]) != len(my_matrix):\n        return False\n\n    # Check if the matrix has the same number of elements in each column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each diagonal\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each anti-diagonal\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix[0]) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix has the same number of elements in each row and column\n    if len(my_matrix"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each item\n    freq_dict = defaultdict(int)\n    for num in nums:\n        freq_dict[num] += 1\n\n    # Find the item with the maximum frequency\n    max_freq = max(freq_dict.values())\n    max_items = [item for item, freq in freq_dict.items() if freq == max_freq]\n\n    return max_items\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    i, j = 0, len(str1) - 1\n    while i < j:\n        if str1[i] not in vowels:\n            i += 1\n        elif str1[j] not in vowels:\n            j -= 1\n        else:\n            str1[i], str1[j] = str1[j], str1[i]\n            i += 1\n            j -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    for i in range(p):\n        arr = [x % 2 for x in arr]\n    return arr[-1] % 2\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units < 0:\n        return \"Invalid input\"\n    elif units <= 50:\n        return units * 0.5\n    elif units <= 150:\n        return 25 + (units - 50) * 0.75\n    elif units <= 250:\n        return 125 + (units - 150) * 1.0\n    else:\n        return 250 + (units - 250) * 1.2\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of boolean values from the input list\n    bool_array = array('b', [num == 0 for num in nums])\n    \n    # Count the number of True values in the array\n    zero_count = bool_array.count(1)\n    \n    # Calculate the ratio of zeroes\n    ratio = zero_count / len(nums)\n    \n    return ratio\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation consists of only 1s and 0s\n    if not set(binary).issubset({'0', '1'}):\n        return False\n    \n    # Check if the binary representation has any consecutive 1s\n    for i in range(len(binary) - 1):\n        if binary[i] == '1' and binary[i + 1] == '1':\n            return False\n    \n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for element in test_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    # Create a list to store the elements that occur singly\n    singly_list = []\n    for key, value in freq_dict.items():\n        if value == 1:\n            singly_list.append(key)\n\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find index of maximum element in unsorted part of list\n        max_index = nums.index(max(nums[:size]))\n        # If max element is not at the beginning of unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip max element to the beginning\n            nums[:max_index + 1] = reversed(nums[:max_index + 1])\n            # Flip max element to its correct position\n            nums[:size] = reversed(nums[:size])\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for same pairs\n    count = 0\n    # Iterate over the first list\n    for i in range(len(list1)):\n        # Iterate over the second list\n        for j in range(len(list2)):\n            # Check if the pair is the same in the third list\n            if (list1[i], list2[j]) in list3:\n                # If the pair is the same, increment the counter\n                count += 1\n    # Return the count of same pairs\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_diff += abs(arr[i] - arr[j])\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Initialize max_diff with negative infinity\n    max_diff = float('-inf')\n    \n    # Iterate over the array from the second element to the last element\n    for i in range(1, n):\n        # Calculate the absolute difference between current element and previous element\n        diff = abs(arr[i] - arr[i-1])\n        \n        # Update max_diff if current difference is greater than max_diff\n        max_diff = max(max_diff, diff)\n    \n    # Return max_diff\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 1):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    if x == 0:\n        return 0\n    return max(sum_digits_single(x // 10), sum_digits_single(x % 10) + x // 10)\n\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    n = 1\n    while True:\n        if a in (n, n + 1, n + 2, n + 3):\n            return True\n        n += 4\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1:\n    return x\n    mid = len(x) // 2\n    left = merge_sort(x[:mid])\n    right = merge_sort(x[mid:])\n    return merge(left, right)"}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    return nums[N][0]\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is even (0), toggle it to 1, otherwise toggle it to 0\n        result += '1' if int(bit) % 2 == 0 else '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    # Split the string by comma to get list of strings\n    str_list = tuple_str.split(',')\n    \n    # Convert each string to integer and store in list\n    int_list = [int(i) for i in str_list]\n    \n    # Convert list to tuple and return\n    return tuple(int_list)\n"}
{"task_id": "MBPP/157", "completion": "\n    if not list1:\n        return []\n\n    encoded_list = []\n    count = 1\n\n    for i in range(1, len(list1)):\n        if list1[i] == list1[i - 1]:\n            count += 1\n        else:\n            encoded_list.append((list1[i - 1], count))\n            count = 1\n\n    encoded_list.append((list1[-1], count))\n    return encoded_list\n\n"}
{"task_id": "MBPP/158", "completion": "\n    arr.sort()\n    min_ops = 0\n    for i in range(n):\n        if arr[i] != arr[0]:\n            min_ops += (arr[i] - arr[0]) // k + 1\n    return min_ops\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    def find_x_y(a, b, n):\n        gcd, x, y = extended_gcd(a, b)\n        if n % gcd != 0:\n            return None\n        x *= n // gcd\n        y *= n // gcd\n        return x, y\n\n    return find_x_y(a, b, n)  # return x, y\n"}
{"task_id": "MBPP/161", "completion": "\n    return [value for value in list1 if value not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    return sum(range(n, 0, -2))  # sum of odd numbers from n to 1\n\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * s) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    char_position = {}\n    for i in range(len(str1)):\n        if str1[i] in char_position:\n            char_position[str1[i]] += 1\n        else:\n            char_position[str1[i]] = 1\n    return char_position\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])  # Include n in the range\n"}
{"task_id": "MBPP/171", "completion": "\n    # The perimeter of a pentagon is the sum of the lengths of its sides.\n    # In this case, we are given the length of one side, so we can simply multiply it by 5.\n    return a * 5\n\n"}
{"task_id": "MBPP/172", "completion": "\n    # Initialize a dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_count[char] = 1\n    \n    # Return the count of the character 's'\n    return char_count.get('s', 0)\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'\\W+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            if L <= lcm(i, j) <= R:\n                return [i, j]\n    return []\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    if x < 2:\n        return False\n    for i in range(2, int(x**0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude to radians\n    slat, slon = radians(slat), radians(slon)\n    elat, elon = radians(elat), radians(elon)\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n\n    # Radius of the Earth in kilometers\n    R = 6371\n\n    # Calculate the distance\n    distance = R * c\n\n    return distance\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    pattern = r\"[a-zA-Z0-9]\"\n    return re.findall(pattern, string)\n\n"}
{"task_id": "MBPP/183", "completion": "\n    # Create a dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize a variable to store the count of pairs\n    count = 0\n\n    # Iterate over the frequency dictionary\n    for num in freq:\n        # For each number, calculate the number of pairs that can be formed with the number and the number plus k\n        # The number of pairs is the product of the frequency of the number and the frequency of the number plus k\n        # If the number plus k is not in the frequency dictionary, the number of pairs is the frequency of the number times the frequency of the number minus k\n        count += freq[num] * freq.get(num + k, 0)\n\n        # If the number minus k is not the same as the number, calculate the number of pairs that can be formed with the number and the number minus k\n        # The number of pairs is the product of the frequency of the number and the frequency of the number minus k\n        # If the number minus k is not in the frequency dictionary, the number of pairs is 0\n        if num - k != num:\n            count += freq[num] * freq.get(num - k, 0)\n\n    # Return the count of pairs\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus coordinates\n    focus_x = -focal_length\n    focus_y = 0\n    \n    return focus_x, focus_y\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequences of\n    # substrings.\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index + 1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store\n    # characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character\n        # is part of LCS\n        if X[i - 1] == Y[j - 1]:\n            lcs[index - 1] = X[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction\n        # of larger value\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    i = 1\n    while i * i <= n:\n        if n % (i * i) == 0:\n            return True\n        i += 1\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers\n    num_set = set()\n    \n    # Iterate over the array and add the positive numbers to the set\n    for num in arr:\n        if 1 <= num <= n:\n            num_set.add(num)\n    \n    # Iterate from 1 to n and return the first missing positive number\n    for i in range(1, n + 1):\n        if i not in num_set:\n            return i\n    \n    # If all numbers from 1 to n are present in the set, return n + 1\n    return n + 1\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points in the square\n    count = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname3 in month_days:\n        if month_days[monthname3] == 30:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/192", "completion": "\n    if any(char.isalpha() for char in str) and any(char.isdigit() for char in str):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Initialize result tuple with 1\n    result = (1, 1)\n    \n    # Iterate over the range of the length of the first tuple\n    for i in range(len(test_tup1)):\n        # Initialize the current result with 1\n        curr_result = 1\n        \n        # Iterate over the range of the length of the second tuple\n        for j in range(len(test_tup2)):\n            # Update the current result by multiplying it with the current element of the second tuple\n            curr_result *= test_tup2[j]\n        \n        # Update the result by multiplying it with the current result\n        result = (result[0] * curr_result, result[1] * curr_result)\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major and semi-minor axes of the ellipse\n    a = a\n    b = b\n\n    # Calculate the area of the largest triangle\n    area = (math.pi * a * b) / 4\n\n    return area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return 2 ** (n.bit_length() - 1)\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    inversions = []\n    for tup in test_tup:\n        for i in range(len(tup)):\n            for j in range(i + 1, len(tup)):\n                if tup[i] > tup[j]:\n                    inversions.append((tup[i], tup[j]))\n    return inversions\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for tup in test_tup:\n        result.append(''.join(tup))\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    max_length = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if str[i - 1] == str[j - 1] and i != j:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n    return max_length\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'[^a-zA-Z0-9]')\n    if pattern.search(string):\n        return False\n    else:\n        return True\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') == n:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum(i ** 4 for i in range(1, n + 1))\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return test_tup1 + test_tup2\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        item = alist[i + 1]\n        decoded_list.extend([item] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    return set(list1).issubset(set(list2))\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    # Calculate the minimum number of operations required\n    min_operations = math.ceil(diff / 2)\n    return min_operations\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple into a list\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the minimum and maximum k elements\n    min_k = test_list[:K]\n    max_k = test_list[-K:]\n    \n    # Return the minimum and maximum k elements\n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, and dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n    \n    # Sort matches by frequency\n    freq = {}\n    for match in matches:\n        if match in freq:\n            freq[match] += 1\n        else:\n            freq[match] = 1\n    \n    # Sort by frequency in descending order\n    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    \n    # Replace the most frequent matches with colon\n    for match, count in sorted_freq[:n]:\n        text = text.replace(match, ':')\n    \n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if not isinstance(test_tuple, tuple):\n        raise TypeError(\"Input is not a tuple\")\n    data_type = type(test_tuple[0])\n    for element in test_tuple:\n        if not isinstance(element, data_type):\n            return False\n    return True\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count of given element\n    count = 0\n    # Traverse through the array\n    for i in range(n):\n        # If element is equal to x, increment count\n        if arr[i] == x:\n            count += 1\n        # If element is not equal to x, decrement count\n        else:\n            count -= 1\n        # If count becomes zero, reset count to 1\n        if count == 0:\n            count = 1\n    # Return True if count is not zero, else return False\n    return count != 0\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    else:\n        return find_Min(arr, low, mid)\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for index, char in enumerate(str) if index % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Check if the range is valid\n    if l > r:\n        return False\n\n    # Check if all bits are unset in the given range\n    for i in range(l, r + 1):\n        # If any bit is set, return False\n        if n & (1 << i):\n            return False\n\n    # If no bits are set, return True\n    return True\n"}
{"task_id": "MBPP/229", "completion": "\n    # Separate negative and positive elements\n    negative = [x for x in arr if x < 0]\n    positive = [x for x in arr if x >= 0]\n    \n    # Combine the two lists\n    result = negative + positive\n    \n    return result\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Create a 2D list to store the maximum sum at each position\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Initialize the first row and column of dp\n    for i in range(n):\n        dp[0][i] = tri[0][i]\n        dp[i][0] = tri[i][0]\n    \n    # Fill the dp table in a bottom-up manner\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum at position (i, j) is the maximum of the sum of the number at position (i, j) and the maximum sum of the numbers above it\n            dp[i][j] = tri[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # The maximum sum in the triangle is stored in the bottom-right corner of the dp table\n    return dp[n-1][n-1]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    return n | n & -n\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of triangles that can be formed\n    # The number of triangles that can be formed is equal to the number of ways to choose 3 points from the total number of points\n    # This can be calculated using the combination formula: nC3 = n*(n-1)*(n-2)/6\n    # In this case, n is the number of points on the side of the triangle\n    # Since the triangle is equilateral, the number of points on the side is equal to the number of points on the other sides\n    # Therefore, the number of points on the side is equal to the number of points on the other sides\n    # The number of points on the other sides is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # The number of points on the side of the triangle is equal to the number of points on the side of the triangle\n    # Therefore, the number of points on the side of the triangle is equal to the number of points on the side of the triangle\n   "}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(test_list)\n    # Find the maximum count\n    max_count = max(record_count.values())\n    # Find the records that occur the maximum number of times\n    max_records = [record for record, count in record_count.items() if count == max_count]\n    return max_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if j >= 2 * (i - 1):\n                dp[i] += dp[i - 1]\n    return dp[n] - 1  # subtract 1 because we don't want to count the sequence with all elements equal to m\n\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: (x[0], lst.count(x[0])))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    # Calculate the next integer greater than sqrt_N\n    next_int = math.ceil(sqrt_N)\n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store maximum sum of bi-tonic sub-sequence\n    # ending at current position and maximum sum of bi-tonic sub-sequence\n    # ending at previous position\n    max_ending_here = [0] * n\n    max_ending_prev = [0] * n\n\n    # Initialize maximum sum of bi-tonic sub-sequence ending at current position\n    # and maximum sum of bi-tonic sub-sequence ending at previous position\n    max_ending_here[0] = max_ending_prev[0] = arr[0]\n\n    # Compute maximum sum of bi-tonic sub-sequence ending at current position\n    # and maximum sum of bi-tonic sub-sequence ending at previous position\n    for i in range(1, n):\n        max_ending_here[i] = max(arr[i], max_ending_here[i-1], max_ending_prev[i-1] + arr[i])\n        max_ending_prev[i] = max(max_ending_prev[i-1], max_ending_here[i-1])\n\n    # Return maximum sum of bi-tonic sub-sequence\n    return max_ending_here[-1]\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    elif number == 0 or number == 1:\n        return number\n    else:\n        guess = number\n        while True:\n            better_guess = (guess + number / guess) / 2\n            if abs(guess - better_guess) < 0.000001:\n                return better_guess\n            guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]  # return the longest palindromic subsequence length\n\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(set(array_nums1) & set(array_nums2))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    new_list = []\n    for i in range(len(list)):\n        new_list.append(list[i])\n        new_list.append(element)\n    return new_list\n"}
{"task_id": "MBPP/252", "completion": "\n    result = []\n    for num in numbers:\n        r = cmath.polar(num)[0]\n        phi = cmath.polar(num)[1]\n        result.append((r, phi))\n    return result\n\n\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\b[aAeE]\\w+\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    return list(combinations_with_replacement(l, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum element from each list\n    return max1, max2\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    # Check if both tuples have the same number of elements\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Both tuples must have the same number of elements.\"\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the divisor is not zero\n        if test_tup2[i] == 0:\n            return \"Error: Division by zero is not allowed.\"\n        \n        # Perform the division operation and append the result to the list\n        result.append(test_tup1[i] / test_tup2[i])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # Calculate dog's age in dog's years\n    d_age = h_age * 7\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum(i**2 for i in range(1, n*2, 2))\n"}
{"task_id": "MBPP/268", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if arr[i] % 2 == 0 and i % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    even_sum = 0\n    for i in range(2, n+1, 2):\n        even_sum += i ** 5\n    return even_sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return [record[-1] for record in test_list]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a + n) % m\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return test_tup.count(test_tup[0])\n"}
{"task_id": "MBPP/279", "completion": "\n    return n >= 1 and n <= 100\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is less than or equal to the digit itself, return True\n        if count <= int(digit):\n            return True\n    \n    # If no digit has a frequency less than or equal to itself, return False\n    return False\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # Repeat the array k times\n    repeated_array = a * k\n\n    # Initialize the maximum sum and the current sum for the repeated array\n    max_sum_repeated = float('-inf')\n    current_sum_repeated = 0\n\n    # Iterate over the repeated array\n    for i in range(len(repeated_array)):\n        # Add the current element to the current sum\n        current_sum_repeated += repeated_array[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum_repeated > max_sum_repeated:\n            max_sum_repeated = current_sum_repeated\n\n        # If the current sum is negative, reset it to 0\n        if current_sum_repeated < 0:\n            current_sum_repeated = 0\n\n    # Return the maximum sum of the repeated array\n    return max_sum_repeated\n\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum(i**2 for i in range(2, n+1, 2))\n"}
{"task_id": "MBPP/288", "completion": "\n    # Create a dictionary to store the modular inverses\n    inverses = {}\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # Check if the number is coprime with P\n        if gcd(num, P) == 1:\n            # Calculate the modular inverse using the Extended Euclidean Algorithm\n            inverse = pow(num, -1, P)\n            inverses[num] = inverse\n        else:\n            # If the number is not coprime, set its modular inverse to None\n            inverses[num] = None\n    \n    return inverses\n"}
{"task_id": "MBPP/289", "completion": "\n    return N//2 + N%2\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(list1, key=len)\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each number of posts\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each number of posts from 3 to n\n    for i in range(3, n + 1):\n        # The number of ways is the sum of the number of ways for the previous two posts\n        # (one color for the current post) and the number of ways for the previous three posts\n        # (two different colors for the current post)\n        ways[i] = ways[i - 1] * (k - 1) + ways[i - 2] * (k - 1)\n\n    # Return the number of ways for n posts\n    return ways[n]\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    sum_div = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum_div += i\n    return sum_div\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    result = []\n    for item in list1:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\n"}
{"task_id": "MBPP/298", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a list and return it\n    return list(common_elements)\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each day\n    max_aggregates = defaultdict(int)\n    \n    # Iterate over each tuple in the list\n    for day, aggregate in stdata:\n        # Update the maximum aggregate for the current day\n        max_aggregates[day] = max(max_aggregates[day], aggregate)\n    \n    # Return the maximum aggregate for each day as a list of tuples\n    return [(day, max_aggregates[day]) for day in max_aggregates]\n\n"}
{"task_id": "MBPP/300", "completion": "\n    if n == 0:\n        return 1\n    else:\n        return 2 * count_binary_seq(n - 1)\n\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    return n.bit_length() - 1\n"}
{"task_id": "MBPP/303", "completion": "\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversions += 1\n    return inversions\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Check if the index is within the range of the array\n    if index < 0 or index >= len(arr):\n        return None\n\n    # Check if the index is within the range of the rotated array\n    if index < rotations or index >= len(arr) - rotations:\n        return None\n\n    # Find the element at the given index\n    return arr[index]\n"}
{"task_id": "MBPP/305", "completion": "\n    return [word for word in words if word.startswith('p')]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill dp[][] in bottom up manner\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = a[i]\n            elif j == 1:\n                dp[i][j] = max(a[i], dp[i - 1][j])\n            else:\n                # If current element is greater than previous element, then include it\n                # Else exclude it\n                if a[i] > a[index - 1]:\n                    dp[i][j] = max(dp[i - 1][j], a[i] + dp[index - 2][j - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n    \n    # Return the maximum sum\n    return dp[n - 1][k - 1]\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Sort the lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n\n    # Initialize the result list\n    result = []\n\n    # Iterate over the lists\n    for i in range(N):\n        # Calculate the product of the current elements\n        product = nums1[i] * nums2[i]\n\n        # Append the product to the result list\n        result.append(product)\n\n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n - 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1.0/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    # Initialize the maximum sum\n    max_sum = 0\n\n    # Iterate over each row in the grid\n    for i in range(2):\n        # Initialize the current sum for the row\n        current_sum = 0\n\n        # Iterate over each column in the grid\n        for j in range(n):\n            # Add the current element to the current sum\n            current_sum += grid[i][j]\n\n            # If the current sum is greater than the maximum sum, update the maximum sum\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n            # If the current sum is less than 0, reset it to 0\n            if current_sum < 0:\n                current_sum = 0\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/316", "completion": "\n    low = 0\n    high = len(A) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            low = mid + 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    encoded_list = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        encoded_list.append((key, count))\n    return encoded_list\n\n"}
{"task_id": "MBPP/318", "completion": "\n    n = len(s)\n    s.sort()\n    max_volume = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                volume = s[i] * s[j] * s[k]\n                if volume > max_volume:\n                    max_volume = volume\n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    pattern = r'\\b\\w{5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_natural = n * (n + 1) // 2\n    sum_squared = n * (n + 1) * (2 * n + 1) // 6\n    return sum_natural ** 2 - sum_squared\n"}
{"task_id": "MBPP/321", "completion": "\n    # Convert the number to string\n    s = str(s)\n    # Initialize the demlo number\n    demlo = 0\n    # Loop through each character in the string\n    for i, c in enumerate(s):\n        # Add the value of the character to the demlo number\n        demlo += int(c) * (10 ** (len(s) - i - 1))\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    min_indices = [i for i, x in enumerate(list1) if x == min_val]\n    return min_indices\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # Create a new array with the rotated elements\n        rotated_arr = [0] * n\n        for i in range(n):\n            if i % 2 == 0:\n                rotated_arr[i] = arr[i // 2]\n            else:\n                rotated_arr[i] = arr[n - 1 - i // 2]\n        return rotated_arr\n    else:\n        # Rotate the array in-place\n        for i in range(n):\n            if i % 2 == 0:\n                arr[i], arr[n - 1 - i // 2] = arr[n - 1 - i // 2], arr[i]\n        return arr\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(test_tuple[i] for i in range(0, len(test_tuple), 2))\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # Update the minimum number of squares for the current number\n            min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return most_common_words\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    n = n % len(list1)\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return sum(1 for num in list if num < 0)\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # reverse = None (Sorts in Ascending order)\n    # or reverse = True (Sorts in Descending order)\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    # check if all sides are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    # check if sum of any two sides is greater than third side\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    return True\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n / 2) * (2 * a + (n - 1) * d)\n\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    if monthname1 in month_days:\n        if month_days[monthname1] == 28:\n            return True\n        else:\n            return False\n    else:\n        return \"Invalid month name\"\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b(?=[\\.,!?;:]$)'\n    return re.search(pattern, text)\n\n"}
{"task_id": "MBPP/338", "completion": "\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i] == s[j - 1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty list to store divisors\n    divisors = []\n    \n    # Iterate over the range from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, append it to the list\n            divisors.append(i)\n    \n    # Return the maximum value in the list\n    return max(divisors)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # We then filter out non-positive numbers\n    positive_lst = [num for num in sorted_lst if num > 0]\n    \n    # If there are less than three positive numbers, we return the sum of all positive numbers\n    if len(positive_lst) < 3:\n        return sum(positive_lst)\n    \n    # Otherwise, we return the sum of the three smallest positive numbers\n    else:\n        return sum(positive_lst[:3])  # We use list slicing to get the first three elements of the list\n\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_range = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_range = max(max_range, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if max_range - node.value < min_range:\n            min_range = max_range - node.value\n        if node.index + 1 < len(list[node.list_num]):\n            next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n            heappush(min_heap, next_node)\n            heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n            max_range = max(max_range, -list[node.list_num][node.index + 1])\n        else:\n            break\n\n    return min_range\n\n"}
{"task_id": "MBPP/343", "completion": "\n    return sum(c.isalpha() for c in s)\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 8\n    if n == 5:\n        return 16\n    if n == 6:\n        return 32\n    if n == 7:\n        return 64\n    if n == 8:\n        return 128\n    if n == 9:\n        return 256\n    if n == 10:\n        return 512\n    if n == 11:\n        return 1024\n    if n == 12:\n        return 2048\n    if n == 13:\n        return 4096\n    if n == 14:\n        return 8192\n    if n == 15:\n        return 16384\n    if n == 16:\n        return 32768\n    if n == 17:\n        return 65536\n    if n == 18:\n        return 131072\n    if n == 19:\n        return 262144\n    if n == 20:\n        return 524288\n    if n == 21:\n        return 1048576\n    if n == 22:\n        return 2097152\n    if n == 23:\n        return 4194304\n    if n == 24:\n        return 8388608\n    if n == 25:\n        return 16777216\n    if n == 26:\n        return 33554432\n    if n == 27:\n        return 67108864\n    if n == 28:\n        return 134217728\n    if n == 29:\n        return 268435456\n    if n == 30:\n        return 536870912\n    if n == 31:\n        return 1073741824\n    if n == 32:\n        return 2147483648\n    if n == 33:\n        return 4294967296\n    if n == 34:\n        return 8589934592\n    if n == 35:\n        return 17179869184\n    if n == 36:\n        return 34359738368\n    if n == 37:\n        return 68719476736\n    if n == 38:\n        return 137438953472\n    if"}
{"task_id": "MBPP/347", "completion": "\n    return m * n\n"}
{"task_id": "MBPP/348", "completion": "\n    if n == 0:\n        return 1\n    if r == 0:\n        return 0\n    if n < 0 or r < 0:\n        return 0\n    return bin_coff(n - r, r) + bin_coff(n, r - 1)\n\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element that occurs k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [x[:n] + x[n+1:] for x in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    # Import necessary modules\n    import math\n\n    # Define the function\n    def count_rectangles(radius):\n        # Calculate the area of the circle\n        circle_area = math.pi * (radius ** 2)\n\n        # Calculate the area of a single rectangle\n        rectangle_area = 1\n\n        # Calculate the number of rectangles that can fit in the circle\n        num_rectangles = circle_area / rectangle_area\n\n        # Return the number of rectangles\n        return num_rectangles\n\n    # Call the function and print the result\n    print(count_rectangles(radius))\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - a - b\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = test_list[0]\n    for i in test_list:\n        if i > max_val:\n            max_val = i\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # If discriminant is zero, then the equation has one real root\n    if d == 0:\n        return False\n    \n    # If discriminant is positive, then the equation has two real roots\n    elif d > 0:\n        return True\n    \n    # If discriminant is negative, then the equation has no real roots\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = [1, 1]\n    for i in range(2, n):\n        carol.append(carol[i-1] + carol[i-2])\n    return carol[n-1]\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the number with the maximum count\n    max_count = max(count_dict.values())\n    max_nums = [num for num, count in count_dict.items() if count == max_count]\n\n    return max_nums\n"}
{"task_id": "MBPP/363", "completion": "\n    return [x + K for x in test_list]\n"}
{"task_id": "MBPP/364", "completion": "\n    # Initialize count of flips\n    flips = 0\n    # Initialize previous character\n    prev_char = None\n    # Iterate over each character in the string\n    for char in ch:\n        # If the current character is the same as the previous one\n        if char == prev_char:\n            # Increment the count of flips\n            flips += 1\n        # Update the previous character\n        prev_char = char\n    # Return the total count of flips\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x[1]))\n\n"}
{"task_id": "MBPP/371", "completion": "\n    # Check if the array is sorted\n    if A != sorted(A):\n        raise ValueError(\"Array is not sorted\")\n\n    # Check if the array is empty\n    if len(A) == 0:\n        raise ValueError(\"Array is empty\")\n\n    # Check if the left and right elements are in the array\n    if left_element not in A or right_element not in A:\n        raise ValueError(\"Left or right element is not in the array\")\n\n    # Find the smallest missing element\n    for i in range(len(A) - 1):\n        if A[i + 1] - A[i] > 1:\n            return A[i] + 1\n\n    # If no missing element is found, return the next element after the right element\n    return A[-1] + 1\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with custom value for duplicates\n    new_tup = ()\n    for element in test_tup:\n        if count_dict[element] == 1:\n            new_tup += (element,)\n        else:\n            new_tup += ('Custom Value',)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) > 1:\n        return [test_list[-1]] + test_list[:-1]\n    else:\n        return test_list\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    for i in range(n):\n        if A[i] > A[(i+1) % n]:\n            return i\n    return n\n"}
{"task_id": "MBPP/383", "completion": "\n    return n ^ (n & -n)\n"}
{"task_id": "MBPP/384", "completion": "\n    # Find the smallest value in the array\n    smallest = min(arr)\n    \n    # Count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    i = 0\n    while (1 << i) <= n:\n        i += 1\n    return 1 << (i - 1)\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    # Create a dictionary with keys from l1 and values from l2\n    dict1 = dict(zip(l1, l2))\n    # Create a dictionary with keys from l1 and values from l3\n    dict2 = dict(zip(l1, l3))\n    # Create a dictionary with keys from l1 and values from dict1 and dict2\n    dict3 = {key: {k: v for k, v in zip(dict1.keys(), dict2.values())} for key in l1}\n    return dict3\n"}
{"task_id": "MBPP/392", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return max(get_max_sum(n//2), get_max_sum(n//3), get_max_sum(n//4), get_max_sum(n//5)) + 1\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return [tup for tup, freq in freq_dict.items() if freq == 1]\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Check if the elements are tuples\n        if isinstance(test_tup1[i], tuple) and isinstance(test_tup2[i], tuple):\n            # Recursively call the function for the nested tuples\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If the elements are not tuples, add them\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result as a tuple\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    if n == r:\n        return 1\n    if n % p == 0:\n        return 0\n    if r == 1:\n        return n % p\n    if r == 2:\n        return (n * (n - 1)) % p\n    pwr = pow(n, r, p)\n    inv = pow(n - 1, p - 2, p)\n    return (pwr * inv) % p\n"}
{"task_id": "MBPP/403", "completion": "\n    url = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url.match(str)\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(x)[2:]\n    # Count the number of 1's in the binary representation\n    count = binary.count('1')\n    # If the count is even, return 'Even', otherwise return 'Odd'\n    if count % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    i = len(n) - 1\n    while i > 0 and n[i - 1] >= n[i]:\n        i -= 1\n    if i <= 0:\n        return -1\n    j = len(n) - 1\n    while n[j] <= n[i - 1]:\n        j -= 1\n    n = list(n)\n    n[i - 1], n[j] = n[j], n[i - 1]\n    n[i : ] = n[len(n) - 1 : i - 1 : -1]\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    \n    # Push the first element of the first array into the heap\n    for num1 in nums1:\n        heapq.heappush(min_heap, (num1, num2))\n    \n    # Pop the smallest pair from the heap k times\n    for _ in range(k):\n        pair = heapq.heappop(min_heap)\n        print(pair)\n    \n    return min_heap\n\n"}
{"task_id": "MBPP/409", "completion": "\n    min_product = float('inf')\n    for i in range(len(list1)):\n        for j in range(i+1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product < min_product:\n                min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the string\n    words = re.findall(r'\\w+', word)\n    \n    # Use list comprehension to capitalize the first letter of each word except the first one\n    camel_case_words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words together to form the camel case string\n    camel_case_string = ''.join(camel_case_words)\n    \n    return camel_case_string\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]  # subtract 1 because list indices start at 0\n\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/416", "completion": "\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n >= MAX:\n        return n\n\n    max_sum = 0\n    for i in range(1, n):\n        left_sum = breakSum(i)\n        right_sum = breakSum(n - i)\n        max_sum = max(max_sum, left_sum + right_sum + i)\n\n    return max_sum\n\n"}
{"task_id": "MBPP/417", "completion": "\n    return [list(x) for x in set(tuple(sorted(x)) for x in Input)]\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n    return max_len\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(list1))\n    return total_sum * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    return sum(i**3 for i in range(2, n+2, 2))\n"}
{"task_id": "MBPP/421", "completion": "\n    return '-'.join(map(str, test_tup))\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    # Loop through first n natural numbers\n    for i in range(1, n + 1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill in the rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            # The maximum gold that can be collected at this cell is the maximum of the gold that can be collected from the cell above, the cell to the left, and the cell diagonally above and to the left\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple(string[-1] for string in test_tuple)\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to replace the date format\n    new_date = re.sub(r'(\\d{4})-(\\d{2})-(\\d{2})', r'\\3-\\2-\\1', dt)\n    return new_date\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Append the tuple of differences to the result list\n        result.append(tuple(tup1[i] - tup2[i] for i in range(len(tup1))))\n    \n    # Return the result list\n    return result\n"}
{"task_id": "MBPP/430", "completion": "\n    # Directrix is a horizontal line y = -1/(4a)\n    return -1/(4*a)\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # Calculate the median of the trapezium\n    median = (base1 + base2) / 2\n    \n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > i for i in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a\\bb+\"\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a regular expression pattern to match adverbs\n    pattern = r'\\b(very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|somewhat|fairly|pretty|rather|pretty|very|extremely|really|quite|som"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l**2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values indicating whether each number is positive\n    positive_array = array('b', [num > 0 for num in nums])\n    \n    # Count the number of True values in the array\n    positive_count = positive_array.count(True)\n    \n    # Calculate the ratio of positive numbers\n    ratio = positive_count / len(nums)\n    \n    return ratio\n\n"}
{"task_id": "MBPP/443", "completion": "\n    return max([num for num in list1 if num < 0])\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][:-K]) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Check if both tuples have the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Use zip() function to pair corresponding elements from both tuples\n    # Use map() function to perform multiplication on each pair\n    result = tuple(map(lambda x, y: x * y, test_tup1, test_tup2))\n    return result\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Return the count of each element\n    return count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    else:\n        a, b, c = 2, 3, 0\n        for _ in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return c\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the length of the sides of the triangle\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    # Use regular expression to find words containing 'z'\n    pattern = r'\\b\\w*z\\w+\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(len(sublist) for sublist in lst)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub(r'[A-Z]+', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return low\n\n    # See the problem description for details\n    mid = (low + high) // 2\n\n    # If the middle element is smaller than its right neighbor,\n    # then the peak must be in right half\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n\n    # If the middle element is greater than its left neighbor,\n    # then the peak must be in left half\n    if mid > 0 and arr[mid] > arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    # If neither of the above conditions is true, then the middle\n    # element is the peak element\n    return mid\n\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product of increasing subsequence ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product of increasing subsequence ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product and minimum product for the first element\n    max_product[0] = min_product[0] = arr[0]\n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        # For each element, calculate the maximum product of increasing subsequence ending at this position\n        # by considering the maximum product of increasing subsequence ending at the previous position and the current element\n        max_product[i] = max(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n        # For each element, calculate the minimum product of increasing subsequence ending at this position\n        # by considering the minimum product of increasing subsequence ending at the previous position and the current element\n        min_product[i] = min(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n    # Return the maximum product of increasing subsequence ending at the last position\n    return max_product[-1]\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2:\n        return 0\n    if k >= n // 2:\n        return sum(max(0, price[i] - price[i - 1]) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n    return dp[k][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next element\n            for j in range(i + 1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the list of results\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result array with zeros\n    result = [0] * lens\n    # Multiply the array by n and store the result in the result array\n    for i in range(lens):\n        result[i] = arr[i] * n\n    # Return the result array\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] == 1:\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    # Convert the lists to sets for efficient lookup\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a list and return it\n    return list(intersection)\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    return int(str(n)[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    for char in str1:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Find the character with maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    # Create a 2D table to store results of subproblems\n    dp = [[False for _ in range(sum + 1)] for _ in range(len(set) + 1)]\n\n    # Initialize the first row and first column of the table\n    for i in range(len(set) + 1):\n        dp[i][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, len(set) + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the current sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                # Otherwise, include the current element in the subset if it helps to reach the current sum\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The result is stored in the bottom-right cell of the table\n    return dp[-1][-1]\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    i = 1\n    while True:\n        factorial = 1\n        for j in range(1, i + 1):\n            factorial *= j\n        if factorial % x == 0:\n            return i\n        i += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [x for x in test_list1 if x not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    return str(n) == str(n)[::-1]\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r to avoid duplicate calculations\n        r = n - r\n    C = [0] * (r + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            C[j] += C[j - 1]\n    return C[r]\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) / 4) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Count the frequency of the maximum value\n    frequency = arr.count(max_val)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the center of the hexagon\n    center_x = (startx + endx) / 2\n    center_y = (starty + endy) / 2\n\n    # Calculate the distance between the start and end points\n    distance = math.sqrt((endx - startx) ** 2 + (endy - starty) ** 2)\n\n    # Calculate the angle between the start and end points\n    angle = math.atan2(endy - starty, endx - startx)\n\n    # Calculate the radius of the hexagon\n    hex_radius = radius\n\n    # Calculate the coordinates of the hexagon\n    hex_coords = []\n    for i in range(6):\n        # Calculate the angle of the current point\n        point_angle = angle + (i * math.pi / 3)\n\n        # Calculate the x and y coordinates of the current point\n        point_x = center_x + math.cos(point_angle) * hex_radius\n        point_y = center_y + math.sin(point_angle) * hex_radius\n\n        # Add the point to the list of coordinates\n        hex_coords.append((point_x, point_y))\n\n    return hex_coords\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert binary tuple to string\n    binary_str = ''.join(test_tup)\n    # Convert binary string to integer\n    integer = int(binary_str, 2)\n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    for _ in range(n):\n        print(hq.heappop(nums))\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate slant height\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate surface area\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while y:\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    # Find the greatest common divisor of two numbers\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return gcd(x, y)\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(range(nums[0], nums[-1] + 1))\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    elif k == 0 or k == n:\n        return 1\n    else:\n        return permutation_coefficient(n - 1, k - 1) + permutation_coefficient(n - 1, k)\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    removewords_set = set(removewords)\n    \n    # Use a list comprehension to create a new list that excludes the words to remove\n    new_list = [word for word in list1 if word not in removewords_set]\n    \n    return new_list\n"}
{"task_id": "MBPP/508", "completion": "\n    return list(l1) == list(l2)\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product < k:\n            count += 1\n    return count\n"}
