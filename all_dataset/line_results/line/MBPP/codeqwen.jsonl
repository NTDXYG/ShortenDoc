{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    if ch in s:\n        s.remove(ch)\n    if ch in s:\n        s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(M, key=lambda row: sum(row))\n    return sorted_matrix\n"}
{"task_id": "MBPP/13", "completion": "\n    word_count = Counter(words)\n    most_common = word_count.most_common(3)\n    return most_common\n\n"}
{"task_id": "MBPP/14", "completion": "\n    return (l * b * h) / 2\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.findall('[A-Z][^A-Z]*', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.findall(r'[a-z]+_[a-z]+', text)\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return 4 * a\n"}
{"task_id": "MBPP/18", "completion": "\n    count = [0] * NO_OF_CHARS\n    for char in string:\n        count[ord(char)] += 1\n    result = \"\"\n    for char in string:\n        if count[ord(char)] == 1:\n            result += char\n    return result\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    if x < 1:\n        return False\n    n = 1\n    while True:\n        woodall_num = n * (2 ** n) - 1\n        if woodall_num == x:\n            return True\n        elif woodall_num > x:\n            return False\n        n += 1\n"}
{"task_id": "MBPP/21", "completion": "\n    return [n * i for i in range(1, m + 1)]\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n"}
{"task_id": "MBPP/23", "completion": "\n    max_sum = float('-inf')\n    for sublist in list1:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    product = 1\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if arr[i] == arr[j]:\n                count += 1\n        if count == 1:\n            product *= arr[i]\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    res = all(i in test_list for i in range(1, K + 1))\n    return res\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    # Base Cases\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n\n    # Recursive Cases\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)\n\n"}
{"task_id": "MBPP/29", "completion": "\n    for i in range(arr_size):\n        count = 0\n        for j in range(arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if count % 2 != 0:\n            return arr[i]\n    return -1\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    count = collections.Counter(nums)\n    heap = []\n    for num, freq in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (freq, num))\n    return [num for freq, num in heap]\n\n"}
{"task_id": "MBPP/32", "completion": "\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n = n / 2\n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)\n\n"}
{"task_id": "MBPP/33", "completion": "\n    binary = \"\"\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary\n"}
{"task_id": "MBPP/34", "completion": "\n    start = 0\n    end = N - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if ar[mid] != mid + ar[0]:\n            if mid == 0 or ar[mid - 1] == mid + ar[0] - 1:\n                return mid + ar[0]\n            end = mid - 1\n        else:\n            start = mid + 1\n    return -1\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/36", "completion": "\n    # Calculate the total number of digits in the proper fraction\n    total_digits = p * q - p - q + 1\n\n    # If N is greater than the total number of digits, return -1\n    if N > total_digits:\n        return -1\n\n    # Initialize variables to keep track of the current digit and the position of the Nth digit\n    current_digit = 0\n    current_position = 0\n\n    # Iterate through the proper fraction to find the Nth digit\n    while current_position < N:\n        # If the current position is in the numerator, increment the numerator\n        if current_position < p:\n            current_digit = current_digit * 10 + 1\n        # If the current position is in the denominator, decrement the denominator\n        else:\n            current_digit = current_digit * 10\n            current_digit //= q - 1\n        # Move to the next position\n        current_position += 1\n\n    # Return the Nth digit\n    return current_digit % 10\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate and sort the integers and strings\n    numbers = sorted([item for item in mixed_list if isinstance(item, int)])\n    words = sorted([item for item in mixed_list if isinstance(item, str)])\n    \n    # Combine the sorted integers and strings\n    sorted_list = numbers + words\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if num % 2 == 0:\n            if even_num is None:\n                even_num = num\n            else:\n                even_num /= num\n        else:\n            if odd_num is None:\n                odd_num = num\n            else:\n                odd_num /= num\n    return even_num, odd_num\n"}
{"task_id": "MBPP/39", "completion": "\n    # Count the frequency of each character\n    freq = Counter(S)\n    # Create a max heap based on the frequency of characters\n    max_heap = [(-freq[char], char) for char in freq]\n    heapq.heapify(max_heap)\n    # Check if the rearranged string is possible\n    if (-max_heap[0][0]) * 2 > len(S) + 1:\n        return \"\"\n    # Rearrange the characters\n    rearranged = []\n    while len(max_heap) > 1:\n        freq1, char1 = heapq.heappop(max_heap)\n        freq2, char2 = heapq.heappop(max_heap)\n        rearranged.extend([char1, char2])\n        if freq1 + 1 < 0:\n            heapq.heappush(max_heap, (freq1 + 1, char1))\n        if freq2 + 1 < 0:\n            heapq.heappush(max_heap, (freq2 + 1, char2))\n    if max_heap:\n        rearranged.append(max_heap[0][1])\n    return \"\".join(rearranged)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    # Flatten the list of lists\n    flat_list = list(chain.from_iterable(nums))\n    # Count the frequency of each element\n    freq = Counter(flat_list)\n    return freq\n\n"}
{"task_id": "MBPP/41", "completion": "\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create an empty dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n    \n    # Initialize the sum to 0\n    sum = 0\n    \n    # Iterate over the dictionary and add the product of each element and its frequency to the sum\n    for key, value in freq.items():\n        sum += key * value\n    \n    return sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = '^\\w+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/45", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(data) == len(set(data))\n"}
{"task_id": "MBPP/47", "completion": "\n    result = 1\n    if A == B:\n        return 1\n    elif (B - A) >= 5:\n        return 0\n    else:\n        for i in range(A + 1, B + 1):\n            result = (result * (i % 10)) % 10\n        return result\n"}
{"task_id": "MBPP/48", "completion": "\n    # Initialize the result and bit position\n    result = n\n    bit_position = 0\n    \n    # Iterate over all bits of the number\n    while n > 0:\n        # Check if the current bit position is odd\n        if bit_position % 2 == 0:\n            # Set the bit at the current position\n            result |= (1 << bit_position)\n        \n        # Move to the next bit position\n        bit_position += 1\n        # Shift the number to the right by one bit\n        n >>= 1\n    \n    return result\n"}
{"task_id": "MBPP/49", "completion": "\n    return [row[N] for row in nums]\n"}
{"task_id": "MBPP/50", "completion": "\n    min_length_list = min(input_list, key=lambda x: len(x))\n    return min_length_list\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if str[0] == str[-1]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    if not my_list:\n        return []\n\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Initialize the count array with zeros\n    count_array = [0] * (max_value + 1)\n\n    # Populate the count array\n    for num in my_list:\n        count_array[num] += 1\n\n    # Generate the sorted list\n    sorted_list = []\n    for i, count in enumerate(count_array):\n        sorted_list.extend([i] * count)\n\n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    tn = a * (math.pow(r, n - 1))\n    return tn\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return 2 * rev(n) == n + 1 print(check_f(21))  # True print(check_f(10))  # False print(check_f(12))  # True print(check_f(13))  # False print(check_f(24))  # True print(check_f(25))  # False\n    \"\"\"\n    \"\"\"\n    return 2 * rev(n) == n + 1 print(check_f(21))  # True print(check_f(10))  # False print(check_f(12))  # True print(check_f(13))  # False print(check_f(24))  # True print(check_f(25))  # False\n    \"\"\"\n    \"\"\"\n    return 2 * rev(n) == n + 1 print(check_f(21))  # True print(check_f(10))  # False print(check_f(12))  # True print(check_f(13))  # False print(check_f(24))  # True print(check_f(25))  # False\n    \"\"\"\n    \"\"\"\n    return 2 * rev(n) == n + 1 print(check_f(21))  # True print(check_f(10))  # False print(check_f(12))  # True print(check_f(13))  # False print(check_f(24))  # True print(check_f(25))  # False\n    \"\"\"\n    \"\"\"\n    return 2 * rev(n) == n + 1 print(check_f(21))  # True print(check_f(10))  # False print(check_f(12))  # True print(check_f(13))  # False print(check_f(24))  # True print(check_f(25))  # False\n    \"\"\""}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    max_num = int(\"\".join(map(str, arr)))\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x ^ y) < 0\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2)\n"}
{"task_id": "MBPP/60", "completion": "\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n"}
{"task_id": "MBPP/61", "completion": "\n    count = 0\n    sum_dict = defaultdict(int)\n    sum_dict[0] = 1\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += ord(s[i]) - ord('0')\n        count += sum_dict[current_sum - (i + 1)]\n        sum_dict[current_sum - (i + 1)] += 1\n\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    if len(xs) == 0:\n        return None\n    else:\n        smallest = xs[0]\n        for x in xs:\n            if x < smallest:\n                smallest = x\n        return smallest\n"}
{"task_id": "MBPP/63", "completion": "\n    # Calculate the difference between each pair\n    diff_list = [abs(x - y) for x, y in test_list]\n    \n    # Return the maximum difference\n    return max(diff_list)\n"}
{"task_id": "MBPP/64", "completion": "\n    subjectmarks.sort(key = lambda x: x[1])\n    return subjectmarks\n"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    count = 0\n    for i in list:\n        if i > 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        bell[i] = bell[i - 1] * (i + 1)\n        for j in range(i - 1, 0, -1):\n            bell[j] = bell[j] + bell[j - 1]\n    return bell[n]\n"}
{"task_id": "MBPP/68", "completion": "\n    increasing = decreasing = True\n\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    if len(s) == 0:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l)):\n        if l[i] == s[0]:\n            n = 1\n            while (n < len(s)) and (l[i+n] == s[n]):\n                n += 1\n            if n == len(s):\n                return True\n    return False\n"}
{"task_id": "MBPP/70", "completion": "\n    # Check if all tuples have the same length\n    if all(len(t) == len(Input[0]) for t in Input):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/71", "completion": "\n    gap = len(nums)\n    shrink_factor = 1.3\n    is_sorted = False\n\n    while not is_sorted or gap > 1:\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        is_sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                is_sorted = False\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i * i - j * j == n) or (j * j - i * i == n):\n                return True\n    return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = [' ', ',', ';', ':', '.', '!', '?', '-', '_', '(', ')', '[', ']', '{', '}', '\"', \"'\", '\\n', '\\t']\n    \n    # Create a regex pattern from the delimiters\n    pattern = '|'.join(map(re.escape, delimiters))\n    \n    # Split the text using the pattern\n    return re.split(pattern, text)\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    \n    pattern_to_color = {}\n    color_to_pattern = {}\n    \n    for i in range(len(patterns)):\n        if patterns[i] not in pattern_to_color and colors[i] not in color_to_pattern:\n            pattern_to_color[patterns[i]] = colors[i]\n            color_to_pattern[colors[i]] = patterns[i]\n        elif pattern_to_color.get(patterns[i]) != colors[i] or color_to_pattern.get(colors[i]) != patterns[i]:\n            return False\n    \n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    res = [ele for ele in test_list if all(num % K == 0 for num in ele)]\n    return res\n"}
{"task_id": "MBPP/76", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m and j * j <= n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n        n = n // 10\n    return abs(even_sum - odd_sum)\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    # Split the string into words\n    words = s.split()\n\n    # Iterate over each word\n    for word in words:\n        # Check if the length of the word is odd\n        if len(word) % 2 != 0:\n            return True\n    return False\n"}
{"task_id": "MBPP/80", "completion": "\n    return n * (n + 1) * (n + 2) // 6\n"}
{"task_id": "MBPP/81", "completion": "\n    res = tuple(zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * r**3\n\n"}
{"task_id": "MBPP/83", "completion": "\n    # Your code here\n    return chr(sum(ord(char) for char in strr))\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1 or n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for i in range(3, n + 1):\n            a, b = b, a + b\n        return b\n\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    if n < 1:\n        return \"Input should be greater than 0\"\n    return 3 * n * (n - 1) + 1\n\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    return collections.Counter(list1)\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return N - 1\n"}
{"task_id": "MBPP/90", "completion": "\n    if not list1:\n        return 0\n    longest = max(list1, key=len)\n    return len(longest)\n"}
{"task_id": "MBPP/91", "completion": "\n    return sub_str in str1\n"}
{"task_id": "MBPP/92", "completion": "\n    n = str(n)\n    if len(n) < 3 or n[0] == n[1] == n[2]:\n        return False\n    for i in range(2, len(n)):\n        if i % 2 == 0 and n[i] != n[0]:\n            return False\n        elif i % 2 != 0 and n[i] != n[1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    if b == 0:\n        return 1\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        result = 1\n        for i in range(b):\n            result *= a\n        return result\n"}
{"task_id": "MBPP/94", "completion": "\n    res = min(enumerate(test_list), key=itemgetter(1))\n    return res\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_len = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n    return min_len\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict\n"}
{"task_id": "MBPP/98", "completion": "\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n\n"}
{"task_id": "MBPP/101", "completion": "\n    if n < k:\n        return -1\n    else:\n        arr.sort()\n        return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return ((n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m))\n\n"}
{"task_id": "MBPP/104", "completion": "\n    # Sort each sublist using a lambda function\n    sorted_list = [sorted(sublist, key=lambda s: s.lower()) for sublist in input_list]\n    return sorted_list\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    res = [ele + tup for ele, tup in zip(test_list, test_tup)]\n    return res\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if 'A' <= hex(i)[2].upper() <= 'F':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Combine all the sorted lists into one\n    combined_list = heapq.merge(num1, num2, num3)\n    \n    # Convert the iterator to a list and return\n    return list(combined_list)\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if s[i] == '1':\n            count += 1\n    return count % 2\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    current_start = strt_val\n\n    for num in test_list:\n        if num > current_start:\n            missing_ranges.append((current_start, num))\n        current_start = max(current_start, num + 1)\n\n    if current_start < stop_val:\n        missing_ranges.append((current_start, stop_val))\n\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    # Flatten the nested list\n    flat_list = [item for sublist in nestedlist for item in sublist]\n    \n    # Find the most common element\n    common_element = max(set(flat_list), key=flat_list.count)\n    \n    return common_element\n"}
{"task_id": "MBPP/112", "completion": "\n    return 2 * (diameter + height)\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    res = Counter(test_list)\n    return list(res.items())\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if i:\n            return False\n    return True\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    result = []\n    for item in test_list:\n        try:\n            result.append(float(item))\n        except ValueError:\n            result.append(item)\n    return result\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        mid = low + (high - low) // 2\n\n        # Check if the mid is even or odd\n        if mid % 2 == 0:\n            # Check if the mid and mid+1 are same\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid\n        else:\n            # Check if the mid and mid-1 are same\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n    return arr[low]\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = float('-inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    if count == 3 and sum == 0:\n        return True\n    if count == 3 or n == 0 or sum < 0:\n        return False\n    # Include the current element in the sum and increment the count\n    include = check_triplet(A, n-1, sum-A[n-1], count+1)\n    # Exclude the current element from the sum\n    exclude = check_triplet(A, n-1, sum, count)\n    return include or exclude\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize a list to store the count of divisors for each number\n    divisorCount = [0] * (MAX + 1)\n\n    # Iterate over all numbers from 1 to MAX\n    for i in range(1, MAX + 1):\n        # Iterate over all factors of the current number\n        for j in range(i, MAX + 1, i):\n            # Increment the count of divisors for the current factor\n            divisorCount[j] += 1\n\n    # Initialize a list to store the smart numbers\n    smartNumbers = []\n\n    # Iterate over all numbers from 1 to MAX\n    for i in range(1, MAX + 1):\n        # If the count of divisors for the current number is greater than or equal to 5,\n        # it is a smart number, so add it to the list\n        if divisorCount[i] >= 5:\n            smartNumbers.append(i)\n\n    # Return the n\u2019th smart number from the list\n    return smartNumbers[n - 1]\n\n"}
{"task_id": "MBPP/123", "completion": "\nHelper function to calculate the sum of proper divisors of n.\"\"\"\n        return sum([i for i in range(1, n) if n % i == 0])\n\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_proper_divisors(a)\n        if a != b and sum_proper_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(a + b)\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    current_diff = 0\n    for i in range(n):\n        if string[i] == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        if current_diff < 0:\n            current_diff = 0\n        max_diff = max(max_diff, current_diff)\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n    return sum(common_divisors)\n"}
{"task_id": "MBPP/127", "completion": "\n    # Check if y is negative\n    if y < 0:\n        return -multiply_int(x, -y)\n    # Base case: if y is 0, the result is 0\n    elif y == 0:\n        return 0\n    # Recursive case: add x to the result of multiplying x by y-1\n    else:\n        return x + multiply_int(x, y-1)\n"}
{"task_id": "MBPP/128", "completion": "\n    word_list = str.split(\" \")\n    long_word_list = []\n    for word in word_list:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the sum of the rows is the same\n    row_sums = [sum(row) for row in my_matrix]\n    if len(set(row_sums)) != 1:\n        return False\n\n    # Check if the sum of the columns is the same\n    col_sums = [sum(col) for col in zip(*my_matrix)]\n    if len(set(col_sums)) != 1:\n        return False\n\n    # Check if the sum of the diagonals is the same\n    diag_sum1 = sum(my_matrix[i][i] for i in range(len(my_matrix)))\n    diag_sum2 = sum(my_matrix[i][len(my_matrix)-1-i] for i in range(len(my_matrix)))\n    if diag_sum1 != diag_sum2 or len(set([diag_sum1, diag_sum2])) != 1:\n        return False\n\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    return max(count.values())\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] in vowels and str1[right] in vowels:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n        elif str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return ''.join(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    negative_nums = list(filter(lambda x: x < 0, nums))\n    return sum(negative_nums)\n"}
{"task_id": "MBPP/134", "completion": "\n    if p % 2 == 0:\n        return arr[-1] % 2 == 0\n    else:\n        return (arr[-1] + 1) % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units <= 50:\n        bill = units * 2.60\n    elif units <= 100:\n        bill = 130 + ((units - 50) * 3.25)\n    elif units <= 200:\n        bill = 130 + 162.5 + ((units - 100) * 5.26)\n    else:\n        bill = 130 + 162.5 + 526 + ((units - 200) * 8.45)\n    return bill\n"}
{"task_id": "MBPP/137", "completion": "\n    zero_count = 0\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    return zero_count / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n            if n % 2 != 0:\n                return False\n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    pi = 3.14\n    return 2 * pi * r\n"}
{"task_id": "MBPP/140", "completion": "\n    res = []\n    for ele in test_list:\n        if test_list.count(ele) == 1:\n            res.append(ele)\n    return res\n"}
{"task_id": "MBPP/141", "completion": "\n    for i in range(len(nums), 1, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:i]))\n        \n        # Flip the list from the start to the index of the maximum element\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        \n        # Flip the list from the start to the current index\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for i in Input:\n        if isinstance(i, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum = 0\n    for i in range(n):\n        sum += (arr[i] * i) - (arr[i] * (n - i - 1))\n    return sum\n"}
{"task_id": "MBPP/145", "completion": "\n    if n < 2:\n        return -1\n    \n    max_diff = arr[1] - arr[0]\n    min_element = arr[0]\n    \n    for i in range(1, n):\n        max_diff = max(max_diff, arr[i] - min_element)\n        min_element = min(min_element, arr[i])\n    \n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    if m == 0:\n        return tri[0][0]\n    if m == n:\n        return max(tri[m])\n    else:\n        tri[m][n] += max(max_path_sum(tri, m - 1, n), max_path_sum(tri, m - 1, n - 1))\n        return tri[m][n]\n\n"}
{"task_id": "MBPP/148", "completion": "\n    sum_digits = 0\n    while x > 0:\n        sum_digits += x % 10\n        x //= 10\n    return sum_digits\n"}
{"task_id": "MBPP/149", "completion": "\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    if a > b:\n        return False\n    return does_Contain_B(a + c, b, c)\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:]))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:]))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:]))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:]))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:]))\n    \"\"\"\n    Write a function to sort the given array by using merge sort.\n    \"\"\"\n    if len(x) == 1: return x else: return merge(merge_sort(x[:len(x)//2]), merge_sort(x[len(x)//2:"}
{"task_id": "MBPP/153", "completion": "\n    x_vertex = -b / (2 * a)\n    y_vertex = a * x_vertex ** 2 + b * x_vertex + c\n    return (x_vertex, y_vertex)\n"}
{"task_id": "MBPP/154", "completion": "\n    result = []\n    for sublist in nums:\n        if len(sublist) > N:\n            result.append(sublist[N])\n    return result\n"}
{"task_id": "MBPP/155", "completion": "\n    result = 0\n    count = 0\n    temp = n\n    while temp > 0:\n        # Check if the bit position is even\n        if count % 2 == 0:\n            # Toggle the bit at the current position\n            result = result | (1 << count)\n        count += 1\n        temp >>= 1\n    return n ^ result\n"}
{"task_id": "MBPP/156", "completion": "\n    tuple_int = tuple(int(i) for i in tuple_str)\n    return tuple_int\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(sum(1 for _ in group), key) for key, group in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Your code here\n    arr.sort()\n    count = 0\n    for i in range(n):\n        if arr[i] < k:\n            count += k - arr[i]\n        elif arr[i] > k:\n            count += arr[i] - k\n    return count\n"}
{"task_id": "MBPP/159", "completion": "\n    if month in ('January', 'February', 'March'):\n        return 'winter'\n    elif month in ('April', 'May', 'June'):\n        return 'spring'\n    elif month in ('July', 'August', 'September'):\n        return 'summer'\n    elif month in ('October', 'November', 'December'):\n        return 'autumn'\n    else:\n        return 'Invalid month'\n"}
{"task_id": "MBPP/160", "completion": "\n    for x in range(n+1):\n        y = (n - (a*x)) / b\n        if y.is_integer():\n            return x, int(y)\n    return None\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return n + sum_series(n-2)\n"}
{"task_id": "MBPP/163", "completion": "\n    return s * (l ** 2) / (4 * tan(pi / s))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    # Initialize sum of divisors\n    sum1 = 1\n    sum2 = 0\n\n    # Iterate through all possible divisors\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # If i is a divisor of n\n        if n % i == 0:\n            # If both divisors are same then add it only once\n            if i == (n // i):\n                sum1 += i\n            else:\n                # Add both divisors\n                sum1 += (i + (n // i))\n\n    # Iterate through all possible divisors\n    for i in range(1, int(math.sqrt(n)) + 1):\n        # If i is a divisor of n\n        if n % i == 0:\n            # If both divisors are same then add it only once\n            if i == (n // i):\n                sum2 += i\n            else:\n                # Add both divisors\n                sum2 += (i + (n // i))\n\n    # Return True if both sums are equal else False\n    return (sum1 == sum2)\n\n"}
{"task_id": "MBPP/165", "completion": "\n    count = 0\n    for i in range(len(str1)):\n        if str1[i].lower() == chr(ord('a') + i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/166", "completion": "\n    even_pairs = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs\n"}
{"task_id": "MBPP/167", "completion": "\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/168", "completion": "\n    count = 0\n    for i in a:\n        if i == x:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        prev = 0\n        curr = 1\n        for i in range(2, n + 1):\n            next_num = 2 * curr + prev\n            prev = curr\n            curr = next_num\n        return curr\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for i in range(len(s)):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'\\W+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    result = {}\n    for key, value in l:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    for i in range(L, R+1):\n        for j in range(i+1, R+1):\n            if (i*j) >= L and (i*j) <= R:\n                return [i, j]\n    return [-1]\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Convert the number to a list of its digits\n    digits = [int(d) for d in str(x)]\n    \n    # Initialize the sum with the first n digits of the number\n    sum_digits = sum(digits[:len(digits)])\n    \n    # Generate the next terms of the sequence and check if the number is a Keith number\n    for i in range(len(digits), x):\n        sum_digits = sum_digits - digits[i - len(digits)] + i\n        if sum_digits == x:\n            return True\n    return False\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n\n    # Calculate the distance using the Haversine formula\n    dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon))\n\n    return dist\n\n"}
{"task_id": "MBPP/181", "completion": "\n    common_prefix = \"\"\n    length = min(len(str1), len(str2))\n    for i in range(length):\n        if str1[i] == str2[i]:\n            common_prefix += str1[i]\n        else:\n            break\n    return common_prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    uppercase = re.findall(r\"[A-Z]\", string)\n    lowercase = re.findall(r\"[a-z]\", string)\n    special_char = re.findall(r\"[^A-Za-z0-9]\", string)\n    numeric = re.findall(r\"\\d\", string)\n\n    return uppercase, lowercase, special_char, numeric\n\n"}
{"task_id": "MBPP/183", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) == k:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    x_focus = -b / (2 * a)\n    y_focus = (1 - (b ** 2) + (4 * a * c)) / (4 * a)\n    return (x_focus, y_focus)\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return 'Matched!'\n        else:\n            return 'Not Matched!'\n\n"}
{"task_id": "MBPP/187", "completion": "\n    if m == 0 or n == 0:\n        return 0\n    elif X[m-1] == Y[n-1]:\n        return 1 + longest_common_subsequence(X, Y, m-1, n-1)\n    else:\n        return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))\n"}
{"task_id": "MBPP/188", "completion": "\n    for i in range(1, n):\n        for j in range(1, n):\n            if i*i * j*j == n:\n                return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    for i in range(n):\n        if arr[i] <= 0 or arr[i] > n:\n            arr[i] = n + 1\n    for i in range(n):\n        index = abs(arr[i]) - 1\n        arr[index] = -abs(arr[index])\n    for i in range(n):\n        if arr[i] > 0:\n            return i + 1\n    return n + 1\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points inside the square\n    integral_points = (x2 - x1 - 1) * (y2 - y1 - 1)\n    return integral_points\n"}
{"task_id": "MBPP/191", "completion": "\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    return monthname3 in months_with_30_days\n"}
{"task_id": "MBPP/192", "completion": "\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        if has_letter and has_number:\n            return True\n    return False\n"}
{"task_id": "MBPP/193", "completion": "\n    res = tuple(set(test_tup))\n    return res\n"}
{"task_id": "MBPP/194", "completion": "\n    num = n\n    dec_value = 0\n    base = 1\n    temp = num\n    while temp:\n        last_digit = temp % 10\n        temp = int(temp / 10)\n        dec_value += last_digit * base\n        base = base * 8\n    return dec_value\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            res = mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return res\n"}
{"task_id": "MBPP/196", "completion": "\n    res = [ele for ele in test_list if len(ele) != K]\n    return res\n"}
{"task_id": "MBPP/197", "completion": "\n    res = tuple(pow(x, y) for x, y in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/198", "completion": "\n    if a < b:\n        a, b = b, a\n    if a <= 0 or b <= 0:\n        return -1\n    return math.sqrt(a**2 - (b**2 / 4))\n\n"}
{"task_id": "MBPP/199", "completion": "\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/200", "completion": "\n    max_value = max(list1)\n    positions = [index for index, value in enumerate(list1) if value == max_value]\n    return positions\n"}
{"task_id": "MBPP/201", "completion": "\n    return all(x == lst[0] for x in lst)\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    xor = n1 ^ n2\n    count = 0\n    while xor:\n        count += xor & 1\n        xor >>= 1\n    return count\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    res = [test_tup[i] for i in range(len(test_tup)) if test_tup[i] < 0]\n    return res\n"}
{"task_id": "MBPP/206", "completion": "\n    result = ''.join([str(elem) + str(test_tup[index + 1]) for index, elem in enumerate(test_tup) if index < len(test_tup) - 1])\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n\n    return dp[n][n]\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = re.compile(r\"^\\d+(\\.\\d{1,2})?$\")\n    return bool(pattern.match(str(num)))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heapify(heap)\n    hq.heappushpop(heap, a)\n    return heap\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'[^a-zA-Z0-9.]')\n    match = pattern.search(string)\n    return not bool(match)\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if (i & (1 << 0)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([math.pow(i, 4) for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    # Using map and join to concatenate strings in tuples\n    result = tuple(map(''.join, zip(test_tup1, test_tup2)))\n    return result\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * (180 / math.pi)\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    for item in alist:\n        if isinstance(item, list):\n            decoded_list.extend([item[1]] * item[0])\n        else:\n            decoded_list.append(item)\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\nFlatten a nested list.\"\"\"\n        for elem in lst:\n            if isinstance(elem, list):\n                yield from flatten(elem)\n            else:\n                yield elem\n\n    flat_list1 = set(flatten(list1))\n    flat_list2 = set(flatten(list2))\n\n    return flat_list1.issubset(flat_list2)\n"}
{"task_id": "MBPP/217", "completion": "\n    seen = set()\n    for char in str:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # If A is greater than B, swap them\n    if A > B:\n        A, B = B, A\n\n    # If A is 0, return B\n    if A == 0:\n        return B\n\n    # If B is a multiple of A, return B/A - 1\n    if B % A == 0:\n        return B // A - 1\n\n    # If none of the above conditions are met, return -1\n    return -1\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Extracting min and max elements\n    min_val = min(test_tup)\n    max_val = max(test_tup)\n    \n    # Extracting min and max k elements\n    min_k_elements = sorted(test_tup)[:K]\n    max_k_elements = sorted(test_tup, reverse=True)[:K]\n    \n    return min_val, max_val, min_k_elements, max_k_elements\n"}
{"task_id": "MBPP/220", "completion": "\n    return re.sub(\"[ ,.]\", \":\", text, n)\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    if not test_tuple:\n        return True\n    first_element_type = type(test_tuple[0])\n    return all(isinstance(element, first_element_type) for element in test_tuple)\n"}
{"task_id": "MBPP/223", "completion": "\n    index = first_occurrence(arr, n, x)\n    if index == -1:\n        return False\n    if ((index + n // 2) < n and arr[index + n // 2] == x):\n        return True\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return arr[low]\n"}
{"task_id": "MBPP/226", "completion": "\n    return str[::2]\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Create a number with all bits set in the given range\n    mask = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n    # Apply the mask and check if the result is zero\n    return (n & mask) == 0\n"}
{"task_id": "MBPP/229", "completion": "\n    neg = []\n    pos = []\n    for i in arr:\n        if i < 0:\n            neg.append(i)\n        else:\n            pos.append(i)\n    return neg + pos\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(' ', char)\n"}
{"task_id": "MBPP/231", "completion": "\n    if n == 0:\n        return tri[0][0]\n    for i in range(1, n+1):\n        tri[i][0] += tri[i-1][0]\n        tri[i][i] += tri[i-1][i-1]\n        for j in range(1, i):\n            tri[i][j] += max(tri[i-1][j-1], tri[i-1][j])\n    return max(tri[n])\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * 3.1415 * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    count = 0\n    temp = n\n    while temp > 0:\n        if count % 2 == 0:\n            n |= (1 << count)\n        count += 1\n        temp >>= 1\n    return n\n"}
{"task_id": "MBPP/236", "completion": "\n    if N < K:\n        return -1\n    else:\n        return ((N - K + 1) * (N - K + 2)) // 2\n"}
{"task_id": "MBPP/237", "completion": "\n    res = Counter(test_list)\n    return {key: val for key, val in res.items() if val == max(res.values())}\n\n"}
{"task_id": "MBPP/238", "completion": "\n    return len(str) * (len(str) + 1) // 2\n"}
{"task_id": "MBPP/239", "completion": "\n    # Initialize a 2D list to store intermediate results\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if j == 1:\n                # Base case: There is only one way to form a sequence of length 1\n                dp[i][j] = i\n            else:\n                # Recurrence relation: Sum of sequences of length j-1 and sequences of length j with the last element being i-1\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n\n    return dp[m][n]\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1:] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[[ '*' for _ in range(m)] for _ in range(n)] for _ in range(o)]\n"}
{"task_id": "MBPP/242", "completion": "\n    count = 0\n    for i in str1:\n        count += 1\n    return count\n"}
{"task_id": "MBPP/243", "completion": "\n    # Create a dictionary to store the occurrence of the first element of tuples\n    occurrence = {}\n    for tup in lst:\n        if tup[0] in occurrence:\n            occurrence[tup[0]] += 1\n        else:\n            occurrence[tup[0]] = 1\n\n    # Sort the list based on the occurrence of the first element of tuples\n    lst.sort(key=lambda x: occurrence[x[0]])\n\n    return lst\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.ceil(math.sqrt(N))\n    return root ** 2\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Create two arrays to store maximum sum of increasing and decreasing subsequences ending at each index\n    inc = [0]*n\n    dec = [0]*n\n\n    # Initialize the first element of both arrays\n    inc[0] = arr[0]\n    dec[n-1] = arr[n-1]\n\n    # Fill inc[] array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n\n    # Fill dec[] array\n    for i in range(n-2, -1, -1):\n        for j in range(i, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n\n    # Find the maximum sum of bi-tonic sub-sequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum\n"}
{"task_id": "MBPP/246", "completion": "\n    if number == 0:\n        return 0\n    estimate = number / 2.0\n    while True:\n        next_estimate = (estimate + number / estimate) / 2\n        if abs(next_estimate - estimate) < 1e-10:  # Arbitrary precision check\n            break\n        estimate = next_estimate\n    return estimate\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    L = [[0 for x in range(n)]for y in range(n)]\n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        L[i][i] = 1\n    # Build the table. The bottom-up approach is used here.\n    for sub_len in range(2, n+1):\n        for start in range(n-sub_len+1):\n            end = start + sub_len - 1\n            if str[start] == str[end] and sub_len == 2:\n                L[start][end] = 2\n            elif str[start] == str[end]:\n                L[start][end] = L[start+1][end-1] + 2\n            else:\n                L[start][end] = max(L[start][end-1], L[start+1][end])\n    return L[0][n-1]\n"}
{"task_id": "MBPP/248", "completion": "\n    if n == 1:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)\n\n"}
{"task_id": "MBPP/249", "completion": "\n    intersection = list(filter(lambda x: x in array_nums1, array_nums2))\n    return intersection\n"}
{"task_id": "MBPP/250", "completion": "\n    count = 0\n    for i in tup:\n        if i == x:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/251", "completion": "\n    return [item for sublist in [[element, item] for item in list] for item in sublist]\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = [cmath.polar(num) for num in numbers]\n    return polar_coordinates\n\n"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if type(i) == int:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    pattern = r'\\b[ae]\\w*\\b'\n    return re.findall(pattern, text, re.IGNORECASE)\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'blue', 'green']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    if n <= 2:\n        return 0\n    \n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n                \n    return sum(is_prime)\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    odd_count = len(list(filter(lambda x: (x % 2 != 0), array_nums)))\n    return odd_count\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum values in each list\n    max_val1 = max(list1)\n    max_val2 = max(list2)\n    \n    # Return the tuples with the maximum values\n    return (max_val1, max_val2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def nsw_number(n):\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 1\n        else:\n            return 2 * nsw_number(n - 1) + nsw_number(n - 2)\n\n    count = 0\n    i = 0\n    while True:\n        num = nsw_number(i)\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        i += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    res = tuple(a / b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    if h_age < 0:\n        return \"Invalid age\"\n    elif h_age <= 2:\n        d_age = h_age * 10.5\n    else:\n        d_age = 21 + (h_age - 2) * 4\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i+step] for i in range(0, len(S), step)]\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l ** 2\n"}
{"task_id": "MBPP/267", "completion": "\n    return n * (2 * n - 1) * (2 * n + 1) // 3\n"}
{"task_id": "MBPP/268", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return n + find_star_num(n-1)\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    sum_even = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum_even += arr[i]\n    return sum_even\n"}
{"task_id": "MBPP/271", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return [sub[-1] for sub in test_list]\n"}
{"task_id": "MBPP/273", "completion": "\n    res = tuple(map(lambda x, y: x - y, test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize result\n    res = 0\n\n    # Loop for each value of k\n    for k in range(0, n + 1, 2):\n        # Calculate binomial coefficient\n        binomial = math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n\n        # Add to result\n        res += binomial\n\n    return res\n\n"}
{"task_id": "MBPP/275", "completion": "\n    if n == 1:\n        return 0\n    a = a[n - 1:] + a[:n - 1]\n    m = m % n\n    return get_Position(a, n - 1, m)\n\n"}
{"task_id": "MBPP/276", "completion": "\n    pi = 3.14159\n    return pi * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {k: v for k, v in dict.items() if v > n}\n"}
{"task_id": "MBPP/278", "completion": "\n    res = [len(test_tup) - i - 1 for i, ele in enumerate(test_tup) if isinstance(ele, tuple)]\n    return res[0] if res else 0\n"}
{"task_id": "MBPP/279", "completion": "\n    if n < 1:\n        return \"Input should be a positive integer.\"\n    return n * 10\n"}
{"task_id": "MBPP/280", "completion": "\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos += 1\n    return found, pos\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    result = map(lambda x, y: x - y, nums1, nums2)\n    return list(result)\n"}
{"task_id": "MBPP/283", "completion": "\n    for i in range(1, n+1):\n        count = 0\n        temp = i\n        while temp > 0:\n            digit = temp % 10\n            if i % digit == 0:\n                count += 1\n            temp //= 10\n        if count == 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = 'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/286", "completion": "\n    max_sum = float('-inf')\n    current_sum = 0\n    total_sum = sum(a) * k\n    \n    for i in range(n * k):\n        current_sum += a[i % n]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_sum if max_sum != float('-inf') else total_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return (n * (n + 1) * (2 * n + 1)) // 3\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for i in range(N):\n        if (arr[i] * arr[i]) % P == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Your code here\n    return N % 7\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = max(len(i) for i in list1)\n    return [i for i in list1 if len(i) == max_len]\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same, diff = k, k * (k - 1)\n    total = same + diff\n    for i in range(3, n + 1):\n        same = diff\n        diff = total * (k - 1)\n        total = (same + diff) % 1000000007\n    return total\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    max_val = listval[0]\n    for val in listval:\n        if val > max_val:\n            max_val = val\n    return max_val\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [1]\n    for i in range(2, number):\n        if number % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n"}
{"task_id": "MBPP/297", "completion": "\n    flattened_list = []\n    for i in list1:\n        if isinstance(i, list):\n            flattened_list.extend(flatten_list(i))\n        else:\n            flattened_list.append(i)\n    return flattened_list\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for sublist1 in l1:\n        for sublist2 in l2:\n            if sublist1 in sublist2:\n                result.append(sublist1)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    aggregate_dict = defaultdict(int)\n    for key, value in stdata:\n        aggregate_dict[key] += value\n    return max(aggregate_dict.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    # Initialize a 2D array to store intermediate results\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    \n    # Base case: There is only one sequence of length 0 with sum 0\n    dp[0][0] = 1\n    \n    # Fill the dp array\n    for i in range(1, n+1):\n        for j in range(i+1):\n            # If the sum of the first i bits is equal to the sum of the last i bits\n            if j == i:\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j-1]\n    \n    # The answer is the sum of sequences of length 2n with sum of first n bits equal to sum of last n bits\n    return dp[n][n]\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict) or not d:\n        return 0\n    else:\n        return 1 + max(dict_depth(value) for value in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    if n == 0:\n        return 0\n    msb = 0\n    n = abs(n)\n    while n > 0:\n        n = n >> 1\n        msb += 1\n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/304", "completion": "\n    for i in range(rotations):\n        start, end = ranges[i]\n        if start <= index <= end:\n            if index == start:\n                index = end\n            else:\n                index -= 1\n    return arr[index]\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = r'\\b(p\\w+)\\b.*\\b(p\\w+)\\b'\n    result = re.search(pattern, words)\n    if result:\n        return result.groups()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == n:\n        return 0\n    if k == index:\n        return a[index]\n    if k < index:\n        return 0\n    if a[index] > a[k]:\n        return max(a[index] + max_sum_increasing_subseq(a, n, index + 1, k), max_sum_increasing_subseq(a, n, index + 1, k))\n    else:\n        return max_sum_increasing_subseq(a, n, index + 1, k)\n"}
{"task_id": "MBPP/307", "completion": "\n    # Create a deep copy of the tuple to avoid modifying the original\n    tuplex = deepcopy(tuplex)\n    # Get the slice of the tuple from index m to index n (exclusive)\n    result = tuplex[m:n]\n    return result\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Calculate all possible products\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    \n    # Sort the products in descending order and return the top N products\n    return sorted(products, reverse=True)[:N]\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n"}
{"task_id": "MBPP/311", "completion": "\n    # If n is 0, return 1\n    if n == 0:\n        return 1\n    \n    # If n is already a power of 2, return n\n    if n & (n - 1) == 0:\n        return n\n    \n    # Find the left most unset bit\n    left_most_unset_bit = 1\n    while n & left_most_unset_bit:\n        left_most_unset_bit <<= 1\n    \n    # Set the left most unset bit\n    return n | left_most_unset_bit\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1/3) * math.pi * r * r * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    pos_nums = [num for num in list1 if num > 0]\n    return pos_nums\n"}
{"task_id": "MBPP/314", "completion": "\n    # Check if the grid is valid\n    if not grid or len(grid) != 2 or n != len(grid[0]):\n        return 0\n\n    # Initialize the maximum sum\n    max_sum = 0\n\n    # Iterate over all possible combinations of two numbers\n    for i in range(n):\n        for j in range(n):\n            for k in range(i + 1, n):\n                for l in range(k + 1, n):\n                    # Check if the two numbers are adjacent\n                    if abs(i - j) != 1 and abs(k - l) != 1:\n                        # Calculate the sum of the two numbers\n                        sum = grid[0][i] + grid[0][j] + grid[1][k] + grid[1][l]\n                        # Update the maximum sum\n                        max_sum = max(max_sum, sum)\n\n    return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/316", "completion": "\n    start, end = 0, len(A) - 1\n    last_found = -1\n    while start <= end:\n        mid = (start + end) // 2\n        if A[mid] == x:\n            last_found = mid\n            start = mid + 1\n        elif A[mid] < x:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return last_found\n"}
{"task_id": "MBPP/317", "completion": "\n    def encode_group(group):\n        count = len(group)\n        element = group[0]\n        if count == 1:\n            return element\n        else:\n            return (count, element)\n\n    return [encode_group(list(group)) for _, group in groupby(alist)]\n\n"}
{"task_id": "MBPP/318", "completion": "\n    # Your code here\n    pass\n"}
{"task_id": "MBPP/319", "completion": "\n    return re.findall(r\"\\b\\w{5}\\b\", text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_of_squares = sum([i**2 for i in range(1, n+1)])\n    squared_sum = sum([i for i in range(1, n+1)]) ** 2\n    return squared_sum - sum_of_squares\n"}
{"task_id": "MBPP/321", "completion": "\n    # Find the length of the string\n    n = len(s)\n    \n    # Initialize the demlo number\n    demlo = \"\"\n    \n    # Iterate over the string\n    for i in range(n):\n        # Find the maximum character in the string from the current index\n        max_char = max(s[i:])\n        \n        # Find the index of the maximum character\n        max_index = s[i:].index(max_char)\n        \n        # Append the maximum character to the demlo number\n        demlo += max_char\n        \n        # Remove the maximum character from the string\n        s = s[:i] + s[i+max_index+1:]\n    \n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_value = min(list1)\n    positions = [index for index, value in enumerate(list1) if value == min_value]\n    return positions\n"}
{"task_id": "MBPP/323", "completion": "\n    while out_of_place < n:\n        if cur % 2 == 0:\n            if arr[out_of_place] >= 0:\n                out_of_place += 1\n            else:\n                arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n        else:\n            if arr[out_of_place] < 0:\n                out_of_place += 1\n            else:\n                arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n        cur += 1\n    return arr\n"}
{"task_id": "MBPP/324", "completion": "\n    result = 0\n    for i in range(0, len(test_tuple), 2):\n        result += test_tuple[i]\n    return result\n"}
{"task_id": "MBPP/325", "completion": "\n    # Base cases\n    if n <= 3:\n        return n\n\n    # This array will store the minimum number of squares that sum up to i\n    dp = [float('inf')] * (n + 1)\n\n    # Zero has zero squares, base case\n    dp[0] = 0\n\n    # Precompute the minimum squares for all numbers up to n\n    for i in range(1, n + 1):\n        # Check squares of numbers up to the square root of i\n        for j in range(1, int(i**0.5) + 1):\n            square = j*j\n            dp[i] = min(dp[i], 1 + dp[i - square])\n\n    return dp[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or z == x:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    # Calculate the effective rotation needed\n    rotation = m % len(list1)\n    # Perform the rotation\n    rotated_list = list1[rotation:] + list1[:rotation]\n    return rotated_list\n"}
{"task_id": "MBPP/329", "completion": "\n    count = 0\n    for i in list:\n        if i < 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/330", "completion": "\n    return re.findall(r\"\\b\\w{3,5}\\b\", text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n > 0:\n        if n & 1 == 0:\n            count += 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if n in keys:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return n/2 * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    months_with_28_days = [\"February\", \"Feb\"]\n    return monthname1 in months_with_28_days\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Create a dictionary to store the frequency of each divisor\n    divisor_freq = {}\n\n    # Iterate over the interval [x, y]\n    for i in range(x, y+1):\n        # Iterate over all possible divisors of i\n        for j in range(1, i+1):\n            # If j is a divisor of i, increment its frequency in the dictionary\n            if i % j == 0:\n                if j in divisor_freq:\n                    divisor_freq[j] += 1\n                else:\n                    divisor_freq[j] = 1\n\n    # Find the divisor with the maximum frequency\n    max_divisor = max(divisor_freq, key=divisor_freq.get)\n\n    return max_divisor\n"}
{"task_id": "MBPP/340", "completion": "\n    # Filter out non-positive numbers and sort the remaining positive numbers\n    positive_nums = sorted([num for num in lst if num > 0])\n    \n    # Sum the first three numbers in the sorted list\n    return sum(positive_nums[:3])\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_value = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        max_value = max(max_value, lst[0])\n\n    min_range = float('inf')\n    start = end = None\n\n    while True:\n        node = heappop(min_heap)\n        if max_value - node.value < min_range:\n            min_range = max_value - node.value\n            start = node.value\n            end = max_value\n\n        if node.index + 1 == len(list[node.list_num]):\n            break\n\n        next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n        heappush(min_heap, next_node)\n        max_value = max(max_value, next_node.value)\n\n    return [start, end]\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = 0\n    letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        if i**0.5 == int(i**0.5):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i+1] - nums[i] for i in range(len(nums)-1)]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    return zigzag(n, k - 1) + zigzag(n - 1, n - k)\n"}
{"task_id": "MBPP/347", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m and j * j <= n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/348", "completion": "\n    # Create a 2D array to store intermediate results\n    dp = [[0 for _ in range(r+1)] for _ in range(n+1)]\n    \n    # Initialize the first row and first column\n    for i in range(n+1):\n        dp[i][0] = 1\n    for j in range(1, r+1):\n        dp[0][j] = 0\n    \n    # Fill the dp array\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            if j > i:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n    \n    return dp[n][r]\n"}
{"task_id": "MBPP/349", "completion": "\n    # Check if the string contains only '0' and '1'\n    if all(c in '01' for c in string):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/350", "completion": "\n    # Initialize a dictionary to store the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_freq = max(freq.values())\n    \n    # Calculate the minimum length of the string after removing the character with the maximum frequency\n    min_length = len(s) - max_freq\n    \n    return min_length\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for i in range(n):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n    \n    # Iterate through the array and return the first element that occurs k times\n    for i in range(n):\n        if count_dict[arr[i]] == k:\n            return arr[i]\n    \n    # If no element occurs k times, return -1\n    return -1\n"}
{"task_id": "MBPP/352", "completion": "\n    # Create a set to store unique characters\n    unique_chars = set()\n\n    # Iterate over each character in the string\n    for char in str:\n        # If the character is already in the set, it's not unique\n        if char in unique_chars:\n            return False\n        # Add the character to the set\n        unique_chars.add(char)\n\n    # If we reach here, all characters are unique\n    return True\n"}
{"task_id": "MBPP/353", "completion": "\n    return [row[:n] + row[n+1:] for row in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    tn = a + (n - 1) * d\n    return tn\n"}
{"task_id": "MBPP/355", "completion": "\n    count = 0\n    for i in range(1, radius):\n        for j in range(1, radius):\n            if i + j <= radius:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - (a + b)\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = max(max(sub) for sub in test_list)\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    result = map(lambda x, y: x % y if y != 0 else \"Division by zero\", nums1, nums2)\n    return list(result)\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is non-negative\n    if discriminant >= 0:\n        # Calculate the roots\n        root1 = (-b + (discriminant**0.5)) / (2*a)\n        root2 = (-b - (discriminant**0.5)) / (2*a)\n        \n        # Check if one root is twice the other\n        if root1 == 2*root2 or root2 == 2*root1:\n            return True\n        else:\n            return False\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    if n < 0:\n        return \"Input should be a non-negative integer\"\n    return (-1) ** n * (2 ** n - 1) ** 2\n"}
{"task_id": "MBPP/361", "completion": "\n    return [sublist for sublist in list1 if sublist]\n"}
{"task_id": "MBPP/362", "completion": "\n    if not nums:\n        return None\n    max_count = 0\n    max_item = nums[0]\n    for num in nums:\n        count = nums.count(num)\n        if count > max_count:\n            max_count = count\n            max_item = num\n    return max_item\n"}
{"task_id": "MBPP/363", "completion": "\n    res = [ele + K for ele in test_list]\n    return res\n"}
{"task_id": "MBPP/364", "completion": "\n    flip_count = 0\n    for i in range(len(ch)):\n        if i % 2 == 0 and ch[i] != '0':\n            flip_count += 1\n        elif i % 2 != 0 and ch[i] != '1':\n            flip_count += 1\n    return flip_count\n"}
{"task_id": "MBPP/365", "completion": "\n    count = 0\n    while n != 0:\n        n //= 10\n        count += 1\n    return count\n"}
{"task_id": "MBPP/366", "completion": "\n    # Check if the list is empty or contains only one element\n    if len(list_nums) < 2:\n        return None\n\n    # Initialize the maximum product to the product of the first two elements\n    max_product = list_nums[0] * list_nums[1]\n\n    # Iterate over the list, starting from the second element\n    for i in range(1, len(list_nums) - 1):\n        # Calculate the product of the current element and the next one\n        current_product = list_nums[i] * list_nums[i + 1]\n        # Update the maximum product if the current product is greater\n        if current_product > max_product:\n            max_product = current_product\n\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) <= 1 and is_tree_balanced(root.left) and is_tree_balanced(root.right):\n        return True\n    return False\n\n"}
{"task_id": "MBPP/368", "completion": "\n    res = test_tup * N\n    return res\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (h * (l + w))\n"}
{"task_id": "MBPP/370", "completion": "\n    return float(price[1])\n"}
{"task_id": "MBPP/371", "completion": "\n    if left_element > right_element:\n        return left_element\n    if A[left_element] == left_element + 1:\n        return smallest_missing(A, left_element + 1, right_element)\n    mid_element = (left_element + right_element) // 2\n    if A[mid_element] == mid_element + 1 and A[mid_element - 1] == mid_element:\n        return mid_element + 1\n    if A[mid_element] == mid_element + 1:\n        return smallest_missing(A, left_element, mid_element - 1)\n    return smallest_missing(A, mid_element + 1, right_element)\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(len(nums))]\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 0:\n        return []\n    if len(str) == 1:\n        return [str]\n    \n    permutations = []\n    for i in range(len(str)):\n        char = str[i]\n        remaining_str = str[:i] + str[i+1:]\n        for permutation in permute_string(remaining_str):\n            permutations.append(char + permutation)\n    \n    return permutations\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    res = []\n    for ele in test_tup:\n        if test_tup.count(ele) == 1:\n            res.append(ele)\n        else:\n            res.append('Custom Value')\n    return tuple(res)\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if not test_list:\n        return []\n    return [test_list[-1]] + test_list[:-1]\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l*w + w*h + h*l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    start, end = 0, len(A) - 1\n    while start <= end:\n        if A[start] <= A[end]:\n            return start\n        mid = (start + end) // 2\n        next_index = (mid + 1) % len(A)\n        prev_index = (mid - 1 + len(A)) % len(A)\n        if A[mid] <= A[next_index] and A[mid] <= A[prev_index]:\n            return mid\n        elif A[mid] <= A[end]:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return -1\n"}
{"task_id": "MBPP/383", "completion": "\n    result = 0\n    count = 0\n    temp = n\n    while temp > 0:\n        # Check if the current bit position is even\n        if count % 2 == 0:\n            # Set the bit at the current position in result\n            result |= (1 << count)\n        count += 1\n        temp >>= 1\n    # XOR the original number with the result to toggle the odd bits\n    return n ^ result\n"}
{"task_id": "MBPP/384", "completion": "\n    # Your code here\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 3)\n"}
{"task_id": "MBPP/386", "completion": "\n    open_brackets = []\n    close_brackets = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            open_brackets.append(i)\n        else:\n            close_brackets.append(i)\n    swaps = 0\n    i = j = 0\n    while i < len(open_brackets) and j < len(close_brackets):\n        if open_brackets[i] < close_brackets[j]:\n            i += 1\n        else:\n            swaps += 1\n            j += 1\n    return swaps\n"}
{"task_id": "MBPP/387", "completion": "\n    if N[-1] in '02468ACE':\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n - 1) + find_lucas(n - 2)\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    return {l1[i]: {l2[i]: l3[i]} for i in range(len(l1))}\n"}
{"task_id": "MBPP/392", "completion": "\n    # Initialize a list to store the maximum sums for each number up to n\n    max_sums = [0] * (n + 1)\n    \n    # Base cases\n    max_sums[0] = 0\n    max_sums[1] = 1\n    \n    # Fill in the max_sums list using the given equation\n    for i in range(2, n + 1):\n        max_sums[i] = max(i, max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5])\n    \n    # Return the maximum sum for n\n    return max_sums[n]\n"}
{"task_id": "MBPP/393", "completion": "\n    max_length_list = max(input_list, key=lambda x: len(x))\n    return max_length_list\n"}
{"task_id": "MBPP/394", "completion": "\n    res = len(test_tup) == len(set(test_tup))\n    return (res)\n"}
{"task_id": "MBPP/395", "completion": "\n    count = {}\n    for char in str1:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in str1:\n        if count[char] == 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n"}
{"task_id": "MBPP/398", "completion": "\n    sum_digits = 0\n    for num in nums:\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n    return sum_digits\n"}
{"task_id": "MBPP/399", "completion": "\n    res = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/400", "completion": "\n    res = {}\n    for sub in test_list:\n        sub.sort()\n        sub = tuple(sub)\n        res[sub] = res.get(sub, 0) + 1\n    return list(res.items())\n"}
{"task_id": "MBPP/401", "completion": "\n    res = tuple(map(lambda x, y: (tuple(map(lambda a, b: a + b, x, y)),), test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/402", "completion": "\n    # Initialize an array to store intermediate results\n    C = [0 for _ in range(r+1)]\n    C[0] = 1  # nC0 is 1\n\n    # Calculate value of [nCr] % p using bottom-up approach\n    for i in range(1, n+1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, r), 0, -1):\n            C[j] = (C[j] + C[j-1]) % p\n\n    return C[r]\n"}
{"task_id": "MBPP/403", "completion": "\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return re.match(regex, str) is not None\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    if tuplex == tuple1:\n        return True\n    else:\n        return False\n\ntuplex = (1, 2, 3, 4, 5)\ntuple1 = (1, 2, 3, 4, 5)\n"}
{"task_id": "MBPP/406", "completion": "\n    count = 0\n    while x:\n        count += x & 1\n        x >>= 1\n    if count % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n"}
{"task_id": "MBPP/407", "completion": "\n    digits = list(str(n))\n    for i in range(len(digits)-2, -1, -1):\n        if digits[i] < digits[i+1]:\n            right = digits[i:]\n            smallest_bigger = min(filter(lambda x: x > right[0], right))\n            right.remove(smallest_bigger)\n            right.sort()\n            digits[i:] = [smallest_bigger] + right\n            return int(\"\".join(digits))\n    return -1\n"}
{"task_id": "MBPP/408", "completion": "\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    min_heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\n\n    result = []\n    while min_heap and len(result) < k:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result\n\n"}
{"task_id": "MBPP/409", "completion": "\n    min_product = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    min_val = listval[0]\n    for i in listval:\n        if i < min_val:\n            min_val = i\n    return min_val\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    result = [tup[n] for tup in list1 if n < len(tup)]\n    return result\n"}
{"task_id": "MBPP/414", "completion": "\n    return any(item in list2 for item in list1)\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return \"No pairs exists\"\n    \n    # Initialize the highest and second highest numbers\n    highest = max(arr[0], arr[1])\n    second_highest = min(arr[0], arr[1])\n    \n    # Initialize the lowest and second lowest numbers\n    lowest = min(arr[0], arr[1])\n    second_lowest = max(arr[0], arr[1])\n    \n    for i in range(2, len(arr)):\n        if arr[i] > highest:\n            second_highest = highest\n            highest = arr[i]\n        elif arr[i] > second_highest:\n            second_highest = arr[i]\n        \n        if arr[i] < lowest:\n            second_lowest = lowest\n            lowest = arr[i]\n        elif arr[i] < second_lowest:\n            second_lowest = arr[i]\n    \n    # Compare the product of highest and second highest with the product of lowest and second lowest\n    if highest * second_highest > lowest * second_lowest:\n        return highest, second_highest\n    else:\n        return lowest, second_lowest\n"}
{"task_id": "MBPP/416", "completion": "\n    # Create a list to store the maximum sum for each number up to n\n    maxSum = [0] * (n + 1)\n\n    # Base cases\n    maxSum[0] = 0\n    maxSum[1] = 1\n\n    # Fill in the maxSum list using dynamic programming\n    for i in range(2, n + 1):\n        # Check each possible division of i\n        for j in range(1, i):\n            # If the sum of the three parts is greater than i, use it\n            if j * j * j + maxSum[i - j * j * j] > i:\n                maxSum[i] = max(maxSum[i], j * j * j + maxSum[i - j * j * j])\n\n    # Return the maximum sum for n\n    return maxSum[n]\n\n"}
{"task_id": "MBPP/417", "completion": "\n    result = []\n    for i in range(len(Input)):\n        for j in range(i+1, len(Input)):\n            if Input[i][0] == Input[j][0]:\n                result.append(Input[i][0])\n    return result\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = max(len(sublist) for sublist in lst)\n    max_sublists = [sublist for sublist in lst if len(sublist) == max_len]\n    return max_sublists\n"}
{"task_id": "MBPP/419", "completion": "\n    total = 0\n    for num in list1:\n        total += round(num)\n    return total * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**3\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    # Define the delimiter\n    delim = \"-\"\n    \n    # Concatenate the elements of the tuple\n    result = delim.join(test_tup)\n    \n    return result\n"}
{"task_id": "MBPP/422", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum/n\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a table to store intermediate results\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            # Gold at cell (i, j) can be obtained by taking gold from cell (i, j+1), (i+1, j+1), and (i-1, j+1)\n            # and subtracting the loss due to moving from one cell to another\n            gold_from_right = dp[i][j+1] if j < n-1 else 0\n            gold_from_right_up = dp[i-1][j+1] if i > 0 and j < n-1 else 0\n            gold_from_right_down = dp[i+1][j+1] if i < m-1 and j < n-1 else 0\n\n            # Add the gold from the current cell to the maximum gold that can be obtained from the cells to the right\n            dp[i][j] = gold[i][j] + max(gold_from_right, gold_from_right_up, gold_from_right_down)\n\n    # The maximum gold that can be obtained will be the maximum value in the first column of the table\n    return max(dp[i][0] for i in range(m))\n"}
{"task_id": "MBPP/424", "completion": "\n    result = tuple(item[-1] for item in test_tuple)\n    return result\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    odd_nums = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_nums\n"}
{"task_id": "MBPP/427", "completion": "\n    return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', r'\\3-\\2-\\1', dt)\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    res = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/430", "completion": "\n    directrix = c - ((b**2) + 1) * 4 * a\n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    for i in list1:\n        for j in list2:\n            if i == j:\n                return True\n    return False\n"}
{"task_id": "MBPP/432", "completion": "\n    median = (base1 + base2) / 2\n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    for i in arr:\n        if number > i:\n            return True\n    return False\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = 'ab+?'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    neg_list = [num for num in list1 if num < 0]\n    return neg_list\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if int(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == (test_list[j][1], test_list[j][0]):\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    result = 0\n    for num in L:\n        result = result * 10 + num\n    return result\n"}
{"task_id": "MBPP/440", "completion": "\n    adverb_positions = []\n    for match in re.finditer(r\"\\w+ly\", text):\n        adverb_positions.append((match.group(), match.start(), match.end()))\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    total_nums = len(nums)\n    positive_nums = sum(1 for num in nums if num > 0)\n    return positive_nums / total_nums\n\n"}
{"task_id": "MBPP/443", "completion": "\n    largest_neg = None\n    for num in list1:\n        if num < 0:\n            if largest_neg is None or num > largest_neg:\n                largest_neg = num\n    return largest_neg\n"}
{"task_id": "MBPP/444", "completion": "\n    res = [tuple(ele[:-K] if len(ele) > K else ele for ele in sub) for sub in test_list]\n    return res\n"}
{"task_id": "MBPP/445", "completion": "\n    res = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/446", "completion": "\n    # Create a counter object for the tuple\n    tuple_counter = Counter(tup)\n\n    # Create a dictionary to store the count of each element in the list\n    count_dict = {}\n\n    # Iterate over the list and count the occurrences of each element\n    for elem in lst:\n        count_dict[elem] = tuple_counter[elem]\n\n    return count_dict\n\n"}
{"task_id": "MBPP/447", "completion": "\n    cubes = list(map(lambda x: x**3, nums))\n    return cubes\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c = 3, 0, 2\n        sum = 5\n        for i in range(3, n + 1):\n            d = a + b\n            sum += d\n            a, b, c = b, c, d\n        return sum\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the area of the triangle using the determinant method\n    area = 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    \n    # If the area is zero, the points are collinear and do not form a valid triangle\n    if area == 0:\n        return False\n    else:\n        return True\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s for s in str if len(s) == l]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    if actual_cost > sale_amount:\n        loss = actual_cost - sale_amount\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n            if (n // i) % 2 == 0 and i != n // i:\n                sum += n // i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 == 1 or monthnum2 == 3 or monthnum2 == 5 or monthnum2 == 7 or monthnum2 == 8 or monthnum2 == 10 or monthnum2 == 12:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    min_len = min(len(i) for i in lst)\n    min_sublist = [i for i in lst if len(i) == min_len]\n    return min_sublist\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub('[A-Z]', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    ctr = 0\n    for i in str:\n        if i.isupper():\n            ctr += 1\n    return ctr\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 0:\n        return [[]]\n    else:\n        first, *rest = list1\n        combinations_without_first = combinations_list(rest)\n        combinations_with_first = [ [first] + combo for combo in combinations_without_first ]\n        return combinations_without_first + combinations_with_first\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return all(value == n for value in dict.values())\n"}
{"task_id": "MBPP/465", "completion": "\n    return {k: v for k, v in dict1.items() if v}\n"}
{"task_id": "MBPP/466", "completion": "\n    mid = low + (high - low) // 2\n\n    # Check if mid is a peak\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n            (mid == n - 1 or arr[mid + 1] <= arr[mid])):\n        return mid\n\n    # If the left neighbor is greater, recurse on the left subarray\n    elif mid > 0 and arr[mid - 1] > arr[mid]:\n        return find_peak_util(arr, low, (mid - 1), n)\n\n    # If the right neighbor is greater, recurse on the right subarray\n    else:\n        return find_peak_util(arr, (mid + 1), high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    octalNum = 0\n    multiplier = 1\n    while deciNum != 0:\n        remainder = deciNum % 8\n        octalNum += remainder * multiplier\n        deciNum //= 8\n        multiplier *= 10\n    return octalNum\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize an array to store the maximum product subsequence ending at each index\n    max_prod_subseq = [0] * n\n    max_prod_subseq[:] = arr[:]\n\n    # Iterate over the array\n    for i in range(1, n):\n        for j in range(i):\n            # If the current element is greater than the previous element and the product of the current element and the maximum product subsequence ending at the previous index is greater than the current maximum product subsequence ending at the current index\n            if arr[i] > arr[j] and max_prod_subseq[i] < max_prod_subseq[j] * arr[i]:\n                max_prod_subseq[i] = max_prod_subseq[j] * arr[i]\n\n    # Return the maximum product subsequence\n    return max(max_prod_subseq)\n"}
{"task_id": "MBPP/469", "completion": "\n    if not price or k <= 0:\n        return 0\n\n    n = len(price)\n    if k >= n // 2:\n        return quick_profit(price)\n\n    dp = [[0 for _ in range(n)] for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - price[j])\n\n    return dp[k][n - 1]\n\n"}
{"task_id": "MBPP/470", "completion": "\n    res = tuple(map(lambda x, y: x + y, test_tup[::2], test_tup[1::2]))\n    return res\n"}
{"task_id": "MBPP/471", "completion": "\n    remainder = 1\n    for i in range(lens):\n        remainder = (remainder * (arr[i] % n)) % n\n    return remainder\n"}
{"task_id": "MBPP/472", "completion": "\n    return sorted(l) == list(range(min(l), max(l)+1))\n"}
{"task_id": "MBPP/473", "completion": "\n    res = tuple(set(test_list1) & set(test_list2))\n    return res\n"}
{"task_id": "MBPP/474", "completion": "\n    str1 = str1.replace(ch, newch)\n    return str1\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1]))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub('[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    while n >= 10:\n        n = n / 10\n    return int(n)\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    for char in str1:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Find the maximum occurring character\n    max_char = max(char_freq, key=char_freq.get)\n\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n    if set[n - 1] > sum:\n        return is_subset_sum(set, n - 1, sum)\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = '[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/483", "completion": "\n    factorial = 1\n    number = 1\n    while True:\n        factorial *= number\n        if factorial % x == 0:\n            return number\n        number += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    res = tuple(filter(lambda ele: ele not in test_list2, test_list1))\n    return res\n"}
{"task_id": "MBPP/485", "completion": "\n    n = str(n)\n    for i in range(len(n) // 2):\n        if n[i] != n[-i - 1]:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return nCr(n-1, r-1) + nCr(n-1, r)\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    max_value = max(arr)\n    frequency = arr.count(max_value)\n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                result.append((test_list[i], test_list[j]))\n    return result\n"}
{"task_id": "MBPP/491", "completion": "\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - math.pow(r, n)) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n    mid = 0\n\n    while low <= high:\n\n        mid = (high + low) // 2\n\n        # If the element is present at the middle itself\n        if item_list[mid] == item:\n            return mid\n\n        # If element is smaller than mid, then it can only be present in left subarray\n        elif item_list[mid] > item:\n            high = mid - 1\n\n        # Else the element can only be present in right subarray\n        else:\n            low = mid + 1\n\n    # We reach here when element is not present in array\n    return -1\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the side length of the hexagon\n    side_length = radius * math.sqrt(3)\n    # Calculate the height of the hexagon\n    height = side_length * 0.75\n    # Calculate the horizontal distance between the centers of two adjacent hexagons\n    horizontal_distance = side_length\n    # Calculate the vertical distance between the centers of two adjacent hexagons\n    vertical_distance = height * 0.5\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = int((endx - startx) / horizontal_distance)\n    num_hexagons_y = int((endy - starty) / vertical_distance)\n    # Initialize the list of hexagons\n    hexagons = []\n    # Calculate the coordinates of the hexagons\n    for i in range(num_hexagons_y):\n        y = starty + i * vertical_distance\n        if i % 2 == 0:\n            x_offset = startx\n        else:\n            x_offset = startx + side_length * 0.5\n        for j in range(num_hexagons_x):\n            x = x_offset + j * horizontal_distance\n            hexagon = [\n                (x, y),\n                (x + side_length * 0.5, y + height * 0.25),\n                (x + side_length * 0.5, y + height * 0.75),\n                (x, y + height),\n                (x - side_length * 0.5, y + height * 0.75),\n                (x - side_length * 0.5, y + height * 0.25),\n            ]\n            hexagons.append(hexagon)\n    return hexagons\n\n"}
{"task_id": "MBPP/494", "completion": "\n    res = int(\"\".join(map(str, test_tup)), 2)\n    return res\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub('[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    smallest_nums = hq.nsmallest(n, nums)\n    return smallest_nums\n\n"}
{"task_id": "MBPP/497", "completion": "\n    slant_height = math.sqrt(r**2 + h**2)\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    concatenated_string = ''.join(list)\n    return concatenated_string\n"}
{"task_id": "MBPP/501", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return [nums[i] + nums[i+1] for i in range(len(nums)-1)]\n"}
{"task_id": "MBPP/504", "completion": "\n    return (n * (n + 1) // 2) ** 2\n"}
{"task_id": "MBPP/505", "completion": "\n    count = 0\n    for i in range(len(A)):\n        if A[i] == 0:\n            count += 1\n    for i in range(count):\n        A.append(0)\n        A.pop(0)\n    return A\n"}
{"task_id": "MBPP/506", "completion": "\n    # Initialize a 2D array to store intermediate results\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n\n    # Fill the dp array\n    for i in range(n+1):\n        for j in range(min(i, k)+1):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + j * dp[i-1][j-1]\n\n    return dp[n][k]\n"}
{"task_id": "MBPP/507", "completion": "\n    return [word for word in list1 if word not in removewords]\n"}
{"task_id": "MBPP/508", "completion": "\n    # Find common elements\n    common_elements = [element for element in l1 if element in l2]\n    \n    # Filter out non-common elements from both lists\n    filtered_l1 = [element for element in l1 if element in common_elements]\n    filtered_l2 = [element for element in l2 if element in common_elements]\n    \n    # Compare the filtered lists\n    return filtered_l1 == filtered_l2\n"}
{"task_id": "MBPP/509", "completion": "\n    if n % 2 == 0:\n        return \"Invalid Input\"\n    else:\n        sum = 0\n        count = 0\n        while n >= 1:\n            sum += n\n            count += 1\n            n -= 2\n        return sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    MOD = 10**9 + 7\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j]\n            if arr[i-1] <= j and arr[i-1] > 0:\n                dp[i][j] += dp[i-1][j//arr[i-1]]\n            dp[i][j] %= MOD\n    return dp[n][k]\n"}
