{"task_id": "MBPP/11", "completion": "\n    if ch not in s:\n        return s\n    else:\n        return s[1:-1].replace(ch, '', 1)\n\n"}
{"task_id": "MBPP/12", "completion": "\n    # Sort the matrix based on the sum of its rows\n    sorted_M = sorted(M, key=lambda row: sum(row))\n    return sorted_M\n"}
{"task_id": "MBPP/13", "completion": "\n    word_counts = Counter(words)\n    most_common_words = word_counts.most_common(10)\n    return most_common_words\n\n"}
{"task_id": "MBPP/14", "completion": "\n    return (1/2) * l * b * h\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'(?=[a-z])', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    pattern = r'[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return 4 * a\n"}
{"task_id": "MBPP/18", "completion": "\n    return list(string)\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    if x < 2:\n        return False\n    for i in range(2, int(x**0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i*n for i in range(1, m+1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    max_sum = 0\n    for i in list1:\n        if sum(i) > max_sum:\n            max_sum = sum(i)\n    return max_sum\n"}
{"task_id": "MBPP/24", "completion": "\n    return int(binary, 2)\n"}
{"task_id": "MBPP/25", "completion": "\n    product = 1\n    for i in range(n):\n        if arr.count(arr[i]) == 1:\n            product *= arr[i]\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    # Create a set from the test_list\n    test_set = set(test_list)\n    \n    # Check if the length of the set is equal to K\n    if len(test_set) == K:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/27", "completion": "\n    new_list = []\n    for string in list:\n        new_string = re.sub(r'\\d', '', string)\n        new_list.append(new_string)\n    return new_list\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_Coeff(n-1, k-1) + binomial_Coeff(n-1, k)\n"}
{"task_id": "MBPP/29", "completion": "\n    # Initialize a dictionary to store the count of each element\n    count_dict = {}\n\n    # Iterate through the array and update the count of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the element with odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n\n    # If no element has odd count, return None\n    return None\n\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq_dict = collections.defaultdict(int)\n\n    # Iterate through the list of lists and count the frequency of each integer\n    for lst in nums:\n        for num in lst:\n            freq_dict[num] += 1\n\n    # Create a heap queue to store the top k integers with their frequencies\n    heap = []\n    for num, freq in freq_dict.items():\n        heapq.heappush(heap, (-freq, num))\n\n    # Pop the top k integers from the heap and return them\n    result = []\n    for _ in range(k):\n        freq, num = heapq.heappop(heap)\n        result.append(num)\n\n    return result\n\n"}
{"task_id": "MBPP/32", "completion": "\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Initialize the maximum prime factor\n    max_prime = 2\n\n    # Check for prime factors starting from 2\n    while n % 2 == 0:\n        max_prime = 2\n        n = n // 2\n\n    # Check for odd prime factors\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n // i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n\n    return max_prime\n\n"}
{"task_id": "MBPP/33", "completion": "\n    binary = \"\"\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary\n\n"}
{"task_id": "MBPP/34", "completion": "\n    for i in range(1, N):\n        if ar[i] - ar[i-1] != 1:\n            return ar[i-1] + 1\n    return ar[-1] + 1\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1)\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the given numbers to strings\n    p_str = str(p)\n    q_str = str(q)\n\n    # Calculate the length of the proper fraction\n    length = len(p_str) + len(q_str) - 1\n\n    # Calculate the position of the nth digit in the proper fraction\n    position = N - 1\n\n    # Calculate the index of the digit in the proper fraction\n    index = position // length\n\n    # Calculate the index of the digit in the number\n    digit_index = position % length\n\n    # Get the digit from the number\n    if index == 0:\n        digit = p_str[digit_index]\n    else:\n        digit = q_str[digit_index]\n\n    return int(digit)\n\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate the integers and strings into two different lists\n    int_list = [x for x in mixed_list if isinstance(x, int)]\n    str_list = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort the lists\n    int_list.sort()\n    str_list.sort()\n\n    # Combine the sorted lists\n    sorted_list = int_list + str_list\n\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even = []\n    odd = []\n    for i in list1:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    if len(even) == 0 or len(odd) == 0:\n        return \"No even or odd number found\"\n    else:\n        return even[0] / odd[0]"}
{"task_id": "MBPP/39", "completion": "\n    # Count the frequency of each character in the string\n    char_count = Counter(S)\n    \n    # Create a max heap based on the frequency of each character\n    max_heap = [(-freq, char) for char, freq in char_count.items()]\n    heapq.heapify(max_heap)\n    \n    # Initialize the previous character and its frequency to None and 0\n    prev_char, prev_freq = None, 0\n    \n    # Initialize the result string\n    result = \"\"\n    \n    # While the heap is not empty\n    while max_heap:\n        # Pop the character with the highest frequency from the heap\n        freq, char = heapq.heappop(max_heap)\n        \n        # Append the character to the result string\n        result += char\n        \n        # If the previous character is not None and its frequency is greater than 0\n        if prev_char is not None and prev_freq > 0:\n            # Push the previous character back into the heap with its updated frequency\n            heapq.heappush(max_heap, (prev_freq, prev_char))\n        \n        # Update the previous character and its frequency\n        prev_char, prev_freq = char, freq + 1\n    \n    # Return the result string\n    return result\n\n"}
{"task_id": "MBPP/40", "completion": "\n    # Flatten the list of lists\n    flat_list = list(chain.from_iterable(nums))\n    \n    # Count the frequency of each element\n    freq = Counter(flat_list)\n    \n    return freq\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the sum of repeated elements\n    sum_repeated = 0\n    for key, value in count_dict.items():\n        if value > 1:\n            sum_repeated += key * value\n    \n    return sum_repeated\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r'[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    match = re.match(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(data) == len(set(data))\n\n"}
{"task_id": "MBPP/47", "completion": "\n    # A factorial is a product of all positive integers less than or equal to a.\n    # For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.\n    # The last digit of a factorial is the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 120, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers in the factorial.\n    # For example, the last digit of 5! is the last digit of 5 * 4 * 3 * 2 * 1, which is 0.\n    # The last digit of a factorial is also the last digit of the product of all the numbers"}
{"task_id": "MBPP/48", "completion": "\n    # Set all odd bits of a given number\n    return n | 0xAAAAAAAA\n\n"}
{"task_id": "MBPP/49", "completion": "\n    result = []\n    for i in range(len(nums)):\n        if i == N:\n            result.append(nums[i][0])\n        else:\n            result.append(nums[i][1])\n    return result\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        print(\"Equilateral triangle\")\n    else:\n        print(\"Not an equilateral triangle\")\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if len(str) < 2:\n        return False\n    return str[0] == str[-1]\n\n"}
{"task_id": "MBPP/54", "completion": "\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Create a count array to store the frequency of each element\n    count = [0] * (max_value + 1)\n\n    # Count the frequency of each element in the list\n    for num in my_list:\n        count[num] += 1\n\n    # Create a sorted list by iterating over the count array\n    sorted_list = []\n    for i in range(len(count)):\n        sorted_list.extend([i] * count[i])\n\n    return sorted_list\n\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return n == 2 * rev(n) + 1\n"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    return int(''.join(map(str, arr)))\n"}
{"task_id": "MBPP/58", "completion": "\n    if x < 0 and y > 0 or x > 0 and y < 0:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2)\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"}
{"task_id": "MBPP/61", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    max_diff = 0\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            diff = abs(test_list[i] - test_list[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1])\n"}
{"task_id": "MBPP/65", "completion": "\n    if len(data_list) == 0:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n\n"}
{"task_id": "MBPP/66", "completion": "\n    count = 0\n    for i in list:\n        if i > 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]\n"}
{"task_id": "MBPP/68", "completion": "\n    if all(A[i] <= A[i+1] for i in range(len(A)-1)):\n        return True\n    elif all(A[i] >= A[i+1] for i in range(len(A)-1)):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    if len(Input) == 0:\n        return False\n    for i in range(len(Input)):\n        if len(Input[i]) != k:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/71", "completion": "\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = False\n            i += 1\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    for i in range(1, n):\n        for j in range(i, n):\n            if i**2 - j**2 == n:\n                return True\n    return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,;:\\s]+'\n    \n    # Use regex to split the string\n    result = re.split(delimiters, text)\n    \n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    return (m * n) // 4\n"}
{"task_id": "MBPP/77", "completion": "\n    sum_even = 0\n    sum_odd = 0\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            sum_even += digit\n        else:\n            sum_odd += digit\n        n = n // 10\n    return sum_even - sum_odd\n\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(n+1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    if len(s) % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n\n"}
{"task_id": "MBPP/80", "completion": "\n    return n * (n + 1) * (n + 2) // 6\n"}
{"task_id": "MBPP/81", "completion": "\n    return tuple(zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * r**3\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return chr(sum(ord(c) for c in strr))\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        sequence_list = [1, 2]\n        for i in range(2, n):\n            sequence_list.append(sequence_list[sequence_list[i-2]-1] + sequence_list[sequence_list[i-1]-1])\n        return sequence_list[n-1]\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return (3 * n * (n - 1)) // 2 + 1\n"}
{"task_id": "MBPP/87", "completion": "\n    merged_dict = dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict\n\n"}
{"task_id": "MBPP/88", "completion": "\n    freq = collections.Counter(list1)\n    return freq\n\n"}
{"task_id": "MBPP/89", "completion": "\n    if N <= 1:\n        return None\n    for i in range(N-1, 0, -1):\n        if N % i == 0:\n            return i\n    return None\n"}
{"task_id": "MBPP/90", "completion": "\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n\n"}
{"task_id": "MBPP/91", "completion": "\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False\n"}
{"task_id": "MBPP/92", "completion": "\n    str_n = str(n)\n    for i in range(1, len(str_n)):\n        if str_n[i] == str_n[i-1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    return min(enumerate(test_list), key=itemgetter(1))[0]\n\n"}
{"task_id": "MBPP/95", "completion": "\n    if not lst:\n        return 0\n    min_length = len(lst)\n    for i in range(len(lst)):\n        for j in range(i, len(lst)):\n            sublist = lst[i:j+1]\n            min_length = min(min_length, len(sublist))\n    return min_length\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n"}
{"task_id": "MBPP/100", "completion": "\n    num_str = str(num)\n    length = len(num_str)\n    if length == 1:\n        return num + 1\n    elif length == 2:\n        if num_str[0] == num_str[1]:\n            return num + 2\n        else:\n            return int(num_str[0] + num_str[0] + num_str[1])\n    else:\n        mid = length // 2\n        left_half = num_str[:mid]\n        right_half = num_str[mid:] if length % 2 == 0 else num_str[mid+1:]\n        if left_half == right_half[::-1]:\n            if int(left_half) < 9:\n                return int(left_half + '0' * (length - mid) + left_half[::-1])\n            else:\n                return int('9' * (mid + 1) + '0' * (length - mid - 1) + '1')\n        else:\n            return int(left_half + '0' * (length - mid) + left_half[::-1])\n\n"}
{"task_id": "MBPP/101", "completion": "\n    if k < 1 or k > n:\n        return None\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if m == 0 or m == n:\n        return 1\n    else:\n        return eulerian_num(n-1, m-1) + m * eulerian_num(n-1, m)\n"}
{"task_id": "MBPP/104", "completion": "\n    return sorted(input_list, key=lambda x: sorted(x))\n"}
{"task_id": "MBPP/105", "completion": "\n    count = 0\n    for i in lst:\n        if i:\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/106", "completion": "\n    return test_list + test_tup\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if is_Hexadecimal(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a heap from the input lists\n    heap = []\n    for i, lst in enumerate([num1, num2, num3]):\n        for j, num in enumerate(lst):\n            heapq.heappush(heap, (num, i, j))\n\n    # Pop elements from the heap and yield them\n    while heap:\n        num, i, j = heapq.heappop(heap)\n        yield num\n        if j + 1 < len(num1):\n            heapq.heappush(heap, (num1[j + 1], i, j + 1))\n        if j + 1 < len(num2):\n            heapq.heappush(heap, (num2[j + 1], i, j + 1))\n        if j + 1 < len(num3):\n            heapq.heappush(heap, (num3[j + 1], i, j + 1))\n\n"}
{"task_id": "MBPP/109", "completion": "\n    # Convert the string to a list of integers\n    binary_list = [int(x) for x in s]\n\n    # Calculate the sum of the binary list\n    sum_binary = sum(binary_list)\n\n    # Check if the sum is odd\n    if sum_binary % 2 == 1:\n        return n\n    else:\n        return 0\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    for i in range(strt_val, stop_val + 1):\n        if i not in test_list:\n            missing_ranges.append(i)\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements.intersection_update(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    return 2 * (3.14 * diameter + height)\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n\ntest_list = [(1, 2), (3, 4), (1, 2), (5, 6), (3, 4), (1, 2)]"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if i:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    for i in range(len(test_list)):\n        try:\n            test_list[i] = float(test_list[i])\n        except ValueError:\n            pass\n    return test_list\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    if n == 1:\n        return arr[0]\n    if arr[0] != arr[1]:\n        return arr[0]\n    if arr[n-1] != arr[n-2]:\n        return arr[n-1]\n    for i in range(1, n-1):\n        if arr[i] != arr[i-1] and arr[i] != arr[i+1]:\n            return arr[i]\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    # Sort the list in descending order\n    list1.sort(reverse=True)\n    \n    # Initialize the maximum product\n    max_product = 0\n    \n    # Iterate through the list and calculate the product of each pair of tuples\n    for i in range(len(list1)-1):\n        product = list1[i][0] * list1[i+1][0]\n        if product > max_product:\n            max_product = product\n    \n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if A[i] + A[j] + A[k] == sum:\n                    count += 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n =="}
{"task_id": "MBPP/123", "completion": "\n    def sum_of_divisors(n):\n        sum_divisors = 0\n        for i in range(1, n):\n            if n % i == 0:\n                sum_divisors += i\n        return sum_divisors\n\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        j = sum_of_divisors(i)\n        if sum_of_divisors(j) == i and i != j:\n            amicable_sum += i\n    return amicable_sum\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(a) - cmath.phase(b)\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    for i in range(n):\n        if string[i] == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        max_diff = max(max_diff, abs(count_0 - count_1))\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def divisors(n):\n        divs = set()\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    common_divs = divisors(gcd(a, b))\n    return sum(common_divs)\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    for i in range(abs(y)):\n        result += x\n    if y < 0:\n        result = -result\n    return result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the matrix is a magic square\n    magic_sum = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    for col in range(len(my_matrix[0])):\n        if sum(my_matrix[row][col] for row in range(len(my_matrix))) != magic_sum:\n            return False\n    if sum(my_matrix[i][i] for i in range(len(my_matrix))) != magic_sum:\n        return False\n    if sum(my_matrix[i][len(my_matrix)-i-1] for i in range(len(my_matrix))) != magic_sum:\n        return False\n\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    frequency = defaultdict(int)\n    for num in nums:\n        frequency[num] += 1\n    max_freq = max(frequency.values())\n    max_items = [num for num, freq in frequency.items() if freq == max_freq]\n    return max_items\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    i, j = 0, len(str1) - 1\n    while i < j:\n        if str1[i] not in vowels:\n            i += 1\n        elif str1[j] not in vowels:\n            j -= 1\n        else:\n            str1[i], str1[j] = str1[j], str1[i]\n            i += 1\n            j -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return ''.join(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(filter(lambda x: x < 0, nums))\n"}
{"task_id": "MBPP/134", "completion": "\n    if arr[-1] % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    if units <= 50:\n        return units * 0.50\n    elif units <= 150:\n        return 25 + (units - 50) * 0.75\n    elif units <= 250:\n        return 100 + (units - 150) * 1.20\n    else:\n        return 220 + (units - 250) * 1.50\n"}
{"task_id": "MBPP/137", "completion": "\n    count = 0\n    for num in nums:\n        if num == 0:\n            count += 1\n    return count / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    if n < 0:\n        return False\n    while n > 0:\n        if n % 2 != 0:\n            if n == 1:\n                return True\n            else:\n                return False\n        n = n // 2\n    return True\n\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * math.pi * r\n"}
{"task_id": "MBPP/140", "completion": "\n    result = []\n    for item in test_list:\n        if test_list.count(item) == 1:\n            result.append(item)\n    return result\n"}
{"task_id": "MBPP/141", "completion": "\n\n        Helper function to flip the first k elements of the array.\n        \"\"\"\n        i, j = 0, k - 1\n        while i < j:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    for i in range(n, 1, -1):\n        max_idx = nums.index(max(nums[:i]))\n        if max_idx != i - 1:\n            if max_idx != 0:\n                flip(nums, max_idx + 1)\n            flip(nums, i)\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    count = 0\n    for i in list1:\n        if i in list2 and i in list3:\n            count += 1\n    return count"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for i in Input:\n        if type(i) == list:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    return sum(arr[i] - arr[i-1] for i in range(1, n))\n"}
{"task_id": "MBPP/145", "completion": "\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            max_diff = max(max_diff, abs(arr[i] - arr[j]))\n    return max_diff\n\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(c) for c in str1)\n\n"}
{"task_id": "MBPP/147", "completion": "\n    # Initialize a 2D array to store the maximum path sum at each position\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Base case: the maximum path sum at the bottom of the triangle is the value at that position\n    for i in range(m):\n        dp[i][n - 1] = tri[i][n - 1]\n\n    # Fill the dp array from bottom to top\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 2, -1, -1):\n            # The maximum path sum at position (i, j) is the value at that position plus the maximum path sum at either of the two positions directly below it\n            dp[i][j] = tri[i][j] + max(dp[i + 1][j], dp[i + 1][j + 1])\n\n    # The maximum path sum in the triangle is the maximum value in the first row of the dp array\n    return max(dp[0])\n"}
{"task_id": "MBPP/148", "completion": "\n    # Convert the number to a string\n    x_str = str(x)\n    \n    # Find the index of the first digit that is greater than 4\n    index = next((i for i, digit in enumerate(x_str) if int(digit) > 4), None)\n    \n    # If no digit is greater than 4, return the number as is\n    if index is None:\n        return x\n    \n    # Otherwise, split the number into two parts at the index\n    part1 = int(x_str[:index])\n    part2 = int(x_str[index:])\n    \n    # Return the sum of the digits of the two parts\n    return part1 + part2\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    if a == c:\n        return True\n    if b == c:\n        return True\n    return False\n\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) == 0 or len(x) == 1: return x else: middle = len(x) / 2 a = merge_sort(x[:middle]) b = merge_sort(x[middle:]) return merge(a, b) print merge_sort([3, 2, 1, 5, 4]) print merge_sort([3, 2, 1, 5, 4, 6, 7, 8, 9]) print merge_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) print merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) print merge_sort([1, 1, 1, 1, 1, 1, 1, 1, 1]) print merge_sort([]) print merge_sort([1]) print merge_sort([2, 1]) print merge_sort([1, 2]) print merge_sort([2, 2, 1, 1]) print merge_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) print merge_sort([20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) print merge_sort([1, 20, 2, 19, 3, 18, 4, 17, 5, 16, 6, 15, 7, 14, 8,"}
{"task_id": "MBPP/153", "completion": "\n    x = -b / (2 * a)\n    y = a * x ** 2 + b * x + c\n    return (x, y)\n"}
{"task_id": "MBPP/154", "completion": "\n    result = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                result.append(nums[i][j])\n    return result\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary\n    binary = bin(n)[2:]\n\n    # Pad the binary string with leading zeros to make it 32 bits long\n    binary = binary.zfill(32)\n\n    # Toggle all even bits\n    toggled_binary = ''.join('1' if bit == '0' else '0' for bit in binary[1::2])\n\n    # Convert the toggled binary string back to a decimal number\n    toggled_number = int(toggled_binary, 2)\n\n    return toggled_number\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(len(list(group)), key) for key, group in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Sort the array\n    arr.sort()\n    # Initialize the count of operations\n    count = 0\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is greater than k, subtract k from it\n        if arr[i] > k:\n            arr[i] -= k\n            # Increment the count of operations\n            count += 1\n    # Return the count of operations\n    return count\n\n"}
{"task_id": "MBPP/159", "completion": "\n    if month in [12, 1, 2]:\n        return \"Winter\"\n    elif month in [3, 4, 5]:\n        return \"Spring\"\n    elif month in [6, 7, 8]:\n        return \"Summer\"\n    elif month in [9, 10, 11]:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n\n    The above code is incorrect because it does not guarantee that the solution will be found. \n    The loop will continue indefinitely if no solution exists. \n    To fix this, we can add a condition to break the loop if x becomes greater than n or y becomes less than 0.\n    \"\"\""}
{"task_id": "MBPP/161", "completion": "\n    for element in list2:\n        while element in list1:\n            list1.remove(element)\n    return list1\n"}
{"task_id": "MBPP/162", "completion": "\n    if n < 0:\n        return \"Input should be a positive integer.\"\n    else:\n        return sum(n for i in range(n+1) if i % 2 == 0)\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * l) / 2\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum1 = 0\n    sum2 = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum1 += i\n    for i in range(1, n):\n        if n % i == 0:\n            sum2 += i\n    if sum1 == sum2:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    count = 0\n    for i in range(len(str1)):\n        if ord(str1[i]) - ord('a') == i:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n\n"}
{"task_id": "MBPP/167", "completion": "\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/168", "completion": "\n    count = 0\n    for i in a:\n        if i == x:\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return 2 * get_pell(n - 1) + get_pell(n - 2)\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for i in range(len(s)-2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    result = {}\n    for k, v in l:\n        if k in result:\n            result[k].append(v)\n        else:\n            result[k] = [v]\n    return result\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char in ['(', '{', '[']:\n            stack.append(char)\n        elif char in [')', '}', ']']:\n            if not stack:\n                return False\n            top = stack.pop()\n            if (char == ')' and top != '(') or (char == '}' and top != '{') or (char == ']' and top != '['):\n                return False\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    # Check if the range is valid\n    if L > R:\n        return \"Invalid range\"\n    \n    # Initialize the answer\n    answer = None\n    \n    # Iterate over all pairs of numbers in the range\n    for i in range(L, R+1):\n        for j in range(i+1, R+1):\n            # Calculate the lcm of the pair\n            lcm = (i * j) // gcd(i, j)\n            \n            # Check if the lcm is within the range\n            if L <= lcm <= R:\n                # Update the answer if it is not already set\n                if answer is None:\n                    answer = (i, j)\n                # Check if the new pair has a smaller lcm\n                elif lcm < answer[0] * answer[1]:\n                    answer = (i, j)\n    \n    # Return the answer\n    return answer\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    if x < 10:\n        return False\n    digits = [int(d) for d in str(x)]\n    sum_digits = sum(digits)\n    while sum_digits < x:\n        digits = [int(d) for d in str(sum_digits)]\n        sum_digits = sum(digits)\n    return sum_digits == x"}
{"task_id": "MBPP/180", "completion": "\n    slat = radians(slat)\n    slon = radians(slon)\n    elat = radians(elat)\n    elon = radians(elon)\n    dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\n    return dist\n\n"}
{"task_id": "MBPP/181", "completion": "\n    if not str1 or not str2:\n        return \"\"\n    i = 0\n    while i < len(str1) and i < len(str2) and str1[i] == str2[i]:\n        i += 1\n    return str1[:i]\n\n"}
{"task_id": "MBPP/182", "completion": "\n    uppercase = re.findall(r'[A-Z]', string)\n    lowercase = re.findall(r'[a-z]', string)\n    special = re.findall(r'[^a-zA-Z0-9]', string)\n    numeric = re.findall(r'\\d', string)\n    return uppercase, lowercase, special, numeric\n\n\nstring = \"Hello, World! 123\"\nuppercase, lowercase, special, numeric = find_character(string)"}
{"task_id": "MBPP/183", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(arr[i] - arr[j]) == k:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the x-coordinate of the focus\n    x = -b / (2 * a)\n    # Calculate the y-coordinate of the focus\n    y = c - (b ** 2) / (4 * a)\n    # Return the coordinates of the focus\n    return (x, y)\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    if m == 0 or n == 0:\n        return 0\n\n    if X[m-1] == Y[n-1]:\n        return 1 + longest_common_subsequence(X, Y, m-1, n-1)\n    else:\n        return max(longest_common_subsequence(X, Y, m-1, n), longest_common_subsequence(X, Y, m, n-1))\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    for i in range(1, int(n**0.5) + 1):\n        if n % (i*i) == 0:\n            return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Initialize the result as 1\n    result = 1\n\n    # Iterate over the array\n    for i in range(n):\n        # If the current element is positive and less than or equal to the result\n        if arr[i] > 0 and arr[i] <= result:\n            # Increment the result\n            result += 1\n\n    # Return the result\n    return result\n\n"}
{"task_id": "MBPP/190", "completion": "\n    # Check if the points are integral\n    if not (x1.is_integer() and y1.is_integer() and x2.is_integer() and y2.is_integer()):\n        return \"Error: All points must be integral.\"\n\n    # Check if the points are in the correct order\n    if x1 > x2 or y1 > y2:\n        return \"Error: Points must be in the correct order.\"\n\n    # Count the number of integral points\n    count = 0\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            count += 1\n\n    return count\n\n"}
{"task_id": "MBPP/191", "completion": "\n    if monthname3 in ['April', 'June', 'September', 'November']:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/192", "completion": "\n    if str.isalpha() or str.isdigit():\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n\n"}
{"task_id": "MBPP/194", "completion": "\n    decimal = 0\n    base = 1\n    while(n):\n        last_digit = n % 10\n        n = n // 10\n        decimal += last_digit * base\n        base = base * 8\n    return decimal\n"}
{"task_id": "MBPP/195", "completion": "\n    for i in range(n):\n        if arr[i] == x:\n            return i\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [t for t in test_list if len(t) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    return tuple(map(pow, test_tup1, test_tup2))\n"}
{"task_id": "MBPP/198", "completion": "\n    # The largest triangle that can be inscribed in an ellipse is a right triangle with the hypotenuse along the major axis of the ellipse.\n    # The length of the hypotenuse is equal to the diameter of the ellipse.\n    # The lengths of the other two sides of the triangle are equal to the semi-major and semi-minor axes of the ellipse.\n    # Therefore, the area of the triangle is equal to one-fourth of the area of the ellipse.\n    # The area of the ellipse is given by the formula A = \u03c0ab, where a and b are the lengths of the semi-major and semi-minor axes, respectively.\n    # Therefore, the area of the triangle is equal to \u03c0ab/4.\n    # The perimeter of the triangle is equal to the sum of the lengths of the three sides, which is equal to a + b + \u221a(a^2 + b^2).\n    # Therefore, the area of the triangle is equal to (a + b + \u221a(a^2 + b^2))/4.\n    # The function returns the area of the triangle.\n    return (a + b + math.sqrt(a**2 + b**2)) / 4\n\n"}
{"task_id": "MBPP/199", "completion": "\n    if n < 1:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n\n"}
{"task_id": "MBPP/200", "completion": "\n    max_value = max(list1)\n    positions = [i for i, value in enumerate(list1) if value == max_value]\n    return positions\n"}
{"task_id": "MBPP/201", "completion": "\n    if len(lst) == 0:\n        return True\n    else:\n        return all(x == lst[0] for x in lst)\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([str1[i] for i in range(len(str1)) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    xor = n1 ^ n2\n    count = 0\n    while xor:\n        count += xor & 1\n        xor >>= 1\n    return count\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    # Create a list from the tuple\n    test_list = list(test_tup)\n    # Sort the list\n    test_list.sort()\n    # Create a new list to store the inversions\n    inversions = []\n    # Iterate through the list\n    for i in range(len(test_list)):\n        # Iterate through the list again\n        for j in range(i+1, len(test_list)):\n            # If the current element is greater than the next element, add it to the inversions list\n            if test_list[i] > test_list[j]:\n                inversions.append((test_list[i], test_list[j]))\n    # Return the inversions list\n    return inversions\n"}
{"task_id": "MBPP/206", "completion": "\n    return ''.join(test_tup)\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[n][n]\n\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heapreplace(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]*$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(n+1):\n        if (i & (1 << 0)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([i**4 for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return tuple(test_tup1 + test_tup2)\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * 180 / math.pi\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    for i in range(0, len(alist), 2):\n        decoded_list.extend([alist[i]] * alist[i+1])\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    return all(item in list2 for item in list1)\n"}
{"task_id": "MBPP/217", "completion": "\n    char_dict = {}\n    for char in str:\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = 1\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # If A is greater than B, swap them\n    if A > B:\n        A, B = B, A\n\n    # If B is a multiple of A, return B // A\n    if B % A == 0:\n        return B // A\n\n    # If B is not a multiple of A, find the smallest multiple of A that is greater than B\n    smallest_multiple = A * math.ceil(B / A)\n\n    # Return the number of operations required to make B equal to the smallest multiple\n    return smallest_multiple - B\n\n"}
{"task_id": "MBPP/219", "completion": "\n    test_list = list(test_tup)\n    test_list.sort()\n    return test_list[:K], test_list[-K:]\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, or dots\n    matches = re.findall(r'[ ,\\.]', text)\n    # Replace maximum n occurrences with a colon\n    for i in range(n):\n        if matches:\n            text = text.replace(matches[i], ':', 1)\n    return text\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    return all(isinstance(i, type(test_tuple[0])) for i in test_tuple)\n\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize the count of x\n    count = 0\n\n    # Traverse the array\n    for i in range(n):\n        # If the current element is x, increment the count\n        if arr[i] == x:\n            count += 1\n\n    # If the count is greater than n/2, then x is the majority element\n    if count > n // 2:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"task_id": "MBPP/225", "completion": "\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return arr[mid + 1]\n    if mid > low and arr[mid - 1] > arr[mid]:\n        return arr[mid]\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)\n\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([str[i] for i in range(len(str)) if i % 2 == 0])\n\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Check if all bits are unset in the given range\n    if (n & ((1 << (r + 1)) - (1 << l))) == 0:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/229", "completion": "\n    # Initialize two pointers\n    left = 0\n    right = n - 1\n\n    # Traverse the array\n    while left <= right:\n        # If the current element is negative, move it to the left side\n        if arr[left] < 0:\n            left += 1\n        # If the current element is positive, move it to the right side\n        elif arr[right] >= 0:\n            right -= 1\n        # If the current element is positive and the element on the left side is negative, swap them\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    return arr\n\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n\n"}
{"task_id": "MBPP/231", "completion": "\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            tri[i][j] += max(tri[i+1][j], tri[i+1][j+1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l**3\n"}
{"task_id": "MBPP/235", "completion": "\n    mask = 0xAAAAAAAA\n    return n | mask\n\n"}
{"task_id": "MBPP/236", "completion": "\n    if N < 3 or K < 1:\n        return 0\n    if K == 1:\n        return N\n    if K == 2:\n        return (N * (N - 1)) // 2\n    return (N * (N - 1) * (N - 2)) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a Counter object to count the occurrences of each record\n    counter = Counter(test_list)\n\n    # Initialize a variable to store the record with the maximum occurrences\n    max_occurrences = 0\n    max_record = None\n\n    # Iterate over the Counter object to find the record with the maximum occurrences\n    for record, occurrences in counter.items():\n        if occurrences > max_occurrences:\n            max_occurrences = occurrences\n            max_record = record\n\n    # Return the record with the maximum occurrences\n    return max_record\n\n"}
{"task_id": "MBPP/238", "completion": "\n    return sum(len(str) - i for i in range(len(str)))\n"}
{"task_id": "MBPP/239", "completion": "\n    # Initialize the total number of sequences to 1\n    total_sequences = 1\n\n    # Iterate through the length of the sequence\n    for i in range(1, n):\n        # Calculate the number of possible values for the next element\n        num_values = min(m, 2 * total_sequences)\n\n        # Update the total number of sequences\n        total_sequences *= num_values\n\n    return total_sequences\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [['*' for _ in range(o)] for _ in range(n) for _ in range(m)]\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: x[0])\n\n"}
{"task_id": "MBPP/244", "completion": "\n    if N < 0:\n        return None\n    if N == 0:\n        return 1\n    if N == 1:\n        return 4\n    if N == 2:\n        return 4\n    if N == 3:\n        return 9\n    if N == 4:\n        return 16\n    if N == 5:\n        return 16\n    if N == 6:\n        return 16\n    if N == 7:\n        return 25\n    if N == 8:\n        return 25\n    if N == 9:\n        return 25\n    if N == 10:\n        return 25\n    if N == 11:\n        return 36\n    if N == 12:\n        return 36\n    if N == 13:\n        return 36\n    if N == 14:\n        return 36\n    if N == 15:\n        return 36\n    if N == 16:\n        return 36\n    if N == 17:\n        return 49\n    if N == 18:\n        return 49\n    if N == 19:\n        return 49\n    if N == 20:\n        return 49\n    if N == 21:\n        return 49\n    if N == 22:\n        return 49\n    if N == 23:\n        return 49\n    if N == 24:\n        return 49\n    if N == 25:\n        return 49\n    if N == 26:\n        return 49\n    if N == 27:\n        return 49\n    if N == 28:\n        return 49\n    if N == 29:\n        return 49\n    if N == 30:\n        return 49\n    if N == 31:\n        return 49\n    if N == 32:\n        return 49\n    if N == 33:\n        return 49\n    if N == 34:\n        return 49\n    if N == 35:\n        return 49\n    if N == 36:\n        return 49\n    if N == 37:\n        return 49\n    if N == 38:\n        return 49\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize the maximum sum array\n    max_sum = [0] * n\n\n    # Initialize the maximum sum of increasing sub-sequence array\n    max_inc = [0] * n\n\n    # Initialize the maximum sum of decreasing sub-sequence array\n    max_dec = [0] * n\n\n    # Initialize the maximum sum of bi-tonic sub-sequence array\n    max_biotonic = [0] * n\n\n    # Calculate the maximum sum of increasing sub-sequence\n    for i in range(n):\n        max_inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and max_inc[i] < max_inc[j] + arr[i]:\n                max_inc[i] = max_inc[j] + arr[i]\n\n    # Calculate the maximum sum of decreasing sub-sequence\n    for i in range(n):\n        max_dec[i] = arr[i]\n        for j in range(i):\n            if arr[i] < arr[j] and max_dec[i] < max_dec[j] + arr[i]:\n                max_dec[i] = max_dec[j] + arr[i]\n\n    # Calculate the maximum sum of bi-tonic sub-sequence\n    for i in range(n):\n        max_biotonic[i] = max_inc[i] + max_dec[i] - arr[i]\n\n    # Return the maximum sum of bi-tonic sub-sequence\n    return max(max_biotonic)\n"}
{"task_id": "MBPP/246", "completion": "\n    guess = number / 2.0\n    while True:\n        better_guess = (guess + number / guess) / 2.0\n        if abs(guess - better_guess) < 0.000001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for x in range(n)] for x in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    return dp[0][n-1]"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0/i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(filter(lambda x: x in array_nums2, array_nums1))\n"}
{"task_id": "MBPP/250", "completion": "\n    count = 0\n    for i in tup:\n        if i == x:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] * len(list) + list\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_numbers = []\n    for number in numbers:\n        r, phi = cmath.polar(number)\n        polar_numbers.append((r, phi))\n    return polar_numbers\n\n\nnumbers = [1+2j, 3+4j, 5+12j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/254", "completion": "\n    return re.findall(r'\\b[a|e]\\w*', text)\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return len(list(filter(lambda x: x % 2 != 0, array_nums)))\n"}
{"task_id": "MBPP/259", "completion": "\n    return tuple(max(test_tup1[i], test_tup2[i]) for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/260", "completion": "\n\n        Check if a number is a newman\u2013shanks\u2013williams prime.\n        \"\"\"\n        # Check if n is a prime number\n        if not is_prime(n):\n            return False\n        \n        # Check if n is a newman\u2013shanks\u2013williams prime\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        \n        return True\n    \n    count = 0\n    num = 2\n    while count < n:\n        if is_newman_prime(num):\n            count += 1\n        num += 1\n    \n    return num - 1\n"}
{"task_id": "MBPP/261", "completion": "\n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] / test_tup2[i])\n    return tuple(result)\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    return h_age * 7\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i+step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    return sum(i**2 for i in range(1, 2*n, 2))\n"}
{"task_id": "MBPP/268", "completion": "\n    # Initialize the star number\n    star_num = 1\n\n    # Loop until the n'th star number is found\n    while n > 0:\n        # Increment the star number\n        star_num += 1\n\n        # Check if the star number is prime\n        if is_prime(star_num):\n            # Decrement the count of star numbers\n            n -= 1\n\n    # Return the n'th star number\n    return star_num\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n\n"}
{"task_id": "MBPP/270", "completion": "\n    sum = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum += arr[i]\n    return sum\n\n"}
{"task_id": "MBPP/271", "completion": "\n    sum = 0\n    for i in range(2, n*2+1, 2):\n        sum += i**5\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    rear_elements = []\n    for record in test_list:\n        rear_elements.append(record[-1])\n    return rear_elements\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(test_tup1[i] - test_tup2[i] for i in range(len(test_tup1)))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize the binomial coefficient\n    binomial_coeff = 1\n\n    # Initialize the sum\n    sum_even_index = 0\n\n    # Loop through the range of n\n    for i in range(n):\n        # Calculate the binomial coefficient\n        binomial_coeff = binomial_coeff * (n - i) / (i + 1)\n\n        # Check if the index is even\n        if i % 2 == 0:\n            # Add the binomial coefficient to the sum\n            sum_even_index += binomial_coeff\n\n    # Return the sum of even index binomial coefficients\n    return sum_even_index\n\n"}
{"task_id": "MBPP/275", "completion": "\n    if n == 1:\n        return 0\n    if m == 1:\n        return n - 1\n    return (get_Position(a, n - 1, m - 1) + a[n - 1]) % n\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {k: v for k, v in dict.items() if v > n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return len(test_tup) - test_tup.index(1) - 1\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * (5 * n - 3) // 2\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n\n"}
{"task_id": "MBPP/283", "completion": "\n    for i in range(10):\n        if n.count(str(i)) > i:\n            return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    for i in list:\n        if i != element:\n            return False\n    return True\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r'a(b{2,3})'\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1)\n    else:\n        return None\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Calculate the sum of the array\n    total_sum = sum(a)\n\n    # Calculate the sum of the subarray of length n\n    subarray_sum = sum(a[:n])\n\n    # Initialize the maximum sum\n    max_sum = subarray_sum\n\n    # Iterate through the array\n    for i in range(1, k):\n        # Calculate the sum of the subarray\n        subarray_sum = subarray_sum - a[i-1] + a[(i*n) % n]\n\n        # Update the maximum sum\n        max_sum = max(max_sum, subarray_sum)\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    return sum(i**2 for i in range(2, n*2+1, 2))\n"}
{"task_id": "MBPP/288", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize the count of elements with modular inverse equal to itself\n    count = 0\n\n    # Iterate over the elements in the array\n    for num in arr:\n        # Calculate the modular inverse of the current element\n        inv = pow(num, N-2, P)\n\n        # Check if the modular inverse is equal to the current element\n        if inv == num:\n            # If it is, increment the count\n            count += freq[num]\n\n    return count\n\n"}
{"task_id": "MBPP/289", "completion": "\n    # Check if the year is a leap year\n    if N % 4 == 0:\n        # If the year is a leap year, there are 2 odd days\n        return 2\n    else:\n        # If the year is not a leap year, there is 1 odd day\n        return 1\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = max(len(lst) for lst in list1)\n    return [lst for lst in list1 if len(lst) == max_len]\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # dp[i] represents the number of ways to paint the first i posts\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n\n    # for i = 3 to n, we have two cases:\n    # 1. the i-th post has the same color as the (i-1)-th post\n    # 2. the i-th post has a different color as the (i-1)-th post\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    max_val = listval[0]\n    for val in listval:\n        if val > max_val:\n            max_val = val\n    return max_val\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = []\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n"}
{"task_id": "MBPP/296", "completion": "\n    # Initialize count\n    count = 0\n\n    # Traverse through array\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n\n    return count\n\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for sublist1 in l1:\n        for sublist2 in l2:\n            if sublist1 == sublist2:\n                result.append(sublist1)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the aggregate values\n    aggregate_dict = defaultdict(int)\n\n    # Iterate over the list of tuples\n    for data in stdata:\n        # Extract the values from the tuple\n        key, value = data\n\n        # Update the aggregate value for the key\n        aggregate_dict[key] += value\n\n    # Find the maximum aggregate value\n    max_aggregate_value = max(aggregate_dict.values())\n\n    return max_aggregate_value\n\n"}
{"task_id": "MBPP/300", "completion": "\n    # Initialize a 2D array to store the count of binary sequences\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n    # Base case: If n is 0, there is only one binary sequence of length 0, which is an empty sequence\n    dp[0][0] = 1\n\n    # Iterate over all possible values of i and j\n    for i in range(1, n+1):\n        for j in range(n+1):\n            # If the sum of the first i bits is equal to the sum of the last i bits, we can add a 0 or a 1 to the sequence\n            dp[i][j] = dp[i-1][j] + dp[i-1][abs(j-1)]\n\n    # The count of binary sequences of length 2n such that sum of first n bits is same as sum of last n bits is stored in dp[n][n]\n    return dp[n][n]\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    if n == 0:\n        return 0\n    msb = 0\n    while n:\n        n >>= 1\n        msb += 1\n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    # Write your code here\n    # return True or False\n    # pass\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n    #     for j in range(i+1, n):\n    #         if a[i] > a[j]:\n    #             count += 1\n    # if count % 2 == 0:\n    #     return True\n    # else:\n    #     return False\n    # count = 0\n    # for i in range(n):\n   "}
{"task_id": "MBPP/304", "completion": "\n    # Check if the index is valid\n    if index < 0 or index >= len(arr):\n        return -1\n\n    # Find the number of rotations\n    num_rotations = rotations % len(arr)\n\n    # Find the index of the element after rotations\n    new_index = (index + num_rotations) % len(arr)\n\n    # Find the element at the new index\n    element = arr[new_index]\n\n    # Return the element\n    return element\n\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = re.compile(r'^p')\n    matches = [word for word in words if pattern.match(word)]\n    return matches\n\n\nwords = ['python', 'java', 'php', 'perl', 'ruby', 'javascript', 'c++', 'c#', 'pascal', 'fortran']"}
{"task_id": "MBPP/306", "completion": "\n    # Base case: If the array is empty or the index is out of bounds, return 0\n    if n == 0 or index >= n:\n        return 0\n\n    # If the value at the current index is greater than or equal to the value at the kth index, return the value at the current index\n    if a[index] >= a[k]:\n        return a[index]\n\n    # Recursively call the function to find the maximum sum of increasing subsequence from prefix till the next index\n    return max_sum_increasing_subseq(a, n, index + 1, k) + a[index]\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Combine the two lists\n    combined = nums1 + nums2\n\n    # Sort the combined list in descending order\n    combined.sort(reverse=True)\n\n    # Return the first N elements of the sorted list\n    return combined[:N]\n\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    return n | (n + 1)\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n\n"}
{"task_id": "MBPP/314", "completion": "\n    # Initialize the maximum sum to be negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over all possible starting points\n    for i in range(n):\n        # Initialize the current sum to be 0\n        current_sum = 0\n        \n        # Iterate over all possible ending points\n        for j in range(i, n):\n            # Add the current element to the current sum\n            current_sum += grid[j]\n            \n            # Update the maximum sum if the current sum is greater\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    str = str.split()\n    max_len = 0\n    for word in str:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/316", "completion": "\n    low, high = 0, len(A) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            else:\n                low = mid + 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    # Create a list to store the encoded values\n    encoded_list = []\n\n    # Iterate over the list\n    for key, group in groupby(alist):\n        # Get the length of the group\n        length = len(list(group))\n\n        # Append the key and length to the encoded list\n        encoded_list.append((key, length))\n\n    return encoded_list\n\n"}
{"task_id": "MBPP/318", "completion": "\n    # Initialize the maximum volume to 0\n    max_vol = 0\n\n    # Iterate through all possible combinations of side lengths\n    for a in range(1, s):\n        for b in range(1, s - a):\n            c = s - a - b\n            # Calculate the volume of the cuboid\n            vol = a * b * c\n            # Update the maximum volume if necessary\n            if vol > max_vol:\n                max_vol = vol\n\n    return max_vol\n\n"}
{"task_id": "MBPP/319", "completion": "\n    pattern = r'\\b\\w{5}\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    # Calculate the sum of first n natural numbers\n    sum_n = n * (n + 1) // 2\n\n    # Calculate the squared sum of first n natural numbers\n    squared_sum_n = sum_n ** 2\n\n    # Calculate the sum of squared first n natural numbers\n    sum_squared_n = sum(i ** 2 for i in range(1, n + 1))\n\n    # Calculate the difference\n    difference = squared_sum_n - sum_squared_n\n\n    return difference\n"}
{"task_id": "MBPP/321", "completion": "\n    demlo = 0\n    for i in range(len(s)):\n        demlo += int(s[i]) * (10 ** (len(s) - i - 1))\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_value = min(list1)\n    return [i for i, x in enumerate(list1) if x == min_value]\n"}
{"task_id": "MBPP/323", "completion": "\n    if cur == n:\n        return\n\n    if out_of_place == 0:\n        if arr[cur] < 0:\n            right_rotate(arr, n, out_of_place, cur + 1)\n        else:\n            arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n            right_rotate(arr, n, out_of_place + 1, cur + 1)\n    else:\n        if arr[cur] > 0:\n            right_rotate(arr, n, out_of_place, cur + 1)\n        else:\n            arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n            right_rotate(arr, n, out_of_place + 1, cur + 1)\n\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(sum_of_alternates(t) if isinstance(t, tuple) else t for t in test_tuple[::2])\n"}
{"task_id": "MBPP/325", "completion": "\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, int(i ** 0.5) + 1):\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n    return dp[n]\n\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n\ntest_list = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"]"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")\n\n"}
{"task_id": "MBPP/328", "completion": "\n    if m > n:\n        m, n = n, m\n    return list1[m:] + list1[:m]\n\n"}
{"task_id": "MBPP/329", "completion": "\n    count = 0\n    for i in list:\n        if i < 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/330", "completion": "\n    pattern = r'\\b\\w{3,5}\\b'\n    matches = re.findall(pattern, text)\n    return matches\n\n\ntext = \"This is a sample text to find words of length 3, 4, and 5\""}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n:\n        if n & 1 == 0:\n            count += 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    l = len(sub_li)\n    for i in range(0, l):\n        for j in range(0, l-i-1):\n            if (sub_li[j][1] > sub_li[j + 1][1]):\n                tempo = sub_li[j]\n                sub_li[j]= sub_li[j + 1]\n                sub_li[j + 1]= tempo\n    return sub_li"}
{"task_id": "MBPP/334", "completion": "\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n/2) * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    monthname1 = monthname1.lower()\n    if monthname1 in ['february', 'april', 'june', 'september', 'november']:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b(?=[.,;!?]?$)'\n    match = re.search(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize the maximum divisor and its count\n    max_divisor = 0\n    max_count = 0\n\n    # Iterate over the interval\n    for i in range(x, y+1):\n        # Count the number of divisors of i\n        count = 0\n        for j in range(1, i+1):\n            if i % j == 0:\n                count += 1\n\n        # Update the maximum divisor and its count if necessary\n        if count > max_count:\n            max_divisor = i\n            max_count = count\n\n    return max_divisor\n"}
{"task_id": "MBPP/340", "completion": "\n    # Check if the list is empty\n    if not lst:\n        return None\n\n    # Remove negative numbers and zeros\n    lst = [num for num in lst if num > 0]\n\n    # Check if the list has less than 3 positive numbers\n    if len(lst) < 3:\n        return None\n\n    # Sort the list in ascending order\n    lst.sort()\n\n    # Return the sum of the three smallest numbers\n    return sum(lst[:3])\n\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(s)\n\n"}
{"task_id": "MBPP/342", "completion": "\n    min_range = float('inf')\n    min_range_list = []\n    max_value = float('-inf')\n    min_heap = []\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        max_value = max(max_value, lst[0])\n\n    while len(min_heap) == len(list):\n        node = heappop(min_heap)\n        current_range = max_value - node.value\n        if current_range < min_range:\n            min_range = current_range\n            min_range_list = [node.value, max_value]\n        if node.index + 1 < len(list[node.list_num]):\n            heappush(min_heap, Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n            max_value = max(max_value, list[node.list_num][node.index + 1])\n\n    return min_range_list\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = 0\n    letters = 0\n    for c in s:\n        if c.isdigit():\n            digits += 1\n        elif c.isalpha():\n            letters += 1\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        if i % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i+1] - nums[i] for i in range(len(nums)-1)]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 0:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return 1\n    if k == 2:\n        return 1\n    if k == 3:\n        return 2\n    if k == 4:\n        return 2\n    if k == 5:\n        return 3\n    if k == 6:\n        return 3\n    if k == 7:\n        return 4\n    if k == 8:\n        return 4\n    if k == 9:\n        return 5\n    if k == 10:\n        return 5\n    if k == 11:\n        return 6\n    if k == 12:\n        return 6\n    if k == 13:\n        return 7\n    if k == 14:\n        return 7\n    if k == 15:\n        return 8\n    if k == 16:\n        return 8\n    if k == 17:\n        return 9\n    if k == 18:\n        return 9\n    if k == 19:\n        return 10\n    if k == 20:\n        return 10\n    if k == 21:\n        return 11\n    if k == 22:\n        return 11\n    if k == 23:\n        return 12\n    if k == 24:\n        return 12\n    if k == 25:\n        return 13\n    if k == 26:\n        return 13\n    if k == 27:\n        return 14\n    if k == 28:\n        return 14\n    if k == 29:\n        return 15\n    if k == 30:\n        return 15\n    if k == 31:\n        return 16\n    if k == 32:\n        return 16\n    if k == 33:\n        return 17\n    if k == 34:\n        return 17\n    if k == 35:\n        return 18\n    if k == 36:\n        return 18\n    if k == 37:\n        return 19\n    if k == 38:\n        return 19\n    if k == 39"}
{"task_id": "MBPP/347", "completion": "\n    return (m * n) // 4\n"}
{"task_id": "MBPP/348", "completion": "\n    # Initialize the binomial coefficient matrix\n    C = [[0 for _ in range(r+1)] for _ in range(n+1)]\n    C[0][0] = 1\n\n    # Fill the binomial coefficient matrix\n    for i in range(1, n+1):\n        for j in range(1, r+1):\n            C[i][j] = C[i-1][j-1] + C[i-1][j]\n\n    return C[n][r]\n"}
{"task_id": "MBPP/349", "completion": "\n    for i in string:\n        if i != '0' and i != '1':\n            return False\n    return True\n\n"}
{"task_id": "MBPP/350", "completion": "\n    # Initialize the minimum length to the length of the string\n    min_length = len(s)\n    \n    # Iterate through each character in the string\n    for char in set(s):\n        # Remove all occurrences of the current character\n        new_s = s.replace(char, '')\n        \n        # Update the minimum length if the new string is shorter\n        min_length = min(min_length, len(new_s))\n    \n    return min_length\n"}
{"task_id": "MBPP/351", "completion": "\n    count = {}\n    for i in range(n):\n        if arr[i] in count:\n            count[arr[i]] += 1\n        else:\n            count[arr[i]] = 1\n    for i in range(n):\n        if count[arr[i]] == k:\n            return arr[i]\n    return -1\n"}
{"task_id": "MBPP/352", "completion": "\n    # Create a set to store unique characters\n    unique_chars = set()\n\n    # Iterate through each character in the string\n    for char in str:\n        # If the character is already in the set, return False\n        if char in unique_chars:\n            return False\n        # Otherwise, add the character to the set\n        unique_chars.add(char)\n\n    # If we reach this point, all characters are unique\n    return True\n\n"}
{"task_id": "MBPP/353", "completion": "\n    return [row[:n] + row[n+1:] for row in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n\n"}
{"task_id": "MBPP/355", "completion": "\n    return int((radius * 2) ** 2)\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - (a + b)\n"}
{"task_id": "MBPP/357", "completion": "\n    max_value = test_list[0][0]\n    for record in test_list:\n        if record[0] > max_value:\n            max_value = record[0]\n    return max_value\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    if a == 0:\n        return \"Not a quadratic equation\"\n    else:\n        discriminant = b**2 - 4*a*c\n        if discriminant < 0:\n            return \"No real roots\"\n        elif discriminant == 0:\n            return \"Equal roots\"\n        else:\n            root1 = (-b + discriminant**0.5) / (2*a)\n            root2 = (-b - discriminant**0.5) / (2*a)\n            if root1 == 2*root2 or root2 == 2*root1:\n                return \"One root is twice the other\"\n            else:\n                return \"No root is twice the other\""}
{"task_id": "MBPP/360", "completion": "\n    # A carol number is a number of the form 2^(2^k) - 1\n    # The first few carol numbers are 3, 7, 31, 127, 8191, 131071, 524287, 2147483647, 2305843009213693951, 618970019642690137449562111, 162259276829213363391578010288127, 170141183460469231731687303715884105727\n    # The n\u2019th carol number can be found using the formula 2^(2^(n-1)) - 1\n    # For example, the 3\u2019rd carol number is 2^(2^(2)) - 1 = 2^4 - 1 = 15\n    # The 4\u2019th carol number is 2^(2^(3)) - 1 = 2^8 - 1 = 255\n    # The 5\u2019th carol number is 2^(2^(4)) - 1 = 2^16 - 1 = 65535\n    # The 6\u2019th carol number is 2^(2^(5)) - 1 = 2^32 - 1 = 4294967295\n    # The 7\u2019th carol number is 2^(2^(6)) - 1 = 2^64 - 1 = 18446744073709551615\n    # The 8\u2019th carol number is 2^(2^(7)) - 1 = 2^128 - 1 = 340282366920938463463374607431768211455\n    # The 9\u2019th carol number is 2^(2^(8)) - 1 = 2^256 - 1 = 1157920892373161954235709850086879078532699846656405640394575840079131296"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the item with maximum occurrences\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item\n"}
{"task_id": "MBPP/363", "completion": "\n    return tuple(x + K for x in test_list)\n"}
{"task_id": "MBPP/364", "completion": "\n    count = 0\n    for i in range(len(ch) - 1):\n        if ch[i] != ch[i + 1]:\n            count += 1\n    return count\n\n"}
{"task_id": "MBPP/365", "completion": "\n    count = 0\n    while n > 0:\n        n = n // 10\n        count += 1\n    return count\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(1, len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) <= 1 and is_tree_balanced(root.left) and is_tree_balanced(root.right):\n        return True\n\n    return False\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return test_tup * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * h + w * h)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x[1]))\n"}
{"task_id": "MBPP/371", "completion": "\n    if A[left_element] != left_element:\n        return left_element\n    if A[right_element] != right_element:\n        return right_element\n    mid_element = (left_element + right_element) // 2\n    if A[mid_element] == mid_element:\n        return smallest_missing(A, mid_element, right_element)\n    else:\n        return smallest_missing(A, left_element, mid_element)\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(len(nums))]\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    # Base case: if the string is empty, return an empty list\n    if len(str) == 0:\n        return []\n\n    # Base case: if the string has only one character, return a list with that character\n    if len(str) == 1:\n        return [str]\n\n    # Recursive case: for each character in the string, generate all permutations of the remaining characters\n    permutations = []\n    for i in range(len(str)):\n        char = str[i]\n        remaining_chars = str[:i] + str[i+1:]\n        for perm in permute_string(remaining_chars):\n            permutations.append(char + perm)\n\n    return permutations\n\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new list to store the result\n    result = []\n    for element in test_tup:\n        if count_dict[element] > 1:\n            result.append(\"Custom Value\")\n        else:\n            result.append(element)\n\n    return tuple(result)\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) == 0:\n        return test_list\n    else:\n        return [test_list[-1]] + test_list[:-1]\n\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    if not A:\n        return 0\n\n    left, right = 0, len(A) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if A[mid] > A[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}
{"task_id": "MBPP/383", "completion": "\n    # Toggle all odd bits of a given number\n    return n ^ 0xAAAAAAAA\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # Find the smallest value in the array\n    smallest = min(arr)\n    \n    # Count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    else:\n        return get_perrin(n-2) + get_perrin(n-3) + get_perrin(n-1)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    swap_count = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(char)\n                swap_count += 1\n    return swap_count + len(stack) // 2\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert the hexadecimal number to decimal\n    decimal = int(str(N), 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    if n < 1:\n        return 0\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n-1) + find_lucas(n-2)\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n\n"}
{"task_id": "MBPP/391", "completion": "\n    return {l1[i]: {l2[i]: l3[i]} for i in range(len(l1))}\n"}
{"task_id": "MBPP/392", "completion": "\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = max(n, helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5))\n        return memo[n]\n    return helper(n)\n"}
{"task_id": "MBPP/393", "completion": "\n    max_length = max(input_list, key=len)\n    return max_length\n"}
{"task_id": "MBPP/394", "completion": "\n    if len(test_tup) == len(set(test_tup)):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/395", "completion": "\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first character with count 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    return bool(re.match(regex, string))\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(map(lambda x, y: x ^ y, test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Check if the input tuples are nested\n    if isinstance(test_tup1, tuple) and isinstance(test_tup2, tuple):\n        # Check if the input tuples have the same structure\n        if len(test_tup1) == len(test_tup2):\n            # Check if the input tuples have the same number of elements\n            if len(test_tup1) > 0:\n                # Check if the first element of each tuple is a tuple\n                if isinstance(test_tup1[0], tuple) and isinstance(test_tup2[0], tuple):\n                    # Recursively add the first element of each tuple\n                    first_element = add_nested_tuples(test_tup1[0], test_tup2[0])\n                    # Add the remaining elements of each tuple\n                    remaining_elements = add_nested_tuples(test_tup1[1:], test_tup2[1:])\n                    # Return the result as a tuple\n                    return (first_element,) + remaining_elements\n                else:\n                    # If the first element of each tuple is not a tuple, add the elements directly\n                    return (test_tup1[0] + test_tup2[0],) + add_nested_tuples(test_tup1[1:], test_tup2[1:])\n            else:\n                # If the input tuples have no elements, return an empty tuple\n                return ()\n        else:\n            # If the input tuples have different structures, return an error message\n            return \"Error: The input tuples have different structures.\"\n    else:\n        # If the input is not a tuple, return an error message\n        return \"Error: The input is not a tuple.\"\n"}
{"task_id": "MBPP/402", "completion": "\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p\n"}
{"task_id": "MBPP/403", "completion": "\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n\n    return re.match(regex, str) is not None\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    if tuplex in tuple1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/406", "completion": "\n    return x % 2\n"}
{"task_id": "MBPP/407", "completion": "\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    \n    # Find the first digit from the right that is smaller than the digit next to it\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            break\n    else:\n        # If no such digit is found, the number is the largest possible permutation\n        return -1\n    \n    # Find the smallest digit on the right of the found digit that is larger than it\n    for j in range(len(digits) - 1, i, -1):\n        if digits[j] > digits[i]:\n            break\n    \n    # Swap the found digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits to the right of the found digit\n    digits = digits[:i + 1] + digits[i + 1:][::-1]\n    \n    # Convert the list of digits back to a number\n    return int(''.join(map(str, digits)))\n"}
{"task_id": "MBPP/408", "completion": "\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    # min heap to store the pairs\n    min_heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < min_heap[0][0]:\n                    heapq.heappop(min_heap)\n                    heapq.heappush(min_heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    # extract the pairs from the heap\n    result = []\n    while min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n\n    return result\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Check if the list is empty\n    if not list1:\n        return None\n\n    # Initialize the minimum product to a large number\n    min_product = float('inf')\n\n    # Iterate through the list of tuples\n    for tuple1 in list1:\n        # Check if the tuple has at least two elements\n        if len(tuple1) < 2:\n            continue\n\n        # Calculate the product of the first two elements of the tuple\n        product = tuple1[0] * tuple1[1]\n\n        # Update the minimum product if necessary\n        if product < min_product:\n            min_product = product\n\n    # Return the minimum product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    min_val = listval[0]\n    for val in listval:\n        if val < min_val:\n            min_val = val\n    return min_val\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the snake case string\n    words = re.findall(r'(\\w+)', word)\n\n    # Capitalize the first letter of each word except the first one\n    camel_case = ''.join(word.capitalize() if i > 0 else word for i, word in enumerate(words))\n\n    return camel_case\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n\n"}
{"task_id": "MBPP/413", "completion": "\n    return [element[n] for element in list1]\n"}
{"task_id": "MBPP/414", "completion": "\n    return any(item in list2 for item in list1)\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    return max(max1 * max2, min1 * min2)\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    return max(n, breakSum(n - 1) + breakSum(n - 3) + breakSum(n - 4))\n\n"}
{"task_id": "MBPP/417", "completion": "\n    # Create a dictionary to store the count of each first element\n    count_dict = {}\n    for tup in Input:\n        first_element = tup[0]\n        if first_element in count_dict:\n            count_dict[first_element] += 1\n        else:\n            count_dict[first_element] = 1\n\n    # Find the first element with the maximum count\n    max_count = 0\n    max_element = None\n    for element, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_element = element\n\n    return max_element\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_sublist = []\n    for i in range(len(lst)):\n        for j in range(i, len(lst)):\n            sublist = lst[i:j+1]\n            if len(sublist) > max_len:\n                max_len = len(sublist)\n                max_sublist = sublist\n    return max_sublist\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    result = total_sum * len(rounded_list)\n    print(result)\n    return result\n"}
{"task_id": "MBPP/420", "completion": "\n    sum = 0\n    for i in range(2, 2*n+1, 2):\n        sum += i**3\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    delimiter = \"-\"\n    result = delimiter.join(test_tup)\n    return result\n"}
{"task_id": "MBPP/422", "completion": "\n    return sum([i**3 for i in range(1, n+1)]) / n\n\n"}
{"task_id": "MBPP/423", "completion": "\n    # Initialize a 2D array to store the maximum gold collected at each cell\n    max_gold = [[0] * n for _ in range(m)]\n\n    # Iterate over each cell in the grid\n    for i in range(m):\n        for j in range(n):\n            # If the cell is not a mine, calculate the maximum gold collected\n            if gold[i][j] != -1:\n                # Check the three possible directions (up, down, left) and take the maximum\n                if i > 0:\n                    max_gold[i][j] = max(max_gold[i][j], max_gold[i-1][j])\n                if j > 0:\n                    max_gold[i][j] = max(max_gold[i][j], max_gold[i][j-1])\n                if i < m-1:\n                    max_gold[i][j] = max(max_gold[i][j], max_gold[i+1][j])\n                # Add the gold at the current cell to the maximum gold collected\n                max_gold[i][j] += gold[i][j]\n\n    # Find the maximum gold collected in the last row\n    max_gold_collected = max(max_gold[-1])\n\n    return max_gold_collected\n"}
{"task_id": "MBPP/424", "completion": "\n    rear_index = test_tuple[0].rfind(' ')\n    return test_tuple[0][rear_index + 1:]\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Define the regex pattern to match the date format\n    pattern = r\"(\\d{4})-(\\d{2})-(\\d{2})\"\n\n    # Use the re.sub() function to replace the date format\n    new_dt = re.sub(pattern, r\"\\3-\\2-\\1\", dt)\n\n    return new_dt\n\n"}
{"task_id": "MBPP/428", "completion": "\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list\n\n"}
{"task_id": "MBPP/429", "completion": "\n    return tuple(map(lambda x: x[0] and x[1], zip(test_tup1, test_tup2)))\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the directrix\n    directrix = -1 / (2 * a)\n\n    # Return the directrix\n    return directrix\n\n"}
{"task_id": "MBPP/431", "completion": "\n    for i in list1:\n        if i in list2:\n            return True\n    return False\n"}
{"task_id": "MBPP/432", "completion": "\n    area = (base1 + base2) / 2 * height\n    return area / 2\n\n"}
{"task_id": "MBPP/433", "completion": "\n    for i in arr:\n        if i > number:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r'a(b+)'\n    match = re.search(pattern, text)\n    if match:\n        return match.group(0)\n    else:\n        return None\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if int(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i][0] == test_list[j][1] and test_list[i][1] == test_list[j][0]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a regular expression pattern to match adverbs\n    pattern = r'\\b\\w+ly\\b'\n\n    # Find all adverbs in the text\n    adverbs = re.findall(pattern, text)\n\n    # Find the positions of the adverbs in the text\n    positions = [m.start() for m in re.finditer(pattern, text)]\n\n    # Return a dictionary with adverbs as keys and their positions as values\n    return dict(zip(adverbs, positions))\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    return count / len(nums)\n\n"}
{"task_id": "MBPP/443", "completion": "\n    list1 = [int(i) for i in list1]\n    list1 = [i for i in list1 if i < 0]\n    if len(list1) == 0:\n        return None\n    else:\n        return max(list1)\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(i[:K]) for i in test_list]\n\n"}
{"task_id": "MBPP/445", "completion": "\n    return tuple(map(lambda x, y: x * y, test_tup1, test_tup2))\n\n"}
{"task_id": "MBPP/446", "completion": "\n    count = Counter(tup)\n    for i in lst:\n        print(f\"{i} : {count[i]}\")\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return cal_sum(n-1) + cal_sum(n-2) + cal_sum(n-3)\n"}
{"task_id": "MBPP/449", "completion": "\n    if (x1 == x2 and y1 == y2) or (x1 == x3 and y1 == y3) or (x2 == x3 and y2 == y3):\n        return False\n    else:\n        return True\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    text1 = re.sub(r'\\s+', '', text1)\n    return text1\n\n"}
{"task_id": "MBPP/452", "completion": "\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    pattern = r'\\b\\w*z\\w*\\b'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    min_len = float('inf')\n    min_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) < min_len:\n                min_len = len(sub_lst)\n                min_lst = sub_lst\n    return min_lst\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n\n"}
{"task_id": "MBPP/459", "completion": "\n    pattern = r'[A-Z]+'\n    return re.sub(pattern, '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [item[0] for item in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    ctr = 0\n    for i in str:\n        if i.isupper():\n            ctr += 1\n    return ctr\n"}
{"task_id": "MBPP/462", "completion": "\n    from itertools import combinations\n    result = []\n    for i in range(1, len(list1)+1):\n        result.extend(list(combinations(list1, i)))\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    if len(dict.values()) == 0:\n        return False\n    else:\n        return all(x == list(dict.values())[0] for x in dict.values())\n"}
{"task_id": "MBPP/465", "completion": "\n    return {k: v for k, v in dict1.items() if v}\n"}
{"task_id": "MBPP/466", "completion": "\n    mid = (low + high) // 2\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n            (mid == n - 1 or arr[mid + 1] <= arr[mid])):\n        return mid\n    elif (mid > 0 and arr[mid - 1] > arr[mid]):\n        return find_peak_util(arr, low, mid - 1, n)\n    else:\n        return find_peak_util(arr, mid + 1, high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    octalNum = oct(deciNum)\n    return octalNum[2:]\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize the maximum product to 1\n    max_product = 1\n\n    # Iterate through the array\n    for i in range(n):\n        # Multiply the current number with the maximum product\n        max_product *= arr[i]\n\n    # Return the maximum product\n    return max_product\n\n"}
{"task_id": "MBPP/469", "completion": "\n    if k == 0:\n        return 0\n    if len(price) < 2:\n        return 0\n    if k >= len(price) // 2:\n        return sum(max(price[i + 1] - price[i], 0) for i in range(len(price) - 1))\n    dp = [[0] * (k + 1) for _ in range(len(price))]\n    for i in range(1, len(price)):\n        for j in range(1, k + 1):\n            dp[i][j] = max(dp[i - 1][j], price[i] + dp[i - 1][j - 1] - price[i - 1])\n    return dp[-1][-1]\n"}
{"task_id": "MBPP/470", "completion": "\n    return sum(test_tup)\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result\n    result = 1\n\n    # Iterate over the array\n    for i in range(len(arr)):\n        # Multiply the current element with the result\n        result = (result * arr[i]) % n\n\n    # Return the result\n    return result % n\n\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] != 1:\n            return False\n    return True\n"}
{"task_id": "MBPP/473", "completion": "\n    return tuple(set(test_list1) & set(test_list2))\n\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n\n"}
{"task_id": "MBPP/478", "completion": "\n    pattern = r'[a-z]+'\n    return re.sub(pattern, '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    while n >= 10:\n        n = n // 10\n    return n\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the character with the maximum count\n    max_count = 0\n    max_char = ''\n    for char, count in char_count.items():\n        if count > max_count:\n            max_count = count\n            max_char = char\n    \n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    # Create a 2D array to store the results of subproblems\n    dp = [[False for x in range(sum + 1)] for x in range(n + 1)]\n\n    # Initialize the first column as True\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the rest of the dp array\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # Return the result\n    return dp[n][sum]\n\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/483", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    num = 1\n    while True:\n        if factorial(num) % x == 0:\n            return num\n        num += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    # Create a new list to store the result\n    result = []\n\n    # Iterate over the first list\n    for i in test_list1:\n        # Check if the current element is not in the second list\n        if i not in test_list2:\n            # If it is not, add it to the result list\n            result.append(i)\n\n    # Return the result list\n    return result\n\n"}
{"task_id": "MBPP/485", "completion": "\n    return str(n) == str(n)[::-1]\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    r = min(r, n - r)\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator *= (n - i)\n        denominator *= (i + 1)\n    return numerator // denominator\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # Find the largest value in the array\n    largest_value = max(arr)\n    \n    # Count the frequency of the largest value\n    frequency = arr.count(largest_value)\n    \n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n    mid = 0\n\n    while low <= high:\n        mid = (high + low) // 2\n\n        if item_list[mid] < item:\n            low = mid + 1\n\n        elif item_list[mid] > item:\n            high = mid - 1\n\n        else:\n            return mid\n\n    return -1\n\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the distance between the start and end points\n    distance = math.sqrt((endx - startx) ** 2 + (endy - starty) ** 2)\n\n    # Calculate the number of hexagons needed along the x and y axes\n    num_hexagons_x = int(distance / (2 * radius))\n    num_hexagons_y = int(distance / (2 * radius))\n\n    # Create a list to store the hexagon coordinates\n    hexagon_coordinates = []\n\n    # Calculate the coordinates for each hexagon\n    for i in range(num_hexagons_x):\n        for j in range(num_hexagons_y):\n            hexagon = []\n            for k in range(6):\n                angle = math.radians(60 * k)\n                x = startx + i * 2 * radius * math.cos(angle) + j * 2 * radius * math.cos(angle + math.radians(30))\n                y = starty + i * 2 * radius * math.sin(angle) + j * 2 * radius * math.sin(angle + math.radians(30))\n                hexagon.append((x, y))\n            hexagon_coordinates.append(hexagon)\n\n    return hexagon_coordinates\n\n"}
{"task_id": "MBPP/494", "completion": "\n    return int(''.join(map(str, test_tup)), 2)\n"}
{"task_id": "MBPP/495", "completion": "\n    pattern = r'[a-z]+'\n    return re.sub(pattern, '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(n)]\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Surface area of a cone = \u03c0r(r + sqrt(h^2 + r^2))\n    return math.pi * r * (r + math.sqrt(h**2 + r**2))\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while y:\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    if x < y:\n        x, y = y, x\n    while y != 0:\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n\n"}
{"task_id": "MBPP/503", "completion": "\n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] + nums[i + 1])\n    return result\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    # Initialize a counter to keep track of the number of non-zero elements\n    count = 0\n\n    # Iterate through the array\n    for i in range(len(A)):\n        # If the current element is non-zero, move it to the left side of the array\n        if A[i] != 0:\n            A[count] = A[i]\n            count += 1\n\n    # Fill the remaining elements with zeroes\n    for i in range(count, len(A)):\n        A[i] = 0\n\n    return A\n"}
{"task_id": "MBPP/506", "completion": "\n    if k > n:\n        return 0\n    result = 1\n    for i in range(n, n-k, -1):\n        result *= i\n    return result\n"}
{"task_id": "MBPP/507", "completion": "\n    for word in removewords:\n        while word in list1:\n            list1.remove(word)\n    return list1\n"}
{"task_id": "MBPP/508", "completion": "\n    common = [x for x in l1 if x in l2]\n    return common == common[::-1]\n"}
{"task_id": "MBPP/509", "completion": "\n    if n % 2 == 0:\n        n -= 1\n    sum = 0\n    count = 0\n    for i in range(1, n+1, 2):\n        sum += i\n        count += 1\n    return sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if arr[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j//arr[i-1]]\n    return dp[n][k]\n"}
