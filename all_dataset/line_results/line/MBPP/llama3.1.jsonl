{"task_id": "MBPP/11", "completion": "\n    s = list(s)\n    s.remove(ch)\n    s.remove(ch)\n    return ''.join(s)\n"}
{"task_id": "MBPP/12", "completion": "\n    # First, we calculate the sum of each row in the matrix\n    row_sums = [sum(row) for row in M]\n    \n    # Then, we sort the matrix based on the row sums\n    sorted_M = [row for _, row in sorted(zip(row_sums, M))]\n    \n    return sorted_M\n"}
{"task_id": "MBPP/13", "completion": "\n    # Split the input string into words\n    words = words.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the most common word and its count\n    most_common_word = word_counts.most_common(1)[0]\n    \n    return most_common_word\n\n"}
{"task_id": "MBPP/14", "completion": "\n    # Calculate the volume of the triangular prism\n    volume = (1/2) * l * b * h\n    return volume\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.split(r'[a-z]+', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    # Use regular expression to find all sequences of lowercase letters joined with an underscore\n    pattern = r\"[a-z]+_[a-z]+\"\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return a * 4\n"}
{"task_id": "MBPP/18", "completion": "\n    return [char for char in string if char not in string2]\n\n"}
{"task_id": "MBPP/19", "completion": "\n    return len(arraynums) != len(set(arraynums))\n"}
{"task_id": "MBPP/20", "completion": "\n    # A Woodall number is a number of the form 2^(2^k) - 1 for some integer k.\n    # So, we need to check if the given number can be expressed in this form.\n    # We can do this by checking if the number is one less than a power of 2.\n    # We can use the bitwise AND operator (&) to check if a number is a power of 2.\n    # If a number is a power of 2, then it has only one bit set to 1 in its binary representation.\n    # So, if we do a bitwise AND operation with the number minus 1, the result should be 0.\n    # If the result is not 0, then the number is not a power of 2, and therefore not a Woodall number.\n    if x & (x - 1) == 0:\n        # If the number is a power of 2, then we need to check if it is one less than a power of 2.\n        # We can do this by checking if the number plus 1 is a power of 2.\n        # If the number plus 1 is a power of 2, then the number is one less than a power of 2, and therefore a Woodall number.\n        return (x + 1) & (x + 1 - 1) == 0\n    else:\n        # If the number is not a power of 2, then it is not a Woodall number.\n        return False\n"}
{"task_id": "MBPP/21", "completion": "\n    return [i for i in range(n, m*n+1, n)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n"}
{"task_id": "MBPP/23", "completion": "\n    return max(sum(lst) for lst in list1)\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    power = 0\n    for digit in reversed(binary):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Initialize product as 1\n    product = 1\n\n    # Iterate over the dictionary\n    for num, count in freq.items():\n        # If the count is 1, multiply the product by the number\n        if count == 1:\n            product *= num\n\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    return all(i in test_list for i in K)\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub('\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:  # Taking advantage of symmetry\n        k = n - k\n    C = [0] * (k + 1)\n    C[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    return C[k]\n"}
{"task_id": "MBPP/29", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(arr_size):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the element with odd frequency\n    for key, value in freq.items():\n        if value % 2 != 0:\n            return key\n\n    # If no element has odd frequency, return None\n    return None\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a heap to store the top k integers\n    heap = []\n    for num, count in freq.items():\n        # Push the integer and its frequency into the heap\n        heapq.heappush(heap, (-count, num))\n\n    # Pop the top k integers from the heap\n    top_k = []\n    for _ in range(k):\n        if heap:\n            top_k.append(heapq.heappop(heap)[1])\n\n    return top_k\n\n"}
{"task_id": "MBPP/32", "completion": "\n    # Initialize the largest prime factor\n    max_prime_factor = 1\n\n    # Iterate from 2 to sqrt(n)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # Update the largest prime factor\n            max_prime_factor = i\n            # Divide n by i\n            n = n // i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        # Update the largest prime factor\n        max_prime_factor = n\n\n    return max_prime_factor\n\n"}
{"task_id": "MBPP/33", "completion": "\n    return bin(N).replace(\"0b\", \"\")\n"}
{"task_id": "MBPP/34", "completion": "\n    # Calculate the sum of the first N natural numbers\n    total_sum = N * (N + 1) // 2\n    \n    # Calculate the sum of the numbers in the array\n    array_sum = sum(ar)\n    \n    # The missing number is the difference between the total sum and the array sum\n    missing_num = total_sum - array_sum\n    \n    return missing_num\n"}
{"task_id": "MBPP/35", "completion": "\n    # Initialize the counter and the current number\n    count = 0\n    num = 1\n\n    # Loop until we find the n-th rectangular number\n    while True:\n        # Check if the current number is rectangular\n        if is_rectangular(num):\n            # If it is, increment the counter\n            count += 1\n            # If the counter is equal to n, return the current number\n            if count == n:\n                return num\n        # If the current number is not rectangular, increment it\n        num += 1\n\n"}
{"task_id": "MBPP/36", "completion": "\n    # Convert the fraction to a decimal\n    decimal = p / q\n    \n    # Convert the decimal to a string\n    decimal_str = str(decimal)\n    \n    # Remove the leading 0.\n    decimal_str = decimal_str[2:]\n    \n    # Find the nth digit\n    nth_digit = decimal_str[N-1]\n    \n    return nth_digit\n"}
{"task_id": "MBPP/37", "completion": "\n    # Use the sorted function with a custom key function to sort the list\n    # The key function returns the first element of each item in the list if it's a string, and the item itself if it's an integer\n    return sorted(mixed_list, key=lambda x: (isinstance(x, str), x))\n"}
{"task_id": "MBPP/38", "completion": "\n    even_count = 0\n    odd_count = 0\n    for num in list1:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if even_count > 0 and odd_count > 0:\n        even_num = list1[even_count - 1]\n        odd_num = list1[odd_count - 1]\n        return even_num / odd_num\n    elif even_count > 0:\n        return list1[even_count - 1]\n    elif odd_count > 0:\n        return list1[odd_count - 1]\n    else:\n        return \"List is empty or contains only one number\"\n"}
{"task_id": "MBPP/39", "completion": "\n    # Count the frequency of each character\n    freq = Counter(S)\n    # Create a max heap\n    max_heap = []\n    for char, count in freq.items():\n        # Push the character and its frequency into the max heap\n        heapq.heappush(max_heap, (-count, char))\n    # Initialize the result string\n    result = []\n    while max_heap:\n        # Pop the character with the highest frequency from the max heap\n        count, char = heapq.heappop(max_heap)\n        # Add the character to the result string\n        result.append(char)\n        # If the frequency of the character is greater than 1, push it back into the max heap\n        if -count > 1:\n            heapq.heappush(max_heap, (-count - 1, char))\n    # Check if the length of the result string is equal to the length of the input string\n    return len(result) == len(S)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    flat_list = chain(*nums)\n    return Counter(flat_list)\n\n"}
{"task_id": "MBPP/41", "completion": "\n    return list(filter(lambda x: x % 2 == 0, nums))\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the dictionary and add the product of frequency and value to the sum\n    for key, value in freq.items():\n        total_sum += key * value\n\n    return total_sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = r\"[a-z]+_[a-z]+\"\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = r'^\\w+'\n    match = re.match(pattern, text)\n    if match:\n        return match.group()\n    else:\n        return None\n\n"}
{"task_id": "MBPP/45", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = x[0]\n    for i in range(1, len(x)):\n        result = gcd(result, x[i])\n    return result\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(set(data)) == len(data)\n"}
{"task_id": "MBPP/47", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(A) // factorial(B) % 10\n"}
{"task_id": "MBPP/48", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/49", "completion": "\n    result = []\n    for i in range(N):\n        result.append(nums[i][0])\n    return result\n"}
{"task_id": "MBPP/50", "completion": "\n    return min(input_list, key=len)  # Return the list with minimum length\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if len(str) == 0:\n        return False\n    return str[0] == str[-1]  # -1 is used to get the last character in the string\n"}
{"task_id": "MBPP/54", "completion": "\n    # Create a count array to store the count of individual elements\n    count = [0] * (max(my_list) + 1)\n    \n    # Store the count of each element in the count array\n    for num in my_list:\n        count[num] += 1\n    \n    # Modify the count array such that each element at index i stores the cumulative count of all elements less than or equal to i\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # Create a sorted array to store the sorted elements\n    sorted_list = [0] * len(my_list)\n    \n    # Build the sorted array by placing each element at its correct position\n    for num in my_list:\n        sorted_list[count[num] - 1] = num\n        count[num] -= 1\n    \n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    return a * (r ** (n - 1))\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return n == 2 * rev(n) - 1"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    max_num = 0\n    for i in range(n):\n        max_num = max_num * 10 + arr[i]\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return (x >= 0) != (y >= 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 1) // 2\n"}
{"task_id": "MBPP/60", "completion": "\n    if n == 0:\n        return 0\n\n    max_len = 1\n    curr_len = 1\n    prev = arr[0]\n\n    for i in range(1, n):\n        if abs(arr[i] - prev) == 1:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n        prev = arr[i]\n\n    return max(max_len, curr_len)  # Return the maximum length of the subsequence\n\n"}
{"task_id": "MBPP/61", "completion": "\n    # Initialize a dictionary to store the frequency of each substring sum\n    freq = defaultdict(int)\n    # Initialize the count of substrings with sum equal to their length\n    count = 0\n    # Iterate over all possible substring lengths\n    for length in range(1, n + 1):\n        # Iterate over all possible substrings of the current length\n        for i in range(n - length + 1):\n            # Calculate the sum of the current substring\n            substring_sum = sum(int(digit) for digit in s[i:i + length])\n            # If the sum of the current substring is equal to its length, increment the count\n            if substring_sum == length:\n                count += 1\n            # Increment the frequency of the current substring sum\n            freq[substring_sum] += 1\n    return count\n\n"}
{"task_id": "MBPP/62", "completion": "\n    return min(xs)\n"}
{"task_id": "MBPP/63", "completion": "\n    # Initialize the maximum difference as 0\n    max_diff = 0\n    \n    # Iterate over the list to find the maximum and minimum values\n    for num in test_list:\n        # If the number is greater than the current max, update the max\n        if num > max(test_list):\n            max_diff = num - min(test_list)\n        # If the number is less than the current min, update the min\n        elif num < min(test_list):\n            max_diff = max(max_diff, max(test_list) - num)\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/64", "completion": "\n    return sorted(subjectmarks, key=lambda x: x[1], reverse=True)\n\nsubjectmarks = [('Math', 90), ('Science', 85), ('English', 95), ('History', 80)]"}
{"task_id": "MBPP/65", "completion": "\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    # Recursive case: add the first element to the sum of the rest of the list\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    return sum(1 for num in list if num > 0)\n"}
{"task_id": "MBPP/67", "completion": "\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 5\n    if n == 4:\n        return 15\n    if n == 5:\n        return 52\n    if n == 6:\n        return 203\n    if n == 7:\n        return 877\n    if n == 8:\n        return 4140\n    if n == 9:\n        return 21147\n    if n == 10:\n        return 115975\n    if n == 11:\n        return 678570\n    if n == 12:\n        return 4213597\n    if n == 13:\n        return 27644370\n    if n == 14:\n        return 190899322\n    if n == 15:\n        return 1382958545\n    if n == 16:\n        return 10480142147\n    if n == 17:\n        return 82864869804\n    if n == 18:\n        return 682076806165\n    if n == 19:\n        return 5832742209970\n    if n == 20:\n        return 51591820185350\n    if n == 21:\n        return 476141316924765\n    if n == 22:\n        return 4527537097290680\n    if n == 23:\n        return 44349202777323905\n    if n == 24:\n        return 446368287406921220\n    if n == 25:\n        return 4634839383707300625\n    if n == 26:\n        return 49847507602412119050\n    if n == 27:\n        return 563670239914882955305\n    if n == 28:\n        return 6560118649071113454190\n    if n == 29:\n        return 79462385110912495330405\n    if n == 30:\n        return 1000217219563821774112200\n    if n == 31:\n        return 130495275"}
{"task_id": "MBPP/68", "completion": "\n    n = len(A)\n    increasing = decreasing = True\n    for i in range(n-1):\n        if A[i] > A[i+1]:\n            increasing = False\n        if A[i] < A[i+1]:\n            decreasing = False\n    return increasing or decreasing\n"}
{"task_id": "MBPP/69", "completion": "\n    return s in l\n"}
{"task_id": "MBPP/70", "completion": "\n    # Check if the input is a list\n    if not isinstance(Input, list):\n        raise TypeError(\"Input should be a list of tuples.\")\n    \n    # Check if all elements in the list are tuples\n    if not all(isinstance(i, tuple) for i in Input):\n        raise TypeError(\"All elements in the list should be tuples.\")\n    \n    # Check if all tuples have the same length\n    if len(set(map(len, Input))) != 1:\n        return False\n    \n    # Check if the length of the tuples is equal to k\n    if len(Input[0]) != k:\n        return False\n    \n    return True\n"}
{"task_id": "MBPP/71", "completion": "\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = max(1, int(gap / 1.3))\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": "MBPP/72", "completion": "\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if (n - i**2) >= 0 and (n - i**2) % i == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/73", "completion": "\n    # Define the delimiters\n    delimiters = r'[,\\s\\|\\-\\+]'\n    \n    # Split the text using the delimiters\n    result = re.split(delimiters, text)\n    \n    # Return the result\n    return result\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    for i in range(len(colors)):\n        if colors[i] != patterns[i]:\n            return False\n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    result = []\n    for tup in test_list:\n        if all(i % K == 0 for i in tup):\n            result.append(tup)\n    return result\n"}
{"task_id": "MBPP/76", "completion": "\n    # Initialize count of squares\n    count = 0\n    # Iterate over each row in the rectangle\n    for i in range(m):\n        # Iterate over each column in the rectangle\n        for j in range(n):\n            # Check if the current cell is a square\n            if (i + 1) % 2 == 0 and (j + 1) % 2 == 0:\n                # If it is, increment the count\n                count += 1\n    # Return the count of squares\n    return count\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum - odd_sum\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(n):\n        # Convert integer to binary and count the number of '1' bits\n        count += bin(i).count('1') % 2\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n*(n+1)*(n+2)//6\n"}
{"task_id": "MBPP/81", "completion": "\n    return zip(test_tup1, test_tup2)\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * (r ** 3)\n\n"}
{"task_id": "MBPP/83", "completion": "\n    return ''.join(chr(ord(c) + 1) for c in strr)\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = collections.defaultdict(int)\n    \n    # Iterate over the list to count the frequency of each element\n    for item in list1:\n        freq_dict[item] += 1\n    \n    return freq_dict\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return max(N - 1, 0)\n"}
{"task_id": "MBPP/90", "completion": "\n    return max(len(word) for word in list1)\n"}
{"task_id": "MBPP/91", "completion": "\n    return sub_str in str1\n"}
{"task_id": "MBPP/92", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Initialize a flag to track if the number is undulating\n    is_undulating = False\n    \n    # Iterate over the digits in the number\n    for i in range(len(str_n) - 1):\n        # Check if the current digit is less than the next digit\n        if int(str_n[i]) < int(str_n[i + 1]):\n            # If it is, set the flag to True\n            is_undulating = True\n        # If the current digit is greater than the next digit, break the loop\n        elif int(str_n[i]) > int(str_n[i + 1]):\n            break\n    \n    # Return the flag\n    return is_undulating\n"}
{"task_id": "MBPP/93", "completion": "\n    return a ** b\n"}
{"task_id": "MBPP/94", "completion": "\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    # Return the index of the first element in the sorted list\n    return sorted_list[0][0]\n\n"}
{"task_id": "MBPP/95", "completion": "\n    return min(len(sublist) for sublist in lst)\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    frequency = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency\n"}
{"task_id": "MBPP/98", "completion": "\n    result = 1\n    for num in numbers:\n        result *= num\n    return result / len(numbers) if numbers else 0\n"}
{"task_id": "MBPP/99", "completion": "\n    return bin(n)[2:]\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n\n"}
{"task_id": "MBPP/101", "completion": "\n    arr.sort()\n    return arr[k-1]\n"}
{"task_id": "MBPP/102", "completion": "\n    # Split the string into words\n    words = re.split('(_|-)', word)\n    # Filter out empty strings\n    words = [word for word in words if word]\n    # Capitalize the first letter of each word except the first one\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n    # Join the words together\n    return ''.join(words)\n\n"}
{"task_id": "MBPP/103", "completion": "\n    # Initialize the result\n    result = 0\n    \n    # Calculate the sum of the first n natural numbers\n    for i in range(1, n + 1):\n        # Add the sum of the first i natural numbers to the result\n        result += (i * (i + 1)) // 2\n    \n    # Calculate the sum of the first m natural numbers\n    for i in range(1, m + 1):\n        # Subtract the sum of the first i natural numbers from the result\n        result -= (i * (i + 1)) // 2\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/104", "completion": "\n    return [sorted(sublist, key=lambda x: x.lower()) for sublist in input_list]\n"}
{"task_id": "MBPP/105", "completion": "\n    return lst.count(True)\n"}
{"task_id": "MBPP/106", "completion": "\n    # Convert the tuple to a list\n    test_tup_list = list(test_tup)\n    \n    # Add the given list to the converted list\n    test_tup_list.extend(test_list)\n    \n    # Convert the list back to a tuple\n    test_tup_list = tuple(test_tup_list)\n    \n    return test_tup_list\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if str(i).startswith('0x'):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Create a min heap to store the elements from the three sorted lists\n    min_heap = []\n    # Push the first element from each list into the min heap along with the list index and element index\n    heapq.heappush(min_heap, (num1[0], 0, 0))\n    heapq.heappush(min_heap, (num2[0], 1, 0))\n    heapq.heappush(min_heap, (num3[0], 2, 0))\n\n    # Initialize an empty list to store the merged sorted elements\n    merged_sorted_list = []\n\n    # Continue the process until the min heap is not empty\n    while min_heap:\n        # Pop the smallest element from the min heap\n        element, list_index, element_index = heapq.heappop(min_heap)\n        # Append the popped element to the merged sorted list\n        merged_sorted_list.append(element)\n\n        # If there are more elements in the list from which the element was popped, push the next element into the min heap\n        if element_index + 1 < len(num1) and list_index == 0:\n            heapq.heappush(min_heap, (num1[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num2) and list_index == 1:\n            heapq.heappush(min_heap, (num2[element_index + 1], list_index, element_index + 1))\n        if element_index + 1 < len(num3) and list_index == 2:\n            heapq.heappush(min_heap, (num3[element_index + 1], list_index, element_index + 1))\n\n    # Return the merged sorted list\n    return merged_sorted_list\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if bin(int(s[i:], 2) + int(s[:i], 2)).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    for i in range(strt_val, stop_val + 1):\n        if i not in test_list:\n            missing_ranges.append(str(i) + '-' + str(i))\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    common_elements = set(nestedlist[0])\n    for sublist in nestedlist[1:]:\n        common_elements &= set(sublist)\n    return list(common_elements)\n"}
{"task_id": "MBPP/112", "completion": "\n    radius = diameter / 2\n    circumference = 2 * 3.14 * radius\n    perimeter = circumference + 2 * 3.14 * radius\n    return perimeter\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    freq_dict = Counter(test_list)\n    return freq_dict\n\n"}
{"task_id": "MBPP/115", "completion": "\n    return all(not dict1 for dict1 in list1)\n"}
{"task_id": "MBPP/116", "completion": "\n    # Convert the tuple into a string\n    str_nums = str(nums)\n    \n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the string\n    for char in str_nums:\n        # Convert the character back into an integer and add it to the result\n        result += str(int(char))\n    \n    # Convert the result back into an integer and return it\n    return int(result)\n"}
{"task_id": "MBPP/117", "completion": "\n    return [float(i) if isinstance(i, (int, float)) else i for i in test_list]\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split(' ')\n"}
{"task_id": "MBPP/119", "completion": "\n    for i in range(n):\n        if i == 0 or arr[i] != arr[i - 1]:\n            if i == 0 or arr[i] != arr[i - 1]:\n                print(arr[i])\n                return\n    return -1\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = 0\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            product = list1[i][0] * list1[j][0]\n            if product > max_product:\n                max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    A.sort()\n    for i in range(n-2):\n        left, right = i+1, n-1\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n            elif current_sum < sum:\n                left += 1\n            else:\n                right -= 1\n    return count\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize the count of smart numbers\n    count = 0\n    # Initialize the number to check\n    num = 1\n    # Loop until we find the nth smart number\n    while True:\n        # Check if the number is smart\n        if isSmart(num):\n            # If it is, increment the count\n            count += 1\n            # If this is the nth smart number, return it\n            if count == n:\n                return num\n        # Move on to the next number\n        num += 1\n\n"}
{"task_id": "MBPP/123", "completion": "\nFind the sum of proper divisors of n.\"\"\"\n        divisors_sum = sum(i for i in range(1, n) if n % i == 0)\n        return divisors_sum\n\n    amicable_numbers = []\n    for i in range(1, limit):\n        if find_amicable(i) != i and find_amicable(i) < limit:\n            amicable_numbers.append(i)\n            amicable_numbers.append(find_amicable(i))\n    return sum(set(amicable_numbers))  # Remove duplicates\n\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(complex(a, b))\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    count = 0\n    for i in range(n):\n        if string[i] == '0':\n            count -= 1\n        else:\n            count += 1\n        max_diff = max(max_diff, abs(count))\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    # Initialize a variable to store the sum of common divisors\n    sum_divisors = 0\n    \n    # Iterate over all numbers from 1 to the minimum of a and b\n    for i in range(1, min(a, b) + 1):\n        # Check if i is a divisor of both a and b\n        if a % i == 0 and b % i == 0:\n            # If i is a common divisor, add it to the sum\n            sum_divisors += i\n    \n    # Return the sum of common divisors\n    return sum_divisors\n"}
{"task_id": "MBPP/127", "completion": "\n    result = 0\n    while y > 0:\n        if y % 2 == 1:\n            result += x\n        x = x << 1\n        y = y >> 1\n    return result\n"}
{"task_id": "MBPP/128", "completion": "\n    return [word for word in str.split() if len(word) > n]\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is a square matrix\n    if not my_matrix or not all(len(row) == len(my_matrix) for row in my_matrix):\n        return False\n\n    # Check if the matrix is a magic square\n    n = len(my_matrix)\n    expected_sum = n * (n ** 2 + 1) // 2\n    for i in range(n):\n        if sum(my_matrix[i]) != expected_sum:\n            return False\n        if sum(my_matrix[j][i] for j in range(n)) != expected_sum:\n            return False\n    if sum(my_matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    if sum(my_matrix[i][n - i - 1] for i in range(n)) != expected_sum:\n        return False\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    # Create a dictionary to store the frequency of each item\n    freq_dict = defaultdict(int)\n    \n    # Iterate over the list to count the frequency of each item\n    for num in nums:\n        freq_dict[num] += 1\n    \n    # Find the item with maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n    \n    return max_freq_item\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = 'aeiouAEIOU'\n    str1 = list(str1)\n    left = 0\n    right = len(str1) - 1\n    while left < right:\n        if str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n        else:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return str(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    return sum(num for num in nums if num < 0)\n"}
{"task_id": "MBPP/134", "completion": "\n    for _ in range(p):\n        arr[-1] = arr[-1] % n\n    return arr[-1] % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n"}
{"task_id": "MBPP/136", "completion": "\n    # Define the base rate\n    base_rate = 0.15  # $0.15 per unit\n    # Define the tax rate\n    tax_rate = 0.12  # 12% tax\n    # Calculate the total bill\n    total_bill = (units * base_rate) + (units * base_rate * tax_rate)\n    return total_bill\n"}
{"task_id": "MBPP/137", "completion": "\n    # Create an array of boolean values indicating whether each element is zero\n    is_zero = array('b', [num == 0 for num in nums])\n    \n    # Count the number of zeroes\n    zero_count = is_zero.count(1)\n    \n    # Count the total number of elements\n    total_count = len(nums)\n    \n    # Return the ratio of zeroes\n    return zero_count / total_count if total_count > 0 else 0\n\n"}
{"task_id": "MBPP/138", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if the binary representation contains any '0' other than the first digit\n    return '0' not in binary[1:]  # [1:] to exclude the first digit which is always '1' for positive numbers\n\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for element in test_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    # Create a list to store the elements that occur singly\n    singly_list = []\n    for key, value in freq_dict.items():\n        if value == 1:\n            singly_list.append(key)\n\n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    n = len(nums)\n    for size in range(n, 0, -1):\n        # Find the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:size]))\n        \n        # If the maximum element is not at the beginning of the unsorted part, flip it to the beginning\n        if max_index != 0:\n            # Flip the maximum element to the beginning\n            nums[:max_index + 1] = nums[:max_index + 1][::-1]\n            # Flip the unsorted part of the list\n            nums[:size] = nums[:size][::-1]\n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    # Initialize a counter for the same pair\n    count = 0\n    \n    # Iterate over the first list\n    for i in list1:\n        # Iterate over the second list\n        for j in list2:\n            # Check if the pair (i, j) exists in the third list\n            if (i, j) in list3 or (j, i) in list3:\n                # If the pair exists, increment the counter\n                count += 1\n                \n    # Return the count of the same pair\n    return count\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for item in Input:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    # Initialize sum of absolute differences\n    sum_abs_diff = 0\n    # Iterate over the array\n    for i in range(n):\n        # Iterate over the array starting from the next element\n        for j in range(i + 1, n):\n            # Calculate the absolute difference and add it to the sum\n            sum_abs_diff += abs(arr[i] - arr[j])\n    return sum_abs_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Initialize the maximum difference with the difference between the first and last elements\n    max_diff = arr[n-1] - arr[0]\n    \n    # Iterate over the array to find the maximum difference\n    for i in range(1, n):\n        # Calculate the difference between the current element and the previous element\n        diff = arr[i] - arr[i-1]\n        \n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference\n    return max_diff\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(c) for c in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    for i in range(m - 2, -1, -1):\n        for j in range(n - 1):\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1])\n    return tri[0][0]\n"}
{"task_id": "MBPP/148", "completion": "\n    if x == 0:\n        return 0\n    max_sum = 0\n    for i in range(1, x):\n        left_sum = sum(int(digit) for digit in str(i))\n        right_sum = sum(int(digit) for digit in str(x - i))\n        max_sum = max(max_sum, left_sum + right_sum)\n    return max_sum\n"}
{"task_id": "MBPP/149", "completion": "\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n"}
{"task_id": "MBPP/150", "completion": "\n    n = 1\n    while True:\n        if a * n + b == c:\n            return True\n        elif a * n + b < c:\n            n += 1\n        else:\n            return False\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) <= 1: return x else: mid = len(x) // 2 a = merge_sort(x[:mid]) b = merge_sort(x[mid:]) return merge(a, b) # Test the function print(merge_sort([3, 6, 8, 10, 1, 2, 1]))  # Output: [1, 1, 2, 3, 6, 8, 10] print(merge_sort([5, 2, 8, 1, 9]))  # Output: [1, 2, 5, 8, 9] print(merge_sort([1, 1, 1, 1, 1]))  # Output: [1, 1, 1, 1, 1] print(merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] "}
{"task_id": "MBPP/153", "completion": "\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    return x_vertex, y_vertex\n"}
{"task_id": "MBPP/154", "completion": "\n    specified = []\n    for i in range(len(nums)):\n        for j in range(len(nums[i])):\n            if nums[i][j] == N:\n                specified.append(nums[i][j])\n    return specified\n"}
{"task_id": "MBPP/155", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(k, len(list(g))) for k, g in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Sort the array in ascending order\n    arr.sort()\n    # Initialize the result variable\n    res = 0\n    # Calculate the median of the array\n    median = arr[n // 2] if n % 2 != 0 else (arr[n // 2 - 1] + arr[n // 2]) / 2\n    # Iterate over the array to calculate the number of operations\n    for i in range(n):\n        # Calculate the absolute difference between the current element and the median\n        res += abs(arr[i] - median)\n    # Return the total number of operations\n    return res\n"}
{"task_id": "MBPP/159", "completion": "\n    if month == 12 or month == 1 or month == 2:\n        return \"Winter\"\n    elif month == 3 or month == 4 or month == 5:\n        return \"Spring\"\n    elif month == 6 or month == 7 or month == 8:\n        return \"Summer\"\n    elif month == 9 or month == 10 or month == 11:\n        return \"Autumn\"\n    else:\n        return \"Invalid month\"\n"}
{"task_id": "MBPP/160", "completion": "\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    else:\n        return x * (n // gcd), y * (n // gcd)  # return x and y\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    sum = 0\n    i = n\n    while i >= 0:\n        sum += i\n        i -= 2\n    return sum\n"}
{"task_id": "MBPP/163", "completion": "\n    return (s * s * tan(pi / l)) / (4 * tan(pi / l))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors\n\n"}
{"task_id": "MBPP/165", "completion": "\n    str1 = str1.lower()\n    char_count = {}\n    for i in range(len(str1)):\n        if str1[i] in char_count:\n            char_count[str1[i]] += 1\n        else:\n            char_count[str1[i]] = 1\n    return char_count\n"}
{"task_id": "MBPP/166", "completion": "\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/167", "completion": "\n    if n <= 0:\n        return 1\n    return 2 ** (n - 1).bit_length()\n"}
{"task_id": "MBPP/168", "completion": "\n    return a.count(x)\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])  # Include n in the range\n"}
{"task_id": "MBPP/171", "completion": "\n    # The perimeter of a pentagon is the sum of the lengths of its sides.\n    # Since all sides of a regular pentagon are equal, we can simply multiply the length of one side by 5.\n    return a * 5\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for char in s:\n        if char in 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub('[^A-Za-z0-9]+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for key, value in l:\n        if key in d:\n            d[key].append(value)\n        else:\n            d[key] = [value]\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n"}
{"task_id": "MBPP/177", "completion": "\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] != L[j] and L[i] <= R <= lcm(L[i], L[j]):\n                return [L[i], L[j]]\n    return None\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Initialize the sum of divisors\n    sum_divisors = 0\n    \n    # Loop through all numbers from 1 to x\n    for i in range(1, x):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If it is, add it to the sum\n            sum_divisors += i\n    \n    # If the sum of divisors is equal to the number, it's a keith number\n    return sum_divisors == x\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n\n    # Haversine formula\n    dlon = elon - slon\n    dlat = elat - slat\n    a = sin(dlat / 2) ** 2 + cos(slat) * cos(elat) * sin(dlon / 2) ** 2\n    c = 2 * acos(sqrt(a))\n    # Radius of the Earth in kilometers\n    R = 6371\n    return R * c\n\n"}
{"task_id": "MBPP/181", "completion": "\n    prefix = \"\"\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] == str2[i]:\n            prefix += str1[i]\n        else:\n            break\n    return prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    # Define the pattern for each type of character\n    uppercase_pattern = r'[A-Z]'\n    lowercase_pattern = r'[a-z]'\n    special_pattern = r'[^A-Za-z0-9]'\n    numeric_pattern = r'\\d'\n\n    # Find all matches for each pattern in the string\n    uppercase_matches = re.findall(uppercase_pattern, string)\n    lowercase_matches = re.findall(lowercase_pattern, string)\n    special_matches = re.findall(special_pattern, string)\n    numeric_matches = re.findall(numeric_pattern, string)\n\n    # Return the matches\n    return uppercase_matches, lowercase_matches, special_matches, numeric_matches\n\n"}
{"task_id": "MBPP/183", "completion": "\n    arr.sort()\n    count = 0\n    i = 0\n    j = 1\n    while j < n:\n        if arr[j] - arr[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif arr[j] - arr[i] < k:\n            j += 1\n        else:\n            i += 1\n            if i == j:\n                j += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    return [i for i in list if i > num]\n"}
{"task_id": "MBPP/185", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the focus coordinates\n    focus_x = -focal_length\n    focus_y = 0\n    \n    return (focus_x, focus_y)\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a table to store lengths of longest common subsequence of substrings.\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # Following code is used to print LCS\n    index = L[m][n]\n\n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index + 1)\n    lcs[index] = \"\"\n\n    # Start from the right-most-bottom-most corner and one by one store characters in lcs[]\n    i = m\n    j = n\n    while i > 0 and j > 0:\n\n        # If current character in X[] and Y are same, then current character is part of LCS\n        if X[i - 1] == Y[j - 1]:\n            lcs[index - 1] = X[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n\n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i - 1][j] > L[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    if n < 0:\n        return False\n    elif n == 0 or n == 1:\n        return True\n    else:\n        for i in range(1, int(n**0.5) + 1):\n            if n % (i * i) == 0:\n                return True\n        return False\n"}
{"task_id": "MBPP/189", "completion": "\n    # Create a set to store the positive numbers in the array\n    num_set = set()\n    \n    # Iterate over the array and add the positive numbers to the set\n    for num in arr:\n        if 1 <= num <= n:\n            num_set.add(num)\n    \n    # Initialize the missing number to 1\n    missing_num = 1\n    \n    # Iterate from 1 to n and check if the number is in the set\n    while missing_num <= n:\n        if missing_num not in num_set:\n            return missing_num\n        missing_num += 1\n    \n    # If all numbers from 1 to n are in the set, return n + 1\n    return missing_num\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points in the square\n    count = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return count\n"}
{"task_id": "MBPP/191", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    return month_days[monthname3] == 30\n"}
{"task_id": "MBPP/192", "completion": "\n    if any(char.isalpha() for char in str) and any(char.isdigit() for char in str):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/193", "completion": "\n    return tuple(set(test_tup))\n"}
{"task_id": "MBPP/194", "completion": "\n    return int(str(n), 8)\n"}
{"task_id": "MBPP/195", "completion": "\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            # If the element is found, check if it's the first occurrence\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            # If it's not the first occurrence, move the high pointer to mid - 1\n            high = mid - 1\n        elif arr[mid] < x:\n            # If the element is greater than the middle element, move the low pointer to mid + 1\n            low = mid + 1\n        else:\n            # If the element is less than the middle element, move the high pointer to mid - 1\n            high = mid - 1\n    # If the element is not found, return -1\n    return -1\n"}
{"task_id": "MBPP/196", "completion": "\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]\n"}
{"task_id": "MBPP/197", "completion": "\n    # Initialize the result as 1\n    result = 1\n    # Iterate over the elements of the first tuple\n    for i in test_tup1:\n        # For each element, multiply the result by the corresponding element in the second tuple\n        result *= test_tup2[i]\n    # Return the final result\n    return result\n"}
{"task_id": "MBPP/198", "completion": "\n    # Calculate the semi-major axis of the ellipse\n    a = a / 2\n    # Calculate the semi-minor axis of the ellipse\n    b = b / 2\n    # Calculate the area of the largest triangle\n    area = (math.pi * a * b) / 2\n    return area\n\n"}
{"task_id": "MBPP/199", "completion": "\n    i = 0\n    while (1 << i) <= n:\n        i += 1\n    return 1 << (i - 1)  # return the highest power of 2 less than or equal to n\n"}
{"task_id": "MBPP/200", "completion": "\n    max_val = max(list1)\n    max_indices = [i for i, x in enumerate(list1) if x == max_val]\n    return max_indices\n"}
{"task_id": "MBPP/201", "completion": "\n    return len(set(lst)) == 1\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 != 0])\n"}
{"task_id": "MBPP/203", "completion": "\n    return bin(n1 ^ n2).count('1')\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    # Initialize an empty list to store the inversion elements\n    inversion_list = []\n    \n    # Iterate over the tuple list\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the remaining elements in the tuple\n            for j in range(i + 1, len(tup)):\n                # Check if the current element is greater than the next element\n                if tup[i] > tup[j]:\n                    # If true, append the inversion to the list\n                    inversion_list.append((tup[i], tup[j]))\n    \n    # Return the list of inversion elements\n    return inversion_list\n"}
{"task_id": "MBPP/206", "completion": "\n    result = []\n    for tup in test_tup:\n        new_tup = []\n        for i in range(len(tup)):\n            if i == 0:\n                new_tup.append(tup[i])\n            elif i == len(tup) - 1:\n                new_tup.append(tup[i])\n            else:\n                new_tup.append(tup[i] + tup[i - 1] + tup[i + 1])\n        result.append(new_tup)\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for gap in range(1, n):\n        for i in range(n - gap):\n            j = i + gap\n            if str[i] == str[j] and i != j:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            elif str[i] == str[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = r'^-?\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heappop(heap)\n    hq.heappush(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if (i & (1 << n)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    # Initialize sum variable to 0\n    sum = 0\n    # Loop through all natural numbers from 1 to n\n    for i in range(1, n + 1):\n        # Add the fourth power of the current number to the sum\n        sum += i ** 4\n    # Return the sum\n    return sum\n\n"}
{"task_id": "MBPP/213", "completion": "\n    return test_tup1 + test_tup2\n"}
{"task_id": "MBPP/214", "completion": "\n    # Use the math library to convert radians to degrees\n    return math.degrees(radian)\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    i = 0\n    while i < len(alist):\n        count = alist[i]\n        char = alist[i + 1]\n        decoded_list.extend([char] * count)\n        i += 2\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    # Check if both lists are lists\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    # Check if all elements in list1 are in list2\n    for element in list1:\n        if not isinstance(element, list):\n            if element not in list2:\n                return False\n        else:\n            if not check_subset_list(element, list2):\n                return False\n\n    return True\n"}
{"task_id": "MBPP/217", "completion": "\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str:\n        if char_count[char] > 1:\n            return char\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # Calculate the absolute difference between the two numbers\n    diff = abs(A - B)\n    \n    # If the difference is 0, no operations are required\n    if diff == 0:\n        return 0\n    \n    # If the difference is 1, one operation is required\n    elif diff == 1:\n        return 1\n    \n    # If the difference is greater than 1, the minimum number of operations is the difference minus 1\n    else:\n        return diff - 1\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Convert the tuple into a list\n    test_list = list(test_tup)\n    \n    # Sort the list in ascending order\n    test_list.sort()\n    \n    # Extract the minimum k elements\n    min_k = test_list[:K]\n    \n    # Extract the maximum k elements\n    max_k = test_list[-K:]\n    \n    # Return the minimum and maximum k elements\n    return min_k, max_k\n"}
{"task_id": "MBPP/220", "completion": "\n    # Find all occurrences of spaces, commas, or dots\n    pattern = r'[ ,.]'\n    matches = re.findall(pattern, text)\n    \n    # If there are less than n matches, replace all matches\n    if len(matches) <= n:\n        return re.sub(pattern, ':', text)\n    \n    # Otherwise, replace n matches\n    else:\n        return re.sub(pattern, ':', text, count=n)\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    # Get the type of the first element in the tuple\n    type_ = type(test_tuple[0])\n    \n    # Iterate over the tuple to check the type of each element\n    for element in test_tuple:\n        # If the type of any element is different from the first element's type, return False\n        if type(element) != type_:\n            return False\n    \n    # If the function hasn't returned False, it means all elements have the same type, so return True\n    return True\n"}
{"task_id": "MBPP/223", "completion": "\n    # Initialize count to 0\n    count = 0\n    # Traverse the array\n    for i in range(n):\n        # If the current element is equal to x, increment the count\n        if arr[i] == x:\n            count += 1\n        # If the current element is not equal to x, decrement the count\n        else:\n            count -= 1\n        # If the count becomes zero, it means we have found the majority element\n        if count == 0:\n            # Reset the count to 1\n            count = 1\n        # If the count becomes greater than n/2, it means x is the majority element\n        if count > n // 2:\n            return True\n    # If we have traversed the entire array and haven't found the majority element, return False\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    if low == high:\n        return arr[low]\n    if high < low:\n        return arr[low]\n    mid = (low + high) // 2\n    if arr[mid] > arr[high]:\n        return find_Min(arr, mid + 1, high)\n    elif arr[mid] < arr[low]:\n        return find_Min(arr, low, mid - 1)\n    else:\n        return arr[mid]\n"}
{"task_id": "MBPP/226", "completion": "\n    return ''.join([char for i, char in enumerate(str) if i % 2 == 0])\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Pad the binary string with leading zeros to make it of length r-l+1\n    binary = binary.zfill(r-l+1)\n    \n    # Check if all the bits in the given range are unset\n    return all(bit == '0' for bit in binary[l-1:r])\n"}
{"task_id": "MBPP/229", "completion": "\n    # Initialize two lists, one for negative numbers and one for positive numbers\n    negative = []\n    positive = []\n\n    # Iterate over the array\n    for num in arr:\n        # If the number is negative, add it to the negative list\n        if num < 0:\n            negative.append(num)\n        # If the number is positive, add it to the positive list\n        else:\n            positive.append(num)\n\n    # Combine the two lists to get the final result\n    return negative + positive\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(\" \", char)\n"}
{"task_id": "MBPP/231", "completion": "\n    # Initialize the maximum sum as negative infinity\n    max_sum = float('-inf')\n    \n    # Iterate over each row in the triangle\n    for i in range(n):\n        # Iterate over each element in the current row\n        for j in range(i + 1):\n            # Update the maximum sum if the current element is greater\n            max_sum = max(max_sum, tri[i][j])\n    \n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * math.pi * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for char in binary:\n        # If the character is '0', append '1' to the result\n        if char == '0':\n            result += '1'\n        # If the character is '1', append '0' to the result\n        else:\n            result += '0'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/236", "completion": "\n    # Calculate the number of triangles that can be formed\n    return (N * (N - 1) * (N - 2)) // 6\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a dictionary to store the count of each record\n    record_count = Counter(test_list)\n    \n    # Find the maximum count\n    max_count = max(record_count.values())\n    \n    # Find the records with the maximum count\n    max_count_records = [record for record, count in record_count.items() if count == max_count]\n    \n    return max_count_records\n\n"}
{"task_id": "MBPP/238", "completion": "\n    count = 0\n    for i in range(len(str)):\n        for j in range(i + 1, len(str) + 1):\n            count += 1\n    return count - 1  # subtract 1 because we counted the empty string\n\n"}
{"task_id": "MBPP/239", "completion": "\n    # Create a list to store the number of sequences of length i\n    dp = [0] * (n + 1)\n    # There is only one way to have a sequence of length 0\n    dp[0] = 1\n    # Iterate over the length of the sequence\n    for i in range(1, n + 1):\n        # Iterate over the possible last element of the sequence\n        for j in range(1, m + 1):\n            # If the last element is greater than or equal to twice of the previous element\n            if j >= 2 * (i - 1):\n                # Add the number of sequences of length i - 1 to the number of sequences of length i\n                dp[i] += dp[i - 1]\n    # Return the number of sequences of length n\n    return dp[n] - 1  # subtract 1 because we counted the empty sequence\n\n"}
{"task_id": "MBPP/240", "completion": "\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1] = list2\n        return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    # Create a 3D array with m rows, n columns and o depth\n    array_3d = [[[ '*' for _ in range(o)] for _ in range(n)] for _ in range(m)]\n    return array_3d\n"}
{"task_id": "MBPP/242", "completion": "\n    return len(str1)\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: lst.count(x[0]))\n"}
{"task_id": "MBPP/244", "completion": "\n    # Calculate the square root of the number\n    sqrt_N = math.sqrt(N)\n    \n    # Calculate the next integer greater than the square root\n    next_int = math.ceil(sqrt_N)\n    \n    # Calculate the next perfect square\n    next_perfect_square = next_int ** 2\n    \n    return next_perfect_square\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Initialize variables to store the maximum sum of increasing and decreasing sub-sequences\n    max_increasing = [0] * n\n    max_decreasing = [0] * n\n\n    # Initialize the maximum sum of increasing sub-sequence for the first element\n    max_increasing[0] = arr[0]\n\n    # Initialize the maximum sum of decreasing sub-sequence for the first element\n    max_decreasing[0] = arr[0]\n\n    # Iterate over the array from the second element to the last element\n    for i in range(1, n):\n        # Update the maximum sum of increasing sub-sequence for the current element\n        max_increasing[i] = max(max_increasing[i-1], max_decreasing[i-1] + arr[i])\n\n        # Update the maximum sum of decreasing sub-sequence for the current element\n        max_decreasing[i] = max(max_decreasing[i-1], max_increasing[i-1] - arr[i])\n\n    # Return the maximum sum of bi-tonic sub-sequence\n    return max(max_increasing[n-1], max_decreasing[n-1])  # Changed to max_increasing[n-1] and max_decreasing[n-1] to fix the bug\n\n"}
{"task_id": "MBPP/246", "completion": "\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    if number == 0 or number == 1:\n        return number\n\n    guess = number\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.000001:\n            return better_guess\n        guess = better_guess\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]  # Return the length of the longest palindromic subsequence\n\n"}
{"task_id": "MBPP/248", "completion": "\n    return sum(1.0 / i for i in range(1, n))\n"}
{"task_id": "MBPP/249", "completion": "\n    return list(filter(lambda x: x in array_nums2, array_nums1))\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [element] + list + [element]\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = []\n    for number in numbers:\n        r = cmath.polar(number)[0]\n        theta = cmath.polar(number)[1]\n        polar_coordinates.append((r, theta))\n    return polar_coordinates\n\n\nnumbers = [1 + 2j, 3 + 4j, 5 + 6j]"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    words = re.findall(r'\\b[aAeE]\\w*\\b', text)\n    return words\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'green', 'blue']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    return sum(1 for num in array_nums if num % 2 != 0)\n"}
{"task_id": "MBPP/259", "completion": "\n    # Convert the tuples to lists\n    list1 = list(test_tup1)\n    list2 = list(test_tup2)\n    \n    # Find the maximum element in each list\n    max1 = max(list1)\n    max2 = max(list2)\n    \n    # Return the maximum of the two maximum elements\n    return max(max1, max2)\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    num = 2\n    while True:\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(\"Error: Division by zero is not allowed.\")\n    return result\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    # A dog's first year is equal to 15 human years.\n    # After that, each additional year is equal to 1 human year.\n    if h_age <= 0:\n        return \"Invalid input. Please enter a positive integer.\"\n    elif h_age == 1:\n        return 15\n    else:\n        return 15 + (h_age - 1)\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i:i + step] for i in range(0, len(S), step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l**2\n"}
{"task_id": "MBPP/267", "completion": "\n    # Initialize sum as 0\n    sum = 0\n    # Loop through odd numbers from 1 to n\n    for i in range(1, n+1):\n        # Check if the number is odd\n        if i % 2 != 0:\n            # Add the square of the odd number to the sum\n            sum += i ** 2\n    # Return the sum\n    return sum\n"}
{"task_id": "MBPP/268", "completion": "\n    # Initialize the first star number\n    star_num = 1\n    # Initialize the current number\n    num = 1\n    # Initialize the count of star numbers\n    count = 0\n    # Loop until we find the n'th star number\n    while count < n:\n        # Check if the current number is a star number\n        if is_star(num):\n            # If it is, increment the count and update the star number\n            count += 1\n            star_num = num\n        # Move to the next number\n        num += 1\n    # Return the n'th star number\n    return star_num\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    even_sum = 0\n    for i in range(n):\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n"}
{"task_id": "MBPP/271", "completion": "\n    # Initialize sum variable\n    sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(2, n*2, 2):\n        # Add the fifth power of the current number to the sum\n        sum += i**5\n    # Return the sum\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    return [record[-1] for record in test_list]\n"}
{"task_id": "MBPP/273", "completion": "\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize sum\n    even_sum = 0\n    # Loop through all binomial coefficients\n    for k in range(n + 1):\n        # Check if k is even\n        if k % 2 == 0:\n            # Add binomial coefficient to sum\n            even_sum += math.comb(n, k)\n    return even_sum\n\n"}
{"task_id": "MBPP/275", "completion": "\n    # Calculate the position of the last removed element\n    position = (a + n) % m\n    return position\n\n"}
{"task_id": "MBPP/276", "completion": "\n    return 3.14 * r**2 * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {key: value for key, value in dict.items() if value >= n}\n"}
{"task_id": "MBPP/278", "completion": "\n    return test_tup.count(test_tup[0])\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * (10 * n - 9) // 2\n"}
{"task_id": "MBPP/280", "completion": "\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return i\n    return -1\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    return list(map(lambda x, y: x - y, nums1, nums2))\n"}
{"task_id": "MBPP/283", "completion": "\n    # Convert the number to a string to easily access each digit\n    str_n = str(n)\n    \n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n    \n    # Iterate over each digit in the string\n    for digit in str_n:\n        # If the digit is already in the dictionary, increment its count\n        if digit in freq:\n            freq[digit] += 1\n        # If the digit is not in the dictionary, add it with a count of 1\n        else:\n            freq[digit] = 1\n    \n    # Iterate over each digit and its frequency in the dictionary\n    for digit, count in freq.items():\n        # If the frequency of the digit is greater than the digit itself, return False\n        if count > int(digit):\n            return False\n    \n    # If the function has not returned False, return True\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = r\"a{1}b{2,3}\"\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/286", "completion": "\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        # If the current sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    # Repeat the array k times and find the maximum sum\n    for _ in range(k - 1):\n        # Initialize the current sum\n        current_sum = 0\n\n        # Iterate over the array\n        for i in range(n):\n            # Add the current element to the current sum\n            current_sum += a[i]\n\n            # If the current sum is greater than the maximum sum, update the maximum sum\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n            # If the current sum is negative, reset it to 0\n            if current_sum < 0:\n                current_sum = 0\n\n    # Return the maximum sum\n    return max_sum\n"}
{"task_id": "MBPP/287", "completion": "\n    # Initialize sum variable to 0\n    sum = 0\n    # Loop through even numbers from 2 to 2n\n    for i in range(2, 2*n+1, 2):\n        # Add square of current even number to sum\n        sum += i**2\n    return sum\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for num in arr:\n        if pow(num, P - 1, P) == 1:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate the number of odd days in a year\n    odd_days = (N + 1) // 2\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    return max(list1, key=len) if list1 else None\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 1\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # Initialize a list to store the number of ways for each post\n    ways = [0] * (n + 1)\n    ways[1] = k\n    ways[2] = k * k\n\n    # For each post from the 3rd post to the nth post\n    for i in range(3, n + 1):\n        # The number of ways to paint the ith post is the sum of the number of ways to paint the (i-1)th post and the (i-2)th post\n        # because we can paint the ith post with the same color as the (i-1)th post or the (i-2)th post\n        ways[i] = ways[i - 1] + ways[i - 2] * (k - 1)\n\n    return ways[n]  # Return the number of ways to paint the nth post\n\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    return max(listval)\n"}
{"task_id": "MBPP/295", "completion": "\n    sum_div = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum_div += i\n    return sum_div\n"}
{"task_id": "MBPP/296", "completion": "\n    # Initialize the inversion count\n    inv_count = 0\n\n    # Iterate over the array\n    for i in range(n):\n        # Iterate over the remaining elements\n        for j in range(i + 1, n):\n            # If the current element is greater than the next element, it's an inversion\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count\n\n"}
{"task_id": "MBPP/297", "completion": "\n    flat_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n"}
{"task_id": "MBPP/298", "completion": "\n    return [item for sublist in l1 for item in sublist] & [item for sublist in l2 for item in sublist]\n"}
{"task_id": "MBPP/299", "completion": "\n    # Create a dictionary to store the maximum aggregate for each number\n    max_dict = defaultdict(int)\n    \n    # Iterate over the list of tuples\n    for num, aggregate in stdata:\n        # Update the maximum aggregate for the current number\n        max_dict[num] = max(max_dict[num], aggregate)\n    \n    # Return the maximum aggregate\n    return max(max_dict.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    # Initialize a 2D array to store the counts of binary sequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: there is one way to have a sum of 0 for a sequence of length 0\n    dp[0][0] = 1\n    \n    # Fill up the dp array\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            # If the current bit is 0, the count is the same as the count without this bit\n            dp[i][j] += dp[i - 1][j]\n            # If the current bit is 1, the count is the same as the count without this bit and with a sum of 1\n            dp[i][j] += dp[i - 1][j - 1]\n    \n    # The total count is the sum of counts for all possible sums\n    return sum(dp[n]) // 2  # Divide by 2 to avoid counting the same sequence twice\n\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict):\n        return 0\n    return 1 + max(dict_depth(v) for v in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize the most significant bit number\n    msb = 0\n    \n    # Iterate over the binary string from right to left\n    for i in range(len(binary) - 1, -1, -1):\n        # If the current bit is 1, update the most significant bit number\n        if binary[i] == '1':\n            msb = len(binary) - i - 1\n            break\n    \n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                inversions += 1\n    return inversions\n\n"}
{"task_id": "MBPP/304", "completion": "\n    # Calculate the effective index after rotations\n    effective_index = (index + rotations) % len(arr)\n    \n    # Check if the effective index is within the given range\n    if effective_index >= ranges[0] and effective_index <= ranges[1]:\n        return arr[effective_index]\n    else:\n        return None\n"}
{"task_id": "MBPP/305", "completion": "\n    # Use regular expression to find words starting with 'p'\n    pattern = re.compile(r'^p')\n    # Use list comprehension to filter the words\n    p_words = [word for word in words if pattern.match(word)]\n    # Return the first two words\n    return p_words[:2]\n\n"}
{"task_id": "MBPP/306", "completion": "\n    # Initialize a 2D table to store the maximum sum of increasing subsequence\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table in a bottom-up manner\n    for i in range(n):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = a[i]\n            elif j == 1:\n                dp[i][j] = max(a[i], dp[i - 1][j])\n            else:\n                dp[i][j] = max(dp[i - 1][j], a[i] + dp[i - 1][j - 1])\n    \n    # Initialize the maximum sum\n    max_sum = 0\n    \n    # Iterate over the table to find the maximum sum\n    for i in range(index, n):\n        for j in range(1, k + 1):\n            max_sum = max(max_sum, dp[i][j])\n    \n    return max_sum\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Combine the two lists into a list of pairs\n    pairs = list(zip(nums1, nums2))\n    \n    # Sort the pairs in descending order based on the product of the numbers\n    pairs.sort(key=lambda x: x[0]*x[1], reverse=True)\n    \n    # Return the specified number of largest products\n    return [pair[0]*pair[1] for pair in pairs[:N]]\n\n"}
{"task_id": "MBPP/309", "completion": "\n    return max(a, b)\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n\n"}
{"task_id": "MBPP/311", "completion": "\n    # Create a mask with all bits set to the left of the left most unset bit\n    mask = n & -n\n    # Set the left most unset bit\n    return n | mask\n"}
{"task_id": "MBPP/312", "completion": "\n    # Calculate the volume of the cone using the formula (1/3)\u03c0r\u00b2h\n    volume = (1/3) * math.pi * r**2 * h\n    return volume\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return grid[0][0]\n    if n == 2:\n        return max(grid[0][0] + grid[0][1], grid[1][0] + grid[1][1])\n\n    # Initialize the dp array\n    dp = [[0 for _ in range(n)] for _ in range(2)]\n\n    # Fill the dp array\n    dp[0][0] = grid[0][0]\n    dp[0][1] = grid[0][0] + grid[0][1]\n    dp[1][0] = grid[1][0]\n    dp[1][1] = grid[1][0] + grid[1][1]\n\n    for i in range(2, n):\n        dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + grid[0][i]\n        dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + grid[1][i]\n\n    # Return the maximum sum\n    return max(dp[0][n-1], dp[1][n-1])  # Changed to n-1 from n-2\n\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_len_word = \"\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_len_word = word\n    return max_len_word\n"}
{"task_id": "MBPP/316", "completion": "\n    left, right = 0, len(A) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if A[mid] == x:\n            if mid == len(A) - 1 or A[mid + 1] != x:\n                return mid\n            left = mid + 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"}
{"task_id": "MBPP/317", "completion": "\n    result = []\n    for key, group in groupby(alist):\n        count = len(list(group))\n        result.append((key, count))\n    return result\n\n"}
{"task_id": "MBPP/318", "completion": "\n    # Initialize the maximum volume\n    max_volume = 0\n    \n    # Iterate over all possible combinations of sides\n    for a in range(1, s):\n        for b in range(a, s):\n            c = s - a - b\n            # Check if the current combination is valid (i.e., a <= b <= c)\n            if a <= b <= c:\n                # Calculate the volume of the cuboid\n                volume = a * b * c\n                # Update the maximum volume if the current volume is larger\n                max_volume = max(max_volume, volume)\n    \n    return max_volume\n"}
{"task_id": "MBPP/319", "completion": "\n    # Use regex to find all five characters long word in the given string\n    long_word = re.findall(r'\\b\\w{5}\\b', text)\n    return long_word\n\n"}
{"task_id": "MBPP/320", "completion": "\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    square_of_sum = n * (n + 1) // 2\n    return square_of_sum ** 2 - sum_of_squares\n"}
{"task_id": "MBPP/321", "completion": "\n    # Initialize the demlo number to 0\n    demlo = 0\n    # Loop through each digit in the number\n    for i in range(len(s)):\n        # Add the digit to the demlo number\n        demlo += int(s[i])\n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_val = min(list1)\n    return [i for i, x in enumerate(list1) if x == min_val]\n"}
{"task_id": "MBPP/323", "completion": "\n    if n == 0:\n        return arr\n\n    if out_of_place:\n        # Create a new array with the first element of the original array\n        new_arr = [arr[0]]\n        # Add the first element of the original array to the new array\n        new_arr.append(arr[1])\n        # Add the rest of the array to the new array\n        new_arr.extend(arr[2:])\n        # Return the new array\n        return new_arr\n\n    # If the current element is positive, add it to the new array\n    if cur >= 0:\n        new_arr.append(cur)\n    # If the current element is negative, add it to the new array\n    else:\n        new_arr.append(cur)\n    # Recursively call the function with the rest of the array\n    return right_rotate(arr[1:], n - 1, out_of_place, arr[0])\n"}
{"task_id": "MBPP/324", "completion": "\n    return sum(sum(x) for x in zip(*[test_tuple[i::2] for i in range(len(test_tuple))]))\n\n"}
{"task_id": "MBPP/325", "completion": "\n    # Create a list to store the minimum number of squares for each number from 0 to n\n    min_squares = [float('inf')] * (n + 1)\n    min_squares[0] = 0\n\n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over each square less than or equal to the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            # If the current number is greater than or equal to the square\n            if i >= j ** 2:\n                # Update the minimum number of squares for the current number\n                min_squares[i] = min(min_squares[i], min_squares[i - j ** 2] + 1)\n\n    # Return the minimum number of squares for the given number\n    return min_squares[n] if min_squares[n] != float('inf') else -1\n\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for string in test_list:\n        words = string.split()\n        for word in words:\n            word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or x == z:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/328", "completion": "\n    return list1[-n:] + list1[:-n]\n"}
{"task_id": "MBPP/329", "completion": "\n    return sum(1 for num in list if num < 0)\n"}
{"task_id": "MBPP/330", "completion": "\n    # Use regex to find all words with 3, 4, or 5 characters\n    pattern = r'\\b\\w{3,5}\\b'\n    words = re.findall(pattern, text)\n    return words\n\n"}
{"task_id": "MBPP/331", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize a counter for unset bits\n    unset_bits = 0\n    \n    # Iterate over each bit in the binary representation\n    for bit in binary:\n        # If the bit is '0', increment the counter\n        if bit == '0':\n            unset_bits += 1\n    \n    # Return the count of unset bits\n    return unset_bits\n"}
{"task_id": "MBPP/332", "completion": "\n    frequency = {}\n    for char in str1:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n"}
{"task_id": "MBPP/333", "completion": "\n    # use built-in sorted function with a custom key\n    return sorted(sub_li, key=lambda x: x[1])\n"}
{"task_id": "MBPP/334", "completion": "\n    # Check if the sum of any two sides is greater than the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return (n/2) * (a + (a + (n-1)*d))\n"}
{"task_id": "MBPP/336", "completion": "\n    month_days = {\n        \"January\": 31,\n        \"February\": 28,\n        \"March\": 31,\n        \"April\": 30,\n        \"May\": 31,\n        \"June\": 30,\n        \"July\": 31,\n        \"August\": 31,\n        \"September\": 30,\n        \"October\": 31,\n        \"November\": 30,\n        \"December\": 31\n    }\n    return month_days[monthname1] == 28\n"}
{"task_id": "MBPP/337", "completion": "\n    # Define a regular expression pattern that matches a word followed by optional punctuation\n    pattern = r'\\b\\w+\\b[^\\w\\s]*$'\n    \n    # Use the re.search function to search for the pattern in the text\n    match = re.search(pattern, text)\n    \n    # If a match is found, return the matched text\n    if match:\n        return match.group()\n    # If no match is found, return None\n    else:\n        return None\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    # Initialize an empty dictionary to store the frequency of each divisor\n    freq = {}\n    \n    # Iterate over all numbers from 1 to y (inclusive)\n    for i in range(1, y + 1):\n        # Check if i is a divisor of x\n        if x % i == 0:\n            # If i is a divisor, increment its frequency in the dictionary\n            freq[i] = freq.get(i, 0) + 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq.values(), default=0)\n    \n    # Find all divisors with the maximum frequency\n    max_divisors = [i for i in freq if freq[i] == max_freq]\n    \n    # Return the maximum divisor\n    return max(max_divisors)\n"}
{"task_id": "MBPP/340", "completion": "\n    # First, we filter out non-positive numbers from the list\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Then, we sort the list of positive numbers in ascending order\n    positive_nums.sort()\n    \n    # Finally, we return the sum of the three smallest positive numbers\n    return sum(positive_nums[:3])  # We use list slicing to get the first three elements of the sorted list\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    min_heap = []\n    max_heap = []\n    min_range = float('inf')\n    max_range = float('-inf')\n    for i, lst in enumerate(list):\n        heappush(min_heap, Node(lst[0], i, 0))\n        heappush(max_heap, Node(-lst[0], i, 0))\n        max_range = max(max_range, -lst[0])\n\n    while min_heap:\n        node = heappop(min_heap)\n        if node.index + 1 == len(list[node.list_num]):\n            return [node.value, max_range]\n        next_node = Node(list[node.list_num][node.index + 1], node.list_num, node.index + 1)\n        heappush(min_heap, next_node)\n        heappush(max_heap, Node(-list[node.list_num][node.index + 1], node.list_num, node.index + 1))\n        max_range = max(max_range, -list[node.list_num][node.index + 1])\n\n    return []\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = sum(c.isdigit() for c in s)\n    letters = sum(c.isalpha() for c in s)\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        for j in range(1, i+1):\n            if i % j == 0 and j % 2 != 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    if len(nums) < 2:\n        return None\n    return [nums[i] - nums[i-1] for i in range(1, len(nums))]\n"}
{"task_id": "MBPP/346", "completion": "\n    # Initialize the first row of the matrix\n    matrix = [[1 for _ in range(n)] for _ in range(k)]\n    \n    # Fill in the rest of the matrix\n    for i in range(1, k):\n        for j in range(1, n):\n            # The value at each position is the sum of the two values directly above it\n            matrix[i][j] = matrix[i-1][j-1] + matrix[i-1][j]\n    \n    # The entringer number is the value at the bottom right of the matrix\n    return matrix[-1][-1]\n"}
{"task_id": "MBPP/347", "completion": "\n    # Initialize count of squares\n    count = 0\n    # Iterate over each row in the rectangle\n    for i in range(m):\n        # Iterate over each column in the rectangle\n        for j in range(n):\n            # Check if the current cell is a square\n            if (i + 1) % 2 == 0 and (j + 1) % 2 == 0:\n                # If it is, increment the count\n                count += 1\n    # Return the count of squares\n    return count\n"}
{"task_id": "MBPP/348", "completion": "\n    # Create a list to store the count of sequences of each length\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    # Iterate over each value\n    for i in range(1, r + 1):\n        # Iterate over each length from the value to n\n        for j in range(i, n + 1):\n            # Update the count of sequences of the current length\n            dp[j] += dp[j - i]\n\n    # Return the count of sequences of length n\n    return dp[n] - 1  # subtract 1 to exclude the sequence with all zeros\n\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) <= {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    # Initialize a dictionary to store the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Initialize a variable to store the minimum length\n    min_len = len(s)\n\n    # Iterate over each character and its frequency\n    for char, count in freq.items():\n        # If the frequency is more than 1, update the minimum length\n        if count > 1:\n            min_len = min(min_len, len(s) - count + 1)\n\n    return min_len\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n\n    # Find the first element occurring k times\n    for key, value in freq.items():\n        if value == k:\n            return key\n    return -1  # Return -1 if no such element is found\n"}
{"task_id": "MBPP/352", "completion": "\n    return len(set(str)) == len(str)\n"}
{"task_id": "MBPP/353", "completion": "\n    return [item[:n] + item[n+1:] for item in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    return a + (n - 1) * d\n"}
{"task_id": "MBPP/355", "completion": "\n    # The number of rectangles is equal to the number of squares that can fit in the circle.\n    # The number of squares that can fit in the circle is equal to the square of the number of squares that can fit in the diameter of the circle.\n    # The number of squares that can fit in the diameter of the circle is equal to the diameter divided by the side length of the square.\n    # The side length of the square is equal to the diameter of the circle divided by the square root of 2.\n    # So, the number of rectangles is equal to the square of the diameter divided by the square root of 2.\n    return int((2 * radius) / (radius * (2 ** 0.5)) ** 2)\n"}
{"task_id": "MBPP/356", "completion": "\n    # Calculate the third angle using the fact that the sum of angles in a triangle is 180 degrees\n    angle_c = 180 - a - b\n    return angle_c\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = float('-inf')\n    for record in test_list:\n        for value in record:\n            if value > max_val:\n                max_val = value\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    return list(map(lambda x, y: x % y, nums1, nums2))\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # Check if the discriminant is negative\n    if d < 0:\n        return False\n    \n    # Calculate the two roots\n    root1 = (-b + d**0.5) / (2*a)\n    root2 = (-b - d**0.5) / (2*a)\n    \n    # Check if one root is twice of the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    carol = 1\n    for i in range(1, n + 1):\n        carol = carol * i\n    return carol\n"}
{"task_id": "MBPP/361", "completion": "\n    return [i for i in list1 if i != []]\n"}
{"task_id": "MBPP/362", "completion": "\n    # Create a dictionary to store the count of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the item with maximum count\n    max_count = max(count_dict.values())\n    max_items = [item for item, count in count_dict.items() if count == max_count]\n\n    return max_items\n"}
{"task_id": "MBPP/363", "completion": "\n    return tuple(x + K for x in test_list)\n"}
{"task_id": "MBPP/364", "completion": "\n    flips = 0\n    for i in range(1, len(ch)):\n        if ch[i] != ch[i - 1]:\n            flips += 1\n    return flips\n"}
{"task_id": "MBPP/365", "completion": "\n    return len(str(abs(n)))\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        product = list_nums[i] * list_nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) > 1:\n        return False\n\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\n"}
{"task_id": "MBPP/368", "completion": "\n    return (test_tup,) * N\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/370", "completion": "\n    return sorted(price, key=lambda x: float(x))\n"}
{"task_id": "MBPP/371", "completion": "\n    # Initialize the smallest missing element as the left element plus one\n    smallest_missing = left_element + 1\n    \n    # Iterate over the array from the left element to the right element\n    for i in range(left_element, right_element + 1):\n        # If the current element is not equal to the smallest missing element\n        if A[i] != smallest_missing:\n            # Return the smallest missing element\n            return smallest_missing\n        # If the current element is equal to the smallest missing element, increment the smallest missing element by one\n        else:\n            smallest_missing += 1\n    \n    # If the loop completes without finding a missing element, return the smallest missing element\n    return smallest_missing\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return nums\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 1:\n        return [str]\n    result = []\n    for i in range(len(str)):\n        char = str[i]\n        rest = str[:i] + str[i+1:]\n        for p in permute_string(rest):\n            result.append(char + p)\n    return result\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for element in test_tup:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n\n    # Create a new tuple with custom value for duplicates\n    new_tup = ()\n    for element in test_tup:\n        if count_dict[element] == 1:\n            new_tup += (element,)\n        else:\n            new_tup += ('Custom Value',)\n\n    return new_tup\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')  # replace() function is used to replace the character with an empty string\n\n"}
{"task_id": "MBPP/378", "completion": "\n    if len(test_list) == 0:\n        return test_list\n    else:\n        return [test_list[-1]] + test_list[:-1]\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l * w + w * h + h * l)\n"}
{"task_id": "MBPP/380", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Loop through the number of rows\n    for i in range(rownum):\n        # Initialize an empty list to store the current row\n        row = []\n        \n        # Loop through the number of columns\n        for j in range(colnum):\n            # Append the current column value to the row\n            row.append(j)\n        \n        # Append the current row to the result\n        result.append(row)\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    n = len(A)\n    for i in range(n):\n        if A[i] > A[(i + 1) % n]:\n            return i\n    return n\n"}
{"task_id": "MBPP/383", "completion": "\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the binary string\n    for bit in binary:\n        # If the bit is '1', toggle it to '0' and vice versa\n        if bit == '1':\n            result += '0'\n        else:\n            result += '1'\n    \n    # Convert the result back to an integer and return it\n    return int(result, 2)  # 2 is the base of the number in the string\n\n"}
{"task_id": "MBPP/384", "completion": "\n    # First, we need to find the smallest value in the array\n    smallest = min(arr)\n    \n    # Then, we need to count the frequency of the smallest value\n    frequency = arr.count(smallest)\n    \n    # Finally, we return the frequency\n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n"}
{"task_id": "MBPP/386", "completion": "\n    stack = []\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(s[i])\n        elif s[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n    return count + len(stack)\n"}
{"task_id": "MBPP/387", "completion": "\n    # Convert the hexadecimal number to decimal\n    decimal = int(N, 16)\n    \n    # Check if the decimal number is even or odd\n    if decimal % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n"}
{"task_id": "MBPP/388", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return 2 ** (n.bit_length() - 1)  # Using bit_length() to get the number of bits required to represent the number in binary\n\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    # Initialize an empty dictionary\n    nested_dict = {}\n    \n    # Iterate over the lists\n    for i in range(len(l1)):\n        # Create a dictionary with the first list as keys and the second list as values\n        dict1 = dict(zip(l1, l2))\n        \n        # Create a dictionary with the third list as keys and the first dictionary as values\n        dict2 = dict(zip(l3, [dict1] * len(l3)))\n        \n        # Add the second dictionary to the main dictionary\n        nested_dict.update(dict2)\n    \n    return nested_dict\n"}
{"task_id": "MBPP/392", "completion": "\n    def f(n):\n        if n == 1:\n            return 0\n        if n in memo:\n            return memo[n]\n        max_sum = 0\n        for i in [2, 3, 4, 5]:\n            if n % i == 0:\n                max_sum = max(max_sum, f(n // i))\n        memo[n] = max(max_sum, n)\n        return memo[n]\n    memo = {}\n    return f(n)  # return the maximum sum for the given number n\n"}
{"task_id": "MBPP/393", "completion": "\n    return max(input_list, key=len)\n"}
{"task_id": "MBPP/394", "completion": "\n    return len(test_tup) == len(set(test_tup))\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    if re.match(regex, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        median = (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\n    else:\n        median = numbers[len(numbers) // 2]\n    return median\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(num)) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n"}
{"task_id": "MBPP/400", "completion": "\n    freq_dict = {}\n    for tup in test_list:\n        tup = tuple(sorted(tup))  # sort the tuple to make it order-irrespective\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/401", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the first tuple\n    for i in range(len(test_tup1)):\n        # Check if the current element is a tuple\n        if isinstance(test_tup1[i], tuple):\n            # If it's a tuple, recursively call the function on the current element and the corresponding element in the second tuple\n            result.append(add_nested_tuples(test_tup1[i], test_tup2[i]))\n        else:\n            # If it's not a tuple, perform the addition directly\n            result.append(test_tup1[i] + test_tup2[i])\n    \n    # Return the result\n    return tuple(result)\n"}
{"task_id": "MBPP/402", "completion": "\n    def mul(a, b, p):\n        return (a * b) % p\n\n    def power(x, y, p):\n        res = 1\n        x = x % p\n        if (x == 0):\n            return 0\n        while (y > 0):\n            if ((y & 1) == 1):\n                res = (res * x) % p\n            y = y >> 1\n            x = (x * x) % p\n        return res\n\n    def inverse(x, p):\n        return power(x, p - 2, p)\n\n    num = den = 1\n    for i in range(1, r + 1):\n        num = mul(num, n - i + 1, p)\n        den = mul(den, i, p)\n    inv = inverse(den, p)\n    return mul(num, inv, p)\n"}
{"task_id": "MBPP/403", "completion": "\n    url_pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(url_pattern.match(str))\n\n"}
{"task_id": "MBPP/404", "completion": "\n    return min(a, b)\n"}
{"task_id": "MBPP/405", "completion": "\n    return tuplex in tuple1\n"}
{"task_id": "MBPP/406", "completion": "\n    # The parity of a number is 0 if it is even and 1 if it is odd.\n    # We can use the modulus operator to find the remainder of the number when divided by 2.\n    # If the remainder is 0, the number is even, otherwise it is odd.\n    return x % 2\n"}
{"task_id": "MBPP/407", "completion": "\n    n = str(n)\n    i = len(n) - 1\n    while i > 0 and n[i - 1] >= n[i]:\n        i -= 1\n    if i <= 0:\n        return -1\n    j = len(n) - 1\n    while n[j] <= n[i - 1]:\n        j -= 1\n    n = list(n)\n    n[i - 1], n[j] = n[j], n[i - 1]\n    n[i : ] = n[len(n) - 1 : i - 1 : -1]\n    return int(''.join(n))\n"}
{"task_id": "MBPP/408", "completion": "\n    # Create a min heap to store the pairs\n    min_heap = []\n    \n    # Push the first element of the first array and the first element of the second array into the heap\n    heapq.heappush(min_heap, (nums1[0] + nums2[0], 0, 0))\n    \n    # Initialize a set to store the pairs\n    pairs = set()\n    \n    # Initialize a counter to count the number of pairs\n    count = 0\n    \n    # Loop until we have k pairs\n    while count < k:\n        # Get the pair with the smallest sum from the heap\n        pair_sum, i, j = heapq.heappop(min_heap)\n        \n        # Add the pair to the set\n        pairs.add((nums1[i], nums2[j]))\n        \n        # Increment the counter\n        count += 1\n        \n        # If we haven't reached the end of the first array, push the next element of the first array and the current element of the second array into the heap\n        if i + 1 < len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        \n        # If we haven't reached the end of the second array, push the current element of the first array and the next element of the second array into the heap\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    \n    # Return the k smallest pairs\n    return list(pairs)\n\n"}
{"task_id": "MBPP/409", "completion": "\n    # Initialize the minimum product with a large number\n    min_product = float('inf')\n    \n    # Iterate over the list of tuples with their indices\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            # Calculate the product of the current pair of tuples\n            product = tuple1 * tuple2\n            \n            # Update the minimum product if the current product is smaller\n            if product < min_product:\n                min_product = product\n                \n    # Return the minimum product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    return min(listval)\n"}
{"task_id": "MBPP/411", "completion": "\n    # Use regex to find all words in the snake case string\n    words = re.findall(r'\\w+', word)\n    \n    # Use list comprehension to capitalize the first letter of each word except the first one\n    camel_case_words = [words[0]] + [word.capitalize() for word in words[1:]]\n    \n    # Join the words together to form the camel case string\n    camel_case_string = ''.join(camel_case_words)\n    \n    return camel_case_string\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [i for i in l if i % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return list1[n-1]  # subtract 1 because list indices start at 0\n"}
{"task_id": "MBPP/414", "completion": "\n    return [value for value in list1 if value in list2]\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return None\n    max1 = max2 = float('-inf')\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n    return max1 * max2\n"}
{"task_id": "MBPP/416", "completion": "\n    if n == 0:\n        return 0\n    if n < 0:\n        return -MAX\n    if n == 1:\n        return 1\n    max_sum = -MAX\n    for i in range(1, n):\n        max_sum = max(max_sum, breakSum(i) + breakSum(n - i - 1) + i + 1)\n    return max_sum\n\n"}
{"task_id": "MBPP/417", "completion": "\n    # Initialize an empty dictionary to store the count of each first element\n    count_dict = {}\n    \n    # Iterate over each tuple in the input list\n    for tup in Input:\n        # Get the first element of the tuple\n        first_element = tup[0]\n        \n        # If the first element is already in the dictionary, increment its count\n        if first_element in count_dict:\n            count_dict[first_element] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[first_element] = 1\n    \n    # Initialize an empty list to store the common first elements\n    common_elements = []\n    \n    # Iterate over each key-value pair in the dictionary\n    for key, value in count_dict.items():\n        # If the count is equal to the number of tuples, add the key to the list\n        if value == len(Input):\n            common_elements.append(key)\n    \n    # Return the list of common first elements\n    return common_elements\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_lst = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sub_lst = lst[i:j]\n            if len(sub_lst) > max_len:\n                max_len = len(sub_lst)\n                max_lst = sub_lst\n    return max_lst\n"}
{"task_id": "MBPP/419", "completion": "\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    print(total_sum * len(list1))\n    return total_sum * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    # Initialize sum as 0\n    sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n+2, 2):\n        # Add the cube of the current number to the sum\n        sum += i**3\n    # Return the sum\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    return delimiter.join(map(str, test_tup))\n"}
{"task_id": "MBPP/422", "completion": "\n    # Initialize sum of cubes\n    sum_of_cubes = 0\n    \n    # Loop through first n natural numbers\n    for i in range(1, n+1):\n        # Add cube of current number to sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate average of cubes\n    average_of_cubes = sum_of_cubes / n\n    \n    # Return average of cubes\n    return average_of_cubes\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a 2D array to store the maximum gold that can be collected at each cell\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    # Initialize the first row and column of the dp array\n    for i in range(m):\n        dp[i][0] = gold[i][0]\n    for j in range(n):\n        dp[0][j] = gold[0][j]\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, m):\n        for j in range(1, n):\n            # For each cell, the maximum gold that can be collected is the maximum of the gold in the cell above it, \n            # the cell to its left, and the cell diagonally above-left, plus the gold in the current cell\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + gold[i][j]\n    \n    # The maximum gold that can be collected is stored in the bottom-right cell of the dp array\n    return dp[m-1][n-1]\n"}
{"task_id": "MBPP/424", "completion": "\n    return tuple(string[-1] for string in test_tuple)\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    return list(filter(lambda x: x % 2 != 0, nums))\n"}
{"task_id": "MBPP/427", "completion": "\n    # Using regex to find the pattern of the date\n    pattern = re.compile(r'(\\d{4})-(\\d{2})-(\\d{2})')\n    # Using the sub function to replace the pattern with the desired format\n    new_date = pattern.sub(r'\\3-\\2-\\1', dt)\n    return new_date\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    # Initialize empty lists to store the elementwise and tuples\n    elementwise = []\n    tuples = []\n\n    # Iterate over the two tuples in parallel using zip\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        # Append the elementwise result to the list\n        elementwise.append(tup1 + tup2)\n        \n        # Append the tuple result to the list\n        tuples.append((tup1, tup2))\n\n    # Return the elementwise and tuples lists\n    return elementwise, tuples\n"}
{"task_id": "MBPP/430", "completion": "\n    # Calculate the focal length\n    focal_length = 1 / (4 * a)\n    \n    # Calculate the directrix\n    directrix = -focal_length\n    \n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "MBPP/432", "completion": "\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n    \n    # The median of a trapezium is the average of the bases\n    median = (base1 + base2) / 2\n    \n    return median\n"}
{"task_id": "MBPP/433", "completion": "\n    return all(number > element for element in arr)\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = r\"a(b+)\"\n    return re.match(pattern, text)\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if ord(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/439", "completion": "\n    return int(''.join(map(str, L)))\n"}
{"task_id": "MBPP/440", "completion": "\n    # Define a list of adverbs\n    adverbs = [\"quickly\", \"slowly\", \"loudly\", \"wisely\", \"carefully\", \"happily\", \"sadly\", \"angrily\", \"patiently\"]\n    \n    # Initialize an empty list to store the positions of adverbs\n    adverb_positions = []\n    \n    # Split the text into words\n    words = text.split()\n    \n    # Iterate over the words and their indices\n    for i, word in enumerate(words):\n        # Check if the word is an adverb\n        if word in adverbs:\n            # If it is, append its position to the list\n            adverb_positions.append(i)\n    \n    # Return the list of adverb positions\n    return adverb_positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    # Create an array of boolean values indicating whether each number is positive\n    positive = array('b', [num > 0 for num in nums])\n    \n    # Count the number of positive numbers\n    count = positive.count(1)\n    \n    # Calculate the ratio of positive numbers\n    ratio = count / len(nums) if nums else 0\n    \n    return ratio\n\n"}
{"task_id": "MBPP/443", "completion": "\n    # Initialize max_neg to negative infinity\n    max_neg = float('-inf')\n    \n    # Iterate over each number in the list\n    for num in list1:\n        # Check if the number is negative and greater than max_neg\n        if num < 0 and num > max_neg:\n            # Update max_neg\n            max_neg = num\n    \n    # Return max_neg\n    return max_neg\n"}
{"task_id": "MBPP/444", "completion": "\n    return [tuple(test_list[i][j] for j in range(len(test_list[i])-K, len(test_list[i]))) for i in range(len(test_list))]\n"}
{"task_id": "MBPP/445", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(test_tup1)):\n        # Multiply the elements at the current index and append the result to the list\n        result.append(test_tup1[i] * test_tup2[i])\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "MBPP/446", "completion": "\n    # Convert the tuple to a list\n    tup_list = list(tup)\n    # Count the occurrence of each element in the list\n    count = Counter(lst)\n    # Count the occurrence of each element in the tuple\n    tup_count = Counter(tup_list)\n    # Return the difference between the two counts\n    return count - tup_count\n\n"}
{"task_id": "MBPP/447", "completion": "\n    return list(map(lambda x: x**3, nums))\n"}
{"task_id": "MBPP/448", "completion": "\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    else:\n        a, b = 2, 3\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate the lengths of the sides of the triangle\n    a = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    b = math.sqrt((x3 - x2)**2 + (y3 - y2)**2)\n    c = math.sqrt((x1 - x3)**2 + (y1 - y3)**2)\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    # Using regex to replace all whitespaces with an empty string\n    text1 = re.sub(r'\\s+', '', text1)\n    return text1\n\n"}
{"task_id": "MBPP/452", "completion": "\n    loss = actual_cost - sale_amount\n    if loss > 0:\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    # Use regular expression to match a word containing 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    return re.search(pattern, text)\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    return min(lst, key=len)\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    # Using regex to find all uppercase substrings\n    uppercase_substrings = re.findall(r'[A-Z]+', str1)\n    \n    # Removing the uppercase substrings from the original string\n    result = re.sub(r'[A-Z]+', '', str1)\n    \n    return result, uppercase_substrings\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    return sum(1 for char in str if char.isupper())\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 1:\n        return [list1]\n    result = []\n    for i in range(len(list1)):\n        current = list1[i]\n        rest = list1[:i] + list1[i+1:]\n        for c in combinations_list(rest):\n            result.append([current] + c)\n    return result\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return len(set(dict.values())) == 1\n"}
{"task_id": "MBPP/465", "completion": "\n    return {key: value for key, value in dict1.items() if value}\n"}
{"task_id": "MBPP/466", "completion": "\n    # Base cases\n    if high == low:\n        return arr[low]\n    if high == low + 1:\n        if arr[low] > arr[high]:\n            return arr[low]\n        else:\n            return arr[high]\n\n    # Find the middle point\n    mid = (low + high) // 2\n\n    # If the middle element is greater than its neighbors, it is the peak\n    if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == n - 1 or arr[mid] >= arr[mid + 1]):\n        return arr[mid]\n\n    # If the middle element is smaller than its left neighbor, the peak must be in the left half\n    if mid > 0 and arr[mid] < arr[mid - 1]:\n        return find_peak_util(arr, low, mid - 1, n)\n\n    # If the middle element is smaller than its right neighbor, the peak must be in the right half\n    if mid < n - 1 and arr[mid] < arr[mid + 1]:\n        return find_peak_util(arr, mid + 1, high, n)\n"}
{"task_id": "MBPP/467", "completion": "\n    return oct(deciNum).replace(\"0o\", \"\")\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize a list to store the maximum product ending at each position\n    max_product = [0] * n\n    # Initialize a list to store the minimum product ending at each position\n    min_product = [0] * n\n    # Initialize the maximum product ending at the first position\n    max_product[0] = arr[0]\n    # Initialize the minimum product ending at the first position\n    min_product[0] = arr[0]\n    # Iterate over the array starting from the second position\n    for i in range(1, n):\n        # For each position, the maximum product ending at that position is the maximum of the current number and the product of the current number and the maximum product ending at the previous position\n        max_product[i] = max(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n        # For each position, the minimum product ending at that position is the minimum of the current number and the product of the current number and the minimum product ending at the previous position\n        min_product[i] = min(arr[i], max_product[i-1] * arr[i], min_product[i-1] * arr[i])\n    # Return the maximum product ending at the last position\n    return max_product[-1]\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if n < 2 or k == 0:\n        return 0\n\n    # Create a 2D table to store the maximum profit for each subproblem\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(1, k + 1):\n            # Initialize the maximum profit for the current subproblem\n            max_profit = 0\n\n            # Try to buy and sell the stock at each previous day\n            for m in range(i):\n                # Calculate the profit if we buy the stock at day m and sell it at day i\n                profit = price[i] - price[m] + dp[m][j - 1]\n\n                # Update the maximum profit for the current subproblem\n                max_profit = max(max_profit, profit)\n\n            # Update the maximum profit for the current subproblem in the table\n            dp[i][j] = max(dp[i - 1][j], max_profit)\n\n    # Return the maximum profit for the entire problem\n    return dp[n - 1][k]\n"}
{"task_id": "MBPP/470", "completion": "\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples\n    for tup in test_tup:\n        # Iterate over the elements in the tuple\n        for i in range(len(tup)):\n            # Iterate over the elements in the tuple starting from the next element\n            for j in range(i + 1, len(tup)):\n                # Add the elements and append the result to the list\n                result.append(tup[i] + tup[j])\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/471", "completion": "\n    # Initialize the result as 1\n    result = 1\n    \n    # Multiply all elements in the array and store the result in result\n    for i in range(lens):\n        result = (result * arr[i]) % n\n    \n    # Return the result\n    return result\n"}
{"task_id": "MBPP/472", "completion": "\n    l.sort()\n    for i in range(len(l)-1):\n        if l[i+1] - l[i] == 1:\n            return True\n    return False\n"}
{"task_id": "MBPP/473", "completion": "\n    # Convert the lists to sets for efficient lookups\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    # Use set intersection to find common elements\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and return it\n    return list(intersection)\n"}
{"task_id": "MBPP/474", "completion": "\n    return str1.replace(ch, newch)\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1], reverse=True))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub(r'[a-z]+', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    # Convert the number to a string to easily access the first character\n    str_n = str(n)\n    \n    # Check if the number is negative\n    if str_n[0] == '-':\n        # If the number is negative, return the first digit after the negative sign\n        return int(str_n[1])\n    else:\n        # If the number is not negative, return the first digit\n        return int(str_n[0])\n"}
{"task_id": "MBPP/480", "completion": "\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in char_freq:\n            char_freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_char = max(char_freq, key=char_freq.get)\n    \n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    # Create a 2D table to store the results of subproblems\n    dp = [[False] * (sum + 1) for _ in range(len(set) + 1)]\n\n    # Initialize the first row and column of the table\n    for i in range(len(set) + 1):\n        dp[i][0] = True\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, len(set) + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the current sum, skip it\n            if set[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            # Otherwise, consider two cases: include the current element or not\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - set[i - 1]]\n\n    # The result is stored in the bottom-right cell of the table\n    return dp[-1][-1]\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n\n"}
{"task_id": "MBPP/483", "completion": "\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n    n = 1\n    while True:\n        if factorial(n) % x == 0:\n            return n\n        n += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    return [t for t in test_list1 if t not in test_list2]\n"}
{"task_id": "MBPP/485", "completion": "\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    max_palindrome = 0\n    for num in n:\n        if is_palindrome(num) and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n - r:  # take the smaller of r and n-r to avoid duplicate calculations\n        r = n - r\n    result = 1\n    for i in range(r):\n        result = result * (n - i) / (i + 1)\n    return result\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(25 + 10 * math.sqrt(5)) / 4) * a ** 2\n\n"}
{"task_id": "MBPP/489", "completion": "\n    # First, find the maximum value in the array\n    max_val = max(arr)\n    \n    # Then, count the number of occurrences of the maximum value in the array\n    frequency = arr.count(max_val)\n    \n    # Return the frequency of the largest value\n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    symmetric_pairs = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                symmetric_pairs.append((test_list[i], test_list[j]))\n    return symmetric_pairs\n"}
{"task_id": "MBPP/491", "completion": "\n    return a * (1 - r ** n) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = math.ceil((endx - startx) / (2 * radius))\n    num_hexagons_y = math.ceil((endy - starty) / (2 * radius))\n\n    # Initialize the grid\n    grid = []\n\n    # Loop over each hexagon in the grid\n    for y in range(num_hexagons_y):\n        row = []\n        for x in range(num_hexagons_x):\n            # Calculate the center of the hexagon\n            center_x = startx + (2 * radius) * x\n            center_y = starty + (2 * radius) * y\n\n            # Calculate the coordinates of the 6 points of the hexagon\n            points = []\n            for i in range(6):\n                angle = math.pi / 3 * i\n                point_x = center_x + radius * math.cos(angle)\n                point_y = center_y + radius * math.sin(angle)\n                points.append((point_x, point_y))\n\n            # Add the hexagon to the grid\n            row.append(points)\n        grid.append(row)\n\n    return grid\n\n"}
{"task_id": "MBPP/494", "completion": "\n    # Convert the binary tuple to a string\n    binary_str = ''.join(map(str, test_tup))\n    \n    # Convert the binary string to an integer\n    integer = int(binary_str, 2)\n    \n    return integer\n"}
{"task_id": "MBPP/495", "completion": "\n    # Using regex to find all lowercase substrings\n    lowercase_substrings = re.findall(r'[a-z]+', str1)\n    \n    # Joining the lowercase substrings into a string\n    lowercase_str = ''.join(lowercase_substrings)\n    \n    # Removing the lowercase substrings from the original string\n    result = re.sub(r'[a-z]+', '', str1)\n    \n    return result, lowercase_str\n\n"}
{"task_id": "MBPP/496", "completion": "\n    # Create a min heap\n    min_heap = []\n    \n    # Push the first n numbers into the heap\n    for i in range(n):\n        hq.heappush(min_heap, nums[i])\n    \n    # Pop the smallest number from the heap and push the next number from the list into the heap\n    for i in range(n, len(nums)):\n        smallest = hq.heappop(min_heap)\n        hq.heappush(min_heap, nums[i])\n    \n    # The smallest numbers are stored in the heap\n    return min_heap\n\n"}
{"task_id": "MBPP/497", "completion": "\n    # Calculate the slant height of the cone\n    slant_height = math.sqrt(r ** 2 + h ** 2)\n    # Calculate the surface area of the cone\n    surface_area = math.pi * r * (r + slant_height)\n    return surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    return ''.join(list)\n"}
{"task_id": "MBPP/501", "completion": "\n    # Find the greatest common divisor of two numbers\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the common divisor between two numbers\n    def common_divisor(x, y):\n        return gcd(x, y)\n\n    return common_divisor(x, y)\n\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    total = 0\n    for i in range(len(nums)):\n        total += nums[i]\n        if i < len(nums) - 1:\n            total += nums[i + 1]\n    return total\n"}
{"task_id": "MBPP/504", "completion": "\n    return sum(i**3 for i in range(1, n+1))\n"}
{"task_id": "MBPP/505", "completion": "\n    return [x for x in A if x != 0] + [x for x in A if x == 0]\n"}
{"task_id": "MBPP/506", "completion": "\n    # Initialize the result\n    result = 1\n    # Calculate the permutation coefficient\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) / i\n    return result\n"}
{"task_id": "MBPP/507", "completion": "\n    # Convert the list to a set for efficient lookups\n    set1 = set(list1)\n    # Convert the list of words to remove to a set for efficient lookups\n    set2 = set(removewords)\n    # Use set difference to remove the words\n    result = list(set1 - set2)\n    return result\n"}
{"task_id": "MBPP/508", "completion": "\n    # Convert the lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements between the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Initialize an empty list to store the common elements in the order they appear in the first list\n    common_elements_in_order = []\n    \n    # Iterate over the first list and add the common elements to the list in the order they appear\n    for element in l1:\n        if element in common_elements:\n            common_elements_in_order.append(element)\n            common_elements.remove(element)\n    \n    # Initialize an empty list to store the common elements in the order they appear in the second list\n    common_elements_in_order_2 = []\n    \n    # Iterate over the second list and add the common elements to the list in the order they appear\n    for element in l2:\n        if element in common_elements:\n            common_elements_in_order_2.append(element)\n            common_elements.remove(element)\n    \n    # Check if the common elements in both lists are in the same order\n    return common_elements_in_order == common_elements_in_order_2\n"}
{"task_id": "MBPP/509", "completion": "\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    product = 1\n    count = 0\n    for i in range(n):\n        product *= arr[i]\n        if product < k:\n            count += 2 ** (n - i - 1)\n    return count\n"}
