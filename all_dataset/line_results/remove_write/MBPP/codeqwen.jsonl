{"task_id": "MBPP/11", "completion": "\n    first_occurrence = s.find(ch)\n    if first_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence + 1:]\n\n    last_occurrence = s.rfind(ch)\n    if last_occurrence != -1:\n        s = s[:last_occurrence] + s[last_occurrence + 1:]\n\n    return s\n"}
{"task_id": "MBPP/12", "completion": "\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(M, key=lambda row: sum(row))\n    return sorted_matrix\n"}
{"task_id": "MBPP/13", "completion": "\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(3)\n    return most_common\n\n"}
{"task_id": "MBPP/14", "completion": "\n    return (l * b * h) / 2\n"}
{"task_id": "MBPP/15", "completion": "\n    return re.findall('[A-Z][^A-Z]*', text)\n\n"}
{"task_id": "MBPP/16", "completion": "\n    return re.findall(r'[a-z]+_[a-z]+', text)\n\n"}
{"task_id": "MBPP/17", "completion": "\n    return 4 * a\n"}
{"task_id": "MBPP/18", "completion": "\n    count = [0] * NO_OF_CHARS\n    for char in string:\n        count[ord(char)] += 1\n\n    result = []\n    for char in string:\n        if count[ord(char)] == 1:\n            result.append(char)\n        count[ord(char)] -= 1\n\n    return ''.join(result)\n\n"}
{"task_id": "MBPP/19", "completion": "\n    for i in range(len(arraynums)):\n        for j in range(i+1, len(arraynums)):\n            if arraynums[i] == arraynums[j]:\n                return True\n    return False\n"}
{"task_id": "MBPP/20", "completion": "\n    if x < 1:\n        return False\n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == x:\n            return True\n        elif woodall_number > x:\n            return False\n        n += 1\n"}
{"task_id": "MBPP/21", "completion": "\n    return [n * i for i in range(1, m + 1)]\n\n"}
{"task_id": "MBPP/22", "completion": "\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n"}
{"task_id": "MBPP/23", "completion": "\n    max_sum = float('-inf')\n    for sublist in list1:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n"}
{"task_id": "MBPP/24", "completion": "\n    decimal = 0\n    for i, digit in enumerate(reversed(binary)):\n        decimal += int(digit) * (2 ** i)\n    return decimal\n"}
{"task_id": "MBPP/25", "completion": "\n    product = 1\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if arr[i] == arr[j]:\n                count += 1\n        if count == 1:\n            product *= arr[i]\n    return product\n"}
{"task_id": "MBPP/26", "completion": "\n    for sub in test_list:\n        if len(sub) != K:\n            return False\n    return True\n"}
{"task_id": "MBPP/27", "completion": "\n    return [re.sub(r'\\d', '', i) for i in list]\n\n"}
{"task_id": "MBPP/28", "completion": "\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(0, k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\n"}
{"task_id": "MBPP/29", "completion": "\n    for i in range(arr_size):\n        count = 0\n        for j in range(arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if count % 2 != 0:\n            return arr[i]\n    return -1\n\n"}
{"task_id": "MBPP/30", "completion": "\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/31", "completion": "\n    # Create a dictionary to store the frequency of each integer\n    freq = collections.defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n\n    # Create a min heap to store the top k integers\n    min_heap = []\n    for num, count in freq.items():\n        if len(min_heap) < k:\n            heapq.heappush(min_heap, (count, num))\n        elif count > min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (count, num))\n\n    # Return the top k integers\n    return [num for count, num in heapq.nsmallest(k, min_heap)]\n\n"}
{"task_id": "MBPP/32", "completion": "\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n = n / 2\n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)\n\n"}
{"task_id": "MBPP/33", "completion": "\n    binary = \"\"\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary\n\n"}
{"task_id": "MBPP/34", "completion": "\n    low, high = 0, N - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if ar[mid] != mid + ar[0]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low + ar[0]\n\n"}
{"task_id": "MBPP/35", "completion": "\n    return n * (n + 1) // 2\n"}
{"task_id": "MBPP/36", "completion": "\n    # Calculate the number of digits in the numerator and denominator\n    num_digits = len(str(p))\n    den_digits = len(str(q))\n    \n    # If N is less than or equal to the number of digits in the numerator,\n    # the nth digit is in the numerator\n    if N <= num_digits:\n        return int(str(p)[-N])\n    \n    # If N is greater than the number of digits in the numerator,\n    # the nth digit is in the denominator\n    else:\n        N -= num_digits\n        return int(str(q)[N-1])\n"}
{"task_id": "MBPP/37", "completion": "\n    # Separate and sort the integers and strings\n    numbers = sorted([item for item in mixed_list if isinstance(item, int)])\n    words = sorted([item for item in mixed_list if isinstance(item, str)])\n    \n    # Combine the sorted integers and strings\n    sorted_list = numbers + words\n    return sorted_list\n"}
{"task_id": "MBPP/38", "completion": "\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if num % 2 == 0:\n            if even_num is None:\n                even_num = num\n            else:\n                even_num /= num\n        else:\n            if odd_num is None:\n                odd_num = num\n            else:\n                odd_num /= num\n    return even_num, odd_num\n"}
{"task_id": "MBPP/39", "completion": "\n    # Count the frequency of each character\n    freq = Counter(S)\n    # Create a max heap based on the frequency of characters\n    max_heap = [(-freq[char], char) for char in freq]\n    heapq.heapify(max_heap)\n    # Check if the rearranged string is possible\n    if (-max_heap[0][0]) * 2 > len(S) + 1:\n        return \"\"\n    # Rearrange the string\n    rearranged = []\n    while len(max_heap) > 1:\n        freq1, char1 = heapq.heappop(max_heap)\n        freq2, char2 = heapq.heappop(max_heap)\n        rearranged.extend([char1, char2])\n        if freq1 + 1 < 0:\n            heapq.heappush(max_heap, (freq1 + 1, char1))\n        if freq2 + 1 < 0:\n            heapq.heappush(max_heap, (freq2 + 1, char2))\n    if max_heap:\n        rearranged.append(max_heap[0][1])\n    return \"\".join(rearranged)\n\n"}
{"task_id": "MBPP/40", "completion": "\n    # Flatten the list of lists into a single list\n    flat_list = list(chain.from_iterable(nums))\n    # Count the frequency of each element\n    freq = Counter(flat_list)\n    return freq\n\n"}
{"task_id": "MBPP/41", "completion": "\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums\n"}
{"task_id": "MBPP/42", "completion": "\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n    \n    # Calculate the sum of elements that appear more than once\n    sum = 0\n    for key, value in freq.items():\n        if value > 1:\n            sum += key * value\n    \n    return sum\n"}
{"task_id": "MBPP/43", "completion": "\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/44", "completion": "\n    pattern = '^\\w+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/45", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/46", "completion": "\n    return len(data) == len(set(data))\n"}
{"task_id": "MBPP/47", "completion": "\n    result = 1\n    if A == B:\n        return 1\n    elif (B - A) >= 5:\n        return 0\n    else:\n        for i in range(A + 1, B + 1):\n            result = (result * (i % 10)) % 10\n        return result\n"}
{"task_id": "MBPP/48", "completion": "\n    # Initialize the result with the given number\n    result = n\n    # Initialize the bit position\n    bit_position = 0\n    # Iterate over the bits of the number\n    while n > 0:\n        # Check if the current bit position is odd\n        if bit_position % 2 == 0:\n            # Set the bit at the current position\n            result |= (1 << bit_position)\n        # Move to the next bit position\n        bit_position += 1\n        # Shift the number to the right by one bit\n        n >>= 1\n    # Return the result\n    return result\n"}
{"task_id": "MBPP/49", "completion": "\n    return [row[N] for row in nums]\n"}
{"task_id": "MBPP/50", "completion": "\n    min_length_list = min(input_list, key=lambda x: len(x))\n    return min_length_list\n"}
{"task_id": "MBPP/51", "completion": "\n    if x == y == z:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n"}
{"task_id": "MBPP/52", "completion": "\n    return b * h\n"}
{"task_id": "MBPP/53", "completion": "\n    if (str[0] == str[-1]):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/54", "completion": "\n    if not my_list:\n        return []\n\n    # Find the maximum value in the list\n    max_value = max(my_list)\n\n    # Initialize the count array with zeros\n    count_array = [0] * (max_value + 1)\n\n    # Populate the count array\n    for number in my_list:\n        count_array[number] += 1\n\n    # Generate the sorted list\n    sorted_list = []\n    for number, count in enumerate(count_array):\n        sorted_list.extend([number] * count)\n\n    return sorted_list\n"}
{"task_id": "MBPP/55", "completion": "\n    tn = a * (math.pow(r, n - 1))\n    return tn\n\n"}
{"task_id": "MBPP/56", "completion": "\n\n    return 2 * rev(n) == n + 1\n\n"}
{"task_id": "MBPP/57", "completion": "\n    arr.sort(reverse=True)\n    max_num = int(\"\".join(map(str, arr)))\n    return max_num\n"}
{"task_id": "MBPP/58", "completion": "\n    return ((x ^ y) < 0)\n"}
{"task_id": "MBPP/59", "completion": "\n    return n * (3 * n - 2)\n"}
{"task_id": "MBPP/60", "completion": "\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n"}
{"task_id": "MBPP/61", "completion": "\n    count = defaultdict(int)\n    count[0] = 1\n    sum_ = 0\n    res = 0\n    for i in range(n):\n        sum_ += ord(s[i]) - ord('0')\n        res += count[sum_ - (i + 1)]\n        count[sum_ - (i + 1)] += 1\n    return res\n\n"}
{"task_id": "MBPP/62", "completion": "\n    if len(xs) == 0:\n        return None\n    else:\n        smallest = xs[0]\n        for x in xs:\n            if x < smallest:\n                smallest = x\n        return smallest\n"}
{"task_id": "MBPP/63", "completion": "\n    # Calculate the difference between each pair\n    diff_list = [abs(x - y) for x, y in test_list]\n    \n    # Return the maximum difference\n    return max(diff_list)\n"}
{"task_id": "MBPP/64", "completion": "\n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks\n"}
{"task_id": "MBPP/65", "completion": "\n    if not data_list:\n        return 0\n    else:\n        return data_list[0] + recursive_list_sum(data_list[1:])\n"}
{"task_id": "MBPP/66", "completion": "\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/67", "completion": "\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        bell[i] = bell[i - 1] * (i + 1)\n        for j in range(i - 1, 0, -1):\n            bell[j] = bell[j] + bell[j - 1]\n    return bell[n]\n\n"}
{"task_id": "MBPP/68", "completion": "\n    increasing = decreasing = True\n\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n\n"}
{"task_id": "MBPP/69", "completion": "\n    if len(s) == 0:\n        return True\n    if len(s) > len(l):\n        return False\n    for i in range(len(l)):\n        if l[i] == s[0]:\n            n = 1\n            while (n < len(s)) and (l[i+n] == s[n]):\n                n += 1\n            if n == len(s):\n                return True\n    return False\n"}
{"task_id": "MBPP/70", "completion": "\n    # Check if the length of the list is less than k\n    if len(Input) < k:\n        return False\n    # Check if all tuples have the same length\n    for i in range(k):\n        if len(Input[i]) != len(Input[0]):\n            return False\n    return True\n"}
{"task_id": "MBPP/71", "completion": "\n    gap = len(nums)\n    shrink_factor = 1.3\n    is_sorted = False\n\n    while not is_sorted or gap > 1:\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        is_sorted = True\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                is_sorted = False\n    return nums\n\n"}
{"task_id": "MBPP/72", "completion": "\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i * i - j * j == n) or (j * j - i * i == n):\n                return True\n    return False\n"}
{"task_id": "MBPP/73", "completion": "\n    return re.split('[,;: ]+', text)\n\n"}
{"task_id": "MBPP/74", "completion": "\n    if len(colors) != len(patterns):\n        return False\n    \n    pattern_to_color = {}\n    color_to_pattern = {}\n    \n    for color, pattern in zip(colors, patterns):\n        if pattern in pattern_to_color and pattern_to_color[pattern] != color:\n            return False\n        if color in color_to_pattern and color_to_pattern[color] != pattern:\n            return False\n        \n        pattern_to_color[pattern] = color\n        color_to_pattern[color] = pattern\n    \n    return True\n"}
{"task_id": "MBPP/75", "completion": "\n    res = [ele for ele in test_list if all(num % K == 0 for num in ele)]\n    return res\n"}
{"task_id": "MBPP/76", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/77", "completion": "\n    even_sum = 0\n    odd_sum = 0\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n        n = n // 10\n    return abs(even_sum - odd_sum)\n"}
{"task_id": "MBPP/78", "completion": "\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/79", "completion": "\n    return len(s) % 2 != 0\n"}
{"task_id": "MBPP/80", "completion": "\n    return n * (n + 1) * (n + 2) // 6\n\n"}
{"task_id": "MBPP/81", "completion": "\n    res = tuple(zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/82", "completion": "\n    return (4/3) * math.pi * r**3\n\n"}
{"task_id": "MBPP/83", "completion": "\n    sum_ascii = sum(ord(char) for char in strr)\n    return chr(sum_ascii % 26 + ord('a'))\n"}
{"task_id": "MBPP/84", "completion": "\n    if n == 1 or n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for i in range(3, n + 1):\n            a, b = b, a + b\n        return b\n\n"}
{"task_id": "MBPP/85", "completion": "\n    return 4 * math.pi * r ** 2\n\n"}
{"task_id": "MBPP/86", "completion": "\n    return 3 * n * (n - 1) + 1\n\n"}
{"task_id": "MBPP/87", "completion": "\n    return {**dict1, **dict2, **dict3}\n\n"}
{"task_id": "MBPP/88", "completion": "\n    return collections.Counter(list1)\n\n"}
{"task_id": "MBPP/89", "completion": "\n    return N - 1\n"}
{"task_id": "MBPP/90", "completion": "\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n"}
{"task_id": "MBPP/91", "completion": "\n    return sub_str in str1\n"}
{"task_id": "MBPP/92", "completion": "\n    n = str(n)\n    if len(n) < 3 or n[0] == n[1] == n[2]:\n        return False\n    for i in range(2, len(n)):\n        if i % 2 == 0 and n[i] != n[0]:\n            return False\n        elif i % 2 != 0 and n[i] != n[1]:\n            return False\n    return True\n"}
{"task_id": "MBPP/93", "completion": "\n    if b == 0:\n        return 1\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        result = 1\n        for _ in range(b):\n            result *= a\n        return result\n"}
{"task_id": "MBPP/94", "completion": "\n    res = min(enumerate(test_list), key=itemgetter(1))\n    return res\n\n"}
{"task_id": "MBPP/95", "completion": "\n    min_len = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n    return min_len\n"}
{"task_id": "MBPP/96", "completion": "\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/97", "completion": "\n    freq_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict\n"}
{"task_id": "MBPP/98", "completion": "\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n"}
{"task_id": "MBPP/99", "completion": "\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n"}
{"task_id": "MBPP/100", "completion": "\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n\n"}
{"task_id": "MBPP/101", "completion": "\n    if n == 1:\n        return arr[0]\n    else:\n        pivot = arr[0]\n        left = [x for x in arr[1:] if x < pivot]\n        right = [x for x in arr[1:] if x >= pivot]\n        if k <= len(left):\n            return kth_element(left, len(left), k)\n        elif k <= len(left) + len(arr[1:]):\n            return arr[0]\n        else:\n            return kth_element(right, len(right), k - len(left) - 1)\n"}
{"task_id": "MBPP/102", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/103", "completion": "\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return ((n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m))\n\n"}
{"task_id": "MBPP/104", "completion": "\n    sorted_list = [sorted(sublist, key=lambda s: s.lower()) for sublist in input_list]\n    return sorted_list\n"}
{"task_id": "MBPP/105", "completion": "\n    return sum(1 for x in lst if x)\n"}
{"task_id": "MBPP/106", "completion": "\n    res = [ele + test_tup[i] for i, ele in enumerate(test_list)]\n    return res\n"}
{"task_id": "MBPP/107", "completion": "\n    count = 0\n    for i in range(L, R+1):\n        if 'A' <= hex(i)[2].upper() <= 'F':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/108", "completion": "\n    # Combine all the sorted lists into one\n    combined_list = heapq.merge(num1, num2, num3)\n    # Convert the iterator to a list and return\n    return list(combined_list)\n\n"}
{"task_id": "MBPP/109", "completion": "\n    count = 0\n    for i in range(n):\n        if s[i] == '1':\n            count += 1\n    return count % 2\n"}
{"task_id": "MBPP/110", "completion": "\n    missing_ranges = []\n    current_start = strt_val\n\n    for num in test_list:\n        if num > current_start:\n            missing_ranges.append((current_start, num))\n        current_start = max(current_start, num + 1)\n\n    if current_start < stop_val:\n        missing_ranges.append((current_start, stop_val))\n\n    return missing_ranges\n"}
{"task_id": "MBPP/111", "completion": "\n    # Flatten the nested list\n    flat_list = [item for sublist in nestedlist for item in sublist]\n    \n    # Find the most common element\n    common_element = max(set(flat_list), key=flat_list.count)\n    \n    return common_element\n"}
{"task_id": "MBPP/112", "completion": "\n    return 2 * (diameter + height)\n"}
{"task_id": "MBPP/113", "completion": "\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"}
{"task_id": "MBPP/114", "completion": "\n    res = Counter(test_list)\n    return list(res.items())\n\n"}
{"task_id": "MBPP/115", "completion": "\n    for i in list1:\n        if i:\n            return False\n    return True\n"}
{"task_id": "MBPP/116", "completion": "\n    return int(''.join(map(str, nums)))\n"}
{"task_id": "MBPP/117", "completion": "\n    result = []\n    for item in test_list:\n        try:\n            result.append(float(item))\n        except (ValueError, TypeError):\n            result.append(item)\n    return result\n"}
{"task_id": "MBPP/118", "completion": "\n    return string.split()\n"}
{"task_id": "MBPP/119", "completion": "\n    low, high = 0, len(arr) - 1\n\n    while low < high:\n        mid = low + (high - low) // 2\n\n        # Check if the mid is at the correct position\n        if mid % 2 == 0:\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid\n        else:\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n    return arr[low]\n\n"}
{"task_id": "MBPP/120", "completion": "\n    max_product = float('-inf')\n    for tup1, tup2 in list1:\n        product = abs(tup1[0] * tup1[1] * tup2[0] * tup2[1])\n        if product > max_product:\n            max_product = product\n    return max_product\n"}
{"task_id": "MBPP/121", "completion": "\n    if count == 3 and sum == 0:\n        return True\n    if count == 3 or n == 0 or sum < 0:\n        return False\n    # Include the current element in the sum and increment the count\n    include = check_triplet(A, n-1, sum-A[n-1], count+1)\n    # Exclude the current element from the sum\n    exclude = check_triplet(A, n-1, sum, count)\n    return include or exclude\n"}
{"task_id": "MBPP/122", "completion": "\n    # Initialize a list to store the count of divisors for each number\n    divisorCount = [0] * (MAX + 1)\n\n    # Iterate over all numbers from 1 to MAX\n    for i in range(1, MAX + 1):\n        # Iterate over all factors of the current number\n        for j in range(i, MAX + 1, i):\n            # Increment the count of divisors for the current factor\n            divisorCount[j] += 1\n\n    # Initialize a list to store the smart numbers\n    smartNumbers = []\n\n    # Iterate over all numbers from 1 to MAX\n    for i in range(1, MAX + 1):\n        # If the count of divisors for the current number is greater than or equal to 5,\n        # it is a smart number, so add it to the list\n        if divisorCount[i] >= 5:\n            smartNumbers.append(i)\n\n    # Return the n\u2019th smart number\n    return smartNumbers[n - 1]\n\n"}
{"task_id": "MBPP/123", "completion": "\n\n        Calculate the sum of proper divisors of a number.\n        \"\"\"\n        return sum([i for i in range(1, n) if n % i == 0])\n\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = proper_divisors_sum(a)\n        if a != b and proper_divisors_sum(b) == a:\n            amicable_sum += a\n    return amicable_sum\n"}
{"task_id": "MBPP/124", "completion": "\n    return cmath.phase(a + b * 1j)\n\n"}
{"task_id": "MBPP/125", "completion": "\n    max_diff = 0\n    current_diff = 0\n    for i in range(n):\n        if string[i] == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        if current_diff < 0:\n            current_diff = 0\n        max_diff = max(max_diff, current_diff)\n    return max_diff\n"}
{"task_id": "MBPP/126", "completion": "\n    common_divisors = []\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n    return sum(common_divisors)\n"}
{"task_id": "MBPP/127", "completion": "\n    # Handle negative numbers\n    if x < 0:\n        return -multiply_int(-x, y)\n    elif y < 0:\n        return -multiply_int(x, -y)\n    # Base case\n    elif y == 0:\n        return 0\n    # Recursive case\n    else:\n        return x + multiply_int(x, y - 1)\n"}
{"task_id": "MBPP/128", "completion": "\n    word_list = str.split(\" \")\n    long_word_list = []\n    for word in word_list:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list\n"}
{"task_id": "MBPP/129", "completion": "\n    # Check if the matrix is square\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Check if the sum of the rows is the same\n    row_sums = [sum(row) for row in my_matrix]\n    if len(set(row_sums)) != 1:\n        return False\n\n    # Check if the sum of the columns is the same\n    col_sums = [sum(col) for col in zip(*my_matrix)]\n    if len(set(col_sums)) != 1:\n        return False\n\n    # Check if the sum of the diagonals is the same\n    diag_sum1 = sum(my_matrix[i][i] for i in range(len(my_matrix)))\n    diag_sum2 = sum(my_matrix[i][len(my_matrix)-1-i] for i in range(len(my_matrix)))\n    if diag_sum1 != diag_sum2 or len(set([diag_sum1, diag_sum2])) != 1:\n        return False\n\n    return True\n"}
{"task_id": "MBPP/130", "completion": "\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    return max(count.values())\n\n"}
{"task_id": "MBPP/131", "completion": "\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    str1 = list(str1)\n    left, right = 0, len(str1) - 1\n    while left < right:\n        if str1[left] in vowels and str1[right] in vowels:\n            str1[left], str1[right] = str1[right], str1[left]\n            left += 1\n            right -= 1\n        elif str1[left] not in vowels:\n            left += 1\n        elif str1[right] not in vowels:\n            right -= 1\n    return ''.join(str1)\n"}
{"task_id": "MBPP/132", "completion": "\n    return ''.join(tup1)\n"}
{"task_id": "MBPP/133", "completion": "\n    negative_nums = list(filter(lambda x: x < 0, nums))\n    return sum(negative_nums)\n"}
{"task_id": "MBPP/134", "completion": "\n    if p % 2 == 0:\n        return arr[-1] % 2 == 0\n    else:\n        return (arr[-1] + 1) % 2 == 0\n"}
{"task_id": "MBPP/135", "completion": "\n    return n * (2 * n - 1)\n\n"}
{"task_id": "MBPP/136", "completion": "\n    if units <= 50:\n        bill = units * 2.60\n    elif units <= 100:\n        bill = 130 + ((units - 50) * 3.25)\n    elif units <= 200:\n        bill = 130 + 162.5 + ((units - 100) * 5.26)\n    else:\n        bill = 130 + 162.5 + 526 + ((units - 200) * 8.45)\n    return bill\n"}
{"task_id": "MBPP/137", "completion": "\n    zero_count = 0\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    return zero_count / len(nums)\n\n"}
{"task_id": "MBPP/138", "completion": "\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n            if n % 2 != 0:\n                return False\n    return True\n"}
{"task_id": "MBPP/139", "completion": "\n    return 2 * 3.14159 * r\n"}
{"task_id": "MBPP/140", "completion": "\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for item in test_list:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Extract elements that occur exactly once\n    singly_list = [item for item in test_list if count_dict[item] == 1]\n    \n    return singly_list\n"}
{"task_id": "MBPP/141", "completion": "\n    for size in range(len(nums), 1, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = nums.index(max(nums[:size]))\n        \n        # Flip the list from the start to the index of the maximum element\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        \n        # Flip the list from the start to the current size of the unsorted part\n        nums[:size] = reversed(nums[:size])\n    \n    return nums\n"}
{"task_id": "MBPP/142", "completion": "\n    same_pair = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            same_pair += 1\n    return same_pair\n"}
{"task_id": "MBPP/143", "completion": "\n    count = 0\n    for i in Input:\n        if isinstance(i, list):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/144", "completion": "\n    arr.sort()\n    sum_diff = 0\n    for i in range(n):\n        sum_diff += (arr[i] * i) - (arr[i] * (n - i - 1))\n    return sum_diff\n"}
{"task_id": "MBPP/145", "completion": "\n    if n < 2:\n        return -1\n\n    max_diff = 0\n    min_element = arr[0]\n    max_element = arr[0]\n\n    for i in range(1, n):\n        min_element = min(min_element, arr[i])\n        max_element = max(max_element, arr[i])\n\n    max_diff = max_element - min_element\n\n    return max_diff\n\n"}
{"task_id": "MBPP/146", "completion": "\n    return sum(ord(char) for char in str1)\n"}
{"task_id": "MBPP/147", "completion": "\n    if m == 0:\n        return tri[0][0]\n    if m == n:\n        return tri[m][n]\n    return max(max_path_sum(tri, m - 1, n), max_path_sum(tri, m - 1, n - 1)) + tri[m][n]\n\n"}
{"task_id": "MBPP/148", "completion": "\n    # Convert the number to a string to iterate over each digit\n    x = str(x)\n    \n    # Initialize the maximum sum to 0\n    max_sum = 0\n    \n    # Iterate over each digit in the string\n    for i in range(len(x)):\n        # Calculate the sum of digits before and after the current digit\n        sum_before = sum(int(digit) for digit in x[:i])\n        sum_after = sum(int(digit) for digit in x[i+1:])\n        \n        # Update the maximum sum if the current sum is greater\n        max_sum = max(max_sum, sum_before + sum_after)\n    \n    return max_sum\n"}
{"task_id": "MBPP/149", "completion": "\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n"}
{"task_id": "MBPP/150", "completion": "\n    if a == b:\n        return True\n    if a > b:\n        return False\n    return does_Contain_B(a + c, b, c)\n"}
{"task_id": "MBPP/151", "completion": "\n    while q != 0:\n        p, q = q, p % q\n    return p\n\n"}
{"task_id": "MBPP/152", "completion": "\n\n    if len(x) == 0 or len(x) == 1:\n        return x\n    else:\n        mid = len(x) // 2\n        a = merge_sort(x[:mid])\n        b = merge_sort(x[mid:])\n        return merge(a, b)\n\n"}
{"task_id": "MBPP/153", "completion": "\n    x_vertex = -b / (2 * a)\n    y_vertex = a * x_vertex ** 2 + b * x_vertex + c\n    return (x_vertex, y_vertex)\n"}
{"task_id": "MBPP/154", "completion": "\n    return [row[N] for row in nums]\n"}
{"task_id": "MBPP/155", "completion": "\n    result = 0\n    count = 0\n    temp = n\n    \n    # Iterate through all bits of n\n    while temp > 0:\n        # Check if the current bit position is even\n        if count % 2 == 0:\n            # Toggle the bit at the current position\n            result = result | (1 << count)\n        count += 1\n        temp >>= 1\n    \n    # XOR the original number with the result to toggle the even bits\n    return n ^ result\n"}
{"task_id": "MBPP/156", "completion": "\n    return tuple(int(i) for i in tuple_str)\n"}
{"task_id": "MBPP/157", "completion": "\n    return [(sum(1 for _ in group), key) for key, group in groupby(list1)]\n\n"}
{"task_id": "MBPP/158", "completion": "\n    # Sort the array\n    arr.sort()\n    \n    # Initialize the count of operations\n    count = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # If the current element is less than k, increment the count\n        if arr[i] < k:\n            count += k - arr[i]\n        # If the current element is greater than or equal to k, break the loop\n        else:\n            break\n    \n    # Return the count of operations\n    return count\n"}
{"task_id": "MBPP/159", "completion": "\n    if month in ('January', 'February', 'March'):\n        print('Winter')\n    elif month in ('April', 'May', 'June'):\n        print('Spring')\n    elif month in ('July', 'August', 'September'):\n        print('Summer')\n    elif month in ('October', 'November', 'December'):\n        print('Autumn')\n    else:\n        print('Invalid month')\n\n    if days < 1 or days > 31:\n        print('Invalid day')\n    elif month in ('January', 'February', 'March') and days > 19:\n        print('Spring')\n    elif month in ('April', 'May', 'June') and days > 20:\n        print('Summer')\n    elif month in ('July', 'August', 'September') and days > 21:\n        print('Autumn')\n    elif month in ('October', 'November', 'December') and days > 22:\n        print('Winter')\n"}
{"task_id": "MBPP/160", "completion": "\n    for x in range(n // b + 1):\n        if (n - x * b) % a == 0:\n            y = (n - x * b) // a\n            return x, y\n    return None, None\n\n"}
{"task_id": "MBPP/161", "completion": "\n    return [element for element in list1 if element not in list2]\n"}
{"task_id": "MBPP/162", "completion": "\n    if n <= 0:\n        return 0\n    else:\n        return n + sum_series(n-2)\n"}
{"task_id": "MBPP/163", "completion": "\n    return s * (l ** 2) / (4 * tan(pi / s))\n\n"}
{"task_id": "MBPP/164", "completion": "\n    # Calculate the sum of divisors\n    sum1 = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum1 += i + n // i\n            else:\n                sum1 += i\n            i += 1\n    return sum1 == n and n != 1\n\n"}
{"task_id": "MBPP/165", "completion": "\n    count = 0\n    for i in range(len(str1)):\n        if str1[i].lower() == chr(ord('a') + i):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/166", "completion": "\n    even_pairs = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if (A[i] ^ A[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs\n"}
{"task_id": "MBPP/167", "completion": "\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/168", "completion": "\n    count = 0\n    for i in a:\n        if i == x:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/169", "completion": "\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        prev = 0\n        curr = 1\n        for _ in range(2, n + 1):\n            next_pell = 2 * curr + prev\n            prev = curr\n            curr = next_pell\n        return curr\n"}
{"task_id": "MBPP/170", "completion": "\n    return sum(list1[m:n+1])\n"}
{"task_id": "MBPP/171", "completion": "\n    return 5 * a\n\n"}
{"task_id": "MBPP/172", "completion": "\n    count = 0\n    for i in range(len(s)):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n"}
{"task_id": "MBPP/173", "completion": "\n    return re.sub(r'\\W+', '', text)\n\n"}
{"task_id": "MBPP/174", "completion": "\n    d = {}\n    for k, v in l:\n        if k not in d:\n            d[k] = []\n        d[k].append(v)\n    return d\n"}
{"task_id": "MBPP/175", "completion": "\n    stack = []\n    for char in str1:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "MBPP/176", "completion": "\n    return a + b + c\n\n"}
{"task_id": "MBPP/177", "completion": "\n    for i in range(L, R):\n        for j in range(i+1, R+1):\n            if (i*j) % gcd(i, j) == 0:\n                return (i, j)\n    return (-1, -1)\n"}
{"task_id": "MBPP/178", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/179", "completion": "\n    # Convert the number to a list of its digits\n    digits = [int(d) for d in str(x)]\n    \n    # Initialize the sum with the first n digits\n    sum_digits = sum(digits[:len(digits)//2])\n    \n    # Generate the next terms and check if they are equal to x\n    for i in range(len(digits)//2, len(digits)):\n        sum_digits += digits[i]\n        if sum_digits == x:\n            return True\n        sum_digits -= digits[i - len(digits)//2]\n    \n    return False\n"}
{"task_id": "MBPP/180", "completion": "\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(radians, [slat, slon, elat, elon])\n\n    # Calculate the distance using the Haversine formula\n    dist = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon))\n\n    return dist\n\n"}
{"task_id": "MBPP/181", "completion": "\n    common_prefix = \"\"\n    length = min(len(str1), len(str2))\n    for i in range(length):\n        if str1[i] == str2[i]:\n            common_prefix += str1[i]\n        else:\n            break\n    return common_prefix\n"}
{"task_id": "MBPP/182", "completion": "\n    uppercase = re.findall(r\"[A-Z]\", string)\n    lowercase = re.findall(r\"[a-z]\", string)\n    special_char = re.findall(r\"[^A-Za-z0-9]\", string)\n    numeric = re.findall(r\"\\d\", string)\n\n    return uppercase, lowercase, special_char, numeric\n\n"}
{"task_id": "MBPP/183", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) == k:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/184", "completion": "\n    greater_specificnum = [i for i in list if i > num]\n    return greater_specificnum\n"}
{"task_id": "MBPP/185", "completion": "\n    x_focus = -b / (2 * a)\n    y_focus = (1 - (b ** 2) + (4 * a * c)) / (4 * a)\n    return (x_focus, y_focus)\n"}
{"task_id": "MBPP/186", "completion": "\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return True\n    return False\n"}
{"task_id": "MBPP/187", "completion": "\n    # Create a 2D array to store the lengths of the longest common subsequences\n    L = [[0 for j in range(n+1)] for i in range(m+1)]\n\n    # Build the L[][] in bottom-up manner\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n\n    # Reconstruct the longest common subsequence from the L[][]\n    index = L[m][n]\n    lcs = [\"\"] * (index+1)\n    lcs[index] = \"\"\n\n    i = m\n    j = n\n    while i > 0 and j > 0:\n        if X[i-1] == Y[j-1]:\n            lcs[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n        elif L[i-1][j] > L[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(lcs)\n\n"}
{"task_id": "MBPP/188", "completion": "\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * i * j * j == n:\n                return True\n    return False\n"}
{"task_id": "MBPP/189", "completion": "\n    for i in range(n):\n        if arr[i] <= 0 or arr[i] > n:\n            arr[i] = n + 1\n    for i in range(n):\n        index = abs(arr[i]) - 1\n        arr[index] = -abs(arr[index])\n    for i in range(n):\n        if arr[i] > 0:\n            return i + 1\n    return n + 1\n\n"}
{"task_id": "MBPP/190", "completion": "\n    # Calculate the number of integral points on the boundary\n    boundary_points = 4\n    \n    # Calculate the number of integral points inside the square\n    inner_points = (x2 - x1 - 1) * (y2 - y1 - 1)\n    \n    # Total number of integral points\n    total_points = boundary_points + inner_points\n    \n    return total_points\n"}
{"task_id": "MBPP/191", "completion": "\n    if monthname3 in ('April', 'June', 'September', 'November'):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/192", "completion": "\n    has_letter = False\n    has_number = False\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        if has_letter and has_number:\n            return True\n    return False\n"}
{"task_id": "MBPP/193", "completion": "\n    res = tuple(set(test_tup))\n    return res\n"}
{"task_id": "MBPP/194", "completion": "\n    num = n\n    dec_value = 0\n    base = 1\n    temp = num\n    while temp:\n        last_digit = temp % 10\n        temp = int(temp / 10)\n        dec_value += last_digit * base\n        base = base * 8\n    return dec_value\n\n"}
{"task_id": "MBPP/195", "completion": "\n    low, high = 0, n - 1\n    res = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            res = mid\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return res\n"}
{"task_id": "MBPP/196", "completion": "\n    res = [ele for ele in test_list if len(ele) != K]\n    return res\n"}
{"task_id": "MBPP/197", "completion": "\n    res = tuple(pow(ele1, ele2) for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/198", "completion": "\n    # The largest triangle that can be inscribed in an ellipse is the one with the largest semi-major axis and semi-minor axis.\n    # The semi-major axis is the radius of the ellipse, and the semi-minor axis is the distance from the center of the ellipse to the focus.\n    # The area of the largest triangle is given by the formula: (3 * sqrt(3) * a^2) / 4\n    # where a is the semi-major axis of the ellipse.\n    # The perimeter of the largest triangle is given by the formula: 3 * a\n    # where a is the semi-major axis of the ellipse.\n    # The diameter of the largest triangle is given by the formula: 2 * a\n    # where a is the semi-major axis of the ellipse.\n    # The focus of the largest triangle is at the center of the ellipse.\n    # The vertices of the largest triangle are at the points: (a, 0), (0, a), and (-a, 0)\n    # where a is the semi-major axis of the ellipse.\n    # The equation of the ellipse is given by: (x^2 / a^2) + (y^2 / (b^2 * (1 - (x^2 / a^2)))) = 1\n    # where a is the semi-major axis of the ellipse, and b is the semi-minor axis of the ellipse.\n    # The equation of the line that passes through the focus and the center of the ellipse is given by: y = -b * sqrt(1 - (x^2 / a^2))\n    # where a is the semi-major axis of the ellipse, and b is the semi-minor axis of the ellipse.\n    # The equation of the line that passes through the focus and a point on the ellipse is given by: y = -b * sqrt(1 - (x^2 / a^2)) + b * sqrt(1 - ((x - a)^2 /"}
{"task_id": "MBPP/199", "completion": "\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/200", "completion": "\n    max_value = max(list1)\n    positions = [index for index, value in enumerate(list1) if value == max_value]\n    return positions\n"}
{"task_id": "MBPP/201", "completion": "\n    return all(x == lst[0] for x in lst)\n"}
{"task_id": "MBPP/202", "completion": "\n    return ''.join([char for i, char in enumerate(str1) if i % 2 == 1])\n"}
{"task_id": "MBPP/203", "completion": "\n    xor = n1 ^ n2\n    count = 0\n    while xor:\n        count += xor & 1\n        xor >>= 1\n    return count\n"}
{"task_id": "MBPP/204", "completion": "\n    return s.count(c)\n"}
{"task_id": "MBPP/205", "completion": "\n    res = [test_tup[i] for i in range(len(test_tup)) if test_tup[i] < test_tup[i - 1]]\n    return len(res)\n"}
{"task_id": "MBPP/206", "completion": "\n    # Using list comprehension and join() to concatenate adjacent elements\n    result = ''.join([str(test_tup[i]) + str(test_tup[i + 1]) for i in range(len(test_tup) - 1)])\n    return result\n"}
{"task_id": "MBPP/207", "completion": "\n    n = len(str)\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n\n    return dp[n][n]\n"}
{"task_id": "MBPP/208", "completion": "\n    pattern = re.compile(r\"^\\d+(\\.\\d{1,2})?$\")\n    return bool(pattern.match(num))\n\n"}
{"task_id": "MBPP/209", "completion": "\n    hq.heapify(heap)\n    return hq.heapreplace(heap, a)\n\n"}
{"task_id": "MBPP/210", "completion": "\n    pattern = re.compile(r'[^a-zA-Z0-9.]')\n    match = pattern.search(string)\n    return not bool(match)\n\n"}
{"task_id": "MBPP/211", "completion": "\n    count = 0\n    for i in range(1, 2**n):\n        if (i & (1 << 0)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/212", "completion": "\n    return sum([math.pow(i, 4) for i in range(1, n+1)])\n\n"}
{"task_id": "MBPP/213", "completion": "\n    # Using zip to pair up elements from both tuples and then join them\n    result = tuple(a + b for a, b in zip(test_tup1, test_tup2))\n    return result\n"}
{"task_id": "MBPP/214", "completion": "\n    return radian * (180 / math.pi)\n\n"}
{"task_id": "MBPP/215", "completion": "\n    decoded_list = []\n    for item in alist:\n        if isinstance(item, list):\n            decoded_list.extend([item[1]] * item[0])\n        else:\n            decoded_list.append(item)\n    return decoded_list\n"}
{"task_id": "MBPP/216", "completion": "\n    for sublist in list1:\n        if sublist not in list2:\n            return False\n    return True\n"}
{"task_id": "MBPP/217", "completion": "\n    char_set = set()\n    for char in str:\n        if char in char_set:\n            return char\n        char_set.add(char)\n    return None\n"}
{"task_id": "MBPP/218", "completion": "\n    # If A is greater than B, swap them\n    if A > B:\n        A, B = B, A\n\n    # If A is 0, return B\n    if A == 0:\n        return B\n\n    # If B is a multiple of A, return B/A - 1\n    if B % A == 0:\n        return B // A - 1\n\n    # If none of the above conditions are met, return -1\n    return -1\n\n"}
{"task_id": "MBPP/219", "completion": "\n    # Extracting min and max elements\n    min_val = min(test_tup)\n    max_val = max(test_tup)\n    \n    # Extracting min and max k elements\n    min_k_elements = sorted(test_tup)[:K]\n    max_k_elements = sorted(test_tup, reverse=True)[:K]\n    \n    return min_val, max_val, min_k_elements, max_k_elements\n"}
{"task_id": "MBPP/220", "completion": "\n    return re.sub(r'[ ,.]', ':', text, n)\n\n"}
{"task_id": "MBPP/221", "completion": "\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"task_id": "MBPP/222", "completion": "\n    res = all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple)\n    return (res) \n"}
{"task_id": "MBPP/223", "completion": "\n    index = first_occurrence(arr, n, x)\n    if index == -1:\n        return False\n    if ((index + n // 2) < n and arr[index + n // 2] == x):\n        return True\n    return False\n"}
{"task_id": "MBPP/224", "completion": "\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/225", "completion": "\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return arr[low]\n"}
{"task_id": "MBPP/226", "completion": "\n    return str[::2]\n"}
{"task_id": "MBPP/227", "completion": "\n    return min(a, b, c)\n"}
{"task_id": "MBPP/228", "completion": "\n    for i in range(l, r+1):\n        if (n & (1 << i)) != 0:\n            return False\n    return True\n"}
{"task_id": "MBPP/229", "completion": "\n    neg = []\n    pos = []\n    for i in range(n):\n        if arr[i] < 0:\n            neg.append(arr[i])\n        else:\n            pos.append(arr[i])\n    return neg + pos\n"}
{"task_id": "MBPP/230", "completion": "\n    return str1.replace(' ', char)\n"}
{"task_id": "MBPP/231", "completion": "\n    for i in range(n-1, -1, -1):\n        for j in range(len(tri[i])):\n            if j == 0:\n                tri[i][j] += tri[i+1][j]\n            elif j == len(tri[i])-1:\n                tri[i][j] += tri[i+1][j-1]\n            else:\n                tri[i][j] += max(tri[i+1][j], tri[i+1][j-1])\n    return tri[0][0]\n\n"}
{"task_id": "MBPP/232", "completion": "\n    return heapq.nlargest(n, list1)\n\n"}
{"task_id": "MBPP/233", "completion": "\n    return 2 * 3.14159 * r * h\n"}
{"task_id": "MBPP/234", "completion": "\n    return l ** 3\n"}
{"task_id": "MBPP/235", "completion": "\n    count = 0\n    temp = n\n    while temp > 0:\n        if count % 2 == 0:\n            n |= (1 << count)\n        count += 1\n        temp >>= 1\n    return n\n"}
{"task_id": "MBPP/236", "completion": "\n    if N < K:\n        return -1\n    else:\n        return ((N - K + 1) * (N - K + 2)) // 2\n"}
{"task_id": "MBPP/237", "completion": "\n    # Create a counter object\n    count_obj = Counter(test_list)\n    \n    # Get the maximum occurrence\n    max_occurrence = max(list(count_obj.values()))\n    \n    # Get the records with maximum occurrence\n    max_occurrence_records = [k for k, v in count_obj.items() if v == max_occurrence]\n    \n    return max_occurrence_records\n"}
{"task_id": "MBPP/238", "completion": "\n    return sum(i * (i + 1) // 2 for i in range(1, len(str) + 1))\n"}
{"task_id": "MBPP/239", "completion": "\n    MOD = 10**9 + 7\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if j == 1:\n                dp[i][j] = i\n            else:\n                dp[i][j] = (dp[i-1][j] + dp[i//2][j-1]) % MOD\n    return dp[m][n]\n"}
{"task_id": "MBPP/240", "completion": "\n    list1[-1:] = list2\n    return list1\n"}
{"task_id": "MBPP/241", "completion": "\n    return [[['*' for _ in range(m)] for _ in range(n)] for _ in range(o)]\n"}
{"task_id": "MBPP/242", "completion": "\n    count = 0\n    for i in str1:\n        count += 1\n    return count\n"}
{"task_id": "MBPP/243", "completion": "\n    return sorted(lst, key=lambda x: lst.count(x[0]))\n"}
{"task_id": "MBPP/244", "completion": "\n    root = math.ceil(math.sqrt(N))\n    return root ** 2\n\n"}
{"task_id": "MBPP/245", "completion": "\n    # Create two arrays to store maximum sum of increasing and decreasing subsequences\n    inc = [0]*n\n    dec = [0]*n\n\n    # Initialize the first element of both arrays\n    inc[0] = arr[0]\n    dec[n-1] = arr[n-1]\n\n    # Fill the inc array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n\n    # Fill the dec array\n    for i in range(n-2, -1, -1):\n        for j in range(i, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n\n    # Find the maximum sum of bi-tonic sub-sequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum\n"}
{"task_id": "MBPP/246", "completion": "\n    if number == 0:\n        return 0\n    estimate = number / 2.0\n    while True:\n        next_estimate = (estimate + number / estimate) / 2\n        if abs(next_estimate - estimate) < 1e-10:  # Arbitrary precision check\n            break\n        estimate = next_estimate\n    return estimate\n"}
{"task_id": "MBPP/247", "completion": "\n    n = len(str)\n    dp = [[0]*n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the table\n    for length in range(2, n+1):\n        for start in range(n-length+1):\n            end = start + length - 1\n            if str[start] == str[end] and length == 2:\n                dp[start][end] = 2\n            elif str[start] == str[end]:\n                dp[start][end] = dp[start+1][end-1] + 2\n            else:\n                dp[start][end] = max(dp[start][end-1], dp[start+1][end])\n    \n    return dp[0][n-1]\n"}
{"task_id": "MBPP/248", "completion": "\n    if n == 1:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)\n\n"}
{"task_id": "MBPP/249", "completion": "\n    intersection = list(filter(lambda x: x in array_nums1, array_nums2))\n    return intersection\n"}
{"task_id": "MBPP/250", "completion": "\n    return tup.count(x)\n"}
{"task_id": "MBPP/251", "completion": "\n    return [item for elt in list for item in (element, elt)]\n"}
{"task_id": "MBPP/252", "completion": "\n    polar_coordinates = [cmath.polar(num) for num in numbers]\n    return polar_coordinates\n\n"}
{"task_id": "MBPP/253", "completion": "\n    count = 0\n    for i in list1:\n        if isinstance(i, int):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/254", "completion": "\n    return re.findall(r'\\b[ae]\\w+', text, re.IGNORECASE)\n\n"}
{"task_id": "MBPP/255", "completion": "\n    colors = ['red', 'blue', 'green']\n    return list(combinations_with_replacement(colors, n))\n\n"}
{"task_id": "MBPP/256", "completion": "\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n"}
{"task_id": "MBPP/257", "completion": "\n    a, b = b, a\n    return a, b\n"}
{"task_id": "MBPP/258", "completion": "\n    odd_count = len(list(filter(lambda x: (x % 2 != 0), array_nums)))\n    return odd_count\n"}
{"task_id": "MBPP/259", "completion": "\n    res = tuple(max(x, y) for x, y in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/260", "completion": "\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def nsw_number(n):\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 1\n        else:\n            return 2 * nsw_number(n - 1) + nsw_number(n - 2)\n\n    count = 0\n    i = 0\n    while True:\n        num = nsw_number(i)\n        if is_prime(num):\n            count += 1\n            if count == n:\n                return num\n        i += 1\n"}
{"task_id": "MBPP/261", "completion": "\n    res = tuple(a / b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/262", "completion": "\n    return list1[:L], list1[L:]\n"}
{"task_id": "MBPP/263", "completion": "\n    return {**d1, **d2}\n"}
{"task_id": "MBPP/264", "completion": "\n    if h_age < 0:\n        return \"Invalid age\"\n    elif h_age <= 2:\n        d_age = h_age * 10.5\n    else:\n        d_age = 21 + (h_age - 2) * 4\n    return d_age\n"}
{"task_id": "MBPP/265", "completion": "\n    return [S[i::step] for i in range(step)]\n\n"}
{"task_id": "MBPP/266", "completion": "\n    return 4 * l ** 2\n"}
{"task_id": "MBPP/267", "completion": "\n    return n * (2 * n - 1) * (2 * n + 1) // 3\n"}
{"task_id": "MBPP/268", "completion": "\n    count = 0\n    num = 1\n    while count < n:\n        if str(num).count('5') == 0:\n            count += 1\n        num += 1\n    return num - 1\n\n"}
{"task_id": "MBPP/269", "completion": "\n    return ord(k)\n"}
{"task_id": "MBPP/270", "completion": "\n    sum_even = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum_even += arr[i]\n    return sum_even\n"}
{"task_id": "MBPP/271", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum\n"}
{"task_id": "MBPP/272", "completion": "\n    # Check if the list is empty\n    if not test_list:\n        return \"The list is empty.\"\n    \n    # Extract the last element from each tuple\n    result = [tup[-1] for tup in test_list]\n    \n    return result\n"}
{"task_id": "MBPP/273", "completion": "\n    res = tuple(a - b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/274", "completion": "\n    # Initialize result\n    res = 0\n\n    # Loop for all even index\n    for i in range(0, n + 1, 2):\n        # Calculate binomial coefficient\n        # and add it to result\n        res += math.comb(n, i)\n\n    return res\n\n"}
{"task_id": "MBPP/275", "completion": "\n    if n == 1:\n        return a[0]\n    else:\n        a.pop(a[m % n])\n        return get_Position(a, n - 1, m + 1)\n\n"}
{"task_id": "MBPP/276", "completion": "\n    pi = 3.14159\n    return pi * r * r * h\n"}
{"task_id": "MBPP/277", "completion": "\n    return {k: v for k, v in dict.items() if v > n}\n"}
{"task_id": "MBPP/278", "completion": "\n    res = {}\n    for idx, ele in enumerate(test_tup):\n        if isinstance(ele, tuple):\n            res[ele] = idx\n    return res\n"}
{"task_id": "MBPP/279", "completion": "\n    return n * 9\n"}
{"task_id": "MBPP/280", "completion": "\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos += 1\n    return found, pos\n"}
{"task_id": "MBPP/281", "completion": "\n    return len(test_list) == len(set(test_list))\n"}
{"task_id": "MBPP/282", "completion": "\n    result = map(lambda x, y: x - y, nums1, nums2)\n    return list(result)\n"}
{"task_id": "MBPP/283", "completion": "\n    for digit in range(10):\n        if str(digit) * (n + 1).count(str(digit)) > str(digit) * n:\n            return False\n    return True\n"}
{"task_id": "MBPP/284", "completion": "\n    return all(item == element for item in list)\n"}
{"task_id": "MBPP/285", "completion": "\n    pattern = 'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/286", "completion": "\n    max_sum = float('-inf')\n    current_sum = 0\n    total_sum = sum(a) * k\n    \n    for i in range(n * k):\n        current_sum += a[i % n]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max(max_sum, total_sum)\n"}
{"task_id": "MBPP/287", "completion": "\n    return (n * (n + 1) * (2 * n + 1)) // 3\n"}
{"task_id": "MBPP/288", "completion": "\n    count = 0\n    for i in range(N):\n        if arr[i] == (i * i) % P:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/289", "completion": "\n    # Calculate the number of 100-year increments\n    centuries = N // 100\n    # Calculate the number of 400-year increments\n    four_centuries = N // 400\n    # Calculate the number of leap years\n    leap_years = N // 4\n    # Calculate the number of ordinary days\n    ordinary_days = N - leap_years\n    # Adjust for centuries that are not leap years\n    if centuries:\n        ordinary_days += centuries\n        leap_years -= centuries\n    # Adjust for 400-year increments that are leap years\n    if four_centuries:\n        ordinary_days -= four_centuries\n        leap_years += four_centuries\n    # Calculate the total number of days\n    total_days = ordinary_days + leap_years * 2\n    # Calculate the number of odd days\n    odd_days = total_days % 7\n    return odd_days\n"}
{"task_id": "MBPP/290", "completion": "\n    max_len = max(len(sublist) for sublist in list1)\n    return [sublist for sublist in list1 if len(sublist) == max_len]\n"}
{"task_id": "MBPP/291", "completion": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same, diff = k, k * (k - 1)\n    total = same + diff\n    for i in range(3, n + 1):\n        same = diff\n        diff = total * (k - 1)\n        total = (same + diff) % 1000000007\n    return total\n"}
{"task_id": "MBPP/292", "completion": "\n    return n // m\n\n"}
{"task_id": "MBPP/293", "completion": "\n    return math.sqrt(w**2 + h**2)\n\n"}
{"task_id": "MBPP/294", "completion": "\n    max_val = listval[0]\n    for val in listval:\n        if val > max_val:\n            max_val = val\n    return max_val\n"}
{"task_id": "MBPP/295", "completion": "\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.append(i)\n            if i != number // i:\n                divisors.append(number // i)\n    return sum(divisors)\n\n"}
{"task_id": "MBPP/296", "completion": "\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\n"}
{"task_id": "MBPP/297", "completion": "\n    flattened_list = []\n    for item in list1:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    return flattened_list\n"}
{"task_id": "MBPP/298", "completion": "\n    result = []\n    for sublist1 in l1:\n        for sublist2 in l2:\n            if sublist1 in sublist2:\n                result.append(sublist1)\n    return result\n"}
{"task_id": "MBPP/299", "completion": "\n    aggregates = defaultdict(int)\n    for key, value in stdata:\n        aggregates[key] += value\n    return max(aggregates.values())\n\n"}
{"task_id": "MBPP/300", "completion": "\n    # Initialize the result\n    result = 0\n    \n    # Iterate over all possible combinations of first n bits\n    for i in range(n+1):\n        # Calculate the number of combinations for the second n bits\n        combinations = nCr(n, i)\n        \n        # Multiply the combinations by the square of the binomial coefficient\n        result += combinations * combinations\n    \n    return result\n"}
{"task_id": "MBPP/301", "completion": "\n    if not isinstance(d, dict) or not d:\n        return 0\n    else:\n        return 1 + max(dict_depth(value) for value in d.values())\n"}
{"task_id": "MBPP/302", "completion": "\n    if n == 0:\n        return 0\n    msb = 0\n    while n > 0:\n        n = n >> 1\n        msb += 1\n    return msb\n"}
{"task_id": "MBPP/303", "completion": "\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                count += 1\n    return count % 2 == 0\n\n"}
{"task_id": "MBPP/304", "completion": "\n    for rotation in rotations:\n        start, end = rotation\n        if start <= index <= end:\n            if index == start:\n                index = end\n            else:\n                index -= 1\n    return arr[index]\n"}
{"task_id": "MBPP/305", "completion": "\n    pattern = r'\\b(p\\w+)\\b.*\\b(p\\w+)\\b'\n    for word in words:\n        if re.match(pattern, word, re.IGNORECASE):\n            return True\n    return False\n\n"}
{"task_id": "MBPP/306", "completion": "\n    if index == n:\n        return 0\n\n    # If the current element is greater than the kth element, then we can include it in the subsequence\n    if a[index] > a[k]:\n        return max(a[index] + max_sum_increasing_subseq(a, n, index + 1, k), max_sum_increasing_subseq(a, n, index + 1, k))\n    else:\n        return max_sum_increasing_subseq(a, n, index + 1, k)\n"}
{"task_id": "MBPP/307", "completion": "\n    return tuplex[m:n]\n\n"}
{"task_id": "MBPP/308", "completion": "\n    # Calculate all possible products\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    \n    # Sort the products in descending order and return the top N\n    return sorted(products, reverse=True)[:N]\n"}
{"task_id": "MBPP/309", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/310", "completion": "\n    return tuple(str1)\n"}
{"task_id": "MBPP/311", "completion": "\n    if n == 0:\n        return 1\n    # If the rightmost bit is set, we can't set the leftmost unset bit\n    if n & 1:\n        return n\n    # Otherwise, we can set the leftmost unset bit by adding 1 to n\n    return n + 1\n"}
{"task_id": "MBPP/312", "completion": "\n    return (1/3) * math.pi * r**2 * h\n\n"}
{"task_id": "MBPP/313", "completion": "\n    for i in list1:\n        if i > 0:\n            print(i)\n"}
{"task_id": "MBPP/314", "completion": "\n    # Initialize the maximum sum to be the first element of the grid\n    max_sum = grid[0][0]\n\n    # Iterate over the grid\n    for i in range(2):\n        for j in range(n):\n            # If the current element is not the first element, add it to the maximum sum\n            if i > 0 and j > 0:\n                grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n            # Update the maximum sum if the current element is greater\n            max_sum = max(max_sum, grid[i][j])\n\n    return max_sum\n"}
{"task_id": "MBPP/315", "completion": "\n    words = str.split()\n    max_len = 0\n    max_word = \"\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_word = word\n    return max_word\n"}
{"task_id": "MBPP/316", "completion": "\n    low, high = 0, len(A) - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if A[mid] == x:\n            result = mid\n            low = mid + 1\n        elif A[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n"}
{"task_id": "MBPP/317", "completion": "\n    def encode_group(group):\n        count = len(group)\n        element = group[0]\n        if count == 1:\n            return element\n        else:\n            return (count, element)\n\n    return [encode_group(list(group)) for _, group in groupby(alist)]\n\n"}
{"task_id": "MBPP/318", "completion": "\n    sides = sorted(list(set(s)))\n    max_vol = 0\n    for i in range(len(sides)):\n        for j in range(i+1, len(sides)):\n            for k in range(j+1, len(sides)):\n                if sides[i] + sides[j] + sides[k] == s:\n                    max_vol = max(max_vol, sides[i] * sides[j] * sides[k])\n    return max_vol\n"}
{"task_id": "MBPP/319", "completion": "\n    return re.findall(r\"\\b\\w{5}\\b\", text)\n\n"}
{"task_id": "MBPP/320", "completion": "\n    # Calculate the sum of first n natural numbers\n    sum_natural = n * (n + 1) // 2\n    \n    # Calculate the sum of squares of first n natural numbers\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the difference\n    difference = sum_natural ** 2 - sum_squares\n    \n    return difference\n"}
{"task_id": "MBPP/321", "completion": "\n    # Convert the number to a string\n    s = str(s)\n    \n    # Initialize the demlo number\n    demlo = \"\"\n    \n    # Iterate over the string in reverse\n    for i in range(len(s)-1, -1, -1):\n        # If the current digit is greater than or equal to the next digit, add it to the demlo number\n        if s[i] >= s[i+1]:\n            demlo += s[i]\n        # If the current digit is less than the next digit, add all the digits between them to the demlo number\n        else:\n            for j in range(i, -1, -1):\n                if s[j] < s[i+1]:\n                    demlo += s[j]\n                else:\n                    break\n    \n    # Return the demlo number\n    return demlo\n"}
{"task_id": "MBPP/322", "completion": "\n    min_value = min(list1)\n    positions = [index for index, value in enumerate(list1) if value == min_value]\n    return positions\n"}
{"task_id": "MBPP/323", "completion": "\n    while out_of_place < n:\n        if cur % 2 == 0:\n            if arr[out_of_place] >= 0:\n                out_of_place += 1\n            else:\n                arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n        else:\n            if arr[out_of_place] < 0:\n                out_of_place += 1\n            else:\n                arr[cur], arr[out_of_place] = arr[out_of_place], arr[cur]\n        cur += 1\n    return arr\n"}
{"task_id": "MBPP/324", "completion": "\n    result = 0\n    for i in range(0, len(test_tuple), 2):\n        result += test_tuple[i]\n    return result\n"}
{"task_id": "MBPP/325", "completion": "\n    # Base cases\n    if n <= 3:\n        return n\n\n    # This array will store the minimum number of squares that sum up to i\n    dp = [float('inf')] * (n + 1)\n\n    # Zero has zero squares, base case\n    dp[0] = 0\n\n    # Precompute the minimum squares for all numbers up to n\n    for i in range(1, n + 1):\n        # Check squares of numbers up to i\n        for j in range(1, int(i**0.5) + 1):\n            square = j*j\n            if square <= i:\n                dp[i] = min(dp[i], dp[i - square] + 1)\n            else:\n                break\n\n    return dp[n]\n"}
{"task_id": "MBPP/326", "completion": "\n    word_count = defaultdict(int)\n    for word in test_list:\n        word_count[word] += 1\n    return max(word_count, key=word_count.get)\n\n"}
{"task_id": "MBPP/327", "completion": "\n    if x == y or y == z or z == x:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n"}
{"task_id": "MBPP/328", "completion": "\n    # Calculate the effective rotation needed\n    rotation = m % len(list1)\n    # Perform the rotation\n    rotated_list = list1[rotation:] + list1[:rotation]\n    return rotated_list\n"}
{"task_id": "MBPP/329", "completion": "\n    count = 0\n    for num in list:\n        if num < 0:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/330", "completion": "\n    return re.findall(r\"\\b\\w{3,5}\\b\", text)\n\n"}
{"task_id": "MBPP/331", "completion": "\n    count = 0\n    while n > 0:\n        if n & 1 == 0:\n            count += 1\n        n >>= 1\n    return count\n"}
{"task_id": "MBPP/332", "completion": "\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if n in keys:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict\n"}
{"task_id": "MBPP/333", "completion": "\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li\n"}
{"task_id": "MBPP/334", "completion": "\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/335", "completion": "\n    return n/2 * (2*a + (n-1)*d)\n"}
{"task_id": "MBPP/336", "completion": "\n    months_with_28_days = [\"February\", \"Feb\"]\n    return monthname1 in months_with_28_days\n"}
{"task_id": "MBPP/337", "completion": "\n    pattern = r'\\b\\w+\\b$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/338", "completion": "\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/339", "completion": "\n    divisor_count = {}\n    for i in range(x, y+1):\n        for j in range(1, i+1):\n            if i % j == 0:\n                if j in divisor_count:\n                    divisor_count[j] += 1\n                else:\n                    divisor_count[j] = 1\n    max_divisor = max(divisor_count, key=divisor_count.get)\n    return max_divisor\n"}
{"task_id": "MBPP/340", "completion": "\n    # Filter out non-positive numbers and sort the remaining numbers\n    positive_nums = sorted([num for num in lst if num > 0])\n    \n    # Sum the first three numbers in the sorted list\n    return sum(positive_nums[:3])\n"}
{"task_id": "MBPP/341", "completion": "\n    return tuple(sorted(s))\n"}
{"task_id": "MBPP/342", "completion": "\n    # Create a min heap to store the elements of the arrays\n    min_heap = []\n    for i in range(len(list)):\n        heappush(min_heap, Node(list[i][0], i, 0))\n\n    # Initialize the maximum element and the range\n    max_element = max(node.value for node in min_heap)\n    range_start, range_end = min_heap[0].value, max_element\n\n    # Iterate until the last element of the last array is not included in the range\n    while min_heap[-1].index + 1 < len(list[min_heap[-1].list_num]):\n        # Pop the smallest element from the heap\n        smallest_node = heappop(min_heap)\n\n        # Update the maximum element\n        max_element = max(max_element, smallest_node.value)\n\n        # Push the next element from the same array to the heap\n        next_index = smallest_node.index + 1\n        next_node = Node(list[smallest_node.list_num][next_index], smallest_node.list_num, next_index)\n        heappush(min_heap, next_node)\n\n        # Update the range if the current range is smaller\n        if max_element - min_heap[0].value < range_end - range_start:\n            range_start, range_end = min_heap[0].value, max_element\n\n    return range_start, range_end\n\n"}
{"task_id": "MBPP/343", "completion": "\n    digits = letters = 0\n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n    return digits, letters\n"}
{"task_id": "MBPP/344", "completion": "\n    count = 0\n    for i in range(n, m+1):\n        if i**0.5 == int(i**0.5):\n            count += 1\n    return count\n"}
{"task_id": "MBPP/345", "completion": "\n    return [nums[i+1] - nums[i] for i in range(len(nums)-1)]\n"}
{"task_id": "MBPP/346", "completion": "\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    return zigzag(n, k - 1) + zigzag(n - 1, n - k)\n\n"}
{"task_id": "MBPP/347", "completion": "\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i * i <= m and j * j <= n:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/348", "completion": "\n    # Create a 2D array to store intermediate results\n    C = [[0 for _ in range(r+1)] for _ in range(n+1)]\n\n    # Fill the array with binomial coefficients\n    for i in range(n+1):\n        for j in range(min(i, r)+1):\n            if j == 0:\n                C[i][j] = 1\n            else:\n                C[i][j] = C[i-1][j] + j*C[i-1][j-1]\n\n    return C[n][r]\n"}
{"task_id": "MBPP/349", "completion": "\n    return set(string) == {'0', '1'}\n"}
{"task_id": "MBPP/350", "completion": "\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_freq = max(freq.values())\n    \n    # Calculate the minimum length of the string\n    min_len = len(s) - max_freq\n    \n    return min_len\n"}
{"task_id": "MBPP/351", "completion": "\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for i in range(n):\n        if arr[i] in count_dict:\n            count_dict[arr[i]] += 1\n        else:\n            count_dict[arr[i]] = 1\n\n    # Iterate through the array and return the first element that occurs k times\n    for i in range(n):\n        if count_dict[arr[i]] == k:\n            return arr[i]\n\n    # If no element occurs k times, return -1\n    return -1\n"}
{"task_id": "MBPP/352", "completion": "\n    # Create a set to store unique characters\n    unique_chars = set()\n\n    # Iterate over each character in the string\n    for char in str:\n        # If the character is already in the set, it's not unique\n        if char in unique_chars:\n            return False\n        # Add the character to the set\n        unique_chars.add(char)\n\n    # If we reach here, all characters were unique\n    return True\n"}
{"task_id": "MBPP/353", "completion": "\n    return [row[:n] + row[n+1:] for row in list1]\n"}
{"task_id": "MBPP/354", "completion": "\n    tn = a + (n - 1) * d\n    return tn\n\n"}
{"task_id": "MBPP/355", "completion": "\n    count = 0\n    for i in range(1, radius):\n        for j in range(i, radius):\n            if (i * j) % 2 == 0:\n                count += 1\n    return count\n"}
{"task_id": "MBPP/356", "completion": "\n    return 180 - (a + b)\n"}
{"task_id": "MBPP/357", "completion": "\n    max_val = max(max(sub) for sub in test_list)\n    return max_val\n"}
{"task_id": "MBPP/358", "completion": "\n    result = map(lambda x, y: x % y if y != 0 else \"Division by zero\", nums1, nums2)\n    return list(result)\n"}
{"task_id": "MBPP/359", "completion": "\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is non-negative\n    if discriminant >= 0:\n        # Calculate the roots\n        root1 = (-b + (discriminant**0.5)) / (2*a)\n        root2 = (-b - (discriminant**0.5)) / (2*a)\n        \n        # Check if one root is twice the other\n        if root1 == 2*root2 or root2 == 2*root1:\n            return True\n        else:\n            return False\n    else:\n        return False\n"}
{"task_id": "MBPP/360", "completion": "\n    return (-1) ** (n + 1) * (2 ** n - 1) ** 2\n"}
{"task_id": "MBPP/361", "completion": "\n    return [sublist for sublist in list1 if sublist]\n"}
{"task_id": "MBPP/362", "completion": "\n    if not nums:\n        return None\n\n    num_counts = {}\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    max_occurrences_num = max(num_counts, key=num_counts.get)\n    return max_occurrences_num\n\n"}
{"task_id": "MBPP/363", "completion": "\n    res = [ele + K for ele in test_list]\n    return (res)\n"}
{"task_id": "MBPP/364", "completion": "\n    flip_count = 0\n    expected_char = ch\n    for char in ch:\n        if char != expected_char:\n            flip_count += 1\n        expected_char = '0' if expected_char == '1' else '1'\n    return flip_count\n"}
{"task_id": "MBPP/365", "completion": "\n    count = 0\n    while n != 0:\n        n //= 10\n        count += 1\n    return count\n"}
{"task_id": "MBPP/366", "completion": "\n    if len(list_nums) < 2:\n        return None\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(1, len(list_nums) - 1):\n        max_product = max(max_product, list_nums[i] * list_nums[i + 1])\n    return max_product\n"}
{"task_id": "MBPP/367", "completion": "\n    if root is None:\n        return True\n\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n\n    if abs(left_height - right_height) <= 1 and is_tree_balanced(root.left) and is_tree_balanced(root.right):\n        return True\n    return False\n\n"}
{"task_id": "MBPP/368", "completion": "\n    res = tuple(ele for tup in test_tup for ele in tup for _ in range(N))\n    return res\n"}
{"task_id": "MBPP/369", "completion": "\n    return 2 * (h * (l + w))\n\n"}
{"task_id": "MBPP/370", "completion": "\n    return float(price[1])\n"}
{"task_id": "MBPP/371", "completion": "\n    if left_element > right_element:\n        return left_element\n    if A[left_element] == left_element + 1:\n        return smallest_missing(A, left_element + 1, right_element)\n    mid_element = (left_element + right_element) // 2\n    if A[mid_element] == mid_element + 1:\n        return smallest_missing(A, mid_element + 1, right_element)\n    return smallest_missing(A, left_element, mid_element - 1)\n\n"}
{"task_id": "MBPP/372", "completion": "\n    hq.heapify(nums)\n    return [hq.heappop(nums) for _ in range(len(nums))]\n\n"}
{"task_id": "MBPP/373", "completion": "\n    return l * w * h\n"}
{"task_id": "MBPP/374", "completion": "\n    if len(str) == 0:\n        return ['']\n    if len(str) == 1:\n        return [str]\n    \n    permutations = []\n    for i in range(len(str)):\n        char = str[i]\n        remaining_str = str[:i] + str[i+1:]\n        for permutation in permute_string(remaining_str):\n            permutations.append(char + permutation)\n    \n    return permutations\n"}
{"task_id": "MBPP/375", "completion": "\n    return round(n / m) * m\n"}
{"task_id": "MBPP/376", "completion": "\n    seen = set()\n    result = []\n    for item in test_tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n        else:\n            result.append('Duplicate')\n    return tuple(result)\n"}
{"task_id": "MBPP/377", "completion": "\n    return s.replace(c, '')\n"}
{"task_id": "MBPP/378", "completion": "\n    # Check if list is empty\n    if not test_list:\n        return []\n\n    # Move last element to first position\n    test_list = test_list[-1:] + test_list[:-1]\n\n    return test_list\n\n"}
{"task_id": "MBPP/379", "completion": "\n    return 2 * (l*w + w*h + h*l)\n"}
{"task_id": "MBPP/380", "completion": "\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]\n"}
{"task_id": "MBPP/381", "completion": "\n    return sorted(list_data, key=itemgetter(index_no))\n\n"}
{"task_id": "MBPP/382", "completion": "\n    start, end = 0, len(A) - 1\n    while start <= end:\n        if A[start] <= A[end]:\n            return start\n        mid = (start + end) // 2\n        next_index = (mid + 1) % len(A)\n        prev_index = (mid - 1 + len(A)) % len(A)\n        if A[mid] <= A[next_index] and A[mid] <= A[prev_index]:\n            return mid\n        elif A[mid] <= A[end]:\n            end = mid - 1\n        else:\n            start = mid + 1\n    return -1\n"}
{"task_id": "MBPP/383", "completion": "\n    result = 0\n    count = 0\n    temp = n\n    \n    # Iterate through all bits of n\n    while temp > 0:\n        # Check if the current bit position is even\n        if count % 2 == 0:\n            # Set the bit at the current position in result\n            result |= (1 << count)\n        count += 1\n        temp >>= 1\n    \n    # XOR the original number with the result to toggle the odd bits\n    return n ^ result\n"}
{"task_id": "MBPP/384", "completion": "\n    smallest = min(arr)\n    frequency = arr.count(smallest)\n    return frequency\n"}
{"task_id": "MBPP/385", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 3)\n\n"}
{"task_id": "MBPP/386", "completion": "\n    open_brackets = []\n    close_brackets = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            open_brackets.append(i)\n        else:\n            close_brackets.append(i)\n    swaps = 0\n    i = j = 0\n    while i < len(open_brackets) and j < len(close_brackets):\n        if open_brackets[i] < close_brackets[j]:\n            i += 1\n        else:\n            swaps += 1\n            j += 1\n    return swaps\n"}
{"task_id": "MBPP/387", "completion": "\n    if N[-1] in '02468ACE':\n        return 'Even'\n    else:\n        return 'Odd'\n"}
{"task_id": "MBPP/388", "completion": "\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n"}
{"task_id": "MBPP/389", "completion": "\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n - 1) + find_lucas(n - 2)\n\n"}
{"task_id": "MBPP/390", "completion": "\n    return [string + item for item in list]\n"}
{"task_id": "MBPP/391", "completion": "\n    return {l1[i]: {l2[i]: l3[i]} for i in range(len(l1))}\n"}
{"task_id": "MBPP/392", "completion": "\n    # Initialize a list to store the maximum sums for each number up to n\n    max_sums = [0] * (n + 1)\n    \n    # Base cases\n    max_sums[0] = 0\n    max_sums[1] = 1\n    \n    # Fill in the list with the maximum sums\n    for i in range(2, n + 1):\n        max_sums[i] = max(i, max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5])\n    \n    # Return the maximum sum for n\n    return max_sums[n]\n"}
{"task_id": "MBPP/393", "completion": "\n    max_length_list = max(input_list, key=lambda x: len(x))\n    return max_length_list\n"}
{"task_id": "MBPP/394", "completion": "\n    res = len(test_tup) == len(set(test_tup))\n    return (res)\n"}
{"task_id": "MBPP/395", "completion": "\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n"}
{"task_id": "MBPP/396", "completion": "\n    return bool(re.match(regex, string, re.IGNORECASE))\n\n"}
{"task_id": "MBPP/397", "completion": "\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n"}
{"task_id": "MBPP/398", "completion": "\n    return [sum(int(digit) for digit in str(abs(num))) for num in nums]\n"}
{"task_id": "MBPP/399", "completion": "\n    res = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/400", "completion": "\n    res = {}\n    for sub in test_list:\n        sub.sort()\n        sub_str = str(sub)\n        if sub_str in res:\n            res[sub_str] += 1\n        else:\n            res[sub_str] = 1\n    return res\n"}
{"task_id": "MBPP/401", "completion": "\n    res = tuple(map(lambda x, y: (sum(x), sum(y)), test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/402", "completion": "\n    # Initialize an array to store intermediate results\n    C = [0 for _ in range(r+1)]\n    C[0] = 1  # nC0 is 1\n\n    # Calculate value of [nCr]%p using bottom-up approach\n    for i in range(1, n+1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, r), 0, -1):\n            C[j] = (C[j] + C[j-1]) % p\n\n    return C[r]\n"}
{"task_id": "MBPP/403", "completion": "\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return re.match(regex, str) is not None\n\n"}
{"task_id": "MBPP/404", "completion": "\n    if a < b:\n        return a\n    else:\n        return b\n"}
{"task_id": "MBPP/405", "completion": "\n    if tuplex == tuple1:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/406", "completion": "\n    count = 0\n    while x:\n        count += x & 1\n        x >>= 1\n    return count % 2\n"}
{"task_id": "MBPP/407", "completion": "\n    digits = list(str(n))\n    for i in range(len(digits)-2, -1, -1):\n        if digits[i] < digits[i+1]:\n            right = digits[i:]\n            smallest_bigger = min(filter(lambda x: x > right[0], right))\n            right.remove(smallest_bigger)\n            right.sort()\n            digits[i:] = [smallest_bigger] + right\n            return int(\"\".join(digits))\n    return -1\n"}
{"task_id": "MBPP/408", "completion": "\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    min_heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\n\n    result = []\n    while min_heap and len(result) < k:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result\n\n"}
{"task_id": "MBPP/409", "completion": "\n    min_product = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    return min_product\n"}
{"task_id": "MBPP/410", "completion": "\n    min_val = listval[0]\n    for val in listval:\n        if val < min_val:\n            min_val = val\n    return min_val\n"}
{"task_id": "MBPP/411", "completion": "\n    return re.sub(r'(?<!^)_([a-zA-Z])', lambda match: match.group(1).upper(), word)\n\n"}
{"task_id": "MBPP/412", "completion": "\n    return [x for x in l if x % 2 == 0]\n"}
{"task_id": "MBPP/413", "completion": "\n    return [tup[n] for tup in list1]\n"}
{"task_id": "MBPP/414", "completion": "\n    for i in list1:\n        if i in list2:\n            return True\n    return False\n"}
{"task_id": "MBPP/415", "completion": "\n    if len(arr) < 2:\n        return \"No pairs exists\"\n    \n    # Initialize the maximum and second maximum elements\n    max_element = max(arr[0], arr[1])\n    second_max_element = min(arr[0], arr[1])\n    \n    # Initialize the minimum and second minimum elements\n    min_element = min(arr[0], arr[1])\n    second_min_element = max(arr[0], arr[1])\n    \n    for i in range(2, len(arr)):\n        # Update the maximum and second maximum elements\n        if arr[i] > max_element:\n            second_max_element = max_element\n            max_element = arr[i]\n        elif arr[i] > second_max_element:\n            second_max_element = arr[i]\n        \n        # Update the minimum and second minimum elements\n        if arr[i] < min_element:\n            second_min_element = min_element\n            min_element = arr[i]\n        elif arr[i] < second_min_element:\n            second_min_element = arr[i]\n    \n    # Compare the product of max_element and second_max_element with the product of min_element and second_min_element\n    if max_element * second_max_element > min_element * second_min_element:\n        return max_element * second_max_element\n    else:\n        return min_element * second_min_element\n"}
{"task_id": "MBPP/416", "completion": "\n    # Create a list to store the maximum sum for each number up to n\n    maxSum = [0] * (n + 1)\n\n    # Base cases\n    maxSum[0] = 0\n    maxSum[1] = 1\n\n    # Fill in the maxSum list\n    for i in range(2, n + 1):\n        # Check each possible division of i\n        for j in range(1, i):\n            # If the sum of the three parts is greater than i, use it\n            if j * j * j + maxSum[j] + maxSum[i - j] > maxSum[i]:\n                maxSum[i] = j * j * j + maxSum[j] + maxSum[i - j]\n\n    return maxSum[n]\n\n"}
{"task_id": "MBPP/417", "completion": "\n    result = []\n    for i in Input:\n        if i[0] not in result:\n            result.append(i[0])\n    return result\n"}
{"task_id": "MBPP/418", "completion": "\n    max_len = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n"}
{"task_id": "MBPP/419", "completion": "\n    total = 0\n    for num in list1:\n        total += round(num)\n    return total * len(list1)\n"}
{"task_id": "MBPP/420", "completion": "\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**3\n    return sum\n"}
{"task_id": "MBPP/421", "completion": "\n    # Define the delimiter\n    delim = \"-\"\n    \n    # Concatenate the elements of the tuple\n    result = delim.join(test_tup)\n    \n    return result\n"}
{"task_id": "MBPP/422", "completion": "\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    average = sum_of_cubes / n\n    return average\n"}
{"task_id": "MBPP/423", "completion": "\n    # Create a table to store intermediate results\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    # Fill the table in bottom-up manner\n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            # Gold at cell (i, j) can be collected in two ways:\n            # 1. Collect gold from cell (i, j) and move right\n            # 2. Collect gold from cell (i, j) and move down\n            right = dp[i][j+1] if j < n-1 else 0\n            down = dp[i+1][j] if i < m-1 else 0\n            dp[i][j] = gold[i][j] + max(right, down)\n\n    # The maximum gold collected will be the maximum value in the first column of the table\n    return dp[0][0]\n"}
{"task_id": "MBPP/424", "completion": "\n    result = tuple(item[-1] for item in test_tuple)\n    return result\n"}
{"task_id": "MBPP/425", "completion": "\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": "MBPP/426", "completion": "\n    odd_nums = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_nums\n"}
{"task_id": "MBPP/427", "completion": "\n    return re.sub(r'(\\d{4})-(\\d{2})-(\\d{2})', r'\\3-\\2-\\1', dt)\n\n"}
{"task_id": "MBPP/428", "completion": "\n    n = len(my_list)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    return my_list\n"}
{"task_id": "MBPP/429", "completion": "\n    res = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/430", "completion": "\n    # The formula for the directrix of a parabola is y = c - (b^2 + 1)/(4a)\n    directrix = c - (b**2 + 1) / (4 * a)\n    return directrix\n"}
{"task_id": "MBPP/431", "completion": "\n    for element in list1:\n        if element in list2:\n            return True\n    return False\n"}
{"task_id": "MBPP/432", "completion": "\n    return (base1 + base2) / 2\n"}
{"task_id": "MBPP/433", "completion": "\n    for i in arr:\n        if number <= i:\n            return False\n    return True\n"}
{"task_id": "MBPP/434", "completion": "\n    pattern = 'ab+?'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/435", "completion": "\n    return n % 10\n"}
{"task_id": "MBPP/436", "completion": "\n    for i in list1:\n        if i < 0:\n            print(i)\n"}
{"task_id": "MBPP/437", "completion": "\n    return ''.join([char for char in str1 if int(char) % 2 == 0])\n"}
{"task_id": "MBPP/438", "completion": "\n    res = 0\n    for idx in range(len(test_list)):\n        for idx1 in range(idx + 1, len(test_list)):\n            if test_list[idx] == test_list[idx1][::-1]:\n                res += 1\n    return res\n"}
{"task_id": "MBPP/439", "completion": "\n    result = 0\n    for num in L:\n        result = result * 10 + num\n    return result\n"}
{"task_id": "MBPP/440", "completion": "\n    adverbs = re.findall(r'\\b\\w+ly\\b', text)\n    positions = [(m.start(), m.end(), m.group()) for m in re.finditer(r'\\b\\w+ly\\b', text)]\n    return adverbs, positions\n\n"}
{"task_id": "MBPP/441", "completion": "\n    return 6 * l ** 2\n"}
{"task_id": "MBPP/442", "completion": "\n    total = len(nums)\n    positive = sum(1 for num in nums if num > 0)\n    return positive / total\n\n"}
{"task_id": "MBPP/443", "completion": "\n    largest_neg = None\n    for num in list1:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n    return largest_neg\n"}
{"task_id": "MBPP/444", "completion": "\n    res = [tuple(ele[:-K] if len(ele) > K else ele for ele in sub) for sub in test_list]\n    return (res)\n"}
{"task_id": "MBPP/445", "completion": "\n    res = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    return res\n"}
{"task_id": "MBPP/446", "completion": "\n    # Create a counter object for the tuple\n    tup_counter = Counter(tup)\n    \n    # Create a counter object for the list\n    lst_counter = Counter(lst)\n    \n    # Use the & operator to find the intersection of the two counters\n    common_elements = tup_counter & lst_counter\n    \n    # Return the count of each common element\n    return {element: common_elements[element] for element in common_elements}\n\n"}
{"task_id": "MBPP/447", "completion": "\n    cubes = list(map(lambda x: x**3, nums))\n    return cubes\n"}
{"task_id": "MBPP/448", "completion": "\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c = 3, 0, 2\n        sum = 5\n        for i in range(3, n + 1):\n            d = a + b\n            sum += d\n            a, b, c = b, c, d\n        return sum\n\n"}
{"task_id": "MBPP/449", "completion": "\n    # Calculate area of triangle formed by 3 points\n    area = 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    \n    # If area is 0, then points are collinear and triangle is not valid\n    if area == 0:\n        return False\n    else:\n        return True\n"}
{"task_id": "MBPP/450", "completion": "\n    return [s[:l] for s in str]\n"}
{"task_id": "MBPP/451", "completion": "\n    return re.sub(r'\\s+', '', text1)\n\n"}
{"task_id": "MBPP/452", "completion": "\n    if actual_cost > sale_amount:\n        loss = actual_cost - sale_amount\n        return loss\n    else:\n        return None\n"}
{"task_id": "MBPP/453", "completion": "\n    sum = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n            if (n // i) % 2 == 0 and i != math.sqrt(n):\n                sum += n // i\n    return sum\n\n"}
{"task_id": "MBPP/454", "completion": "\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n"}
{"task_id": "MBPP/455", "completion": "\n    if monthnum2 == 1 or monthnum2 == 3 or monthnum2 == 5 or monthnum2 == 7 or monthnum2 == 8 or monthnum2 == 10 or monthnum2 == 12:\n        return True\n    else:\n        return False\n"}
{"task_id": "MBPP/456", "completion": "\n    return [s[::-1] for s in stringlist]\n"}
{"task_id": "MBPP/457", "completion": "\n    min_len = min(len(i) for i in lst)\n    min_sublist = [i for i in lst if len(i) == min_len]\n    return min_sublist\n"}
{"task_id": "MBPP/458", "completion": "\n    return l * b\n"}
{"task_id": "MBPP/459", "completion": "\n    return re.sub('[A-Z]', '', str1)\n\n"}
{"task_id": "MBPP/460", "completion": "\n    return [sublist[0] for sublist in lst]\n"}
{"task_id": "MBPP/461", "completion": "\n    ctr = 0\n    for char in str:\n        if char.isupper():\n            ctr += 1\n    return ctr\n"}
{"task_id": "MBPP/462", "completion": "\n    if len(list1) == 0:\n        return [[]]\n    else:\n        first, *rest = list1\n        combinations_without_first = combinations_list(rest)\n        combinations_with_first = [ [first] + combo for combo in combinations_without_first ]\n        return combinations_without_first + combinations_with_first\n"}
{"task_id": "MBPP/463", "completion": "\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result\n"}
{"task_id": "MBPP/464", "completion": "\n    return all(value == n for value in dict.values())\n"}
{"task_id": "MBPP/465", "completion": "\n    return {k: v for k, v in dict1.items() if v}\n"}
{"task_id": "MBPP/466", "completion": "\n    mid = low + (high - low) // 2\n\n    # Check if the middle element is greater than or equal to its neighbors\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n            (mid == n - 1 or arr[mid + 1] <= arr[mid])):\n        return mid\n\n    # If the left neighbor is greater, recurse on the left subarray\n    elif mid > 0 and arr[mid - 1] > arr[mid]:\n        return find_peak_util(arr, low, (mid - 1), n)\n\n    # If the right neighbor is greater, recurse on the right subarray\n    else:\n        return find_peak_util(arr, (mid + 1), high, n)\n\n"}
{"task_id": "MBPP/467", "completion": "\n    octalNum = 0\n    multiplier = 1\n    while deciNum != 0:\n        remainder = deciNum % 8\n        octalNum += remainder * multiplier\n        deciNum //= 8\n        multiplier *= 10\n    return octalNum\n\n"}
{"task_id": "MBPP/468", "completion": "\n    # Initialize an array to store the maximum product subsequence ending at each index\n    max_prod_subseq = [0] * n\n    max_prod_subseq[:] = arr[:]\n\n    # Iterate over the array\n    for i in range(1, n):\n        for j in range(i):\n            # If the current element is greater than the previous element and the product of the current element and the maximum product subsequence ending at the previous index is greater than the current maximum product subsequence ending at the current index\n            if arr[i] > arr[j] and max_prod_subseq[i] < max_prod_subseq[j] * arr[i]:\n                max_prod_subseq[i] = max_prod_subseq[j] * arr[i]\n\n    # Return the maximum product subsequence\n    return max(max_prod_subseq)\n"}
{"task_id": "MBPP/469", "completion": "\n    n = len(price)\n    if k >= n // 2:\n        return quick_profit(price)\n\n    profit = [[0 for _ in range(n)] for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -price[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j - 1], price[j] + max_diff)\n            max_diff = max(max_diff, profit[i - 1][j] - price[j])\n    return profit[k][n - 1]\n\n"}
{"task_id": "MBPP/470", "completion": "\n    res = tuple(map(lambda x, y: x + y, test_tup[::2], test_tup[1::2]))\n    return res\n"}
{"task_id": "MBPP/471", "completion": "\n    rem = 1\n    for i in range(lens):\n        rem = (rem * (arr[i] % n)) % n\n    return rem\n"}
{"task_id": "MBPP/472", "completion": "\n    return sorted(l) == list(range(min(l), max(l)+1))\n"}
{"task_id": "MBPP/473", "completion": "\n    res = tuple(set(test_list1) & set(test_list2))\n    return res\n"}
{"task_id": "MBPP/474", "completion": "\n    str1 = str1.replace(ch, newch)\n    return str1\n"}
{"task_id": "MBPP/475", "completion": "\n    return dict(sorted(dict1.items(), key=lambda item: item[1]))\n\n"}
{"task_id": "MBPP/476", "completion": "\n    return max(nums) + min(nums)\n"}
{"task_id": "MBPP/477", "completion": "\n    return string.lower()\n"}
{"task_id": "MBPP/478", "completion": "\n    return re.sub('[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/479", "completion": "\n    while n >= 10:\n        n = n / 10\n    return int(n)\n"}
{"task_id": "MBPP/480", "completion": "\n    max_count = 0\n    max_char = ''\n    for char in str1:\n        if str1.count(char) > max_count:\n            max_count = str1.count(char)\n            max_char = char\n    return max_char\n"}
{"task_id": "MBPP/481", "completion": "\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n    if set[n - 1] > sum:\n        return is_subset_sum(set, n - 1, sum)\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])\n"}
{"task_id": "MBPP/482", "completion": "\n    pattern = '[A-Z][a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n\n"}
{"task_id": "MBPP/483", "completion": "\n    factorial = 1\n    number = 1\n    while True:\n        factorial *= number\n        if factorial % x == 0:\n            return number\n        number += 1\n"}
{"task_id": "MBPP/484", "completion": "\n    res = [ele for ele in test_list1 if ele not in test_list2]\n    return tuple(res)\n"}
{"task_id": "MBPP/485", "completion": "\n    n = str(n)\n    for i in range(len(n) // 2):\n        if n[i] != n[-i - 1]:\n            return False\n    return True\n\n"}
{"task_id": "MBPP/486", "completion": "\n    if r > n / 2:\n        r = n - r\n    numerator = 1\n    denominator = 1\n    for i in range(1, r + 1):\n        numerator *= (n - r + i)\n        denominator *= i\n    return numerator / denominator\n\n"}
{"task_id": "MBPP/487", "completion": "\n    return sorted(tup, key=lambda x: x[-1])\n"}
{"task_id": "MBPP/488", "completion": "\n    return (math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a ** 2) / 4\n\n"}
{"task_id": "MBPP/489", "completion": "\n    max_value = max(arr)\n    frequency = arr.count(max_value)\n    return frequency\n"}
{"task_id": "MBPP/490", "completion": "\n    result = []\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if test_list[i] == test_list[j]:\n                result.append((test_list[i], test_list[j]))\n    return result\n"}
{"task_id": "MBPP/491", "completion": "\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - math.pow(r, n)) / (1 - r)\n\n"}
{"task_id": "MBPP/492", "completion": "\n    first = 0\n    last = len(item_list) - 1\n    found = False\n    while first <= last and not found:\n        mid = (first + last) // 2\n        if item_list[mid] == item:\n            found = True\n        else:\n            if item < item_list[mid]:\n                last = mid - 1\n            else:\n                first = mid + 1\n    return found\n"}
{"task_id": "MBPP/493", "completion": "\n    # Calculate the side length of the hexagon\n    side_length = radius * math.sqrt(3)\n    # Calculate the height of the hexagon\n    height = side_length * 0.75\n    # Calculate the horizontal distance between the centers of two adjacent hexagons\n    horizontal_distance = side_length\n    # Calculate the vertical distance between the centers of two adjacent hexagons\n    vertical_distance = height * 1.5\n    # Calculate the number of hexagons in the grid\n    num_hexagons_x = int((endx - startx) / horizontal_distance)\n    num_hexagons_y = int((endy - starty) / vertical_distance)\n    # Initialize the list of hexagons\n    hexagons = []\n    # Calculate the coordinates of the hexagons\n    for i in range(num_hexagons_y):\n        y = starty + i * vertical_distance\n        if i % 2 == 0:\n            x_offset = startx\n        else:\n            x_offset = startx + side_length * 0.5\n        for j in range(num_hexagons_x):\n            x = x_offset + j * horizontal_distance\n            hexagon = [\n                (x + side_length * 0.5, y),\n                (x + side_length, y + height * 0.25),\n                (x + side_length, y + height * 0.75),\n                (x + side_length * 0.5, y + height),\n                (x, y + height * 0.75),\n                (x, y + height * 0.25),\n            ]\n            hexagons.append(hexagon)\n    return hexagons\n\n"}
{"task_id": "MBPP/494", "completion": "\n    res = int(\"\".join(map(str, test_tup)), 2)\n    return res\n"}
{"task_id": "MBPP/495", "completion": "\n    return re.sub('[a-z]', '', str1)\n\n"}
{"task_id": "MBPP/496", "completion": "\n    # Create a min heap from the given list\n    hq.heapify(nums)\n    \n    # Extract the smallest n elements from the heap\n    smallest_nums = [hq.heappop(nums) for _ in range(n)]\n    \n    return smallest_nums\n\n"}
{"task_id": "MBPP/497", "completion": "\n    slant_height = math.sqrt(r**2 + h**2)\n    base_area = math.pi * r**2\n    lateral_surface_area = math.pi * r * slant_height\n    return base_area + lateral_surface_area\n\n"}
{"task_id": "MBPP/498", "completion": "\n    if y == 0:\n        return x\n    else:\n        return gcd(y, x % y)\n\n"}
{"task_id": "MBPP/499", "completion": "\n    return 2 * r\n"}
{"task_id": "MBPP/500", "completion": "\n    concatenated_string = ''\n    for element in list:\n        concatenated_string += str(element)\n    return concatenated_string\n"}
{"task_id": "MBPP/501", "completion": "\n    while(y):\n        x, y = y, x % y\n    return x\n"}
{"task_id": "MBPP/502", "completion": "\n    return n % m\n"}
{"task_id": "MBPP/503", "completion": "\n    return sum(nums)\n"}
{"task_id": "MBPP/504", "completion": "\n    return (n * (n + 1) // 2) ** 2\n"}
{"task_id": "MBPP/505", "completion": "\n    i = 0\n    for j in range(len(A)):\n        if A[j] != 0:\n            A[i], A[j] = A[j], A[i]\n            i += 1\n    return A\n\n"}
{"task_id": "MBPP/506", "completion": "\n    # Initialize a 2D array to store intermediate results\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    \n    # Fill the dp array\n    for i in range(n+1):\n        for j in range(min(i, k)+1):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + j * dp[i-1][j-1]\n    \n    return dp[n][k]\n"}
{"task_id": "MBPP/507", "completion": "\n    return [word for word in list1 if word not in removewords]\n"}
{"task_id": "MBPP/508", "completion": "\n    # Find common elements\n    common_elements = [element for element in l1 if element in l2]\n    \n    # Filter out non-common elements from both lists\n    filtered_l1 = [element for element in l1 if element in common_elements]\n    filtered_l2 = [element for element in l2 if element in common_elements]\n    \n    # Compare the filtered lists\n    return filtered_l1 == filtered_l2\n"}
{"task_id": "MBPP/509", "completion": "\n    if n % 2 == 0:\n        return \"Invalid Input\"\n    else:\n        sum = 0\n        count = 0\n        while n >= 1:\n            sum += n\n            count += 1\n            n -= 2\n        return sum / count\n"}
{"task_id": "MBPP/510", "completion": "\n    n = len(arr)\n    MOD = 10**9 + 7\n    # Initialize the dp array\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    # Base case\n    for i in range(n+1):\n        dp[i][0] = 1\n    # Fill the dp array\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j]\n            if arr[i-1] <= j and arr[i-1] > 0:\n                dp[i][j] += dp[i-1][j//arr[i-1]]\n            dp[i][j] %= MOD\n    return dp[n][k]\n"}
