{"task_id": "valid/0", "completion": "\n    # Define the categories and their corresponding keywords\n    categories = {\n        'sports': ['football', 'basketball', 'soccer', 'tennis'],\n        'politics': ['government', 'election', 'policy', 'law'],\n        'entertainment': ['movie', 'music', 'celebrity', 'award']\n    }\n\n    # Initialize the category with the highest score\n    best_category = None\n    best_score = 0\n\n    # Tokenize the text into words\n    words = text.split()\n\n    # Iterate over each category\n    for category, keywords in categories.items():\n        # Initialize the score for the current category\n        score = 0\n\n        # Iterate over each keyword in the category\n        for keyword in keywords:\n            # Check if the keyword is in the text\n            if keyword in words:\n                # Increment the score if the keyword is found\n                score += 1\n\n        # Update the best category if the current category has a higher score\n        if score > best_score:\n            best_category = category\n            best_score = score\n\n    # Return the best category\n    return best_category\n"}
{"task_id": "valid/1", "completion": "\n    return frozenset(s)\n"}
{"task_id": "valid/2", "completion": "\n    return num1 ^ num2\n"}
{"task_id": "valid/3", "completion": "\n    return sorted(instruments, key=lambda x: x.lower(), reverse=True)\n"}
{"task_id": "valid/4", "completion": "\n    return json.loads(json_string)\n\n"}
{"task_id": "valid/5", "completion": "\n    if not isinstance(n, (int, float)):\n        return False\n    if n % 3 == 0:\n        return sum(int(digit) for digit in str(n)) % 3 == 0\n    return False\n"}
{"task_id": "valid/6", "completion": "\n    if n == 1:\n        return 0\n    elif n == base:\n        return 1\n    else:\n        return 1 + discrete_logarithm(n // base, base)\n"}
{"task_id": "valid/7", "completion": "\n    try:\n        json_data = json.loads(json_str)\n        pprint.pprint(json_data)\n    except json.JSONDecodeError as e:\n        print(f\"Error: {e}\")\n\n"}
{"task_id": "valid/8", "completion": "\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    return False\n"}
{"task_id": "valid/9", "completion": "\n    for key, value in values.items():\n        template = template.replace(\"{{\" + key + \"}}\", str(value))\n    return template\n"}
{"task_id": "valid/10", "completion": "\n    return len(string) == len(set(string))\n"}
{"task_id": "valid/11", "completion": "\n    date = datetime.strptime(date_string, '%Y-%m-%d')\n    new_date = date + timedelta(days=days)\n    return new_date.strftime('%Y%m%d')\n\n"}
{"task_id": "valid/12", "completion": "\n    # remove leading whitespace\n    text = text.lstrip()\n    \n    # split the text into words\n    words = text.split()\n    \n    # join the words back together with a single space in between\n    text = ' '.join(words)\n    \n    return text\n"}
{"task_id": "valid/13", "completion": "\n    # Convert text to lowercase\n    text = text.lower()\n    \n    # Remove punctuation\n    text = ''.join(e for e in text if e.isalnum() or e.isspace())\n    \n    # Remove special characters\n    text = ''.join(e for e in text if e.isalnum() or e.isspace() or e in string.punctuation)\n    \n    # Remove extra whitespace\n    text = ' '.join(text.split())\n    \n    return text\n\n"}
{"task_id": "valid/14", "completion": "\n    return bool(re.search(r'\\b' + re.escape(word1) + r'\\b|\\b' + re.escape(word2) + r'\\b', text))\n\n"}
{"task_id": "valid/15", "completion": "\n    return [sum(row) for row in array]\n"}
{"task_id": "valid/16", "completion": "\n    # remove the comment character from the string\n    comment = comment.lstrip('#')\n    \n    # split the string into individual settings\n    settings = comment.split(',')\n    \n    # create a dictionary to store the settings\n    vim_settings = {}\n    \n    # iterate over each setting\n    for setting in settings:\n        # split the setting into key and value\n        key, value = setting.split('=')\n        \n        # strip any leading or trailing whitespace from the key and value\n        key = key.strip()\n        value = value.strip()\n        \n        # add the setting to the dictionary\n        vim_settings[key] = int(value)\n    \n    # return the dictionary of settings\n    return vim_settings\n"}
{"task_id": "valid/17", "completion": "\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Return the list of words\n    return words\n"}
{"task_id": "valid/18", "completion": "\n    if num == 0:\n        return 0\n    else:\n        return 1 + find_digits_count(num // 10)\n"}
{"task_id": "valid/19", "completion": "\n    # reverse the elements of each list\n    reversed_list1 = list1[::-1]\n    reversed_list2 = list2[::-1]\n    \n    # combine the elements of the lists into a single list\n    combined_list = reversed_list1 + reversed_list2\n    \n    # sort the elements of the combined list in order\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list\n"}
{"task_id": "valid/20", "completion": "\n    return input_string.replace(old_word, new_word)\n"}
{"task_id": "valid/21", "completion": "\n    return z * z\n"}
{"task_id": "valid/22", "completion": "\n    return dictionary.get(\"name\")\n"}
{"task_id": "valid/23", "completion": "\n    if isinstance(struct, dict):\n        return {key: struct_to_dict(value) for key, value in struct.items()}\n    elif isinstance(struct, list):\n        return [struct_to_dict(item) for item in struct]\n    elif isinstance(struct, tuple):\n        return tuple(struct_to_dict(item) for item in struct)\n    elif isinstance(struct, set):\n        return set(struct_to_dict(item) for item in struct)\n    else:\n        return struct\n"}
{"task_id": "valid/24", "completion": "\n    # Convert the number to string to easily reverse it\n    num_str = str(num)\n    \n    # Initialize the closest palindrome and its distance\n    closest_palindrome = num\n    closest_distance = abs(num - int(str(num)[::-1]))\n    \n    # Check all numbers from num - 1 to num + 1\n    for i in range(num - 1, num + 2):\n        # Convert the number to string to easily reverse it\n        i_str = str(i)\n        \n        # Check if the number is a palindrome\n        if i_str == i_str[::-1]:\n            # Calculate the distance between the number and the closest palindrome\n            distance = abs(i - closest_palindrome)\n            \n            # If the distance is smaller than the current closest distance, update the closest palindrome and its distance\n            if distance < closest_distance:\n                closest_palindrome = i\n                closest_distance = distance\n                \n    return closest_palindrome\n"}
{"task_id": "valid/25", "completion": "\n    if num < 0:\n        return \"Error: Square root of negative number is not a real number\"\n    else:\n        return num ** 0.5\n"}
{"task_id": "valid/26", "completion": "\n    rows = len(matrix)\n    cols = len(matrix[0])\n    diagonal_sum = 0\n    is_square = rows == cols\n    for i in range(rows):\n        diagonal_sum += matrix[i][i]\n    return rows, cols, diagonal_sum, is_square\n"}
{"task_id": "valid/27", "completion": "\n    return base64.b64encode(string.encode()).decode()\n\n"}
{"task_id": "valid/28", "completion": "\n    return ''.join(c for c in s if c.isalpha()).lower()\n"}
{"task_id": "valid/29", "completion": "\n    return min(lst)\n"}
{"task_id": "valid/30", "completion": "\n    if isinstance(json_data, str):\n        json_data = json.loads(json_data)\n    if key not in json_data:\n        return True\n    if json_data[key] != value:\n        return True\n    return False\n\n"}
{"task_id": "valid/31", "completion": "\n    # Initialize an empty list to store the buttons\n    button_table = []\n    \n    # Calculate the number of rows needed\n    num_rows = -(-len(buttons) // num_columns)  # Ceiling division\n    \n    # Iterate over the number of rows\n    for i in range(num_rows):\n        # Initialize an empty list to store the buttons in the current row\n        row = []\n        \n        # Iterate over the number of columns\n        for j in range(num_columns):\n            # Calculate the index of the button in the list\n            index = i * num_columns + j\n            \n            # If the index is within the bounds of the list, add the button to the row\n            if index < len(buttons):\n                # Create a button with the action specified in the list\n                button = Button(text=buttons[index], command=lambda action=buttons[index]: action())\n                \n                # Add the button to the row\n                row.append(button)\n        \n        # Add the row to the button table\n        button_table.append(row)\n    \n    # Return the button table\n    return button_table\n"}
{"task_id": "valid/32", "completion": "\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for i in range(len(alphabet) - 1):\n        if alphabet[i] not in s or alphabet[i + 1] not in s or s.index(alphabet[i]) > s.index(alphabet[i + 1]):\n            return False\n    return True\n"}
{"task_id": "valid/33", "completion": "\n    if a > b:\n        return a\n    else:\n        return b\n"}
{"task_id": "valid/34", "completion": "\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Initialize an empty string to store the current numeric substring\n    current_num = \"\"\n    \n    # Iterate over each character in the input string\n    for char in ts:\n        # Check if the character is a digit\n        if char.isdigit():\n            # If the character is a digit, add it to the current numeric substring\n            current_num += char\n        else:\n            # If the character is not a digit and the current numeric substring is not empty\n            if current_num != \"\":\n                # Add the current numeric substring to the total sum\n                total_sum += int(current_num)\n                # Reset the current numeric substring\n                current_num = \"\"\n    \n    # If the input string ends with a numeric substring, add it to the total sum\n    if current_num != \"\":\n        total_sum += int(current_num)\n    \n    # Return the total sum\n    return total_sum\n"}
{"task_id": "valid/35", "completion": "\n    return [word[:-1] + word[-1].upper() for word in words]\n"}
{"task_id": "valid/36", "completion": "\n    # Check if all elements in the array are numerical\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"Array must only contain numerical values\")\n\n    # Compute the sum of the array\n    total = sum(arr)\n\n    return total\n"}
{"task_id": "valid/37", "completion": "\n    # First, we load the json data into a python dictionary\n    data = json.loads(json_data)\n    \n    # Then, we extract the list of neighborhoods from the dictionary\n    neighborhoods = data['neighborhoods']\n    \n    # Next, we sort the list of neighborhoods in alphabetical order\n    sorted_neighborhoods = sorted(neighborhoods, key=lambda x: x['name'])\n    \n    # Finally, we extract the names of the neighborhoods from the sorted list and return them\n    return [neighborhood['name'] for neighborhood in sorted_neighborhoods]\n\n"}
{"task_id": "valid/38", "completion": "\n    arr.sort()\n    min_sum = float('inf')\n    for i in range(n - 1):\n        # Calculate the absolute difference of the current pair\n        diff = abs(arr[i] + arr[i + 1])\n        # Update the minimum sum if the current difference is smaller\n        min_sum = min(min_sum, diff)\n    return min_sum\n"}
{"task_id": "valid/39", "completion": "\n    stack = []\n    for c in p:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return not stack\n"}
{"task_id": "valid/40", "completion": "\n    # Initialize an empty dictionary to store the results\n    results = {}\n\n    # Check if the total number of votes is at least 100\n    if len(votes) < 100:\n        raise ValueError(\"The total number of votes must be at least 100.\")\n\n    # Iterate over each vote in the list\n    for vote in votes:\n        # Extract the candidate name and number of votes from the tuple\n        candidate, num_votes = vote\n\n        # Check if the candidate name is a string consisting of uppercase letters with a maximum length of 10 characters\n        if not isinstance(candidate, str) or not candidate.isupper() or len(candidate) > 10:\n            raise ValueError(\"Candidate name must be a string consisting of uppercase letters with a maximum length of 10 characters.\")\n\n        # Check if the number of votes is a positive integer not exceeding 1000\n        if not isinstance(num_votes, int) or num_votes <= 0 or num_votes > 1000:\n            raise ValueError(\"Number of votes must be a positive integer not exceeding 1000.\")\n\n        # If the candidate is already in the results dictionary, add the number of votes to their current count\n        if candidate in results:\n            results[candidate] += num_votes\n        # Otherwise, add the candidate to the results dictionary with their number of votes\n        else:\n            results[candidate] = num_votes\n\n    # Calculate the total number of votes\n    total_votes = sum(results.values())\n\n    # Calculate the percentage of votes each candidate received, rounded to two decimal places\n    for candidate in results:\n        results[candidate] = (results[candidate] / total_votes) * 100\n\n    # Return the results dictionary\n    return results\n"}
{"task_id": "valid/41", "completion": "\n    # Define the possible date formats\n    date_formats = [\"%d-%m-%Y\", \"%d-%b-%Y\"]\n\n    # Try to parse the date string with each format\n    for date_format in date_formats:\n        try:\n            # Attempt to parse the date string\n            date = datetime.strptime(date_string, date_format)\n\n            # Validate the date\n            if date.month == 2 and date.day == 29 and (date.year % 4 != 0 or (date.year % 100 == 0 and date.year % 400 != 0)):\n                raise ValueError(\"Invalid date: February 29 is not a valid date unless it's a leap year.\")\n            elif date.month in [1, 3, 5, 7, 8, 10, 12] and date.day > 31:\n                raise ValueError(\"Invalid date: This month does not have 31 days.\")\n            elif date.month in [4, 6, 9, 11] and date.day > 30:\n                raise ValueError(\"Invalid date: This month does not have 30 days.\")\n            else:\n                # If the date is valid, return it in the standardized format\n                return date.strftime(\"%B %d, %Y\")\n\n        except ValueError:\n            # If the date string does not match the current format, continue to the next format\n            continue\n\n    # If the date string does not match any of the formats, raise an error\n    raise ValueError(\"Invalid date format. Please use dd-mm-yyyy or dd-mmm-yyyy (where mmm signifies months).\")  # Changed the error message to be more specific\n\n"}
{"task_id": "valid/42", "completion": "\n    # Define the allowed file types\n    allowed_types = {\n        'txt': ['.txt', '.text'],\n        'docx': ['.docx', '.doc'],\n        'pdf': ['.pdf'],\n        'jpg': ['.jpg', '.jpeg'],\n        'png': ['.png'],\n        'mp3': ['.mp3'],\n        'mp4': ['.mp4']\n    }\n\n    # Check if the new file name has a valid extension\n    for file_type, extensions in allowed_types.items():\n        if newname.endswith(extensions):\n            return True\n\n    # If no valid extension is found, return False\n    return False\n"}
{"task_id": "valid/43", "completion": "\n    def is_even(num):\n        if isinstance(num, int) or isinstance(num, float):\n            return num % 2 == 0\n        elif isinstance(num, str):\n            try:\n                return float(num) % 2 == 0\n            except ValueError:\n                return False\n        else:\n            raise TypeError(\"Input must be a list of integers, floats, or strings\")\n\n    def remove_uneven(lst):\n        if isinstance(lst, list):\n            return [remove_uneven(i) for i in lst if is_even(i)]\n        elif isinstance(lst, tuple):\n            return tuple(remove_uneven(i) for i in lst if is_even(i))\n        else:\n            return lst\n\n    return remove_uneven(lst)  # Call the helper function to start the recursion\n\n"}
{"task_id": "valid/44", "completion": "\n    return hours * 60\n"}
{"task_id": "valid/45", "completion": "\n    return string.lower().count(specific_character.lower())\n"}
{"task_id": "valid/46", "completion": "\n    # histogram_data = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    # histogram_data[generation] = accs\n    histogram_data[generation] = accs\n    return histogram_data\n"}
{"task_id": "valid/47", "completion": "\n    return bool(re.match(\"^[a-zA-Z0-9]{5}$\", string))\n\n"}
{"task_id": "valid/48", "completion": "\n    # Initialize an empty set to store unique languages\n    unique_languages = set()\n\n    # Iterate over each classifier in the list\n    for classifier in classifiers:\n        # Split the classifier into parts using '::' as the separator\n        parts = classifier.split('::')\n\n        # Check if the classifier matches the expected format\n        if len(parts) == 3 and parts[0] == 'programming language':\n            # Extract the language from the classifier\n            language = parts[1]\n\n            # Add the language to the set of unique languages\n            unique_languages.add(language)\n\n    # Return the count of unique languages\n    return len(unique_languages)\n\n"}
{"task_id": "valid/49", "completion": "\n    # Initialize an empty dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate over each row in the array\n    for row in arr:\n        # Iterate over each element in the row\n        for element in row:\n            # If the element is already in the dictionary, increment its count by 1\n            if element in count_dict:\n                count_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                count_dict[element] = 1\n    \n    # Convert the dictionary to an array and return it\n    return list(count_dict.values())\n"}
{"task_id": "valid/50", "completion": "\n    # Define a regular expression pattern to match the url\n    pattern = re.compile(r'^/competition/(\\d+)/$')\n\n    # Check if the url matches the pattern\n    match = pattern.match(url)\n\n    # If the url matches the pattern, return the view function associated with the match\n    if match:\n        # Get the group from the match (the group is the part of the url that matches the group in the pattern)\n        group = match.group(1)\n\n        # Return the view function associated with the match\n        return competition_view\n    else:\n        # If the url does not match the pattern, return None\n        return None\n\n"}
{"task_id": "valid/51", "completion": "\n    list.insert(position, item)\n    return list\n"}
{"task_id": "valid/52", "completion": "\n    string = \"Hello\"\n    sentence = \" world\"\n    concatenated_string = string + sentence\n    return concatenated_string\n"}
{"task_id": "valid/53", "completion": "\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substrings.add(s[i:j])\n    return substrings\n"}
{"task_id": "valid/54", "completion": "\n    price_sum = 0\n    for dictionary in list_of_dicts:\n        for key in dictionary:\n            if key.startswith(\"price_\"):\n                price_sum += dictionary[key]\n    return price_sum\n"}
{"task_id": "valid/55", "completion": "\n    intersection = [value for value in list1 if value in list2]\n    list1[:] = [value for value in list1 if value not in intersection]\n    return intersection\n"}
{"task_id": "valid/56", "completion": "\n    # Define a dictionary to map request methods to their corresponding endpoints\n    endpoints = {\n        'GET': api_advisor_view,\n        'POST': api_advisor_view_post\n    }\n    \n    # Check if the request method is valid (i.e., it exists in the endpoints dictionary)\n    if request_method in endpoints:\n        # If the request method is valid, return the corresponding endpoint\n        return endpoints[request_method]\n    else:\n        # If the request method is not valid, return a default endpoint (e.g., a 404 error page)\n        return lambda: HttpResponse(\"Invalid request method\", status=404)\n"}
{"task_id": "valid/57", "completion": "\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both inputs must be integers.\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both inputs must be positive integers.\")\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a > b:\n        return gcd_recursive(a - b, b)\n    return gcd_recursive(a, b - a)\n"}
{"task_id": "valid/58", "completion": "\n    categorized_files = {}\n    for file_path in file_paths:\n        # get the directory path of the file\n        dir_path = os.path.dirname(file_path)\n        # get the file name\n        file_name = os.path.basename(file_path)\n        # get the file extension\n        file_ext = os.path.splitext(file_name)[1]\n        # categorize the file based on its location and extension\n        if dir_path in categorized_files:\n            if file_ext in categorized_files[dir_path]:\n                categorized_files[dir_path][file_ext].append(file_name)\n            else:\n                categorized_files[dir_path][file_ext] = [file_name]\n        else:\n            categorized_files[dir_path] = {file_ext: [file_name]}\n    return categorized_files\n"}
{"task_id": "valid/59", "completion": "\n    numbers = [a, b, c, d, e]\n    numbers.sort()\n    n = len(numbers)\n    if n % 2 == 0:\n        median = (numbers[n // 2 - 1] + numbers[n // 2]) / 2\n    else:\n        median = numbers[n // 2]\n    return median\n"}
{"task_id": "valid/60", "completion": "\n    return len(my_list) == len(set(my_list))\n"}
{"task_id": "valid/61", "completion": "\n    # Calculate the absolute difference between timeEnd and timeStart\n    timeDifference = abs(timeEnd - timeStart)\n    \n    # Return the calculated time difference\n    return timeDifference\n"}
{"task_id": "valid/62", "completion": "\n    # Base case: If the start index is greater than the end index, the target is not in the array.\n    if start > end:\n        return False\n\n    # Calculate the middle index of the array.\n    mid = (start + end) // 2\n\n    # If the middle element is equal to the target, return True.\n    if array[mid] == target:\n        return True\n\n    # If the middle element is greater than the target, search the left half of the array.\n    elif array[mid] > target:\n        return binary_search_recursive(array, target, start, mid - 1)\n\n    # If the middle element is less than the target, search the right half of the array.\n    else:\n        return binary_search_recursive(array, target, mid + 1, end)\n\n"}
{"task_id": "valid/63", "completion": "\n    colors = [\"red\", \"green\", \"blue\", \"white\"]\n    if color not in colors:\n        return \"Invalid color\"\n    index = colors.index(color)\n    next_index = (index + 1) % len(colors)\n    return colors[next_index]\n"}
{"task_id": "valid/64", "completion": "\n    for i in range(len(list)):\n        list[i] += 1\n"}
{"task_id": "valid/65", "completion": "\n    for num in range(start, end + 1):\n        root = int(num ** 0.5)\n        if root * root == num:\n            return True\n    return False\n"}
{"task_id": "valid/66", "completion": "\n    for word in words:\n        if target in word:\n            return word\n    return None\n"}
{"task_id": "valid/67", "completion": "\n    return sentence.split()\n"}
{"task_id": "valid/68", "completion": "\n    print(\"the keys in the given dictionary are:\")\n    for key in dict.keys():\n        print(key)\n"}
{"task_id": "valid/69", "completion": "\n    name = \"John\"\n    age = 30\n    phrase = \"Hello, my name is {} and I am {} years old.\"\n    concatenated_string = phrase.format(name, age)\n    return concatenated_string\n"}
{"task_id": "valid/70", "completion": "\n    result = []\n    for string in strings:\n        if re.match(\"^[a-zA-Z0-9\\s]+$\", string):\n            result.append(string.capitalize())\n    return result\n\n"}
{"task_id": "valid/71", "completion": "\n    try:\n        return string.index(char)\n    except ValueError:\n        return -1\n"}
{"task_id": "valid/72", "completion": "\n    bold_text = []\n    i = 0\n    while i < len(html_code):\n        if html_code[i:i+4] == '<b>':\n            start = i + 4\n            end = html_code.find('</b>', start)\n            if end != -1:\n                bold_text.append(html_code[start:end])\n                i = end + 4\n            else:\n                i = len(html_code)\n        else:\n            i += 1\n    return bold_text\n"}
{"task_id": "valid/73", "completion": "\n    # Define the items and their prices\n    items = {\n        \"1\": {\"name\": \"Coke\", \"price\": 1.00},\n        \"2\": {\"name\": \"Pepsi\", \"price\": 1.50},\n        \"3\": {\"name\": \"Water\", \"price\": 0.50},\n    }\n\n    # Check if the item is in stock\n    if item in items:\n        # Calculate the change\n        change = money_inserted - items[item][\"price\"]\n        # Update the stock\n        items[item][\"stock\"] -= 1\n        # Return the change and a success message\n        return f\"Thank you for your purchase! Your change is ${change:.2f}.\"\n    else:\n        # Return an error message if the item is not in stock\n        return \"Sorry, that item is not available.\"\n"}
{"task_id": "valid/74", "completion": "\n    # Combine the two lists into one\n    combined_list = list1 + list2\n    \n    # Convert the combined list to a set to remove duplicates\n    # Sets in Python are unordered collections of unique elements\n    combined_set = set(combined_list)\n    \n    # Convert the set back to a list and return it\n    return list(combined_set)\n"}
{"task_id": "valid/75", "completion": "\n    return list.count(target)\n"}
{"task_id": "valid/76", "completion": "\n    return base64.b64encode(string.encode()).decode()\n\n"}
{"task_id": "valid/77", "completion": "\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    # Create a stem plot of the vector\n    plt.stem(vector)\n\n    # Get the indices of the non-zero entries in the vector\n    non_zero_indices = np.where(np.array(vector) != 0)[0]\n\n    return non_zero_indices\n"}
{"task_id": "valid/78", "completion": "\n    # Assign a value to a variable\n    a = 5\n\n    # Validate the assigned value\n    if a == 5:\n        print(\"The value is 5\")\n    else:\n        print(\"The value is not 5\")\n"}
{"task_id": "valid/79", "completion": "\n    word_list = list(word)\n    random.shuffle(word_list)\n    return ''.join(word_list)\n\n"}
{"task_id": "valid/80", "completion": "\n    if isinstance(element, int):\n        return \"Integer\"\n    elif isinstance(element, float):\n        return \"Float\"\n    elif isinstance(element, str):\n        return \"String\"\n    elif isinstance(element, list):\n        return \"List\"\n    elif isinstance(element, dict):\n        return \"Dictionary\"\n    else:\n        return \"Unknown\"\n"}
{"task_id": "valid/81", "completion": "\n    if len(arr) == 0:\n        return arr\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] == arr[1]:\n            return [arr[0]]\n        else:\n            return arr\n    i = 0\n    while i < len(arr) - 1:\n        if arr[i] == arr[i + 1]:\n            arr.pop(i + 1)\n        else:\n            i += 1\n    return arr\n"}
{"task_id": "valid/82", "completion": "\n    # Regular expression to find words and numbers\n    pattern = r'\\b\\w+\\b|[0-9]+'\n    # Find all matches of the pattern in the text\n    tokens = re.findall(pattern, text)\n    return tokens\n\n"}
{"task_id": "valid/83", "completion": "\n    divisible_numbers = [num for num in numbers if num % 3 == 0 and num % 7 == 0]\n    average = sum(divisible_numbers) / len(divisible_numbers) if divisible_numbers else 0\n    max_num = max(divisible_numbers) if divisible_numbers else 0\n    min_num = min(divisible_numbers) if divisible_numbers else 0\n    occurrences = {num: numbers.count(num) for num in divisible_numbers}\n    return average, max_num, min_num, occurrences\n\nnumbers = [10, 15, 21, 28, 35, 42, 49, 56, 63, 70]\naverage, max_num, min_num, occurrences = find_divisible_numbers(numbers)\n"}
{"task_id": "valid/84", "completion": "\n    words = sentence.split()\n    frequency = {}\n    for word in words:\n        word = word.lower()\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    max_frequency = max(frequency.values())\n    for word, freq in frequency.items():\n        if freq == max_frequency:\n            return word\n    return None\n"}
{"task_id": "valid/85", "completion": "\n    return round(math.e, decimal_places)\n\n"}
{"task_id": "valid/86", "completion": "\n    average = sum(numbers) / len(numbers)\n    sum_of_numbers = sum(numbers)\n    return average, sum_of_numbers\n\nnumbers = [1, 2, 3, 4, 5]\naverage, sum_of_numbers = getAverageAndSum(numbers)"}
{"task_id": "valid/87", "completion": "\n    if not time_series:\n        raise ValueError(\"Time series is empty\")\n    if not all(isinstance(x, (int, float)) for x in time_series):\n        raise ValueError(\"Time series contains non-numerical values\")\n    return min(time_series), max(time_series)\n\n"}
{"task_id": "valid/88", "completion": "\n    related_articles = {}\n    for article in encyclopedia:\n        related_articles[article] = 0\n        for other_article in encyclopedia:\n            if article != other_article:\n                if is_related(article, other_article):\n                    related_articles[article] += 1\n    return related_articles\n"}
{"task_id": "valid/89", "completion": "\n    return lst.index(max(lst))\n"}
{"task_id": "valid/90", "completion": "\n    return len(set(list1) & set(list2)) > 0\n"}
{"task_id": "valid/91", "completion": "\n    root = Element('data')\n    for key, value in dictionary.items():\n        child = Element(key)\n        child.text = str(value)\n        root.append(child)\n    return tostring(root, encoding='unicode')\n\n"}
{"task_id": "valid/92", "completion": "\n    if not matrix or not matrix[0]:\n        return False\n\n    row, col = 0, len(matrix[0]) - 1\n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    return False\n"}
{"task_id": "valid/93", "completion": "\n    odd_sum = 0\n    odd_count = 0\n    for num in lst:\n        if num % 2 != 0:  # check if a number is odd\n            odd_sum += num\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return odd_sum / odd_count\n"}
{"task_id": "valid/94", "completion": "\n    if n < 1 or n > len(lst):\n        return None\n    return sorted(lst, reverse=True)[n - 1]\n"}
{"task_id": "valid/95", "completion": "\n    return sum(lst)\n\n"}
{"task_id": "valid/96", "completion": "\n    return set_a.symmetric_difference(set_b)\n"}
{"task_id": "valid/97", "completion": "\n    # Define the description of the bot\n    description = \"A Discord bot that can manage play music on a server. It has the ability to provide information about its features and a web app for managing personal playlists and server settings.\"\n    \n    # Define the features of the bot\n    features = {\n        \"Music\": \"Play music on a server\",\n        \"Web App\": \"Manage personal playlists and server settings\",\n        \"Help\": \"Get help information for each command\"\n    }\n    \n    # Define the commands of the bot\n    commands = {\n        \"play\": \"Play a song\",\n        \"pause\": \"Pause the current song\",\n        \"resume\": \"Resume the current song\",\n        \"stop\": \"Stop the current song\",\n        \"skip\": \"Skip the current song\",\n        \"help\": \"Get help information for each command\"\n    }\n    \n    # Create a mapping of the bot's features and commands\n    bot_mapping = {\n        \"description\": description,\n        \"features\": features,\n        \"commands\": commands\n    }\n    \n    # Return the mapping of the bot's features and commands\n    return bot_mapping\n"}
{"task_id": "valid/98", "completion": "\n    if n == 0:\n        return '0'\n    elif n < 0:\n        return '-' + dec_to_ternary(-n)\n    else:\n        return dec_to_ternary(n // 3) + str(n % 3)\n"}
{"task_id": "valid/99", "completion": "\n    return tuple(filename.split('.')[-1] for filename in file_names)\n"}
{"task_id": "valid/100", "completion": "\n    if age < 0:\n        return \"Invalid age\"\n    elif age < 18:\n        return \"minor\"\n    elif age < 65:\n        return \"adult\"\n    else:\n        return \"senior\"\n"}
{"task_id": "valid/101", "completion": "\n    # Define the grade scale\n    grade_scale = {\n        90: \"A\",\n        80: \"B\",\n        70: \"C\",\n        60: \"D\",\n        0: \"F\"\n    }\n\n    # Determine the letter grade using ternary operator\n    letter_grade = \"A\" if numerical_grade >= 90 else \"B\" if numerical_grade >= 80 else \"C\" if numerical_grade >= 70 else \"D\" if numerical_grade >= 60 else \"F\"\n\n    # Calculate the grade point equivalent (gpa on a scale of 4.0)\n    gpa = (numerical_grade / 10) if numerical_grade >= 0 else 0\n\n    return letter_grade, gpa\n"}
{"task_id": "valid/102", "completion": "\n    return sum(item['price'] for item in listing)\n"}
{"task_id": "valid/103", "completion": "\n    # Initialize an empty dictionary to store the count of vowels in each palindrome\n    vowel_count_dict = {}\n    \n    # Iterate over each palindrome in the input tuple\n    for palindrome in palindrome_tuples:\n        # Initialize a counter for vowels in the current palindrome\n        vowel_count = 0\n        \n        # Iterate over each character in the palindrome\n        for char in palindrome:\n            # Check if the character is a vowel\n            if char.lower() in 'aeiou':\n                # If it's a vowel, increment the counter\n                vowel_count += 1\n        \n        # Store the count of vowels in the dictionary\n        vowel_count_dict[palindrome] = vowel_count\n    \n    # Return the dictionary\n    return vowel_count_dict\n"}
{"task_id": "valid/104", "completion": "\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the order of the words\n    words = words[::-1]\n    \n    # Join the words back into a string with spaces in between\n    modified_string = ' '.join(words)\n    \n    return modified_string\n"}
{"task_id": "valid/105", "completion": "\n    num_set = set()\n    for num in arr:\n        if -num in num_set:\n            return True\n        num_set.add(num)\n    return False\n"}
{"task_id": "valid/106", "completion": "\n    # Initialize an empty dictionary to store the latest version for each dependency\n    latest_versions = {}\n\n    # Iterate over each dependency\n    for dependency in dependencies:\n        # Extract the package name and version number from the tuple\n        package_name, version_number = dependency\n\n        # Split the version number into its components\n        version_components = version_number.split('_')\n\n        # Extract the numerical identifier and the date and time from the version number\n        numerical_identifier = version_components[0]\n        date_time = version_components[1]\n\n        # Convert the date and time to a datetime object\n        from datetime import datetime\n        date_time_object = datetime.strptime(date_time, '%Y%m%d_%H%M')\n\n        # If the package name is not in the dictionary or the current version is newer than the stored version, update the dictionary\n        if package_name not in latest_versions or date_time_object > latest_versions[package_name][1]:\n            latest_versions[package_name] = (numerical_identifier, date_time_object)\n\n    # Return the dictionary of latest versions\n    return latest_versions\n"}
{"task_id": "valid/107", "completion": "\n    # Create a dictionary to store the categorized causes of death\n    categorized = {}\n    \n    # Loop through each cause of death\n    for cause in causes:\n        # Split the cause into action and result\n        action, result = cause.split(\", \")\n        \n        # If the action is not already in the dictionary, add it\n        if action not in categorized:\n            categorized[action] = []\n        \n        # Add the cause to the list of causes for the action\n        categorized[action].append(result)\n    \n    # Return the dictionary of categorized causes of death\n    return categorized\n"}
{"task_id": "valid/108", "completion": "\n    # Remove spaces from the input name and convert it to lowercase\n    code_name = name.replace(\" \", \"-\").lower()\n    return code_name\n"}
{"task_id": "valid/109", "completion": "\n    return any(ord(c) > 127 for c in text)\n"}
{"task_id": "valid/110", "completion": "\n    # Import the string module which contains a pre-initialized string of punctuation marks\n    import string\n    \n    # Use the translate method to remove punctuation marks\n    # The maketrans method is used to create a translation table\n    # The string.punctuation constant contains all punctuation marks\n    translator = str.maketrans('', '', string.punctuation)\n    \n    # Use the translate method to remove punctuation marks\n    return string.translate(translator)\n"}
{"task_id": "valid/111", "completion": "\n    try:\n        result = []\n        for num in num_list:\n            result.append(num ** exp)\n        return result\n    except TypeError:\n        print(\"Error: The input list must contain only numbers.\")\n    except ValueError:\n        print(\"Error: The exponent must be a non-negative integer.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n"}
{"task_id": "valid/112", "completion": "\n    min_values = [min(row) for row in grid]\n    for i, value in enumerate(min_values):\n        print(f\"Minimum value in row {i+1}: {value}\")\n"}
{"task_id": "valid/113", "completion": "\n    # validate input\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # print thank you message for 'n' numbers\n    for i in range(n):\n        print(f\"Thank you for the amazing {current_num}!\")\n\n        # increment current number\n        current_num += 1\n"}
{"task_id": "valid/114", "completion": "\n    count = 0\n    for i in lst:\n        if i == element:\n            count += 1\n        else:\n            break\n    return count\n"}
{"task_id": "valid/115", "completion": "\n    if not isinstance(num, int):\n        raise TypeError(\"num must be an integer\")\n    if not isinstance(base, int):\n        raise TypeError(\"base must be an integer\")\n    if num < 0:\n        raise ValueError(\"num must be a non-negative integer\")\n    if base < 2:\n        raise ValueError(\"base must be at least 2\")\n    if base > 36:\n        raise ValueError(\"base must be at most 36\")\n    if num == 0:\n        return True\n    digits = []\n    while num:\n        digits.append(num % base)\n        num //= base\n    return len(set(digits)) == 1\n\n"}
{"task_id": "valid/116", "completion": "\n    # Base case: if the string is empty, return it as is\n    if not s:\n        return s\n\n    # If the first character is a vowel, remove it and recurse on the rest of the string\n    if s[0].lower() in 'aeiou':\n        return remove_vowels_recursive(s[1:])\n\n    # If the first character is not a vowel, keep it and recurse on the rest of the string\n    return s[0] + remove_vowels_recursive(s[1:])  # <--- changed here\n\n"}
{"task_id": "valid/117", "completion": "\n    # Initialize an empty string to store the help message\n    help_message = \"\"\n\n    # Iterate over each option in the options list\n    for option in options:\n        # Extract the option name and description from the tuple\n        option_name, option_description = option\n\n        # Add the option name and description to the help message\n        help_message += f\"  --{option_name}  {option_description}\\n\"\n\n    # Return the generated help message\n    return help_message\n\n"}
{"task_id": "valid/118", "completion": "\n    return input_string[0]\n"}
{"task_id": "valid/119", "completion": "\n    return [Val] * len(input_array)\n"}
{"task_id": "valid/120", "completion": "\n    return ~sample_bitset\n\n"}
{"task_id": "valid/121", "completion": "\n    vowels = 'aeiou'\n    for char in s:\n        if char.lower() not in vowels:\n            return False\n    return True\n"}
{"task_id": "valid/122", "completion": "\n    count = 0\n    for i in range(len(sequence)):\n        if sequence[i:i+len(subsequence)] == subsequence:\n            count += 1\n    return count\n"}
{"task_id": "valid/123", "completion": "\n    # Initialize quotient to 0\n    q = 0\n    # Initialize remainder to 0\n    r = 0\n    # Loop until the remainder is less than the divisor\n    while r < t:\n        # Add the divisor to the remainder\n        r += t\n        # Increment the quotient\n        q += 1\n    # Subtract the divisor from the remainder\n    r -= t\n    # Subtract 1 from the quotient\n    q -= 1\n    # Return the quotient\n    return q\n"}
{"task_id": "valid/124", "completion": "\n    return sum(input_list)\n"}
{"task_id": "valid/125", "completion": "\n    # Convert the string to lowercase to handle case insensitivity\n    string = string.lower()\n    # Initialize a counter for consonants\n    consonant_count = 0\n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Check if the character is not a vowel\n            if char not in 'aeiou':\n                # Increment the consonant counter\n                consonant_count += 1\n    # Return the total count of consonants\n    return consonant_count\n"}
{"task_id": "valid/126", "completion": "\n    # Initialize the number of electrons\n    num_electrons = 0\n    \n    # Iterate over the grid energies and ADOS values\n    for energy, ados in zip(grid_energies, ados):\n        # Calculate the number of electrons at the current energy\n        num_electrons += ados * (1 + (energy - dope) / dos_grid_size)\n    \n    # Return the total number of electrons\n    return num_electrons\n"}
{"task_id": "valid/127", "completion": "\n    return tuple(set(tuple_to_process))\n"}
{"task_id": "valid/128", "completion": "\n    arr.sort()\n    return arr[-1] - arr[0]\n"}
{"task_id": "valid/129", "completion": "\n    color_dict = {}\n    for color in color_list:\n        color_dict[color[0]] = color[1]\n    return color_dict\n"}
{"task_id": "valid/130", "completion": "\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n"}
{"task_id": "valid/131", "completion": "\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n        if len(unique_elements) == 3:\n            break\n    return unique_elements\n"}
{"task_id": "valid/132", "completion": "\n    return sorted(fruit_list)\n"}
{"task_id": "valid/133", "completion": "\n    sublists = [[]]\n    for elem in lst:\n        sublists += [sublist + [elem] for sublist in sublists]\n    return sublists\n"}
{"task_id": "valid/134", "completion": "\n    pattern = r'\\d+\\.\\d+'\n    if re.search(pattern, string):\n        return True\n    else:\n        return False\n\n"}
{"task_id": "valid/135", "completion": "\n    # Define the migration operation\n    migration_operation = {\n        \"operation\": \"alter_field\",\n        \"model\": f\"{app_name}.{model_name}\",\n        \"field\": f\"{field_name}\",\n        \"new_field\": f\"{field_name}_new\",\n        \"old_field\": f\"{field_name}_old\",\n        \"new_type\": \"CharField\",\n        \"new_length\": 255,\n        \"old_type\": \"IntegerField\"\n    }\n    \n    return migration_operation\n"}
{"task_id": "valid/136", "completion": "\n    # Convert the lists to sets for efficient lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Calculate the sum of the common elements\n    common_elements_sum = sum(common_elements)\n    \n    return common_elements_sum\n"}
{"task_id": "valid/137", "completion": "\n    # Calculate the length of the dataset\n    dataset_length = len(df)\n    \n    # Calculate 1% of the dataset length\n    one_percent = dataset_length * 0.01\n    \n    # Round up to the nearest integer\n    forecast_period = math.ceil(one_percent)\n    \n    return forecast_period\n\n"}
{"task_id": "valid/138", "completion": "\n    return sorted(array, key=lambda x: x[attr])\n"}
{"task_id": "valid/139", "completion": "\n    start = (page_number - 1) * items_per_page\n    end = start + items_per_page\n    return items[start:end]\n\n"}
{"task_id": "valid/140", "completion": "\n    n = [int(x) for x in n_str]\n    n = n[::-1]\n    result = [0] * len(n)\n    carry = 0\n    for i in range(len(n)):\n        product = n[i] * 2 + carry\n        result[i] = product % 10\n        carry = product // 10\n    if carry > 0:\n        result.append(carry)\n    result = result[::-1]\n    return ''.join(map(str, result))\n"}
{"task_id": "valid/141", "completion": "\n    presets = {\n        \"home\": (0.0, 0.0, 0.0),\n        \"start\": (0.0, 0.0, 0.0),\n        \"end\": (0.0, 0.0, 0.0),\n        \"left\": (0.0, 0.0, 0.0),\n        \"right\": (0.0, 0.0, 0.0),\n        \"up\": (0.0, 0.0, 0.0),\n        \"down\": (0.0, 0.0, 0.0),\n        \"front\": (0.0, 0.0, 0.0),\n        \"back\": (0.0, 0.0, 0.0),\n        \"center\": (0.0, 0.0, 0.0),\n        \"left_up\": (0.0, 0.0, 0.0),\n        \"left_down\": (0.0, 0.0, 0.0),\n        \"right_up\": (0.0, 0.0, 0.0),\n        \"right_down\": (0.0, 0.0, 0.0),\n        \"left_front\": (0.0, 0.0, 0.0),\n        \"left_back\": (0.0, 0.0, 0.0),\n        \"right_front\": (0.0, 0.0, 0.0),\n        \"right_back\": (0.0, 0.0, 0.0),\n        \"left_center\": (0.0, 0.0, 0.0),\n        \"right_center\": (0.0, 0.0, 0.0),\n        \"up_left\": (0.0, 0.0, 0.0),\n        \"up_right\": (0.0, 0.0, 0.0),\n        \"down_left\": (0.0, 0.0, 0.0),\n        \"down_right\": (0.0, 0.0, 0.0),\n        \"front_left\": (0.0, 0.0, 0.0),\n        \"front_right\": (0.0, 0.0, 0."}
{"task_id": "valid/142", "completion": "\n    # Convert the lists to sets for efficient lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets (common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Initialize the product to 1\n    product = 1\n    \n    # Iterate over the common elements and multiply them together\n    for element in common_elements:\n        product *= element\n    \n    return product\n"}
{"task_id": "valid/143", "completion": "\n    if allow_multiple_answer:\n        # if multiple answers are allowed, the quiz system will display all possible answers and allow users to select multiple answers\n        return \"Multiple answers are allowed. Users can select multiple answers.\"\n    else:\n        # if multiple answers are not allowed, the quiz system will display only one possible answer and allow users to select only one answer\n        return \"Only one answer is allowed. Users can select only one answer.\"\n\n    # the zoom level of the quiz system is not relevant to the behavior of the quiz system\n    # however, if you want to include the zoom level in the behavior, you can do so like this:\n    if zoom_level > 10:\n        # if the zoom level is greater than 10, the quiz system will display the answers in a larger font size\n        return \"Zoom level is greater than 10. Answers will be displayed in a larger font size.\"\n    else:\n        # if the zoom level is not greater than 10, the quiz system will display the answers in the default font size\n        return \"Zoom level is not greater than 10. Answers will be displayed in the default font size.\"\n"}
{"task_id": "valid/144", "completion": "\n    return math.floor(num)\n\n"}
{"task_id": "valid/145", "completion": "\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in sentence if char not in vowels])\n"}
{"task_id": "valid/146", "completion": "\n    # create a new object to store the merged result\n    merged = {}\n    \n    # get all keys from both objects\n    keys_a = [key for key in a.keys() if key.isalpha()]\n    keys_b = [key for key in b.keys() if key.isalpha()]\n    \n    # merge keys from both objects\n    all_keys = list(set(keys_a + keys_b))\n    \n    # sort the keys\n    all_keys.sort()\n    \n    # iterate over the keys\n    for key in all_keys:\n        # check if the key exists in both objects\n        if key in a and key in b:\n            # if the values are objects, merge them recursively\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                merged[key] = merge_objects(a[key], b[key])\n            # if the values are not objects, overwrite the value from the first object with the value from the second object\n            else:\n                merged[key] = b[key]\n        # if the key only exists in the first object, add it to the merged object\n        elif key in a:\n            merged[key] = a[key]\n        # if the key only exists in the second object, add it to the merged object\n        else:\n            merged[key] = b[key]\n    \n    # return the merged object\n    return merged\n"}
{"task_id": "valid/147", "completion": "\n    if not isinstance(d, dict):\n        raise ValueError(\"Input must be a dictionary\")\n    max_val = float('-inf')\n    for k, v in d.items():\n        if isinstance(v, dict):\n            max_val = max(max_val, find_max_in_dict(v))\n        else:\n            max_val = max(max_val, v)\n    return max_val\n"}
{"task_id": "valid/148", "completion": "\n    values = dict.get(key, [])\n    if not values:\n        return 0\n    return sum(values) / len(values)\n\n"}
{"task_id": "valid/149", "completion": "\n    if not string:\n        return None\n    return string.replace('e', '')\n"}
{"task_id": "valid/150", "completion": "\n    return heapq.nsmallest(n, lst)\n\n"}
{"task_id": "valid/151", "completion": "\n    return x % 2 == 0 and x % 3 == 0 and x % 5 == 0 and x % 7 == 0 and x % 11 == 0 and x % 13 == 0 and x % 17 == 0 and x % 19 == 0 and x % 23 == 0 and x % 29 == 0 and x % 31 == 0 and x % 37 == 0 and x % 41 == 0 and x % 43 == 0 and x % 47 == 0 and x % 53 == 0 and x % 59 == 0 and x % 61 == 0 and x % 67 == 0 and x % 71 == 0 and x % 73 == 0 and x % 79 == 0 and x % 83 == 0 and x % 89 == 0 and x % 97 == 0\n\n"}
{"task_id": "valid/152", "completion": "\n    return date + datetime.timedelta(days=10)\n\n"}
